{ "_links" : { "self" : { "href" : "/charter/emails?pagesize=1000&filter={_id:{$in:['CA+Y5xYfqKR6yC2Q-G7D9N7FeY=xs1x3frq==syGoqYpOcL9yrw@mail.gmail.com','CAA+bWKUPaPtN8sFiNzp+xrZV47iJdi9g_3hUrAiaG39-j7YPpg@mail.gmail.com','CAA+bWKXSTkAuFC+NTLPaO0XAOa09kUt5CNNNrGyoL+SZgf7ZhQ@mail.gmail.com','CACR_FB63_19+4uwtyUgnt7MQ6KY7NPCTS1p1K7r8Xw3AXRBmNw@mail.gmail.com','314A26E1-C235-4C68-81EE-18B2284CEC5A@lorentey.hu','CA+Y5xYcEiEvW8fT55UGT7gUEWUzW3e-cgf6UgbGjdJd7B1Dd1A@mail.gmail.com','CA+Y5xYcgdxbqo7cHR4KXdBXu6stncn4WVhBea9GroeFLJLy6gw@mail.gmail.com','DE386A8B-8454-4137-AB74-E29BD13C621C@architechies.com','CA+Y5xYcNqZTOCh5LZnM=Y07_o8ShL-e_xe9+itHqMkgtR-dNtw@mail.gmail.com']}}&page=1"} , "curies" : [ ]} , "_id" : "emails" , "_created_on" : "2016-02-12T02:49:33Z" , "_etag" : { "$oid" : "56bd483da07fe857fb4ce84b"} , "_collection-props-cached" : false , "_returned" : 9 , "_embedded" : { "rh:doc" : [ { "_links" : { "self" : { "href" : "/charter/emails/DE386A8B-8454-4137-AB74-E29BD13C621C@architechies.com"}} , "_id" : "DE386A8B-8454-4137-AB74-E29BD13C621C@architechies.com" , "from" : "brent at architechies.com (Brent Royal-Gordon)" , "date" : { "$date" : 1456909736000} , "subject" : "Re: [swift-evolution] [RFC] New collections model: collections advance indices" , "references" : [ "CA+Y5xYfqKR6yC2Q-G7D9N7FeY=xs1x3frq==syGoqYpOcL9yrw@mail.gmail.com"] , "mailingList" : "swift-evolution" , "content" : "> We would like to propose a major change to how collection indices\n> work.  The standard library team has discussed this idea internally\n> and we wrote a prototype.  Now we think it is a viable direction to\n> consider, and we are bringing it for wider public discussion.\n\nThis is super-interesting, and overall I think it's probably an improvement (although I haven't gone *really* deep with generic CollectionType code very often).\n\nI do have a question, though it may simply betray my ignorance. `advance` has two forms:\n\n\tfunc advance(i: Index, by n: IndexDistance) -> Index\n\tfunc advance(i: Index, by n: IndexDistance, limit: Index) -> Index\n\nThis is a pretty straight port of the old `advance`:\n\n\tpublic func advancedBy(amount: Distance) -> Self\n\tpublic func advancedBy(amount: Distance, limit: Self) -> Self\n\nBut I'm not sure the `limit` parameter is still appropriate. I've always figured that you were supposed to pass the collection's `endIndex` there, but now that `advance` *is* a method on the collection, it can access that itself. Would we be better served with something like this?\n\n\tfunc unsafeAdvance(i: Index, by n: IndexDistance) -> Index\t\t// no endIndex check\n\tfunc advance(i: Index, by n: IndexDistance) -> Index\t\t\t// endIndex check\n\nOr do you imagine the `limit` parameter being put to some other use that I'm not thinking of?\n\n\n\n-- \nBrent Royal-Gordon\nArchitechies\n\n_______________________________________________\nswift-evolution mailing list\nswift-evolution@swift.org\nhttps://lists.swift.org/mailman/listinfo/swift-evolution\n" , "inReplyTo" : "CA+Y5xYfqKR6yC2Q-G7D9N7FeY=xs1x3frq==syGoqYpOcL9yrw@mail.gmail.com" , "archiveURL" : "" , "descendants" : [ "DE386A8B-8454-4137-AB74-E29BD13C621C@architechies.com" , "CA+Y5xYcNqZTOCh5LZnM=Y07_o8ShL-e_xe9+itHqMkgtR-dNtw@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CACR_FB63_19+4uwtyUgnt7MQ6KY7NPCTS1p1K7r8Xw3AXRBmNw@mail.gmail.com"}} , "_id" : "CACR_FB63_19+4uwtyUgnt7MQ6KY7NPCTS1p1K7r8Xw3AXRBmNw@mail.gmail.com" , "from" : "howard.lovatt at gmail.com (Howard Lovatt)" , "date" : { "$date" : 1456901467000} , "subject" : "Re: [swift-evolution] [RFC] New collections model: collections advance indices" , "references" : [ "CA+Y5xYfqKR6yC2Q-G7D9N7FeY=xs1x3frq==syGoqYpOcL9yrw@mail.gmail.com" , "CAA+bWKUPaPtN8sFiNzp+xrZV47iJdi9g_3hUrAiaG39-j7YPpg@mail.gmail.com" , "CA+Y5xYcgdxbqo7cHR4KXdBXu6stncn4WVhBea9GroeFLJLy6gw@mail.gmail.com" , "CAA+bWKXSTkAuFC+NTLPaO0XAOa09kUt5CNNNrGyoL+SZgf7ZhQ@mail.gmail.com"] , "mailingList" : "swift-evolution" , "content" : "Sorry, unfortunately I can't see that it really helps. All that happens is\nthat the client of the collection now holds the reference to the collection\nas well as the reference to the iterator. In the more traditional model the\nclient holds a reference to the iterator which in turn holds a reference to\nthe collection.\n\nMaybe the problem arose with the double indirection trick. Would a better\napproach be to keep it simple:\n\n    struct SomeCollection<E>: Collection {\n        private var refToInternalStorage: UnsafePointerOfSomeSort<E>\n        func iterable() -> SomeCollectionIterator { return\nSomeCollectionIterator(self) }\n        mutating func append(element: E) {\n            copyInternalStorageIfNecessary(size + 1) // Makes a copy if\neither not large enough or if already aliased\n            // Append `element` to `refToInternalStorage`\n        }\n        // Other functions access `refToInternalStorage`, but if mutating\ncall `copyInternalStorageIfNecessary(Int)` before modifying\n    }\n\n    struct SomeCollectionIterator<E>: Iterator {\n        private let someCollection: SomeCollection<E> // Note let not var -\ncould be direct link to internal storage\n        private var index: Index\n        init(someCollection: someCollection <E>) {\n            self.someCollection = someCollection\n            index = someCollection.firstIndex()\n        }\n        // next()\n    }\n\nObviously above is pseudo code - but hopefully you get the idea.\n\nThe difference comes when with the proposal you do:\n\n    var array = [1]\n    var iterator = array.makeIterator()\n    array.removeAll()\n    array.next(iterator) // Runtime exception\n\nSimilarly with modifications in another thread. With the above suggested\n`obvious` implementation:\n\n    var array = [1]\n    var iterator = array.iterator()\n    array.removeAll()\n    iterator.next() // OK, returns 1 because it has the original before\narray was mutated.\n\nIn essence I am saying do the obvious, since that is easiest for the\nclients (i.e. the programmers that use Swift).\n\nSorry to be negative,\n\n -- Howard.\n\n  -- Howard.\n\nOn 2 March 2016 at 14:03, Trent Nadeau via swift-evolution <\nswift-evolution@swift.org> wrote:\n\n> Ah. Thanks. I've read through that proposal before but totally forgot that\n> change.\n>\n> On Tue, Mar 1, 2016 at 10:01 PM, Dmitri Gribenko <gribozavr@gmail.com>\n> wrote:\n>\n>> On Tue, Mar 1, 2016 at 6:55 PM, Trent Nadeau <tanadeau@gmail.com> wrote:\n>> > Why is the protocol for iterators called IteratorProtocol instead of\n>> > Iterator or Iterable? If that is/was discussed elsewhere, I apologize,\n>> but I\n>> > don't remember seeing that particular name before. Is that new to this\n>> > proposal?\n>>\n>> I'm using the new names introduced by SE-0006\n>>\n>> https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md\n>>\n>> The protocol is not called Iterator to disambiguate it with the\n>> Iterator associated type in Sequence from the protocol:\n>>\n>> protocol Sequence {\n>>   associatedtype Iterator : IteratorProtocol\n>> }\n>>\n>> It is not called Iterable because that would have the wrong meaning\n>> (Sequence is iterable, the iterator iterates over its elements).\n>>\n>> Dmitri\n>>\n>> --\n>> main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if\n>> (j){printf(\"%d\\n\",i);}}} /*Dmitri Gribenko <gribozavr@gmail.com>*/\n>>\n>\n>\n>\n> --\n> Trent Nadeau\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution@swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>\n_______________________________________________\nswift-evolution mailing list\nswift-evolution@swift.org\nhttps://lists.swift.org/mailman/listinfo/swift-evolution\n" , "inReplyTo" : "CAA+bWKXSTkAuFC+NTLPaO0XAOa09kUt5CNNNrGyoL+SZgf7ZhQ@mail.gmail.com" , "archiveURL" : "" , "descendants" : [ "CACR_FB63_19+4uwtyUgnt7MQ6KY7NPCTS1p1K7r8Xw3AXRBmNw@mail.gmail.com" , "CA+Y5xYcEiEvW8fT55UGT7gUEWUzW3e-cgf6UgbGjdJd7B1Dd1A@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAA+bWKXSTkAuFC+NTLPaO0XAOa09kUt5CNNNrGyoL+SZgf7ZhQ@mail.gmail.com"}} , "_id" : "CAA+bWKXSTkAuFC+NTLPaO0XAOa09kUt5CNNNrGyoL+SZgf7ZhQ@mail.gmail.com" , "from" : "tanadeau at gmail.com (Trent Nadeau)" , "date" : { "$date" : 1456887802000} , "subject" : "Re: [swift-evolution] [RFC] New collections model: collections advance indices" , "references" : [ "CA+Y5xYfqKR6yC2Q-G7D9N7FeY=xs1x3frq==syGoqYpOcL9yrw@mail.gmail.com" , "CAA+bWKUPaPtN8sFiNzp+xrZV47iJdi9g_3hUrAiaG39-j7YPpg@mail.gmail.com" , "CA+Y5xYcgdxbqo7cHR4KXdBXu6stncn4WVhBea9GroeFLJLy6gw@mail.gmail.com"] , "mailingList" : "swift-evolution" , "content" : "Ah. Thanks. I've read through that proposal before but totally forgot that\nchange.\n\nOn Tue, Mar 1, 2016 at 10:01 PM, Dmitri Gribenko <gribozavr@gmail.com>\nwrote:\n\n> On Tue, Mar 1, 2016 at 6:55 PM, Trent Nadeau <tanadeau@gmail.com> wrote:\n> > Why is the protocol for iterators called IteratorProtocol instead of\n> > Iterator or Iterable? If that is/was discussed elsewhere, I apologize,\n> but I\n> > don't remember seeing that particular name before. Is that new to this\n> > proposal?\n>\n> I'm using the new names introduced by SE-0006\n>\n> https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md\n>\n> The protocol is not called Iterator to disambiguate it with the\n> Iterator associated type in Sequence from the protocol:\n>\n> protocol Sequence {\n>   associatedtype Iterator : IteratorProtocol\n> }\n>\n> It is not called Iterable because that would have the wrong meaning\n> (Sequence is iterable, the iterator iterates over its elements).\n>\n> Dmitri\n>\n> --\n> main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if\n> (j){printf(\"%d\\n\",i);}}} /*Dmitri Gribenko <gribozavr@gmail.com>*/\n>\n\n\n\n-- \nTrent Nadeau\n_______________________________________________\nswift-evolution mailing list\nswift-evolution@swift.org\nhttps://lists.swift.org/mailman/listinfo/swift-evolution\n" , "inReplyTo" : "CA+Y5xYcgdxbqo7cHR4KXdBXu6stncn4WVhBea9GroeFLJLy6gw@mail.gmail.com" , "archiveURL" : "" , "descendants" : [ "CAA+bWKXSTkAuFC+NTLPaO0XAOa09kUt5CNNNrGyoL+SZgf7ZhQ@mail.gmail.com" , "CACR_FB63_19+4uwtyUgnt7MQ6KY7NPCTS1p1K7r8Xw3AXRBmNw@mail.gmail.com" , "CA+Y5xYcEiEvW8fT55UGT7gUEWUzW3e-cgf6UgbGjdJd7B1Dd1A@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAA+bWKUPaPtN8sFiNzp+xrZV47iJdi9g_3hUrAiaG39-j7YPpg@mail.gmail.com"}} , "_id" : "CAA+bWKUPaPtN8sFiNzp+xrZV47iJdi9g_3hUrAiaG39-j7YPpg@mail.gmail.com" , "from" : "tanadeau at gmail.com (Trent Nadeau)" , "date" : { "$date" : 1456887327000} , "subject" : "Re: [swift-evolution] [RFC] New collections model: collections advance indices" , "references" : [ "CA+Y5xYfqKR6yC2Q-G7D9N7FeY=xs1x3frq==syGoqYpOcL9yrw@mail.gmail.com"] , "mailingList" : "swift-evolution" , "content" : "Why is the protocol for iterators called IteratorProtocol instead of\nIterator or Iterable? If that is/was discussed elsewhere, I apologize, but\nI don't remember seeing that particular name before. Is that new to this\nproposal?\n\nOn Tue, Mar 1, 2016 at 9:04 PM, Dmitri Gribenko via swift-evolution <\nswift-evolution@swift.org> wrote:\n\n> Hi,\n>\n> We would like to propose a major change to how collection indices\n> work.  The standard library team has discussed this idea internally\n> and we wrote a prototype.  Now we think it is a viable direction to\n> consider, and we are bringing it for wider public discussion.\n>\n> I'm pasting the first section of the proposal below to give you a\n> general idea about this change, but please read the proposal to\n> understand the full details.\n>\n> You can find the most up to date version of the proposal at\n>\n> https://github.com/gribozavr/swift-evolution/blob/new-collections/proposals/NNNN-collections-move-indices.md\n>\n> Permalink:\n> https://github.com/gribozavr/swift-evolution/blob/87df19a9a9d73e64a2a966b807440216a608b8ad/proposals/NNNN-collections-move-indices.md\n>\n> Dmitri\n>\n> ## Introduction\n>\n> We are proposing a new model for collections, where indices can only be\n> advanced forward or backward by the corresponding collection instance.\n> Indices become opaque tokens representing collection positions, that can\n> be produced and consumed by collection APIs.  This allows us to reduce\n> the amount of data stored in indices to the bare minimum.\n>\n> Compared to the current state, the new scheme simplifies implementation\n> of non-trivial indices, and fixes concurrency issues in `Set` and\n> `Dictionary` indices.  It also allows us to eliminate reference-counted\n> stored properties from most indices, including non-trivial ones, like\n> `Set.Index` and `Dictionary.Index`, creating more optimizable code.\n>\n> Out of scope for this proposal:\n>\n> * Expanding the set of concrete collections provided by the standard\n>   library.\n>\n> * Expanding the set of collection protocols to provide functionality\n>   beyond what is already provided (for example, protocols for sorted\n>   collections, queues etc.)  Discussing how other concrete collections\n>   fit into the current protocol hierarchy is in scope, though.\n>\n> --\n> main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if\n> (j){printf(\"%d\\n\",i);}}} /*Dmitri Gribenko <gribozavr@gmail.com>*/\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution@swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n\n\n\n-- \nTrent Nadeau\n_______________________________________________\nswift-evolution mailing list\nswift-evolution@swift.org\nhttps://lists.swift.org/mailman/listinfo/swift-evolution\n" , "inReplyTo" : "CA+Y5xYfqKR6yC2Q-G7D9N7FeY=xs1x3frq==syGoqYpOcL9yrw@mail.gmail.com" , "archiveURL" : "" , "descendants" : [ "CAA+bWKUPaPtN8sFiNzp+xrZV47iJdi9g_3hUrAiaG39-j7YPpg@mail.gmail.com" , "CA+Y5xYcgdxbqo7cHR4KXdBXu6stncn4WVhBea9GroeFLJLy6gw@mail.gmail.com" , "CAA+bWKXSTkAuFC+NTLPaO0XAOa09kUt5CNNNrGyoL+SZgf7ZhQ@mail.gmail.com" , "CACR_FB63_19+4uwtyUgnt7MQ6KY7NPCTS1p1K7r8Xw3AXRBmNw@mail.gmail.com" , "CA+Y5xYcEiEvW8fT55UGT7gUEWUzW3e-cgf6UgbGjdJd7B1Dd1A@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CA+Y5xYfqKR6yC2Q-G7D9N7FeY=xs1x3frq==syGoqYpOcL9yrw@mail.gmail.com"}} , "_id" : "CA+Y5xYfqKR6yC2Q-G7D9N7FeY=xs1x3frq==syGoqYpOcL9yrw@mail.gmail.com" , "from" : "gribozavr at gmail.com (Dmitri Gribenko)" , "date" : { "$date" : 1456884243000} , "subject" : "[swift-evolution] [RFC] New collections model: collections advance indices" , "references" :  null  , "mailingList" : "swift-evolution" , "content" : "Hi,\n\nWe would like to propose a major change to how collection indices\nwork.  The standard library team has discussed this idea internally\nand we wrote a prototype.  Now we think it is a viable direction to\nconsider, and we are bringing it for wider public discussion.\n\nI'm pasting the first section of the proposal below to give you a\ngeneral idea about this change, but please read the proposal to\nunderstand the full details.\n\nYou can find the most up to date version of the proposal at\nhttps://github.com/gribozavr/swift-evolution/blob/new-collections/proposals/NNNN-collections-move-indices.md\n\nPermalink: https://github.com/gribozavr/swift-evolution/blob/87df19a9a9d73e64a2a966b807440216a608b8ad/proposals/NNNN-collections-move-indices.md\n\nDmitri\n\n## Introduction\n\nWe are proposing a new model for collections, where indices can only be\nadvanced forward or backward by the corresponding collection instance.\nIndices become opaque tokens representing collection positions, that can\nbe produced and consumed by collection APIs.  This allows us to reduce\nthe amount of data stored in indices to the bare minimum.\n\nCompared to the current state, the new scheme simplifies implementation\nof non-trivial indices, and fixes concurrency issues in `Set` and\n`Dictionary` indices.  It also allows us to eliminate reference-counted\nstored properties from most indices, including non-trivial ones, like\n`Set.Index` and `Dictionary.Index`, creating more optimizable code.\n\nOut of scope for this proposal:\n\n* Expanding the set of concrete collections provided by the standard\n  library.\n\n* Expanding the set of collection protocols to provide functionality\n  beyond what is already provided (for example, protocols for sorted\n  collections, queues etc.)  Discussing how other concrete collections\n  fit into the current protocol hierarchy is in scope, though.\n\n-- \nmain(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if\n(j){printf(\"%d\\n\",i);}}} /*Dmitri Gribenko <gribozavr@gmail.com>*/\n_______________________________________________\nswift-evolution mailing list\nswift-evolution@swift.org\nhttps://lists.swift.org/mailman/listinfo/swift-evolution\n" , "archiveURL" : "" , "descendants" : [ "CA+Y5xYfqKR6yC2Q-G7D9N7FeY=xs1x3frq==syGoqYpOcL9yrw@mail.gmail.com" , "CAA+bWKUPaPtN8sFiNzp+xrZV47iJdi9g_3hUrAiaG39-j7YPpg@mail.gmail.com" , "CA+Y5xYcgdxbqo7cHR4KXdBXu6stncn4WVhBea9GroeFLJLy6gw@mail.gmail.com" , "CAA+bWKXSTkAuFC+NTLPaO0XAOa09kUt5CNNNrGyoL+SZgf7ZhQ@mail.gmail.com" , "314A26E1-C235-4C68-81EE-18B2284CEC5A@lorentey.hu" , "CACR_FB63_19+4uwtyUgnt7MQ6KY7NPCTS1p1K7r8Xw3AXRBmNw@mail.gmail.com" , "CA+Y5xYcEiEvW8fT55UGT7gUEWUzW3e-cgf6UgbGjdJd7B1Dd1A@mail.gmail.com" , "DE386A8B-8454-4137-AB74-E29BD13C621C@architechies.com" , "CA+Y5xYcNqZTOCh5LZnM=Y07_o8ShL-e_xe9+itHqMkgtR-dNtw@mail.gmail.com"] , "inReplyTo" :  null } , { "_links" : { "self" : { "href" : "/charter/emails/CA+Y5xYcgdxbqo7cHR4KXdBXu6stncn4WVhBea9GroeFLJLy6gw@mail.gmail.com"}} , "_id" : "CA+Y5xYcgdxbqo7cHR4KXdBXu6stncn4WVhBea9GroeFLJLy6gw@mail.gmail.com" , "from" : "gribozavr at gmail.com (Dmitri Gribenko)" , "date" : { "$date" : 1456887685000} , "subject" : "Re: [swift-evolution] [RFC] New collections model: collections advance indices" , "references" : [ "CA+Y5xYfqKR6yC2Q-G7D9N7FeY=xs1x3frq==syGoqYpOcL9yrw@mail.gmail.com" , "CAA+bWKUPaPtN8sFiNzp+xrZV47iJdi9g_3hUrAiaG39-j7YPpg@mail.gmail.com"] , "mailingList" : "swift-evolution" , "content" : "On Tue, Mar 1, 2016 at 6:55 PM, Trent Nadeau <tanadeau@gmail.com> wrote:\n> Why is the protocol for iterators called IteratorProtocol instead of\n> Iterator or Iterable? If that is/was discussed elsewhere, I apologize, but I\n> don't remember seeing that particular name before. Is that new to this\n> proposal?\n\nI'm using the new names introduced by SE-0006\nhttps://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md\n\nThe protocol is not called Iterator to disambiguate it with the\nIterator associated type in Sequence from the protocol:\n\nprotocol Sequence {\n  associatedtype Iterator : IteratorProtocol\n}\n\nIt is not called Iterable because that would have the wrong meaning\n(Sequence is iterable, the iterator iterates over its elements).\n\nDmitri\n\n-- \nmain(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if\n(j){printf(\"%d\\n\",i);}}} /*Dmitri Gribenko <gribozavr@gmail.com>*/\n_______________________________________________\nswift-evolution mailing list\nswift-evolution@swift.org\nhttps://lists.swift.org/mailman/listinfo/swift-evolution\n" , "inReplyTo" : "CAA+bWKUPaPtN8sFiNzp+xrZV47iJdi9g_3hUrAiaG39-j7YPpg@mail.gmail.com" , "archiveURL" : "" , "descendants" : [ "CA+Y5xYcgdxbqo7cHR4KXdBXu6stncn4WVhBea9GroeFLJLy6gw@mail.gmail.com" , "CAA+bWKXSTkAuFC+NTLPaO0XAOa09kUt5CNNNrGyoL+SZgf7ZhQ@mail.gmail.com" , "CACR_FB63_19+4uwtyUgnt7MQ6KY7NPCTS1p1K7r8Xw3AXRBmNw@mail.gmail.com" , "CA+Y5xYcEiEvW8fT55UGT7gUEWUzW3e-cgf6UgbGjdJd7B1Dd1A@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CA+Y5xYcNqZTOCh5LZnM=Y07_o8ShL-e_xe9+itHqMkgtR-dNtw@mail.gmail.com"}} , "_id" : "CA+Y5xYcNqZTOCh5LZnM=Y07_o8ShL-e_xe9+itHqMkgtR-dNtw@mail.gmail.com" , "from" : "gribozavr at gmail.com (Dmitri Gribenko)" , "date" : { "$date" : 1456910518000} , "subject" : "Re: [swift-evolution] [RFC] New collections model: collections advance indices" , "references" : [ "CA+Y5xYfqKR6yC2Q-G7D9N7FeY=xs1x3frq==syGoqYpOcL9yrw@mail.gmail.com" , "DE386A8B-8454-4137-AB74-E29BD13C621C@architechies.com"] , "mailingList" : "swift-evolution" , "content" : "On Wed, Mar 2, 2016 at 1:08 AM, Brent Royal-Gordon\n<brent@architechies.com> wrote:\n>> We would like to propose a major change to how collection indices\n>> work.  The standard library team has discussed this idea internally\n>> and we wrote a prototype.  Now we think it is a viable direction to\n>> consider, and we are bringing it for wider public discussion.\n>\n> This is super-interesting, and overall I think it's probably an improvement (although I haven't gone *really* deep with generic CollectionType code very often).\n>\n> I do have a question, though it may simply betray my ignorance. `advance` has two forms:\n>\n>         func advance(i: Index, by n: IndexDistance) -> Index\n>         func advance(i: Index, by n: IndexDistance, limit: Index) -> Index\n>\n> This is a pretty straight port of the old `advance`:\n>\n>         public func advancedBy(amount: Distance) -> Self\n>         public func advancedBy(amount: Distance, limit: Self) -> Self\n>\n> But I'm not sure the `limit` parameter is still appropriate. I've always figured that you were supposed to pass the collection's `endIndex` there, but now that `advance` *is* a method on the collection, it can access that itself. Would we be better served with something like this?\n>\n>         func unsafeAdvance(i: Index, by n: IndexDistance) -> Index              // no endIndex check\n>         func advance(i: Index, by n: IndexDistance) -> Index                    // endIndex check\n>\n> Or do you imagine the `limit` parameter being put to some other use that I'm not thinking of?\n\nIf limit was implied to be endIndex, how would Slice implement the\nlimiting advance?  Only by ignoring the advance() implementation from\nthe collection, and incrementing manually.  So it seems like advance\nwith an explicit limit is a basic operation that you can use to build\nothers.\n\nAnother thing is that 'unsafeAdvance' is not really unsafe, it used to\nbe implementation-defined, but not memory-unsafe.  But now that the\ncollection is always available in advance(_:by:), we should be able to\nrequire it to perform a trap if result is out of bounds.\n\nDmitri\n\n-- \nmain(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if\n(j){printf(\"%d\\n\",i);}}} /*Dmitri Gribenko <gribozavr@gmail.com>*/\n_______________________________________________\nswift-evolution mailing list\nswift-evolution@swift.org\nhttps://lists.swift.org/mailman/listinfo/swift-evolution\n" , "inReplyTo" : "DE386A8B-8454-4137-AB74-E29BD13C621C@architechies.com" , "archiveURL" : "" , "descendants" : [ "CA+Y5xYcNqZTOCh5LZnM=Y07_o8ShL-e_xe9+itHqMkgtR-dNtw@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CA+Y5xYcEiEvW8fT55UGT7gUEWUzW3e-cgf6UgbGjdJd7B1Dd1A@mail.gmail.com"}} , "_id" : "CA+Y5xYcEiEvW8fT55UGT7gUEWUzW3e-cgf6UgbGjdJd7B1Dd1A@mail.gmail.com" , "from" : "gribozavr at gmail.com (Dmitri Gribenko)" , "date" : { "$date" : 1456902301000} , "subject" : "Re: [swift-evolution] [RFC] New collections model: collections advance indices" , "references" : [ "CA+Y5xYfqKR6yC2Q-G7D9N7FeY=xs1x3frq==syGoqYpOcL9yrw@mail.gmail.com" , "CAA+bWKUPaPtN8sFiNzp+xrZV47iJdi9g_3hUrAiaG39-j7YPpg@mail.gmail.com" , "CA+Y5xYcgdxbqo7cHR4KXdBXu6stncn4WVhBea9GroeFLJLy6gw@mail.gmail.com" , "CAA+bWKXSTkAuFC+NTLPaO0XAOa09kUt5CNNNrGyoL+SZgf7ZhQ@mail.gmail.com" , "CACR_FB63_19+4uwtyUgnt7MQ6KY7NPCTS1p1K7r8Xw3AXRBmNw@mail.gmail.com"] , "mailingList" : "swift-evolution" , "content" : "On Tue, Mar 1, 2016 at 10:51 PM, Howard Lovatt <howard.lovatt@gmail.com> wrote:\n> Sorry, unfortunately I can't see that it really helps. All that happens is\n> that the client of the collection now holds the reference to the collection\n> as well as the reference to the iterator. In the more traditional model the\n> client holds a reference to the iterator which in turn holds a reference to\n> the collection.\n\nI don't think there is a problem with iterators holding references to\nthe collection.  Iterators are value types, so they have to hold a\nstrong reference to the underlying collection, to make it non-uniquely\nreferenced, to prevent it from being mutated in place.  It is a\nfeature that iterators traverse a snapshot of the collection --\nbecause of value semantics.\n\n// Append array to itself:\nfor x in myArray { // for loop is just syntactic sugar for extracting\nan iterator, and consuming it.\n  myArray.append(x)\n}\n\nI think you might be confusing iterators and indexes.  Iterators\ntraverse the collection once.  Once you moved the iterator to the next\nposition, you can't move it back.  Sequences and collections both have\niterators.  Indices, on the other hand, are the basis of the\nmulti-pass nature of the collection.  If you hold onto an index, you\ncan use it multiple times to refer to collection's element, and even\nmutate it.\n\nDmitri\n\n-- \nmain(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if\n(j){printf(\"%d\\n\",i);}}} /*Dmitri Gribenko <gribozavr@gmail.com>*/\n_______________________________________________\nswift-evolution mailing list\nswift-evolution@swift.org\nhttps://lists.swift.org/mailman/listinfo/swift-evolution\n" , "inReplyTo" : "CACR_FB63_19+4uwtyUgnt7MQ6KY7NPCTS1p1K7r8Xw3AXRBmNw@mail.gmail.com" , "archiveURL" : "" , "descendants" : [ "CA+Y5xYcEiEvW8fT55UGT7gUEWUzW3e-cgf6UgbGjdJd7B1Dd1A@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/314A26E1-C235-4C68-81EE-18B2284CEC5A@lorentey.hu"}} , "_id" : "314A26E1-C235-4C68-81EE-18B2284CEC5A@lorentey.hu" , "from" : "karoly at lorentey.hu (Károly Lőrentey)" , "date" : { "$date" : 1456900744000} , "subject" : "Re: [swift-evolution] [RFC] New collections model: collections advance indices" , "references" : [ "CA+Y5xYfqKR6yC2Q-G7D9N7FeY=xs1x3frq==syGoqYpOcL9yrw@mail.gmail.com"] , "mailingList" : "swift-evolution" , "content" : "This looks interesting! As the author of a number of custom collection\nimplementations, including a rather elaborate B-tree package\n(https://github.com/lorentey/BTree), it always felt strange to me that\nindices are expected to be able to move around the collection on their\nown, while element access has to go through by the collection. It is a\ngreat idea to fix this asymmetry.\n\nI’ll have to carefully read through it a couple more times and look at\nthe prototype branch to form a real opinion, but at first glance I\nlike the proposal. Here are a couple of quick thoughts, with more to\ncome once I had time to think about the implications in detail:\n\n- I’m not at a great fan of the `*IndexType` protocols in Swift 2. I\n  do not believe they work hard enough compared to how hard it is to\n  implement them, and I welcome any change that makes them even a \n  little bit simpler for the collection writer.\n\n- Having to call a collection method to increment an index looks\n  unnatural at first glance, but I can see myself getting used to it\n  in a few hours.\n\n- I know that it isn't a new requirement, but I do dislike that\n  `Indexable` specifies the complexity of index operations; this puts\n  a hard constraint on custom collection design. I do understand the\n  desire for concrete complexity promises on operations using\n  indexes, but can't we express these instead e.g. in terms of number\n  of index accesses?\n\n- I love that there is a section with detailed guidance on designing \n  tree-based collections. It’s interesting and informative.\n\n- My B-trees are persistent data structures, thus my nodes cannot have\n  parent or sibling links. Index lookup and navigation is still O(1)\n  though, as my indices contain pointers to every node on the path to\n  the current element. Since I have to keep looking up these nodes\n  anyway to retrieve elements and to navigate around in the tree, I\n  simply decided to keep them directly in the index. B-trees are super\n  shallow, so there are only a handful of nodes on any path.\n\n- I found that the most straightforward place to implement tree\n  navigation methods like `next(:)` and `advance(:by:)` is on the path\n  struct that contains the actual node references. There is no reason\n  I couldn't have the new collection methods simply call through to\n  these path methods, though -- I am currently doing the same thing in\n  the BTreeIndex type anyway.\n  \n- I'm using weak references inside the index, with a (seriously\n  underdeveloped) index invalidation method that happens to be closer\n  to #2b than #2a. I'm not happy about using weak references, but this\n  seemed the most sensible thing to do. I'd love to replace them with\n  `unowned(unsafe)`, and the mutation counter seems like a great idea.\n  The ARC issue mentioned at the end of the proposal is rather scary,\n  though -- I don't know how I would protect against that.\n  \n  Generators/iterators look to be safe from this issue,\n  so I’ll probably optimize their path representation first. \n\n- For mutation, I think custom APIs often make much more sense\n  than general-purpose solutions. I try to discourage use of the normal\n  B-tree index for doing complex tree mutations, and I instead provide \n  a cursor construct that was designed especially for performing \n  a batch of mutations in a batch:\n\n  https://github.com/lorentey/BTree/blob/master/Sources/BTreeCursor.swift#L295-L707 \n\n  The cursor is like an index on steroids. It has an identity with\n  mutable state on its own, and it takes unique ownership of the tree\n  while it is active. This frees the cursor to disable some costly\n  invariants (such as maintaining up-to-date descendant counts in each\n  node). This in turn allows for convenient batch editing of elements\n  in the tree, with amortized O(1) insertion and removal operations.\n\n  The cursor's approach goes the exact opposite way of this proposal:\n  not only is the collection not necessary to use the cursor, but the\n  collection's value isn't even available while there is an active\n  cursor on it. (This is like how\n  `Array.withUnsafeMutableBufferPointer()` works.)\n\n- I'm almost positive this has been discussed before, but what is the\n  rationale behind allowing non-Int `IndexDistance`s? The distance is\n  getting cast to Int in a lot of places anyway (IIRC, even the stdlib\n  uses numericCasts to cut a way through it.)\n\n    associatedtype IndexDistance : SignedIntegerType = Int\n\n- The `Indices` associated type is intriguing. I assume it is brand new?\n  It seems strange that it is allowed to hold a strong reference, but\n  I’ll have to look through the prototype code to grok it.\n\n  Superficial comment: I’m not too happy with the name. The irregular\n  plural is hard on non-native English speakers, plus it seems weird\n  to have both an `Index` and an `Indices` type. The `indices` property\n  calls it `IndexRange` (I assume by accident); I think I like that \n  name better.\n\n- In this declaration:\n\n    subscript(position: Index) -> Generator.Element { get }\n\n  I find the argument name rather unfortunate, because I've been using\n  the term \"position\" to consistently refer to the (numerical)\n  position of an element in an ordered collection, which is typically\n  not the same as the element's index. Could we just quietly rename\n  this to `index` or `i`? :-)\n\n\n> On 2016-03-02, at 03:04, Dmitri Gribenko <gribozavr@gmail.com> wrote:\n> \n> Hi,\n> \n> We would like to propose a major change to how collection indices\n> work.  The standard library team has discussed this idea internally\n> and we wrote a prototype.  Now we think it is a viable direction to\n> consider, and we are bringing it for wider public discussion.\n> \n> I'm pasting the first section of the proposal below to give you a\n> general idea about this change, but please read the proposal to\n> understand the full details.\n> \n> You can find the most up to date version of the proposal at\n> https://github.com/gribozavr/swift-evolution/blob/new-collections/proposals/NNNN-collections-move-indices.md\n> \n> Permalink: https://github.com/gribozavr/swift-evolution/blob/87df19a9a9d73e64a2a966b807440216a608b8ad/proposals/NNNN-collections-move-indices.md\n> \n> Dmitri\n> \n> ## Introduction\n> \n> We are proposing a new model for collections, where indices can only be\n> advanced forward or backward by the corresponding collection instance.\n> Indices become opaque tokens representing collection positions, that can\n> be produced and consumed by collection APIs.  This allows us to reduce\n> the amount of data stored in indices to the bare minimum.\n> \n> Compared to the current state, the new scheme simplifies implementation\n> of non-trivial indices, and fixes concurrency issues in `Set` and\n> `Dictionary` indices.  It also allows us to eliminate reference-counted\n> stored properties from most indices, including non-trivial ones, like\n> `Set.Index` and `Dictionary.Index`, creating more optimizable code.\n> \n> Out of scope for this proposal:\n> \n> * Expanding the set of concrete collections provided by the standard\n>  library.\n> \n> * Expanding the set of collection protocols to provide functionality\n>  beyond what is already provided (for example, protocols for sorted\n>  collections, queues etc.)  Discussing how other concrete collections\n>  fit into the current protocol hierarchy is in scope, though.\n\n-- \nKaroly\n\n_______________________________________________\nswift-evolution mailing list\nswift-evolution@swift.org\nhttps://lists.swift.org/mailman/listinfo/swift-evolution\n" , "inReplyTo" : "CA+Y5xYfqKR6yC2Q-G7D9N7FeY=xs1x3frq==syGoqYpOcL9yrw@mail.gmail.com" , "archiveURL" : "" , "descendants" : [ "314A26E1-C235-4C68-81EE-18B2284CEC5A@lorentey.hu"]}]}}