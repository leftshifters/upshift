{ "_links" : { "self" : { "href" : "/charter/emails?filter={mailingList:'swift-evolution'}&page=1&pagesize=300&sort_by=date"} , "curies" : [ ]} , "_id" : "emails" , "_created_on" : "2016-02-12T02:49:33Z" , "_etag" : { "$oid" : "56bd483da07fe857fb4ce84b"} , "_collection-props-cached" : false , "_returned" : 300 , "_embedded" : { "rh:doc" : [ { "_links" : { "self" : { "href" : "/charter/emails/2E514F6E-5BF9-465D-AC41-D1182E0FA373@apple.com"}} , "_id" : "2E514F6E-5BF9-465D-AC41-D1182E0FA373@apple.com" , "from" : "jgroff at apple.com (Joe Groff)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 5, 2015, at 10:13 AM, David Owens II <david at owensd.io> wrote:\n> \n> Is there a reason we cannot use labelled case statements?\n> \n>     switch some_value {\n>     case .REFINED:\n>         if !validate(some_value) { return NULL }\n>         fallthrough base\n> \n>     base: case .BASE:\n>         handle_enum_value();\n>     }\n> \n> At least this is explicit now.\n\nYeah, maybe there's a more general language feature that could replace 'fallthrough' here. Instead of labelling cases, we could support a 'reswitch' statement that redispatches the switch to the case matching the operand:\n\n    switch some_value {\n    case .REFINED:\n        if !validate(some_value) { return NULL }\n        reswitch .BASE\n\n    case .BASE:\n        handle_enum_value();\n    }\n\nThat should be easy to peephole to a proper fallthrough in constant cases, but would also nicely generalize to applications like interpreters, where it's often desirable to push the dispatch inline into the logic for better pipelining.\n\n-Joe\n\n> \n>> On Dec 5, 2015, at 10:04 AM, Vinicius Vendramini <vinivendra at gmail.com <mailto:vinivendra at gmail.com>> wrote:\n>> \n>> I understand there might be some cases in which the syntax provided is indeed useful for experienced programmers writing their code. However, in almost all the examples here, I had to struggle to understand the logic behind the code. Not because it’s poorly written... probably because this syntax may be used for many different purposes, so it’s hard to get what exactly is the intent behind each use.\n>> \n>> In Pierre’s latest example, for instance, it took me a few seconds to understand what was going on. I know it’s a simplified case, but it seems clearer to me to just write something like\n>> \n>> if some_value == .Refined && !validate(some_value) {\n>> \treturn NULL\n>> }\n>> handle_enum_value()\n>> \n>> More complex cases make for a better argument for `switch`es, mainly because they avoid big `if` pyramids, but especially in those I feel the resulting code is significantly harder to understand.\n>> \n>>> On Dec 5, 2015, at 12:15 PM, Pierre Habouzit <phabouzit at apple.com <mailto:phabouzit at apple.com>> wrote:\n>>> \n>>> \n>>>> On Dec 5, 2015, at 9:02 AM, Chris Lattner <clattner at apple.com <mailto:clattner at apple.com>> wrote:\n>>>> \n>>>> On Dec 4, 2015, at 2:05 PM, jalkut at red-sweater.com <mailto:jalkut at red-sweater.com> wrote:\n>>>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the \"fallthrough\" keyword from the language?\n>>>> \n>>>> I’m not making an argument either way, but I want to point something out: there is a major difference between fallthrough vs ++/c-style-for.  To someone who doesn’t know them, the later are \"syntactic magic” with no reasonable way to decipher other than looking them up somewhere.  The former is an English word whose meaning is obvious in context.\n>>>> \n>>>> All I’m saying is that to a reader of code, the “badness” of ++ and c-style for loops is greater than the “badness\" of fallthrough.\n>>> \n>>> Given that Swift has the goal to also be a low level language, fallthrough is really useful for conciseness and readability.\n>>> \n>>> in system programming C, I find myself writing things like this very often:\n>>> \n>>> \n>>> switch (some_value) {\n>>> case ENUM_VALUE_REFINED:\n>>>     if (validate(some_value)) {\n>>>         return NULL;\n>>>     }\n>>>     /* fallthrough */\n>>> case ENUM_VALUE_BASE:\n>>>     handle_enum_value();\n>>>     …\n>>> }\n>>> \n>>> Where the swift equivalent would roughly be:\n>>> \n>>> switch some_value {\n>>> case .REFINED:\n>>>     if !validate(some_value) { return NULL }\n>>>     fallthrough\n>>> case .BASE:\n>>>     handle_enum_value();\n>>> }\n>>> \n>>> This is as readable as it gets and is a pattern that the libdispatch has in several places e.g.\n>>> \n>>> Of course, you cannot fall through to arbitrary cases, so things like this C code cannot be done in swift:\n>>> \n>>> switch (some_value) {\n>>> case ENUM_VALUE_REFINED_1:\n>>>     if (validate(some_value)) {\n>>>         return NULL;\n>>>     }\n>>>     goto base_value;\n>>> case ENUM_VALUE_REFINED_2:\n>>>     if (validate(some_value)) {\n>>>         return NULL;\n>>>     }\n>>>     goto base_value;\n>>> \n>>> case ENUM_VALUE_BASE:\n>>> base_value:\n>>>     handle_enum_value();\n>>>     …\n>>> }\n>>> \n>>> \n>>> cannot be written in swift, despite also being quite useful.\n>>> \n>>> Jumping between arbitrary points inside a switch is disgusting. jumping from label to label is useful and not harmful especially in swift where you can’t place code between the “switch” and the first case.\n>>> \n>>> -Pierre\n>>> \n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>> \n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n> \n>  _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000411.html" , "inReplyTo" : "7CC39B1D-F4D5-4C56-B927-CFE719E5FF18@owensd.io" , "date" : { "$date" : 1449341764000} , "subject" : "[swift-evolution] Proposal: Remove the \"fallthrough\" keyword" , "references" : [ "3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com" , "ECBFB28A-19AE-4207-A336-CB328A61B3FF@apple.com" , "5BDE338D-E239-4B87-8F9C-29127FA31B08@apple.com" , "656EA51E-3A37-4A39-988A-7A84ED84C690@gmail.com" , "7CC39B1D-F4D5-4C56-B927-CFE719E5FF18@owensd.io"]} , { "_links" : { "self" : { "href" : "/charter/emails/CADcs6kPtiQ47HEoW1hZ+__rb5KA8aK0Y7qBSS2sgyj9M5w=0cA@mail.gmail.com"}} , "_id" : "CADcs6kPtiQ47HEoW1hZ+__rb5KA8aK0Y7qBSS2sgyj9M5w=0cA@mail.gmail.com" , "from" : "jtbandes at gmail.com (Jacob Bandes-Storch)" , "mailingList" : "swift-evolution" , "content" : "Another approach would be to simply allow\n\nguard let self = self else { return }\nOn Sat, Dec 5, 2015 at 3:48 AM Robert Vojta <rvojta at me.com> wrote:\n\n> Hi all,\n>\n> let’s say we have a completion handler closure for some function\n> (networking, …) and we have [weak self] there. Example …\n>\n> doSomething() { [weak self] result in\n>   …\n> }\n>\n> … then we can use self?.whatever to access self properties, methods. Or we\n> can try to check if self exists ...\n>\n> guard let strongSelf = self else { return }\n>\n> … and use strongSelf.\n>\n> Can we introduce [weakStrong self] with following behavior:\n>\n>  - self is a weak reference\n>  - when the closure is going to be executed, all weakStrong weak\n> references are checked if they do exist\n>  - if they do exist, they’re strong referenced for the closure and the\n> closure is executed\n>  - if they don’t exist, closure is not executed\n>\n> doSomething() { [weakStrong self] result in\n>   // Closure code is not executed if self no longer exists\n>   // self is a strong reference now\n> }\n>\n> What do you think? Does it make sense?\n>\n> My motivation is to get rid off of the repetitive code like this one:\n>\n> doSomething() { [weak self] result in\n>   guard let strongSelf = self else { return }\n>   strongSelf.doSomethingWithResult(result)\n> }\n>\n> Robert\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000412.html" , "inReplyTo" : "6B853E77-1E06-4246-A823-1D055689FE22@me.com" , "date" : { "$date" : 1449343315000} , "subject" : "[swift-evolution] Proposal: weakStrong self in completion handler closures" , "references" : [ "6B853E77-1E06-4246-A823-1D055689FE22@me.com"] , "descendants" : [ "DCEF9750-F5E0-4639-8D78-8CC37F5A60A3@me.com" , "242D65BB-3319-468D-A259-DA1AC28FB5C7@me.com" , "CADcs6kMKhQRV_k=Mvh5Q1Z8bULY1kaF3XQKv9nZkHdeTyNdVMw@mail.gmail.com" , "CAHF2dSLBLDwWFOvQOgKWbry-ABruSVsbu208Ay3RXP_7=CLmYw@mail.gmail.com" , "BLU436-SMTP178F245BC064926665ED9B9AA0A0@phx.gbl"]} , { "_links" : { "self" : { "href" : "/charter/emails/BD305678-84D8-49BF-AC25-8F3492044536@alexkolov.com"}} , "_id" : "BD305678-84D8-49BF-AC25-8F3492044536@alexkolov.com" , "from" : "me at alexkolov.com (Alexander Kolov)" , "mailingList" : "swift-evolution" , "content" : "Hi everyone,\n\nComing from a short discussion in swift-corelibs-dev, I’m investigating the need of a standard logging API as a part of core libraries.\n\nThe motivation behind this would be having a unified and configurable set of APIs between all first-party modules and third party applications and libraries.\nI think this will help each of us since right now we’re inventing our own solutions as well many bigger third-party library providers have formats and facilities of their own.\n\nAs I currently see it would be somewhat similar to python logging and possibly even structlog (http://www.structlog.org/en/stable/ <http://www.structlog.org/en/stable/>), with configurable formatters and handlers, including and not limited to remote loggers and syslog support.\n\nI’d love to hear your opinions and feedback on this and possibly start with some more formalized proposal and implementation if there’s enough support and need.\n\nThanks,\nAlex" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000413.html" , "date" : { "$date" : 1449343447000} , "subject" : "[swift-evolution] Proposal: standard logging facility" , "references" : [ ""] , "inReplyTo" :  null  , "descendants" : [ "CAGUyf_E8Sahb6XB9namSQGfuap=kmVEdfud=YTZuyz+rowaj0A@mail.gmail.com" , "72739D97-A103-4894-AC0E-2BE87EFB99EA@alexkolov.com" , "CAC4po2bgFCdZz7vsoYT182VEU_CSq9+DbisUWU3YTCv1Ox2shA@mail.gmail.com" , "DFB23D2F-A970-423F-B23D-1D6F181B1F6A@alkaline-solutions.com" , "87E6ED33-E2D8-42CB-A999-14285D96AA40@alexkolov.com" , "FDA512BC-9A25-4360-9BBC-718CAAC19E43@gmail.com" , "B13A0695-75A2-445C-858F-7D854C19C326@apple.com" , "A1E5FCF7-C4EF-4126-BB2A-C39028773A18@alexkolov.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/A7E9633F-7227-47A7-BE95-68F839D76549@icloud.com"}} , "_id" : "A7E9633F-7227-47A7-BE95-68F839D76549@icloud.com" , "from" : "zarzycki at icloud.com (David Zarzycki)" , "mailingList" : "swift-evolution" , "content" : "Hi Chris,\n\nAn observation about SE-0004: Remove the ++ and — operators:\n\nGiven that the above is accepted, the only remaining postfix operator in the language is ‘!’ — and that is implemented by the compiler. Please consider just removing user-defined postfix operators entirely. Doing so would define away a type checking ambiguity where “let f : T -> T = someOperatorIdentifier” is ambiguous when both prefix and postfix operators exist.\n\nCheers,\nDave" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000414.html" , "date" : { "$date" : 1449343573000} , "subject" : "[swift-evolution] Feedback for SE-0004: Remove the ++ and -- operators" , "references" : [ ""] , "inReplyTo" :  null  , "descendants" : [ "7C63AD72-C9A4-4794-9F1F-7D978357F5C5@apple.com" , "7BDB9D9E-C327-4904-AC6F-D430D98A9EAC@icloud.com" , "B6FE292E-AD5C-417D-8F79-96EF7AECCF35@icloud.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/C6420D4E-B7FF-4A40-B9CE-2FC92EEC6EFF@icloud.com"}} , "_id" : "C6420D4E-B7FF-4A40-B9CE-2FC92EEC6EFF@icloud.com" , "from" : "plxswift at icloud.com (plx)" , "mailingList" : "swift-evolution" , "content" : "Swift’s standard library's core collections' value-like, copy-on-write behavior is handy in the small, but they compose rather poorly with each other: if you have e.g. [K:Set<V>], and plan to mutate the “inner\" sets, it seems at present as if there is no way to avoid an unnecessary transient copy of each set for each mutation you perform upon it.\n\nVarious workarounds/solutions exist but all are full of unfortunate tradeoffs and/or limited further composability; in concrete cases you can do alright, but it’s hard to craft a generic solution that doesn’t inadvertently reintroduce the problem you started-out trying to solve.\n\nIs anything currently on the roadmap to address this specifically — whether optimizer improvements, extended APIs, implementation adjustments, a `borrow` construct, or some other approach?" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000415.html" , "date" : { "$date" : 1449344096000} , "subject" : "[swift-evolution] Inquiry: Improved Composability of stdlib Collections?" , "references" : [ ""] , "inReplyTo" :  null  , "descendants" : [ "90FCCED1-02A8-4842-8467-20B31D23AF63@apple.com" , "A3773EB7-8ED6-4576-97BE-329A3BFB5CF4@icloud.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com"}} , "_id" : "BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com" , "from" : "david at hartbit.com (David Hart)" , "mailingList" : "swift-evolution" , "content" : "> This is subtle and requires thought\n\nWhat do you envision as the pitfalls of the design thinking behind if/switch expressions? I’m not a compiler programmer, but a prog-lang enthusiast. I wouldn’t mind a little nudge in the right direction.\n\nDavid.\n\n> On 05 Dec 2015, at 18:09, Chris Lattner <clattner at apple.com> wrote:\n> \n> \n>> On Dec 4, 2015, at 11:43 AM, J. Cheyo Jimenez <cheyo at masters3d.com <mailto:cheyo at masters3d.com>> wrote:\n>> \n>> I'd like some feedback from the core team to see if eliminating the ternary operator and replacing it with if-else is even proposal worthy. \n>> \n>> Some interesting code in the standard library that uses the ternary operator quite a bit. \n>> \n>> https://gist.github.com/masters3d/7b0c6f3653368afe4357 <https://gist.github.com/masters3d/7b0c6f3653368afe4357>\n> \n> FWIW, I have no love for the ternary operator (it is totally \"bizarre C magic”), but it does solve a problem that Swift currently otherwise has no solution for.\n> \n> If you’re interested in pursuing this, then the right path forward is to build a holistic proposal to turn statements (like if and switch) into expressions.  This is subtle and requires thought, but is widely desired and if someone were interested in driving the design and implementation, then I’d be interested to see it happen.\n> \n> -Chris\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000416.html" , "inReplyTo" : "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com" , "date" : { "$date" : 1449344443000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com" , "CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com" , "C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com" , "18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com" , "2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io" , "BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com" , "CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com" , "CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com" , "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com"] , "descendants" : [ "D381E334-74B7-41EC-90BF-544A925D2204@icloud.com" , "D9043847-2CF1-40A8-9BDD-2C0DCCAB5A38@supmenow.com" , "EAEE8B4A-12A2-4FD6-BA7B-B26071F08489@gmail.com" , "909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net" , "4998B6F2-B53E-451A-8DDA-353C631562D1@apple.com" , "CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com" , "4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com" , "CAAcV4sbQxUywKAHE=3SCACEFH4YvUqjwEr_0=fjf59ndZtoedg@mail.gmail.com" , "07270E34-E284-4FF0-B2EA-6DBB54FF78B5@portableinnovations.de" , "67057217-F4BC-4584-8B52-8EBA2CFA8CC7@portableinnovations.de" , "45B71AF5-DD4F-4E9C-A128-5B8041917564@me.com" , "CAKCGC8BmmCk55=6UC_qk_C+ZNq2JfGpOPO5cJ=SK2784kmvbGg@mail.gmail.com" , "B6DDD94B-0755-4D40-94F0-D2469A644818@portableinnovations.de" , "CAKCGC8AerqpPTrwdmPAvhmp-fLt-v=LXw4z0t+2o93g9GmAaxw@mail.gmail.com" , "54E5D8F5-616D-41EB-A550-E639FE861575@gmail.com" , "CAKCGC8CsJ7g_Fu8fnQ5Mv=yAzbSvb0Z+iNmdXKnJaAcWR2UKuw@mail.gmail.com" , "6830F74D-78FC-4B20-A6D5-683185B30164@gmail.com" , "691A92C4-1A5F-4CAE-AF50-F6AAA3A3F32C@portableinnovations.de" , "D35074A6-1C34-4BA3-AAF1-8CFE1992A522@me.com" , "1EE735A6-FF0F-4E49-BE7D-AC7E6C8A87EC@tarantsov.com" , "3D250DE5-09BC-4A6B-AF59-E1D714DF709A@tarantsov.com" , "BB6A4434-E2B1-4192-8450-90D636E6A7F5@fastmail.fm" , "0ED79E6D-A89A-4F3E-9269-6216BD10EB22@sealedabstract.com" , "CAAcV4sb9eMhuLGL3QsBw4bFxj1FQrokCAanKjEFRNNReE8zWOQ@mail.gmail.com" , "7253CF12-DBD4-483D-941F-04851E5AD394@tarantsov.com" , "CAAcV4sbo4=Hdzp+yx-km-CnhNDm2uQ-gDJsvdug_Pg-MjTPC=Q@mail.gmail.com" , "CAAcV4sbAk_eSdjz7bQ6ggdZNE+thmj7-wT_pG2+eRMKDVba+wA@mail.gmail.com" , "B619CC7E-59A8-4B3C-8E46-FC7FD4C4C6E6@apple.com" , "2372BF92-E97D-40C3-8FEC-0CA9B00ACACE@icloud.com" , "BB1D04A8-2E17-497F-AE74-8FDE4AEC4D77@fastmail.fm" , "2F722DE2-D3AE-44D5-83BB-CBCD371801AD@icloud.com" , "7B70F158-5B8A-425B-980C-CD08210342D4@me.com" , "FDB72AC4-0B0A-4D0F-A9D2-FFE43A55362E@gmail.com" , "9E0141FF-8B3B-4736-88EE-11F05930D149@fastmail.fm" , "CAAcV4sba2j1hOrBJO1kmLpLcjwSQoE0LUejbdNxa05zFzUmi3g@mail.gmail.com" , "DE316C42-6FA7-4A60-80C2-AFF74844EF09@fastmail.fm" , "33B028BA-EB5F-4986-9F16-3057390C3F16@gmail.com" , "BB8653D1-400D-49BC-AA77-6ECC096747B3@icloud.com" , "54B5FAEC-8636-44C5-96A2-0401999DD5D2@gmail.com" , "D679F068-B7C8-4DF2-A7E6-4D78B74F6B17@tarantsov.com" , "DDCE4FC9-2DED-45E5-8D9B-CAB2AA8CF9E6@gmail.com" , "C1C319DB-3934-40B6-ABEE-51B07463E6EF@upzzle.com" , "1C3ADBD7-D4CD-417A-AC45-029D7A889812@fastmail.fm" , "39024D06-E664-42EB-9E68-4D3E5BDC577D@anandabits.com" , "CAE+=ROVg0cJVKnSdwB=KPrEtr=GYd+PMMaOvbCj=N0RtUT=Q6A@mail.gmail.com" , "CAE+=ROVUD1ECe9yHG8kMW0skCFV0=BK70rw+5V7rNHEfmGhNjQ@mail.gmail.com" , "C04621E1-91D2-4A7D-9F9C-58F862B38355@icloud.com" , "581FE433-8169-4D61-9C3F-D90DAD600B9B@icloud.com" , "DB890044-1DAF-4832-8380-F78F61FBC96D@uzh.ch" , "CAE+=ROXg+tM0VYn1bscairmM9sQQ0nh1tYb4SexyWnM7TbeyaA@mail.gmail.com" , "CAE+=ROX9M8XSU8reKMf=RNCwu4Xu95V0G9W9T=Xr0nc8KerHjw@mail.gmail.com" , "CAAcV4sZKJg+x0v4rc1h=ydKE+EFEjanyBnqm8BWO=za-fF+jXA@mail.gmail.com" , "B017EE8F-7732-448E-80AB-7694904D28B4@icloud.com" , "D6AA07FC-261F-4D09-BC32-9FF7792659EC@eggerapps.at" , "CAE+=ROWf2XT2mxM5uWJCjz1Q3wZB71w=svWmGgX5v2=Y2rLzNw@mail.gmail.com" , "EB862217-2E54-4503-9C0C-DD943D428880@gmail.com" , "E0FCC493-27B9-499C-9884-4E00DB831131@gmail.com" , "934A39F6-ECB6-405B-8EF6-97E3C55604AD@uzh.ch" , "5824A613-F216-400B-AD16-9D368FA3A397@gmail.com" , "29A77367-05BF-4667-B25F-C06F520D0CB5@fastmail.fm" , "5525CD3F-062A-4ECB-809F-1964AE645CFC@gmail.com" , "CALkjWZsKQUQc0oDMkru8YGRv5rqOeqXF=4HnU2V0wo_5Q8SjnQ@mail.gmail.com" , "047B4955-1E5A-4A77-BAE3-63E8633A3AE1@gmail.com" , "CAE+=ROWxmKEic9DxN+CXyf=O7AtxgoHox5tSM1SCy_6E0ODphQ@mail.gmail.com" , "A7043ACA-9CE9-4739-919F-93F65FE7273B@gmail.com" , "6137630B-E3E8-45C6-AB48-FABFE9586EA9@me.com" , "CBB03FEA-50E2-4D7B-92B5-FB8A74B6719A@icloud.com" , "28E69DC8-4663-4FB6-8F99-F645E5D3F960@gmail.com" , "CAAcV4sZRQkVeBSqHv8UE_SJh-oEzZ74W6zd+sYxwEKhYZYsfxA@mail.gmail.com" , "CAAcV4sbakzYnefbui=hYKRDTMkrN_s1hFTn3CLwZUzWWa0M3LA@mail.gmail.com" , "63683E0A-B1FE-42A1-9878-FFEA34D1B993@gmail.com" , "CAAcV4sY8O=z5TL41vMoW3rKCHEWH3ikD8ZVJu-AEgVBYx-JXsA@mail.gmail.com" , "CAAcV4sbgPfRGZcU2U3fHcN2nky_ZqhCspWkz9DXYCjXyZFhvOQ@mail.gmail.com" , "A97ACA91-183C-41D9-ACEF-61B74D51E5BA@icloud.com" , "A9768B92-225F-49C8-B2D1-D572E1BD93DB@gmail.com" , "3BBED4DB-4944-4D4D-8603-A9E122B108B9@fastmail.fm" , "4C94F89B-CEDF-4480-8043-ED80AE0EB76A@eggerapps.at" , "B834ABFE-0DB7-426F-B932-74CD7884E46F@icloud.com" , "D58261F7-759A-4B10-84BE-A7882D50C7A5@owensd.io" , "0FEC8813-07C3-48E2-8D76-D0EF7709DA8E@tarantsov.com" , "6C13EC21-3BF0-4633-ABAB-C91322598ABC@apple.com" , "50765AC5-1CFE-406D-9CB5-B28ABBEB84ED@fastmail.fm" , "C64EC68B-1BBE-498A-937A-257E01314DEB@apple.com" , "CALkjWZu1S0ykcnenz_Z0AEuaiyeyTpxSYRMwknqeRxJAxnJT7w@mail.gmail.com" , "CAPrQK3CZy45bfx7qTgJoCH6pkocd_9sPTc0CNrAvsrRM6Vixkg@mail.gmail.com" , "CAB056B2-A975-45B3-93BD-14DE06903042@gmail.com" , "6FDA08B7-192F-42F2-BD2F-F7980463C833@novafore.com" , "40273CEA-F386-47C3-9314-C355B2E320CB@gmail.com" , "CANGnqV1WfTHxgfk4PNTQozU31EAa7z4MZF7d0gc058F4_=EtcQ@mail.gmail.com" , "C9FD779C-AF2C-466C-B741-34D40FB47413@icloud.com" , "48DEE2AB-7D93-47AC-9296-42AD9DD987E2@gmail.com" , "A4DFD8C0-135E-4B40-A264-B7FBCD07D322@fastmail.fm" , "CALkjWZvopih52vGsUfsqzrsEPP-G02eDg=8+EKLrpCMNciW+gA@mail.gmail.com" , "CALkjWZsMC7daCZHg_SDw=EiySCZtN7knDqVhXiF6+3dKTZZTGA@mail.gmail.com" , "CAEEOKET4Ud0bbSW_-Ss6V08tLy2YhF3n1TvQ06Xk5Jjak5-GHg@mail.gmail.com" , "CAAcV4sYaK4=N=ePDkHKbiodYp3HfiHW2yFxWs0A9Rt7LJ8DYvg@mail.gmail.com" , "CAAcV4sbOpH=sbPePnKhcHNXFy-YbPubUvF5PDaoLN_Rs8yL_rw@mail.gmail.com" , "C0B48136-1470-48EB-89D8-CD1B6F8553B1@apple.com" , "7227A933-1AFF-4470-90CB-2880776CEF03@fastmail.fm" , "3017B038-022E-4E46-8ABD-74873DC4C14C@icloud.com" , "CAAcV4sZ=8N3FDgo5aJT50dPwBh=SjM5NTSFgiT6OgSGcbsdcKg@mail.gmail.com" , "A2116BA7-633C-40BA-B7EF-B6A69582C2A3@icloud.com" , "9B4EA1B7-9D30-4B60-9AD0-34119EB9837D@apple.com" , "4BBB2771-4817-4BF3-919D-D7E14826C38D@apple.com" , "D17C306A-4934-4D72-B4FA-E7897B8E82B1@gmail.com" , "99FBC506-E086-4609-8585-42CA7E7E9852@apple.com" , "CAB5C60u6fSAaFgWDw2MY-PP1sJDEDqGRObqF+WwiHoXYvTwwZg@mail.gmail.com" , "3F9131C9-B757-4211-AED4-8E71E3CE9810@anandabits.com" , "EC7C2819-0125-437D-8940-1E3F610B500D@icloud.com" , "38E32460-C46B-428A-91A1-37A74D863127@gmail.com" , "CAAcV4sZZt8mwh9_rixfQ3dAdrPV77=uuqsAvdBM5f90K8sb6hw@mail.gmail.com" , "473B2AAA-7AE4-4B09-B013-6EE9CA6AB2AA@gmail.com" , "32A23B96-9CCC-4114-8939-07EE62E7B6AC@apple.com" , "A5DF87B9-47F1-4A2D-A51B-27CB3221912D@apple.com" , "028924F8-3DD9-40F9-A907-C4DB2344043B@gmail.com" , "CAB5C60tv0=-aBnPzwDCAp8oE8Km+tB6huYPxTrZNi=ObBKXAww@mail.gmail.com" , "CAB5C60sGJPaYPFtEoKB0DC-6A11LogCQAOCeZ-C6dvkmMd2oyg@mail.gmail.com" , "277EE0B5-01B3-48CE-992F-AE838034C0F1@apple.com" , "897A3F1D-1BCB-41B3-9096-0E46DEFA844A@apple.com" , "CAB5C60vD=QyN6LqyKU431jUSQQbuBEJcGiHkwq=+nRmTFhbU9A@mail.gmail.com" , "F4ED804A-2DC1-48DE-AD7C-DBE2A0BEF047@apple.com" , "81AA5235-A524-4F1A-AAA0-EB44BFFB0FEC@architechies.com" , "34A6EE6D-AECF-4887-BEB8-0D841C7CB1F2@icloud.com" , "CAAcV4sYZ6JoLy+=XKStCyh-XTJVmttrBZvqTuNq=Decsv2NEzg@mail.gmail.com" , "F5E748B4-BD58-408D-9330-DE255B9531E9@icloud.com" , "CACOvyQXZ1-qfbz7=0R1iXudZQdFMHPPQ2GVv_5DKwFEvZEF2pA@mail.gmail.com" , "27C9213F-B866-4A98-B0DC-E1492700B28B@apple.com" , "AE17F2D6-0107-4F61-AE13-01E5236ED770@apple.com" , "C320EC78-2D4E-46A8-90ED-4175F5B80072@gmail.com" , "CAB5C60szP8_2p8qqX13ph3wDQU6iRM0P09hVmXu7ar9SvRN+vw@mail.gmail.com" , "15A5CF07-DAED-4B92-A983-D88C2FA6BC8E@gmail.com" , "2822BF6F-172E-4003-B1A4-FB1C518CB701@googlemail.com" , "414E3C0D-EEC1-4005-8D68-5CA91EBADD0F@gmail.com" , "72FA697D-D1C9-4E73-B554-7313DC940D4B@apple.com" , "63C561FE-B75F-4A9B-8DF6-B2335D4C03CB@apple.com" , "CAEEOKEQyUwgvkEvPu2Xv_xAEJWiMTgGtv=KdY-2gkzhJXR7D4A@mail.gmail.com" , "A5DE0BD4-E526-4682-82B0-9B541CEF1C15@gmail.com" , "CAB5C60tn=nNstD2ke_RACYJsmAVvWQx-vJV=PfhqsOgaKx9pfw@mail.gmail.com" , "30B4EAF6-C852-4691-B397-24086AE1F9D9@icloud.com" , "1E2BDCE0-2132-40E8-96BC-BA51233281C7@novafore.com" , "C5F7CACF-736F-4794-B38E-0BE409F96835@novafore.com" , "FAEB0D09-1CB7-4706-B4CC-43DF40A2D243@apple.com" , "03C1FF36-43C3-46D1-88A1-3ECDCBB56567@gmail.com" , "CAB5C60sXr46WbfmaUctNKfWk01G_4pHgktykf4dJQZDbQ1QPWA@mail.gmail.com" , "4FB8F138-A0EF-4DDF-9AAD-A7172195F469@novafore.com" , "0C330020-F7D9-45D0-9B2D-E4DAD3AE105C@anandabits.com" , "CAB5C60vXzip01M6r62uQdkrXCxfBaQPgU7tdHsz+0Tu0i4Zksw@mail.gmail.com" , "BED20179-20C3-4F3A-B5D5-5E09286333F5@anandabits.com" , "E09BFA74-9DDF-4607-B52B-6C8EEC931D1F@gmail.com" , "1449374024.2155187.459254033.067DF6CC@webmail.messagingengine.com" , "CADcs6kN7gAr8x9ZbHBSX9gpOoJps=21wi-9ZC7hbtHUtRp54HA@mail.gmail.com" , "1449377752.2181216.459275089.1BA7CBAC@webmail.messagingengine.com" , "D9EA05A0-B3E8-4437-A0D1-F1FC27B0E124@gmail.com" , "A8D2920B-554C-4495-A6E1-B797802C42A3@gmail.com" , "B35331BD-313C-4B83-ADA1-9A8DBA287715@gmail.com" , "D14076A5-FF22-4708-BFB2-516699EC4520@web.de" , "CAKCGC8CWGc1L0fsc7TtzDeCqu5bxPX3q3MMZCw+2HPGuPHHC1A@mail.gmail.com" , "7D68F57E-C847-4E0D-AF3A-FD1F2DC928A9@icloud.com" , "1449429569.1342623.459603529.32C935BC@webmail.messagingengine.com" , "11462DA4-ACDD-4CF3-BD57-47886B655970@anandabits.com" , "CAKCGC8AVDe6W9X=XvFEnbkae8xom2Us8xczKFShqKu2+kPnRJA@mail.gmail.com" , "0DF0732F-0958-47C1-A6C3-62A8AB2F4386@icloud.com" , "CAKCGC8BEzyEPAFWCPKPiH+UL3KmZm7aM6KUPu-F9DKV-YvUbCA@mail.gmail.com" , "4A5C6452-0A1B-42A3-AFD4-3DEA04E310C6@icloud.com" , "6DA2FDFF-F978-4ECA-9E2B-F757F6D8BBF3@icloud.com" , "2116BFD1-25BC-4B9F-A3A6-08758782BB88@anandabits.com" , "C919D677-30C0-4F1E-B221-9B28365D67A9@gmail.com" , "CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com" , "49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net" , "49EEA2E6-55F2-49DE-A59F-A13017626370@web.de" , "0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/5E968E10-2DBD-4999-978C-B398BC446A21@me.com"}} , "_id" : "5E968E10-2DBD-4999-978C-B398BC446A21@me.com" , "from" : "a.michail at me.com (Amir Michail)" , "mailingList" : "swift-evolution" , "content" : "Python is still easier than Swift for beginning programmers. But maybe such a mode can allow Swift to be used by beginners also?" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000417.html" , "date" : { "$date" : 1449345087000} , "subject" : "[swift-evolution] A mode with no type checking to compete with Python." , "references" : [ ""] , "inReplyTo" :  null  , "descendants" : [ "8FB8385B-F55C-4DB0-B4F8-626D3FAB9AF6@apple.com" , "CAL-BAQv_62_FfxbD2f3jmvz=fMVFKT7z1_T-Epe=TGgyyNhOew@mail.gmail.com" , "F0885284-6615-4EEC-89BF-38B8A10EF3AA@me.com" , "7240610C-B5DA-41B8-909A-D138404C6799@me.com" , "0CFEA686-79B9-4B51-A984-7C706879BB5D@klundberg.com" , "8E150B28-BDE3-4289-8515-3110150B269C@me.com" , "F648DD81-C548-4B5A-BF45-890CA34B71FE@architechies.com" , "7F08A62B-6FD7-4AF2-A939-EF1D3CD71BD7@me.com" , "E2C52ABB-8CD4-4D5C-BFA3-F3EA995AC6FC@gmail.com" , "B3DEBE77-A879-4A1E-BC4D-1F028E6D326A@gmail.com" , "etPan.56637dbe.227d026a.10e90@Manav-Gabhawalas-MacBook-Pro.local" , "11A9AA09-5F9E-4AF7-8CE1-82BAB42E896A@jonshier.com" , "9354DB3D-8EFE-4AA9-B372-1FBB575381D7@web.de" , "CAKCGC8Dcw0w-vzR=vmHN2ik9GTjiaZmRiGqdnF8Kq7xhX7+m7A@mail.gmail.com" , "75B91A7D-2A61-471C-BA61-D3F92EEACC89@pobox.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/69616483-02EA-4925-8104-4DB8309605A1@aol.com"}} , "_id" : "69616483-02EA-4925-8104-4DB8309605A1@aol.com" , "from" : "cloutiertyler at aol.com (Tyler Cloutier)" , "mailingList" : "swift-evolution" , "content" : "Maybe a keyword like \"oncontinue\" would be a little more obvious about its behavior than \"defer\"?\n\n> On Dec 5, 2015, at 5:17 AM, Michel Fortin <michel.fortin at michelf.ca> wrote:\n> \n>> Le 5 déc. 2015 à 2:54, Roland King <rols at rols.org> a écrit :\n>> \n>> Convert that to a while(), if you have a continue in the body, you have a good chance of not incrementing at all, or duplicating the increment code before every continue.\n> \n> Well... you can do that:\n> \n>    var x = 0\n>    while x < 10 {\n>        defer { x += 1 } // warning: also increment x if an exception is thrown\n>        continue\n>    }\n> \n> Or maybe the C-style for loop could just be made more readable. You could replace the semicolons with words:\n> \n>    for var x = 0 while x < 10 defer x += 1 {\n>    }\n> \n> But that might be slightly misleading. \"defer\" would imply that this part is executed when an exception is thrown, which would be unlike a regular for loop.\n> \n> -- \n> Michel Fortin\n> michel.fortin at michelf.ca\n> https://michelf.ca\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000418.html" , "inReplyTo" : "A2B6547D-CC4B-4A16-A481-522F9BF01813@michelf.ca" , "date" : { "$date" : 1449345215000} , "subject" : "[swift-evolution] C-style For Loops" , "references" : [ "40184c7c-c237-4076-85b7-298d08bdf188@me.com" , "EFCA4F26-1031-4356-AEEA-C62B041A38C8@aol.com" , "437319C0-F168-480E-A234-834645C90487@rols.org" , "A2B6547D-CC4B-4A16-A481-522F9BF01813@michelf.ca"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAGUyf_E8Sahb6XB9namSQGfuap=kmVEdfud=YTZuyz+rowaj0A@mail.gmail.com"}} , "_id" : "CAGUyf_E8Sahb6XB9namSQGfuap=kmVEdfud=YTZuyz+rowaj0A@mail.gmail.com" , "from" : "thisisroshansmail at gmail.com (Roshan)" , "mailingList" : "swift-evolution" , "content" : "I have used Lumberjack[1] with Objective-C and I found it pretty good.\nMaybe it's scope is too large for the standard library, but it could serve\nas a good reference.\n\n[1] - https://github.com/CocoaLumberjack/CocoaLumberjack\n\nOn Sun, Dec 6, 2015 at 12:54 AM, Alexander Kolov via swift-evolution <\nswift-evolution at swift.org> wrote:\n\n> Hi everyone,\n>\n> Coming from a short discussion in swift-corelibs-dev, I’m investigating\n> the need of a standard logging API as a part of core libraries.\n>\n> The motivation behind this would be having a unified and configurable set\n> of APIs between all first-party modules and third party applications and\n> libraries.\n> I think this will help each of us since right now we’re inventing our own\n> solutions as well many bigger third-party library providers have formats\n> and facilities of their own.\n>\n> As I currently see it would be somewhat similar to python logging and\n> possibly even structlog (http://www.structlog.org/en/stable/), with\n> configurable formatters and handlers, including and not limited to remote\n> loggers and syslog support.\n>\n> I’d love to hear your opinions and feedback on this and possibly start\n> with some more formalized proposal and implementation if there’s enough\n> support and need.\n>\n> Thanks,\n> Alex\n>\n>\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>\n\n\n-- \nWarm regards\nRoshan" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000419.html" , "inReplyTo" : "BD305678-84D8-49BF-AC25-8F3492044536@alexkolov.com" , "date" : { "$date" : 1449346582000} , "subject" : "[swift-evolution] Proposal: standard logging facility" , "references" : [ "BD305678-84D8-49BF-AC25-8F3492044536@alexkolov.com"] , "descendants" : [ "72739D97-A103-4894-AC0E-2BE87EFB99EA@alexkolov.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAC4po2bgFCdZz7vsoYT182VEU_CSq9+DbisUWU3YTCv1Ox2shA@mail.gmail.com"}} , "_id" : "CAC4po2bgFCdZz7vsoYT182VEU_CSq9+DbisUWU3YTCv1Ox2shA@mail.gmail.com" , "from" : "kevboh at gmail.com (Kevin Barrett)" , "mailingList" : "swift-evolution" , "content" : "+1 to this.\n\nOn Sat, Dec 5, 2015 at 2:24 PM, Alexander Kolov via swift-evolution <\nswift-evolution at swift.org> wrote:\n\n> Hi everyone,\n>\n> Coming from a short discussion in swift-corelibs-dev, I’m investigating\n> the need of a standard logging API as a part of core libraries.\n>\n> The motivation behind this would be having a unified and configurable set\n> of APIs between all first-party modules and third party applications and\n> libraries.\n> I think this will help each of us since right now we’re inventing our own\n> solutions as well many bigger third-party library providers have formats\n> and facilities of their own.\n>\n> As I currently see it would be somewhat similar to python logging and\n> possibly even structlog (http://www.structlog.org/en/stable/), with\n> configurable formatters and handlers, including and not limited to remote\n> loggers and syslog support.\n>\n> I’d love to hear your opinions and feedback on this and possibly start\n> with some more formalized proposal and implementation if there’s enough\n> support and need.\n>\n> Thanks,\n> Alex\n>\n>\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000421.html" , "inReplyTo" : "BD305678-84D8-49BF-AC25-8F3492044536@alexkolov.com" , "date" : { "$date" : 1449346817000} , "subject" : "[swift-evolution] Proposal: standard logging facility" , "references" : [ "BD305678-84D8-49BF-AC25-8F3492044536@alexkolov.com"] , "descendants" : [ "DFB23D2F-A970-423F-B23D-1D6F181B1F6A@alkaline-solutions.com" , "87E6ED33-E2D8-42CB-A999-14285D96AA40@alexkolov.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/193BF74F-CC27-4C1B-B0BD-9F845BB02FEC@gmail.com"}} , "_id" : "193BF74F-CC27-4C1B-B0BD-9F845BB02FEC@gmail.com" , "from" : "landerbrandt at gmail.com (Lander Brandt)" , "mailingList" : "swift-evolution" , "content" : "On the Swift package manager page on swift.org <http://swift.org/> (https://swift.org/package-manager/#example-usage <https://swift.org/package-manager/#example-usage>) the requirements for creating a package/application are clearly outlined, but why not include a command in the swift tool for autogenerating the require? I did a quick look and didn’t see any existing discussion, so I apologize if this has already been discussed.\n\nExample of the tool command: `swift init foo --type=(lib|app)`\n\nWould create a new directory called “foo” with the following tree structure for a project of type app:\n\nfoo\n├── Package.swift\n├── Packages\n├── README.md\n└── main.swift\n\nAnd for project of type lib:\n\nfoo\n├── Package.swift\n├── README.md\n└── Sources\n    └── Foo.swift\n\nIn both cases Package.swift would contain something basic like:\n\nimport PackageDescription\n\nlet package = Package(\n    name: “Foo\",\n    dependencies: [\n    ]\n)" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000422.html" , "date" : { "$date" : 1449347112000} , "subject" : "[swift-evolution] swift tool project init command" , "references" : [ ""] , "inReplyTo" :  null  , "descendants" : [ "D1CFC4EF-BA8D-424A-AD42-83E252C40206@jacopo.giola.org"]} , { "_links" : { "self" : { "href" : "/charter/emails/72739D97-A103-4894-AC0E-2BE87EFB99EA@alexkolov.com"}} , "_id" : "72739D97-A103-4894-AC0E-2BE87EFB99EA@alexkolov.com" , "from" : "me at alexkolov.com (Alexander Kolov)" , "mailingList" : "swift-evolution" , "content" : "Yes, we could definitely use it as a reference of use cases and requirements. \nFor the standard library we'd need fast extensible solution upon which anyone can build their own handlers.\n\nSent from my iPhone\n\n> On Dec 5, 2015, at 9:16 PM, Roshan <thisisroshansmail at gmail.com> wrote:\n> \n> I have used Lumberjack[1] with Objective-C and I found it pretty good. Maybe it's scope is too large for the standard library, but it could serve as a good reference.\n> \n> [1] - https://github.com/CocoaLumberjack/CocoaLumberjack\n> \n>> On Sun, Dec 6, 2015 at 12:54 AM, Alexander Kolov via swift-evolution <swift-evolution at swift.org> wrote:\n>> Hi everyone,\n>> \n>> Coming from a short discussion in swift-corelibs-dev, I’m investigating the need of a standard logging API as a part of core libraries.\n>> \n>> The motivation behind this would be having a unified and configurable set of APIs between all first-party modules and third party applications and libraries.\n>> I think this will help each of us since right now we’re inventing our own solutions as well many bigger third-party library providers have formats and facilities of their own.\n>> \n>> As I currently see it would be somewhat similar to python logging and possibly even structlog (http://www.structlog.org/en/stable/), with configurable formatters and handlers, including and not limited to remote loggers and syslog support.\n>> \n>> I’d love to hear your opinions and feedback on this and possibly start with some more formalized proposal and implementation if there’s enough support and need.\n>> \n>> Thanks,\n>> Alex\n>> \n>> \n>> \n>> \n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> \n> \n> \n> -- \n> Warm regards\n> Roshan" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000420.html" , "inReplyTo" : "CAGUyf_E8Sahb6XB9namSQGfuap=kmVEdfud=YTZuyz+rowaj0A@mail.gmail.com" , "date" : { "$date" : 1449347187000} , "subject" : "[swift-evolution] Proposal: standard logging facility" , "references" : [ "BD305678-84D8-49BF-AC25-8F3492044536@alexkolov.com" , "CAGUyf_E8Sahb6XB9namSQGfuap=kmVEdfud=YTZuyz+rowaj0A@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/1449347746.2071795.459083425.1FD398E4@webmail.messagingengine.com"}} , "_id" : "1449347746.2071795.459083425.1FD398E4@webmail.messagingengine.com" , "from" : "kevin at sb.org (Kevin Ballard)" , "mailingList" : "swift-evolution" , "content" : "On Sat, Dec 5, 2015, at 04:30 AM, Michel Fortin wrote:\n> Like this:\n> \n> \tview.action = \"_doSomething_UniqueSelector1234_currentModuleName_blahblah\"\n> \n> \textension NSObject {\n> \t\tfunc _doSomething_UniqueSelector1234_currentModuleName_blahblah() {\n> \t\t\tlet target = self\n> \t\t\t(target as! MyObject).doSomething()\n> \t\t}\n> \t}\n> \n> (Joe Groff suggested it first.) This simply assumes the receiver will\n> derive from NSObject. You also need to set a non-nil target. And note\n> that the closure is context-free, meaning you can't capture variables\n> with it.\n\nHow is this type-safe? You're using as! in there (and silently ignoring\nthe message if the receiver is wrong wouldn't be any better). If I send\na selector to the wrong receiver, it's still going to crash.\n\nThis comes back to my fundamental argument, which is that\n@convention(selector) looks like it's type-safe, but there's so many\nholes and so many implicit coercions that need to be added that you can\ndrive a gigantic truck full of unsafety right through it without even\nnoticing.\n\n-Kevin Ballard" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000423.html" , "inReplyTo" : "8508E135-791E-4B88-A758-9208388DA878@michelf.ca" , "date" : { "$date" : 1449347746000} , "subject" : "[swift-evolution] Type-safe selectors" , "references" : [ "B4E7896A-ACC6-49C0-8E15-47418D012C0B@michelf.ca" , "2CA0197A-B5E5-466B-AF27-C552A998764E@apple.com" , "1449271642.2877123.458487961.609100F1@webmail.messagingengine.com" , "B70B24CB-485C-4A9B-8575-E391FBC8C263@apple.com" , "1449296613.1919415.458667425.16848C1F@webmail.messagingengine.com" , "8508E135-791E-4B88-A758-9208388DA878@michelf.ca"] , "descendants" : [ "92C8AF30-9249-4152-A24E-86496425BD4D@apple.com" , "1449372912.2146477.459241273.0F8138F3@webmail.messagingengine.com" , "1A62EBA8-4AC4-4F05-B486-F90194FE5740@michelf.ca"]} , { "_links" : { "self" : { "href" : "/charter/emails/E23C6CB7-7192-403C-AF80-5CEF176F92BD@alkaline-solutions.com"}} , "_id" : "E23C6CB7-7192-403C-AF80-5CEF176F92BD@alkaline-solutions.com" , "from" : "david at alkaline-solutions.com (David Waite)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 4, 2015, at 4:49 PM, Kevin Ballard <kevin at sb.org> wrote:\n> \n> On Fri, Dec 4, 2015, at 03:32 PM, David Waite wrote:\n>> A few thoughts:\n>> \n>> 1. In a lot of situations they are not pure functions - they have state\n>> associated across them determined by the context in which your closure\n>> was called. So the import would not be of a static function, but of an\n>> input parameter, aka:\n>> \tit(“…”) {\n>> \t\tbuilder in\n>> \t\timport builder\n>> \t\texpect(sections).to{…}\n>>         }\n>> \n>> Assuming expect is the only function, this may very well be equivalent to\n>> \n>> \tit(“…”) {\n>> \t\tbuilder in\n>> \t\tlet expect = builder.expect\n>> \t\texpect(sections).to{…}\n>>         }\n> \n> I don't think we want to add `import builder`, importing methods that\n> are implicitly bound to some value seems like a dangerous can of worms\n> to open up.\n\nI’m not sure about that; isn’t that exactly what ‘self’ is? If anything, it is deciding whether it is worth having two cans of worms open. And the semantics would likely be similar to self - it has to be a fixed value type or reference through the scope.\n\nImport might be a poor overloading of an existing concept though. Alternative syntax based on the setup closure thread’s ‘with’ syntax examples:\n\n\tit(“…”) {\n\t\tbuilder in\n\t\twith builder {\n\t\t\texpect(sections).to{…}\n\t\t}\n        }\n\nbut obviously I would like to not have the extra level of nesting, so probably more like:\n\tit(“…”) {\n\t\twith builder in\n\t\texpect(sections).to{…}\n        }\n\nUsing .. syntax likely would be inappropriate for this example, since there may be additional business logic in between calls to expect.\n\n> If you need state (and don't want to encode that state as\n> thread-local variables, though of course Swift doesn't currently have\n> support for those outside of NSThread.threadDictionary), then personally\n> I don't think it's a big deal to require the explicit state argument.\n> You could even adopt a convention of using $ for the identifier here\n> (while $0, $1, etc are defined by the language, $ appears to be open for\n> use as an identifier), so that would look like\n> \n> describe(\"foo\") { $ in\n>    $.it(\"has bar\") { $ in\n>        $.expect(sections).to(...)\n>    }\n> }\n\nThis is probably the simplest alternative to my proposal, and requires no language changes. However,\n- IMHO the $0, $1, etc syntax is meant for when terseness is a benefit that outweighs readability. This is primarily because $ looks more like an operator than part of a parameter name, and the names themselves aren’t based on the signature of the method calling the closure. Even after a fair amount of swift work, I stumble whenever I see $0, etc syntax. For this reason, using $ as the parameter name feels like it counteracts the expressiveness I was going for.\n- Coming up with an alternative explicit name (builder? context?) for a passed parameter is hard, because the code is often not so much manipulating that state as it is operating within the context of that state. The term the language gives us for this is ‘self’, but that isn’t assignable/overridable. This could actually wind up making $ feel more like a keyword than an arbitrary parameter name choice.\n\n> \n> And you can also do things like make the expectations actually be static\n> members of their return value, so you'd have code like\n> \n>    $.expect(sections).to(.contain(bar))\n\nI hadn’t considered that - your Swift-fu is strong :-)\n\n> In the future, if Swift ever gains a fully-fledged macro system, then\n> maybe you'd be able to rewrite these scopes-with-state as macros that\n> carry implicit state. Or, heck, maybe someday we'll have higher-order\n> types AND a monadic system (and either custom syntax or macros to\n> simulate Haskell's `do` notation) and then we can just use monads to\n> represent the state :D\nOne could hope - although I don’t believe macro systems or monads/monoids as a concept (rather than an API influence like Optional) are conducive for learning languages.\n\n>> 5. Imports likely should generate conflicts at compile-time if they\n>> shadow defined functions if you can do wildcard imports. No need to have\n>> syntax to alias names - one should either change the code to not conflict\n>> or use the longer-form names\n> \n> I agree that imports should throw an error if they'd shadow something\n> defined locally (though perhaps they can still shadow things from other\n> imports?). But I would actually like an alias syntax so you can import\n> something under a different name, even if it's just restricted to naming\n> modules in some kind of `import qualified` syntax (that would require\n> the module name to use any member), e.g. `import qualified\n> LongModuleName as L; /* ... */ L.foo(bar)`.\n\nI was thinking more that \"import LongModuleName.foo as bar” perhaps would be abused.\n\n>> 6. import could be an attribute:\n>> \tit(“…”) {\n>> \t\t@import builder in\n>> \t\texpect(sections).to{…}\n>>         }\n> \n> What would that actually be an attribute of? Attributes aren't distinct\n> items, they modify something else. And why make this an attribute when\n> we have a perfectly good `import` keyword already?\n\nYeah, drop that idea.\n\n-DW" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000424.html" , "inReplyTo" : "1449272977.2880806.458506745.0738A7AA@webmail.messagingengine.com" , "date" : { "$date" : 1449348382000} , "subject" : "[swift-evolution] Idea for enabling DSLs: bind to self in closures" , "references" : [ "D9A4A638-97F5-46BE-BE7A-89310DACA0AE@alkaline-solutions.com" , "20503D63-9E81-4C0B-9513-5E534E35D84F@apple.com" , "1449269507.2870902.458470841.617B34D2@webmail.messagingengine.com" , "D387A01A-99F3-4D36-9B00-404B3088B38E@alkaline-solutions.com" , "1449272977.2880806.458506745.0738A7AA@webmail.messagingengine.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CADcs6kN-D2ETv-Uqhkm8KH9g5N3rWrjNDR77-EK4_w-kVa8F-A@mail.gmail.com"}} , "_id" : "CADcs6kN-D2ETv-Uqhkm8KH9g5N3rWrjNDR77-EK4_w-kVa8F-A@mail.gmail.com" , "from" : "jtbandes at gmail.com (Jacob Bandes-Storch)" , "mailingList" : "swift-evolution" , "content" : "There are several functions in public API, such as dispatch_sync and\ndispatch_apply, which do not allow their block parameters to escape the\nfunction call.\n\nHowever, they are not currently exposed to Swift as @noescape, meaning that\nusers are required to specify \"self.\" or \"[weak self]\" in their closures.\n\nThe instances I can think of:\n\n- dispatch_sync\n- dispatch_barrier_sync\n- dispatch_apply\n- dispatch_block_perform (thanks to Pierre Habouzit for pointing this out)\n\nI provided a preliminary implementation at\nhttps://github.com/apple/swift-corelibs-libdispatch/pull/6, but it needs\nrefinement. Tony Parker mentioned commented that there might be similar\nchanges to make for the swift-corelibs-foundation project.\n\nThoughts?\n\nQuestion: does __attribute__((noescape)) have the same meaning when applied\nto C function pointers? Namely, does Swift understand @noescape as it\napplies to @convention(c)?\n\nJacob Bandes-Storch" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000425.html" , "date" : { "$date" : 1449348785000} , "subject" : "[swift-evolution] Proposal: add `noescape` attribute to public API (particularly libdispatch)" , "references" : [ ""] , "inReplyTo" :  null  , "descendants" : [ "CADcs6kMh=7p+sLe7pPH253OTw4N=d5s3nWaT_pom42CsSMi4Fg@mail.gmail.com" , "D1CECE38-501F-4F12-8B89-43A849393285@apple.com" , "E361A2D0-CD93-4AF9-BCBD-FBD4312E43D7@apple.com" , "E5B092E4-2635-4217-8946-7A374CD29F53@apple.com" , "CADcs6kMYVPfbUeh9+obGhm45ao9Bo-JWSG22CdgfwkcsfmtW0w@mail.gmail.com" , "5585D80C-4127-4FD2-B405-F135400D823C@apple.com" , "CADcs6kP_v1E6FFwvrho4GsZQYqFhPu2ASKFVSXfpJYKbQQqYug@mail.gmail.com" , "CADcs6kNhrkOYJs2ZZ05WPYPnnf9jtE6UWNZbg2FSYqtjr701zQ@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/49EF0786-90E4-4748-B532-E4C68D33458D@gmail.com"}} , "_id" : "49EF0786-90E4-4748-B532-E4C68D33458D@gmail.com" , "from" : "alex.blewitt at gmail.com (Alex Blewitt)" , "mailingList" : "swift-evolution" , "content" : "Sent from my iPhat 6\n\n> On 5 Dec 2015, at 19:23, Adrian Kashivskyy <adrian.kashivskyy at me.com> wrote:\n> \n>> SwiftLint looks really nice, but one thing I'd really like is automatic formatting.\n> \n> That's a feature of IDE, not the language itself.\n\nNot necessarily. The existence of \"go fmt\" has resulted in teams running it as a pre-commit translation and as a way of standardising across all users, regardless of IDEs. Otherwise you end up with multiple IDEs (like Eclipse and IntelliJ) which do formatting slightly differently and lead to all manner of pointless arguments. \n\nLetting \"the IDE\" do formatting is fine provided there is a maximum of one IDE. \n\nAlex\n\n> Pozdrawiam – Regards,\n> Adrian Kashivskyy\n> \n>> Wiadomość napisana przez Harlan Haskins <harlan at harlanhaskins.com> w dniu 05.12.2015, o godz. 17:52:\n>> \n>> SwiftLint looks really nice, but one thing I'd really like is automatic formatting. I'd absolutely like to see clang-format adapted with Swift support. Maybe the SwiftLint people can, now that Swift is open source, contribute the bulk of the SwiftLint project directly into clang-format.\n>> \n>>> On Dec 5, 2015, at 9:09 AM, Paul Young <paulyoungonline at gmail.com> wrote:\n>>> \n>>> Amir, you may be interested in SwiftLint: https://github.com/realm/SwiftLint\n>>> \n>>> \n>>> \n>>>> On Sat, Dec 5, 2015 at 1:43 PM, Amir Michail <amichail at gmail.com> wrote:\n>>>> \n>>>>> On Dec 5, 2015, at 8:14 AM, Austin Zheng <austinzheng at gmail.com> wrote:\n>>>>> \n>>>>> Rather than having the compiler attempt to enforce (subjective, constantly evolving) best practices, maybe we should think about ways to make it easier for people to write their own linters that can integrate well with the rest of the toolchain.\n>>>> \n>>>> All programming languages are already enforcing subjective views about best practice in one form or another.\n>>>> \n>>>>> \n>>>>> Austin\n>>>>> \n>>>>>> On Dec 5, 2015, at 5:02 AM, Amir Michail <amichail at gmail.com> wrote:\n>>>>>> \n>>>>>> The problem is that solo developers rarely have the self-discipline to avoid obviously bad code style.\n>>>>>> \n>>>>>>> On Dec 5, 2015, at 5:15 AM, Adrian Kashivskyy <adrian.kashivskyy at me.com> wrote:\n>>>>>>> \n>>>>>>> I'm -1 on that – compiler should guarantee the program correctness, not style correctness.\n>>>>>>> \n>>>>>>>> Perhaps you could specify a programming style at the top of each file (e.g., OOP, functional, hybrid, etc.)\n>>>>>>> \n>>>>>>> I almost immediately thought of whole projects where people would put `@style(hybrid)` at the top to get rid of troublesome compiler warnings, or put the \"style exception\" annotation for the whole file. This would become \"public static void main\" of Swift.\n>>>>>>> \n>>>>>>>> For example, a long method could trigger an error along with suggestions for refactorings to fix this “bad smell”.\n>>>>>>> \n>>>>>>> My greatest concern is about who will define what \"bad smell\" and individual styles look like. Coding style is a very subjective matter, and should not be enforced by compiler or any manifest (that's why I'm against strict code style guides as well).\n>>>>>>> \n>>>>>>> Besides, enforcing one style per source file would loose one of the best features of Swift – diversity. Swift is a multi-paradigm language, influenced by the best features of many other modern languages. It is imperative, functional, object-oriented and protocol-oriented at the same time. We'd loose that variety.\n>>>>>>> \n>>>>>>> \n>>>>>>> Regards,\n>>>>>>> Adrian Kashivskyy\n>>>>>>> iOS Developer at Netguru\n>>>>>>> \n>>>>>>>> Wiadomość napisana przez Amir Michail <amichail at gmail.com> w dniu 05.12.2015, o godz. 00:53:\n>>>>>>>> \n>>>>>>>> Perhaps you could specify a programming style at the top of each file (e.g., OOP, functional, hybrid, etc.) and code that doesn’t match that style would result in a compiler error.\n>>>>>>>> \n>>>>>>>> For example, a long method could trigger an error along with suggestions for refactorings to fix this “bad smell”.\n>>>>>>>> \n>>>>>>>> If you don’t want to fix the problem, you could use a style exception construct to surround the code in question and it would get rid of the compile error.\n>>>>>>>> \n>>>>>>>> _______________________________________________\n>>>>>>>> swift-evolution mailing list\n>>>>>>>> swift-evolution at swift.org\n>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>>>> \n>>>>>>  _______________________________________________\n>>>>>> swift-evolution mailing list\n>>>>>> swift-evolution at swift.org\n>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>>> \n>>>>>  _______________________________________________\n>>>>> swift-evolution mailing list\n>>>>> swift-evolution at swift.org\n>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>> \n>>> \n>>> \n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>> \n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> \n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000426.html" , "inReplyTo" : "E4BE1F82-1BCB-4E27-B2E5-CDBE673EF7B8@me.com" , "date" : { "$date" : 1449348879000} , "subject" : "[swift-evolution] \"bad smells\" should be compiler errors with suggestions on how to fix them" , "references" : [ "557CCA5F-E52F-439C-B224-AC4990140373@gmail.com" , "1449324589110.9d79fd62@Nodemailer" , "CF5C0804-061E-487B-9030-005E76177BD1@harlanhaskins.com" , "E4BE1F82-1BCB-4E27-B2E5-CDBE673EF7B8@me.com"] , "descendants" : [ "9D5E0564-E4A2-4F64-8741-526CF79959F4@ericasadun.com" , "63A9B880-DBDC-4566-80F4-A02CCBFD0EFD@architechies.com" , "26C0DF64-7EE4-4F56-BC99-2C8EAF9D8781@me.com" , "4F75A42F-4721-4932-85B7-912DFCA57C2D@apple.com" , "CACyzo1jKFZZ2TLTxXYyd_o1j9d5HBAKmg3Doz7QN9O=JGViOtA@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/981D5E32-8D9D-4B24-8085-04E7C8DBC81A@anandabits.com"}} , "_id" : "981D5E32-8D9D-4B24-8085-04E7C8DBC81A@anandabits.com" , "from" : "matthew at anandabits.com (Matthew Johnson)" , "mailingList" : "swift-evolution" , "content" : "Hi Steve,\n\nThanks for looking at my proposal and sharing the internal consensus.  I do like the more explicit names.\n\nOne of the reasons I proposed this was to follow up with a proposal for a RangeDiscoverable protocol that would be conformed to by all numeric types:\n\nprotocol RangeDiscoverable {\n    static var min: Self { get }\n    static var max: Self { get }\n}\n\nA better interface would looks like this (not sure why I didn’t think of this before):\n\npublic protocol RangeDiscoverable {\n\tstatic var representableRange: Range<Self> { get }\n}\n\nWith conformances that look like this:\n\nextension Int: RangeDiscoverable {\n\tstatic let representableRange: Range<Int> = Int.min…Int.max\n}\n\nextension Float: RangeDiscoverable {\n\t// not sure it would be better to use -Float. greatestFiniteMagnitude..Float. greatestFiniteMagnitude here or not\n\tstatic let representableRange: Range<Float> = -Float.infinity...Float.infinity\n}\n\nThis would require numeric types to conform to ForwardIndexType.  Integer types already conform to RandomAccessIndexType.  Floating point types do not currently conform to ForwardIndexType but could conform not just to ForwardIndexType, but also BidirectionalIndexType.\n\nMy original implementation looked like this:\n\nextension Float: BidirectionalIndexType {\n    public func predecessor() -> Float {\n        return nextafterf(self, Float.min)\n    }\n    public func successor() -> Float {\n        return nextafterf(self, Float.max)\n    }\n}\n\nWith the nextUp and nextDown properties I see in test/Prototypes/FloatingPoint.swift this could change to:\n\nextension Float: BidirectionalIndexType {\n    public func predecessor() -> Float {\n        return nextDown\n    }\n    public func successor() -> Float {\n        return nextUp\n    }\n}\n\nWhat is your thought on adding a protocol similar to RangeDiscoverable (conformed to by all numeric types) and the supporting BidirectionalIndexType conformance for floating point types?  Is this something that would be considered?\n\n\n\n\n> On Dec 5, 2015, at 11:41 AM, Stephen Canon <scanon at apple.com> wrote:\n> \n> Hi Matthew —\n> \n> This is something that we’ve discussed quite a bit internally, and are close to consensus on.  Many people feel that “max” and “min” are confusing or misleading, as they are not actually the largest / smallest values of the type, so the plan is to use much more explicit names (you can see an early sketch of this in test/Prototypes/FloatingPoint.swift, though there are a number of things that will be changed as well).  I’ve excerpted the relevant section here for convenience:\n> \n>   /// Positive infinity.\n>   ///\n>   /// Compares greater than all finite numbers.\n>   static var infinity: Self { get }\n>   \n>   /// The greatest finite value.\n>   ///\n>   /// Compares greater than or equal to all finite numbers, but less than\n>   /// infinity.\n>   static var greatestFiniteMagnitude: Self { get }\n>   \n>   /// The least positive normal value.\n>   ///\n>   /// Compares less than or equal to all positive normal numbers.  There may\n>   /// be smaller positive numbers, but they are \"subnormal\", meaning that\n>   /// they are represented with less precision than normal numbers.\n>   static var leastNormalMagnitude: Self { get }\n>   \n>   /// The least positive value.\n>   ///\n>   /// Compares less than or equal to all positive numbers, but greater than\n>   /// zero.  If the target supports subnormal values, this is smaller than\n>   /// `leastNormalMagnitude`; otherwise they are equal.\n>   static var leastMagnitude: Self { get }\n> \n> – Steve\n> \n>> On Dec 5, 2015, at 11:10 AM, Matthew Johnson <matthew at anandabits.com <mailto:matthew at anandabits.com>> wrote:\n>> \n>> In the spirit of small commits and incremental change I have a very small proposal.  I am not sure if this belongs on the list or if small changes like this are ok as pull requests, but am starting here because it involves adding public API in the standard library.  \n>> \n>> Integer types have static min / max properties, but floating point types currently do not.  The Darwin implementation is very straightforward.  \n>> \n>> import Darwin\n>> \n>> public extension Float {\n>>   static let min = -FLT_MAX\n>>   static let max = FLT_MAX\n>> }\n>> \n>> public extension Double {\n>>   static let min = -DBL_MAX\n>>   static let max = DBL_MAX\n>> }\n>> \n>> Is there interest in adding this?  If so, what is the right way to proceed?\n>> \n>> Matthew\n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000427.html" , "inReplyTo" : "9060D0D4-BB70-47FE-A3F7-A572ACE8BD64@apple.com" , "date" : { "$date" : 1449349101000} , "subject" : "[swift-evolution] Proposal: floating point static min / max properties" , "references" : [ "36C3F015-B77D-4256-9FAB-2853218D5973@anandabits.com" , "9060D0D4-BB70-47FE-A3F7-A572ACE8BD64@apple.com"] , "descendants" : [ "76657877-5D42-4486-AD4B-79BFC8677941@architechies.com" , "B47BE4E1-F761-4452-8CF2-7A9CFB0D3613@anandabits.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/4F8C6141-CEFA-43DA-8FD9-5C787789ED68@architechies.com"}} , "_id" : "4F8C6141-CEFA-43DA-8FD9-5C787789ED68@architechies.com" , "from" : "brent at architechies.com (Brent Royal-Gordon)" , "mailingList" : "swift-evolution" , "content" : "> There’s lots of boilerplate of initializing structs with stored properties and initializer parameters. I’d like to create a syntax for alleviating that in the 90% case.\n> \n> ```swift\n> struct Foo {\n>     let bar: String\n>     let baz: Int\n> \n>     init(self.bar: String = \"default\", counter self.baz: Int) {\n>     }\n> }\n> ```\n\nI’d like to propose an alternative approach.\n\nSwift already generates a default initializer for structs that don’t have any initializers explicitly defined. However, the moment you write init(, that initializer disappears. It’s also never available on classes, because they have to dispatch to another initializer.\n\nI propose that we make it possible to explicitly ask for that default initializer:\n\n    struct Foo {\n        let bar: String\n        let baz: Int\n        \n        init() {\n            bar = “default”\n            baz = 0\n        }\n\n        init default\t// automatically generates init(bar: String, baz: Int)\n    }\n\nMoreover, I propose we extend this to classes:\n\n    struct Foo: Bar {\n        let bar: String\n        let baz: Int\n        \n        init() {\n            bar = “default”\n            baz = 0\n        }\n\n        init default()\t// automatically generates init(bar: String, baz: Int) with super.init()\n    }\n\nIn a class, the “default” statement must have parens after it; these indicate the parameters to be added for the superclass initializer. If you need to super up to an initializer that takes parameters, you add the needed parameters there:\n\n    struct Foo {\n        let bar: String\n        let baz: Int\n        \n        init() {\n            bar = “default”\n            baz = 0\n        }\n\n        init default(quux: Double)\t// automatically generates init(quux: Double, bar: String, baz: Int) with super.init(quux: quux)\n    }\n\nIf you super up to a failable initializer, of course, that will have to be “init? default(quux: Double)”.\n\nNow, one little quirk of the current system is that Swift may actually generate *two* default initializers: a parameterless initializer when all properties have default values, and a memberwise initializer which requires all values be provided. I further propose that these be unified into one default initializer by giving default values to parameters which map to properties with default values. This gives you all the parameter sets currently supported, plus a whole range in between.\n\n    struct Foo {\n        let bar: String = “default\"\n        let baz: Int\n        \n        init() {\n            bar = “default”\n            baz = 0\n        }\n\n        init default\t// automatically generates init(bar: String = “default\", baz: Int)\n    }\n\nFinally, you can continue to decorate the “init” keyword with attributes as you normally would.\n\n\tpublic init default\n\tinternal init default\n\tprivate init default\n\trequired init default\n\toverride init default\n\t@objc init default\n\t@objc public required init default\n\n(I don’t think convenience initializers make much sense here.)\n\nThis does not, unfortunately, eliminate boilerplate in initializers which do more than just set properties. Nor does it allow you to rename parameters, as your example does with “counter”. \n\n-- \nBrent Royal-Gordon\nArchitechies" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000428.html" , "inReplyTo" : "CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com" , "date" : { "$date" : 1449349435000} , "subject" : "[swift-evolution] Proposal: helpers for initializing properties of same name as parameters" , "references" : [ "CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com"] , "descendants" : [ "DB740B9C-987F-42BF-96DF-95570F070A89@architechies.com" , "C3D71715-4957-441C-B277-E8CC3BBE4CA0@alkaline-solutions.com" , "3925DEF8-2B69-4AB5-AD95-49BD2FE6401B@alkaline-solutions.com" , "5B57FA0A-C205-4937-8005-94DD2F69806A@dimsumthinking.com" , "6F2EF9CF-2E73-4470-9AA7-93DFE00FEA6D@apple.com" , "CA+ddMk2uvrEwLZf4fcsYxDbFnagOcywttsdC7HRB9jkeVdZ=zA@mail.gmail.com" , "9DC6F2A2-53E0-4DBB-AF5F-D51314AA49F7@anandabits.com" , "63177F8D-6BA7-4B1E-9052-BA6D3ED6B0CC@architechies.com" , "FC624F3D-20B7-4F42-A04F-97AFDB0287CB@alkaline-solutions.com" , "CA+ddMk042v6whHcVu8kLZyAk1JaEQ3LYxttAbZfGq6KBvrcGNw@mail.gmail.com" , "CADcs6kN6MT3cbEsPjtiXbR1U6-YzwD8v_Rbiv0PLHsm6xFiiZg@mail.gmail.com" , "6935BB3A-2203-406C-9EC2-02FF7287767F@anandabits.com" , "819785E7-2803-4A65-882F-DB1A9EC0483B@apple.com" , "E3BD5430-C4DF-4284-99FA-14B61512E74A@apple.com" , "475AB355-591C-42D9-A43B-1ED8D02BA1C3@anandabits.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/DFB23D2F-A970-423F-B23D-1D6F181B1F6A@alkaline-solutions.com"}} , "_id" : "DFB23D2F-A970-423F-B23D-1D6F181B1F6A@alkaline-solutions.com" , "from" : "david at alkaline-solutions.com (David Waite)" , "mailingList" : "swift-evolution" , "content" : "I would propose the simplest interface that I can assume is available *everywhere* to be defined by the Swift standard library, so as a framework developer I can make assumptions on my ability to provide diagnostics for internals, expose information for statistical use, provide information needed for auditing usage if I’m working on a hosted service and not a GUI app, and so on.\n\nThings like custom formatters and appenders providing integration into remote/system services are something that the application can decide when it chooses a logging framework that implements the standard-defined protocol.\n\nThere isn’t any sort of dependency injection/inversion of control at the core swift level, which usually means that either logging is done by global functions, or by a global factory returns an instance of some type implementing the logging protocol.\n\nThe only piece of this which jumps out as not pure swift would be default integration into something like syslog or NSLog, and possibly adding a new preprocessor “macro” like __MODULE__ \n\n-DW\n\n> On Dec 5, 2015, at 1:20 PM, Kevin Barrett via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> +1 to this.\n> \n> On Sat, Dec 5, 2015 at 2:24 PM, Alexander Kolov via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n> Hi everyone,\n> \n> Coming from a short discussion in swift-corelibs-dev, I’m investigating the need of a standard logging API as a part of core libraries.\n> \n> The motivation behind this would be having a unified and configurable set of APIs between all first-party modules and third party applications and libraries.\n> I think this will help each of us since right now we’re inventing our own solutions as well many bigger third-party library providers have formats and facilities of their own.\n> \n> As I currently see it would be somewhat similar to python logging and possibly even structlog (http://www.structlog.org/en/stable/ <http://www.structlog.org/en/stable/>), with configurable formatters and handlers, including and not limited to remote loggers and syslog support.\n> \n> I’d love to hear your opinions and feedback on this and possibly start with some more formalized proposal and implementation if there’s enough support and need.\n> \n> Thanks,\n> Alex\n> \n> \n> \n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n> \n> \n>  _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000429.html" , "inReplyTo" : "CAC4po2bgFCdZz7vsoYT182VEU_CSq9+DbisUWU3YTCv1Ox2shA@mail.gmail.com" , "date" : { "$date" : 1449349514000} , "subject" : "[swift-evolution] Proposal: standard logging facility" , "references" : [ "BD305678-84D8-49BF-AC25-8F3492044536@alexkolov.com" , "CAC4po2bgFCdZz7vsoYT182VEU_CSq9+DbisUWU3YTCv1Ox2shA@mail.gmail.com"] , "descendants" : [ "87E6ED33-E2D8-42CB-A999-14285D96AA40@alexkolov.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/63A9B880-DBDC-4566-80F4-A02CCBFD0EFD@architechies.com"}} , "_id" : "63A9B880-DBDC-4566-80F4-A02CCBFD0EFD@architechies.com" , "from" : "brent at architechies.com (Brent Royal-Gordon)" , "mailingList" : "swift-evolution" , "content" : ">>> SwiftLint looks really nice, but one thing I'd really like is automatic formatting.\n>> \n>> That's a feature of IDE, not the language itself.\n> \n> Not necessarily. The existence of \"go fmt\" has resulted in teams running it as a pre-commit translation and as a way of standardising across all users, regardless of IDEs. Otherwise you end up with multiple IDEs (like Eclipse and IntelliJ) which do formatting slightly differently and lead to all manner of pointless arguments. \n> \n> Letting \"the IDE\" do formatting is fine provided there is a maximum of one IDE. \n\nThis is perhaps out of scope for this group, but I’ve actually long wanted languages to move in a direction where indentation is not present at all in the source file—your git repo might never have an instance of /\\n[ \\t]/ in it. Instead, it’s automatically added by the IDE while displaying the code, based on the block beginnings and endings present in the actual source. This would make incorrectly indented code a thing of the past; it would also be obvious when you’re missing a curly bracket, because your code would be indented all wrong. And it would end the destructive whitespace wars, because everyone could just set their IDE to do whatever they liked best.\n\n-- \nBrent Royal-Gordon\nArchitechies" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000430.html" , "inReplyTo" : "49EF0786-90E4-4748-B532-E4C68D33458D@gmail.com" , "date" : { "$date" : 1449349814000} , "subject" : "[swift-evolution] \"bad smells\" should be compiler errors with suggestions on how to fix them" , "references" : [ "557CCA5F-E52F-439C-B224-AC4990140373@gmail.com" , "1449324589110.9d79fd62@Nodemailer" , "CF5C0804-061E-487B-9030-005E76177BD1@harlanhaskins.com" , "E4BE1F82-1BCB-4E27-B2E5-CDBE673EF7B8@me.com" , "49EF0786-90E4-4748-B532-E4C68D33458D@gmail.com"] , "descendants" : [ "26C0DF64-7EE4-4F56-BC99-2C8EAF9D8781@me.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/87E6ED33-E2D8-42CB-A999-14285D96AA40@alexkolov.com"}} , "_id" : "87E6ED33-E2D8-42CB-A999-14285D96AA40@alexkolov.com" , "from" : "me at alexkolov.com (Alexander Kolov)" , "mailingList" : "swift-evolution" , "content" : "I agree we need as minimal interface in the core library as possible while allowing application to take over whole logging configuration process.\nSpecific formatters, handlers and such will have to be implemented as external packages of course. \n\nSent from my iPhone\n\n> On Dec 5, 2015, at 10:05 PM, David Waite <david at alkaline-solutions.com> wrote:\n> \n> I would propose the simplest interface that I can assume is available *everywhere* to be defined by the Swift standard library, so as a framework developer I can make assumptions on my ability to provide diagnostics for internals, expose information for statistical use, provide information needed for auditing usage if I’m working on a hosted service and not a GUI app, and so on.\n> \n> Things like custom formatters and appenders providing integration into remote/system services are something that the application can decide when it chooses a logging framework that implements the standard-defined protocol.\n> \n> There isn’t any sort of dependency injection/inversion of control at the core swift level, which usually means that either logging is done by global functions, or by a global factory returns an instance of some type implementing the logging protocol.\n> \n> The only piece of this which jumps out as not pure swift would be default integration into something like syslog or NSLog, and possibly adding a new preprocessor “macro” like __MODULE__ \n> \n> -DW\n> \n>> On Dec 5, 2015, at 1:20 PM, Kevin Barrett via swift-evolution <swift-evolution at swift.org> wrote:\n>> \n>> +1 to this.\n>> \n>> On Sat, Dec 5, 2015 at 2:24 PM, Alexander Kolov via swift-evolution <swift-evolution at swift.org> wrote:\n>>> Hi everyone,\n>>> \n>>> Coming from a short discussion in swift-corelibs-dev, I’m investigating the need of a standard logging API as a part of core libraries.\n>>> \n>>> The motivation behind this would be having a unified and configurable set of APIs between all first-party modules and third party applications and libraries.\n>>> I think this will help each of us since right now we’re inventing our own solutions as well many bigger third-party library providers have formats and facilities of their own.\n>>> \n>>> As I currently see it would be somewhat similar to python logging and possibly even structlog (http://www.structlog.org/en/stable/), with configurable formatters and handlers, including and not limited to remote loggers and syslog support.\n>>> \n>>> I’d love to hear your opinions and feedback on this and possibly start with some more formalized proposal and implementation if there’s enough support and need.\n>>> \n>>> Thanks,\n>>> Alex\n>>> \n>>> \n>>> \n>>> \n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>> \n>>  _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000431.html" , "inReplyTo" : "DFB23D2F-A970-423F-B23D-1D6F181B1F6A@alkaline-solutions.com" , "date" : { "$date" : 1449350036000} , "subject" : "[swift-evolution] Proposal: standard logging facility" , "references" : [ "BD305678-84D8-49BF-AC25-8F3492044536@alexkolov.com" , "CAC4po2bgFCdZz7vsoYT182VEU_CSq9+DbisUWU3YTCv1Ox2shA@mail.gmail.com" , "DFB23D2F-A970-423F-B23D-1D6F181B1F6A@alkaline-solutions.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAHF2dSLBLDwWFOvQOgKWbry-ABruSVsbu208Ay3RXP_7=CLmYw@mail.gmail.com"}} , "_id" : "CAHF2dSLBLDwWFOvQOgKWbry-ABruSVsbu208Ay3RXP_7=CLmYw@mail.gmail.com" , "from" : "javier.api at gmail.com (Javier Soto)" , "mailingList" : "swift-evolution" , "content" : "My understanding was that [weak variable] behaved that way in Swift already\n(but now I'm not certain and can't find a definitive answer on the book),\ncreating a strong reference. Otherwise this turns into inconsistent\nbehavior, where the variable could deallocate and become nil at any point\ninside the closure.\n\nThose semantics are also important in a case with a closure within a\nclosure:\n\nfunction1(){ [weak self] in\nfunction2() {\n// the value (If present) inside Optional<Self> is a strong reference here\n}\n}\nOn Sat, Dec 5, 2015 at 11:22 AM Jacob Bandes-Storch via swift-evolution <\nswift-evolution at swift.org> wrote:\n\n> Another approach would be to simply allow\n>\n> guard let self = self else { return }\n> On Sat, Dec 5, 2015 at 3:48 AM Robert Vojta <rvojta at me.com> wrote:\n>\n>> Hi all,\n>>\n>> let’s say we have a completion handler closure for some function\n>> (networking, …) and we have [weak self] there. Example …\n>>\n>> doSomething() { [weak self] result in\n>>   …\n>> }\n>>\n>> … then we can use self?.whatever to access self properties, methods. Or\n>> we can try to check if self exists ...\n>>\n>> guard let strongSelf = self else { return }\n>>\n>> … and use strongSelf.\n>>\n>> Can we introduce [weakStrong self] with following behavior:\n>>\n>>  - self is a weak reference\n>>  - when the closure is going to be executed, all weakStrong weak\n>> references are checked if they do exist\n>>  - if they do exist, they’re strong referenced for the closure and the\n>> closure is executed\n>>  - if they don’t exist, closure is not executed\n>>\n>> doSomething() { [weakStrong self] result in\n>>   // Closure code is not executed if self no longer exists\n>>   // self is a strong reference now\n>> }\n>>\n>> What do you think? Does it make sense?\n>>\n>> My motivation is to get rid off of the repetitive code like this one:\n>>\n>> doSomething() { [weak self] result in\n>>   guard let strongSelf = self else { return }\n>>   strongSelf.doSomethingWithResult(result)\n>> }\n>>\n>> Robert\n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n-- \nJavier Soto" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000443.html" , "inReplyTo" : "CADcs6kPtiQ47HEoW1hZ+__rb5KA8aK0Y7qBSS2sgyj9M5w=0cA@mail.gmail.com" , "date" : { "$date" : 1449350690000} , "subject" : "[swift-evolution] Proposal: weakStrong self in completion handler closures" , "references" : [ "6B853E77-1E06-4246-A823-1D055689FE22@me.com" , "CADcs6kPtiQ47HEoW1hZ+__rb5KA8aK0Y7qBSS2sgyj9M5w=0cA@mail.gmail.com"] , "descendants" : [ "DCEF9750-F5E0-4639-8D78-8CC37F5A60A3@me.com" , "CADcs6kMKhQRV_k=Mvh5Q1Z8bULY1kaF3XQKv9nZkHdeTyNdVMw@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com"}} , "_id" : "444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com" , "from" : "rjmccall at apple.com (John McCall)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 4, 2015, at 11:37 PM, John Calsbeek <john.calsbeek+lists at gmail.com> wrote:\n> `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.\n> \n> It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.\n\nRight.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.\n\nOn the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.\n\nJohn.\n\n> \n> One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).\n> \n> switch op {\n> case LOAD_INDIRECT:\n>    in0 = memory[in1]\n>    fallthrough\n> case LOAD:\n>    out0 = memory[in0]\n> //...\n> }\n> \n> I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.\n> \n> Cheers,\n> John\n> \n>> On Dec 4, 2015, at 2:42 PM, John McCall <rjmccall at apple.com <mailto:rjmccall at apple.com>> wrote:\n>> \n>>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard <kevin at sb.org <mailto:kevin at sb.org>> wrote:\n>>> It's not actually Duff's Device. Duff's Device relies on the fact that C switch statements don't actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it's a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.\n>> \n>> To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.\n>> \n>> But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.\n>> \n>> John.\n>> \n>>>  \n>>> Steve's code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It's a good example of one of the uses of `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's Device in Swift.\n>>>  \n>>> -Kevin Ballard\n>>>  \n>>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:\n>>>> Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.\n>>>>  \n>>>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:\n>>>>>  \n>>>>> Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it. \n>>>>>  \n>>>>> True fact: On all of gist.github.com <http://gist.github.com/>, there are only 22 gist results for \"fallthrough language:swift\".\n>>>>> Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:\n>>>>> case .Enum1, .Enum2:\n>>>>> expressed as \n>>>>> case .Enum1: fallthrough\n>>>>> case .Enum2:\n>>>>>  \n>>>>> And then there's streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea <https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea>   I'm pretty sure that ponies were harmed in the production of whatever that last bit is.\n>>>>>  \n>>>>>  \n>>>>>  \n>>>>>  \n>>>>>> On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com <mailto:jalkut at red-sweater.com> wrote:\n>>>>>>  \n>>>>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the \"fallthrough\" keyword from the language?\n>>>>>>  \n>>>>>> My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.\n>>>>>>  \n>>>>>> The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:\n>>>>>>  \n>>>>>> \"The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.\"\n>>>>>>  \n>>>>>> To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.\n>>>>>>  \n>>>>>> I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.\n>>>>>>  \n>>>>>> In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.\n>>>>>>  \n>>>>>> Thoughts?\n>>>>>>  \n>>>>>> Daniel\n>>>>>>  \n>>>>>> _______________________________________________\n>>>>>> swift-evolution mailing list\n>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>> \n>>>>>  \n>>>>> \n>>>>> _______________________________________________\n>>>>> swift-evolution mailing list\n>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>> \n>>>>  \n>>>> \n>>>> _______________________________________________\n>>>> swift-evolution mailing list\n>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>  \n>>> \n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>> \n>>  _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000432.html" , "inReplyTo" : "E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com" , "date" : { "$date" : 1449351065000} , "subject" : "[swift-evolution] Proposal: Remove the \"fallthrough\" keyword" , "references" : [ "3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com" , "AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com" , "8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com" , "1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com" , "02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com" , "E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com"] , "descendants" : [ "6CACDDEC-7FB7-433D-AFA1-15DD4208BE16@jacopo.giola.org" , "0FCA62AB-3FBE-472E-AD11-95E18DC650A9@apple.com" , "ECE284CE-EDE3-4071-ABB6-821820F1FC44@jacopo.giola.org" , "EF9FEF97-C7B8-4D54-B406-2B62FDD15B59@springsandstruts.com" , "98973CF0-B5A8-491F-A8D0-DA73456FF01B@jacopo.giola.org" , "CAKCGC8B0UPGUHeJ_1n8XsGoo+E6Anyj_+_R7WsT76rV1Q-qu2w@mail.gmail.com" , "E7877054-1CF7-4596-800A-0D3C578A0CF1@portableinnovations.de" , "CAKCGC8Cp52O7DX6wWSc3J6FR8Xmoo_WLBgjGBa6fSXzNHhdHEg@mail.gmail.com" , "D7B06EA6-A46C-4920-9E09-CB99B96242AA@jacopo.giola.org" , "1449442122.2380087.459714713.0AC4A201@webmail.messagingengine.com" , "D9340CB2-A696-478A-BAE7-F93ED39CB2DC@red-sweater.com" , "CEA837D7-E2B1-48DC-A53B-D216F96DD8DF@apple.com" , "2423784D-3B84-41CE-9BE2-0850BFE5A3C0@apple.com" , "2A8EA416-B4FF-45B3-9C6D-F94059151129@apple.com" , "82BBEAF7-A512-460A-998C-054AE6D70BEB@springsandstruts.com" , "9C8A3DCA-B80C-4D1F-9528-DD65C0020680@apple.com" , "CAKCGC8BL6SHkO0T_Rg6Ren-NfCLs+eGBb6Zm9aFuZ5rMkWJXtQ@mail.gmail.com" , "AC2407AD-ABFF-4657-A04C-F37E52466316@springsandstruts.com" , "1449524366.1229815.460824345.0E2309C2@webmail.messagingengine.com" , "1449524552.1230499.460828169.5289846B@webmail.messagingengine.com" , "6BABB1A5-55CD-43AF-8D5D-9758F55AD611@apple.com" , "266A61BA-1890-46D7-8969-4A0225EA60B4@springsandstruts.com" , "37FA3360-5F23-462D-BE9B-3743253D2693@apple.com" , "EF1675F6-7918-4262-B535-696104BFC405@apple.com" , "CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com" , "D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org" , "071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com" , "CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org" , "C19956A6-C9B2-45CC-8C91-DA2215EBEA5C@alkaline-solutions.com" , "6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com" , "6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org" , "A56C416E-E246-44FC-A681-3DD66171DF30@springsandstruts.com" , "CADQN+5atyJ78vi0xssjOxh2ka_-jZTaO3ZabxFdY80YqJHFmxg@mail.gmail.com" , "CAKCGC8DHCxwtiU82CjxChc6PaiB495WOCJBP0iq04uw7iWcQmA@mail.gmail.com" , "DEBE0A49-3E5A-431F-8559-63EBA7214068@jacopo.giola.org" , "CAKCGC8DbhMOX6bHtzXQcAhjHQSw1wSSoX-TBUtew0arWA=4pSw@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/FDA512BC-9A25-4360-9BBC-718CAAC19E43@gmail.com"}} , "_id" : "FDA512BC-9A25-4360-9BBC-718CAAC19E43@gmail.com" , "from" : "an00na at gmail.com (Ling Wang)" , "mailingList" : "swift-evolution" , "content" : "+1. I filed a radar about it months ago.\n\n> On Dec 5, 2015, at 1:24 PM, Alexander Kolov via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> Hi everyone,\n> \n> Coming from a short discussion in swift-corelibs-dev, I’m investigating the need of a standard logging API as a part of core libraries.\n> \n> The motivation behind this would be having a unified and configurable set of APIs between all first-party modules and third party applications and libraries.\n> I think this will help each of us since right now we’re inventing our own solutions as well many bigger third-party library providers have formats and facilities of their own.\n> \n> As I currently see it would be somewhat similar to python logging and possibly even structlog (http://www.structlog.org/en/stable/ <http://www.structlog.org/en/stable/>), with configurable formatters and handlers, including and not limited to remote loggers and syslog support.\n> \n> I’d love to hear your opinions and feedback on this and possibly start with some more formalized proposal and implementation if there’s enough support and need.\n> \n> Thanks,\n> Alex\n> \n> \n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000433.html" , "inReplyTo" : "BD305678-84D8-49BF-AC25-8F3492044536@alexkolov.com" , "date" : { "$date" : 1449351094000} , "subject" : "[swift-evolution] Proposal: standard logging facility" , "references" : [ "BD305678-84D8-49BF-AC25-8F3492044536@alexkolov.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/9DC6F2A2-53E0-4DBB-AF5F-D51314AA49F7@anandabits.com"}} , "_id" : "9DC6F2A2-53E0-4DBB-AF5F-D51314AA49F7@anandabits.com" , "from" : "matthew at anandabits.com (Matthew Johnson)" , "mailingList" : "swift-evolution" , "content" : "Did you read through by reply to the original proposal?  I believe it provides the convenience you're looking for here while still allowing for the flexibility to avoid boilerplate in initializers that do more than just set properties.  \n\nThe syntax I used is a bit different, but not too much for the default initializer case (and isn't as important as expressive power IMO). \n\nIf you believe we should have a feature focused strictly on memberwise initializers and not also allow for less boilerplate in more sophisticated initializers I am interested to hear your rationale.\n\nSent from my iPhone\n\nOn Dec 5, 2015, at 3:03 PM, Brent Royal-Gordon via swift-evolution <swift-evolution at swift.org> wrote:\n\n>> There’s lots of boilerplate of initializing structs with stored properties and initializer parameters. I’d like to create a syntax for alleviating that in the 90% case.\n>> \n>> ```swift\n>> struct Foo {\n>>    let bar: String\n>>    let baz: Int\n>> \n>>    init(self.bar: String = \"default\", counter self.baz: Int) {\n>>    }\n>> }\n>> ```\n> \n> I’d like to propose an alternative approach.\n> \n> Swift already generates a default initializer for structs that don’t have any initializers explicitly defined. However, the moment you write init(, that initializer disappears. It’s also never available on classes, because they have to dispatch to another initializer.\n> \n> I propose that we make it possible to explicitly ask for that default initializer:\n> \n>    struct Foo {\n>        let bar: String\n>        let baz: Int\n> \n>        init() {\n>            bar = “default”\n>            baz = 0\n>        }\n> \n>        init default    // automatically generates init(bar: String, baz: Int)\n>    }\n> \n> Moreover, I propose we extend this to classes:\n> \n>    struct Foo: Bar {\n>        let bar: String\n>        let baz: Int\n> \n>        init() {\n>            bar = “default”\n>            baz = 0\n>        }\n> \n>        init default()    // automatically generates init(bar: String, baz: Int) with super.init()\n>    }\n> \n> In a class, the “default” statement must have parens after it; these indicate the parameters to be added for the superclass initializer. If you need to super up to an initializer that takes parameters, you add the needed parameters there:\n> \n>    struct Foo {\n>        let bar: String\n>        let baz: Int\n> \n>        init() {\n>            bar = “default”\n>            baz = 0\n>        }\n> \n>        init default(quux: Double)    // automatically generates init(quux: Double, bar: String, baz: Int) with super.init(quux: quux)\n>    }\n> \n> If you super up to a failable initializer, of course, that will have to be “init? default(quux: Double)”.\n> \n> Now, one little quirk of the current system is that Swift may actually generate *two* default initializers: a parameterless initializer when all properties have default values, and a memberwise initializer which requires all values be provided. I further propose that these be unified into one default initializer by giving default values to parameters which map to properties with default values. This gives you all the parameter sets currently supported, plus a whole range in between.\n> \n>    struct Foo {\n>        let bar: String = “default\"\n>        let baz: Int\n> \n>        init() {\n>            bar = “default”\n>            baz = 0\n>        }\n> \n>        init default    // automatically generates init(bar: String = “default\", baz: Int)\n>    }\n> \n> Finally, you can continue to decorate the “init” keyword with attributes as you normally would.\n> \n>    public init default\n>    internal init default\n>    private init default\n>    required init default\n>    override init default\n>    @objc init default\n>    @objc public required init default\n> \n> (I don’t think convenience initializers make much sense here.)\n> \n> This does not, unfortunately, eliminate boilerplate in initializers which do more than just set properties. Nor does it allow you to rename parameters, as your example does with “counter”. \n> \n> -- \n> Brent Royal-Gordon\n> Architechies\n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000434.html" , "inReplyTo" : "4F8C6141-CEFA-43DA-8FD9-5C787789ED68@architechies.com" , "date" : { "$date" : 1449351160000} , "subject" : "[swift-evolution] Proposal: helpers for initializing properties of same name as parameters" , "references" : [ "CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com" , "4F8C6141-CEFA-43DA-8FD9-5C787789ED68@architechies.com"] , "descendants" : [ "DB740B9C-987F-42BF-96DF-95570F070A89@architechies.com" , "C3D71715-4957-441C-B277-E8CC3BBE4CA0@alkaline-solutions.com" , "3925DEF8-2B69-4AB5-AD95-49BD2FE6401B@alkaline-solutions.com" , "63177F8D-6BA7-4B1E-9052-BA6D3ED6B0CC@architechies.com" , "FC624F3D-20B7-4F42-A04F-97AFDB0287CB@alkaline-solutions.com" , "CA+ddMk042v6whHcVu8kLZyAk1JaEQ3LYxttAbZfGq6KBvrcGNw@mail.gmail.com" , "CADcs6kN6MT3cbEsPjtiXbR1U6-YzwD8v_Rbiv0PLHsm6xFiiZg@mail.gmail.com" , "6935BB3A-2203-406C-9EC2-02FF7287767F@anandabits.com" , "E3BD5430-C4DF-4284-99FA-14B61512E74A@apple.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/76657877-5D42-4486-AD4B-79BFC8677941@architechies.com"}} , "_id" : "76657877-5D42-4486-AD4B-79BFC8677941@architechies.com" , "from" : "brent at architechies.com (Brent Royal-Gordon)" , "mailingList" : "swift-evolution" , "content" : "> extension Int: RangeDiscoverable {\n> \tstatic let representableRange: Range<Int> = Int.min…Int.max\n> }\n\n\nThere’s a problem with that:\n\n\t 24> Int.min...Int.max\n\tfatal error: Range end index has no valid successor\n\nThe problem is that Int.min … Int.max is actually represented as Int.min ..< Int.max.successor(), which is obviously not going to work.\n\n> This would require numeric types to conform to ForwardIndexType.  Integer types already conform to RandomAccessIndexType.  Floating point types do not currently conform to ForwardIndexType but could conform not just to ForwardIndexType, but also BidirectionalIndexType.\n\nFloats don’t currently conform to the IndexType protocols because there’s no *natural* interval for them to use. nextUp/nextDown are rarely what you want in practice, while 1 breaks down at large sizes.\n\nHowever, we can fix both of these issues by using ClosedInterval instead of Range. ClosedInterval requires only that the bounds be Comparable, and doesn’t try to add 1 to the end.\n\n-- \nBrent Royal-Gordon\nArchitechies" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000435.html" , "inReplyTo" : "981D5E32-8D9D-4B24-8085-04E7C8DBC81A@anandabits.com" , "date" : { "$date" : 1449351197000} , "subject" : "[swift-evolution] Proposal: floating point static min / max properties" , "references" : [ "36C3F015-B77D-4256-9FAB-2853218D5973@anandabits.com" , "9060D0D4-BB70-47FE-A3F7-A572ACE8BD64@apple.com" , "981D5E32-8D9D-4B24-8085-04E7C8DBC81A@anandabits.com"] , "descendants" : [ "B47BE4E1-F761-4452-8CF2-7A9CFB0D3613@anandabits.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CADcs6kMKhQRV_k=Mvh5Q1Z8bULY1kaF3XQKv9nZkHdeTyNdVMw@mail.gmail.com"}} , "_id" : "CADcs6kMKhQRV_k=Mvh5Q1Z8bULY1kaF3XQKv9nZkHdeTyNdVMw@mail.gmail.com" , "from" : "jtbandes at gmail.com (Jacob Bandes-Storch)" , "mailingList" : "swift-evolution" , "content" : "When you use \"weak self\", self becomes Optional inside the closure, and\nindeed it *can* become nil partway through. This is the same as __weak in\nObjective-C, and there's actually a clang warning for it (search for\n\"repeated-use-of-weak\" or see\nhttp://devstreaming.apple.com/videos/wwdc/2013/404xbx2xvp1eaaqonr8zokm/404/404.pdf\n).\n\nThat's why \"guard let strongSelf = self\" is important, and I think \"guard\nlet self = self\" would add value without adding confusion.\n\nThe current behavior is easily demonstrated:\n\nimport Foundation\n\nclass C {\n    func doStuff() {\n        dispatch_async(dispatch_get_global_queue(0, 0)) { [weak self] in\n            print(\"self is \\(self), waiting...\")\n            usleep(500_000)\n            print(\"self is \\(self), waiting...\")\n            usleep(500_000)\n            print(\"self is \\(self)\")\n        }\n    }\n}\n\nvar obj: C? = C()\nobj!.doStuff()\n\nusleep(750_000)\nprint(\"main thread - releasing\")\nobj = nil\n\nsleep(2)\n\n\n\nOn Sat, Dec 5, 2015 at 1:24 PM, Javier Soto <javier.api at gmail.com> wrote:\n\n> My understanding was that [weak variable] behaved that way in Swift\n> already (but now I'm not certain and can't find a definitive answer on the\n> book), creating a strong reference. Otherwise this turns into inconsistent\n> behavior, where the variable could deallocate and become nil at any point\n> inside the closure.\n>\n> Those semantics are also important in a case with a closure within a\n> closure:\n>\n> function1(){ [weak self] in\n> function2() {\n> // the value (If present) inside Optional<Self> is a strong reference here\n> }\n> }\n> On Sat, Dec 5, 2015 at 11:22 AM Jacob Bandes-Storch via swift-evolution <\n> swift-evolution at swift.org> wrote:\n>\n>> Another approach would be to simply allow\n>>\n>> guard let self = self else { return }\n>> On Sat, Dec 5, 2015 at 3:48 AM Robert Vojta <rvojta at me.com> wrote:\n>>\n>>> Hi all,\n>>>\n>>> let’s say we have a completion handler closure for some function\n>>> (networking, …) and we have [weak self] there. Example …\n>>>\n>>> doSomething() { [weak self] result in\n>>>   …\n>>> }\n>>>\n>>> … then we can use self?.whatever to access self properties, methods. Or\n>>> we can try to check if self exists ...\n>>>\n>>> guard let strongSelf = self else { return }\n>>>\n>>> … and use strongSelf.\n>>>\n>>> Can we introduce [weakStrong self] with following behavior:\n>>>\n>>>  - self is a weak reference\n>>>  - when the closure is going to be executed, all weakStrong weak\n>>> references are checked if they do exist\n>>>  - if they do exist, they’re strong referenced for the closure and the\n>>> closure is executed\n>>>  - if they don’t exist, closure is not executed\n>>>\n>>> doSomething() { [weakStrong self] result in\n>>>   // Closure code is not executed if self no longer exists\n>>>   // self is a strong reference now\n>>> }\n>>>\n>>> What do you think? Does it make sense?\n>>>\n>>> My motivation is to get rid off of the repetitive code like this one:\n>>>\n>>> doSomething() { [weak self] result in\n>>>   guard let strongSelf = self else { return }\n>>>   strongSelf.doSomethingWithResult(result)\n>>> }\n>>>\n>>> Robert\n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>\n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>\n> --\n> Javier Soto" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000436.html" , "inReplyTo" : "CAHF2dSLBLDwWFOvQOgKWbry-ABruSVsbu208Ay3RXP_7=CLmYw@mail.gmail.com" , "date" : { "$date" : 1449351388000} , "subject" : "[swift-evolution] Proposal: weakStrong self in completion handler closures" , "references" : [ "6B853E77-1E06-4246-A823-1D055689FE22@me.com" , "CADcs6kPtiQ47HEoW1hZ+__rb5KA8aK0Y7qBSS2sgyj9M5w=0cA@mail.gmail.com" , "CAHF2dSLBLDwWFOvQOgKWbry-ABruSVsbu208Ay3RXP_7=CLmYw@mail.gmail.com"] , "descendants" : [ "DCEF9750-F5E0-4639-8D78-8CC37F5A60A3@me.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/E361A2D0-CD93-4AF9-BCBD-FBD4312E43D7@apple.com"}} , "_id" : "E361A2D0-CD93-4AF9-BCBD-FBD4312E43D7@apple.com" , "from" : "phabouzit at apple.com (Pierre Habouzit)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 5, 2015, at 12:53 PM, Jacob Bandes-Storch via swift-corelibs-dev <swift-corelibs-dev at swift.org> wrote:\n> \n> There are several functions in public API, such as dispatch_sync and dispatch_apply, which do not allow their block parameters to escape the function call.\n> \n> However, they are not currently exposed to Swift as @noescape, meaning that users are required to specify \"self.\" or \"[weak self]\" in their closures.\n> \n> The instances I can think of:\n> \n> - dispatch_sync\n> - dispatch_barrier_sync\n> - dispatch_apply\n> - dispatch_block_perform (thanks to Pierre Habouzit for pointing this out)\n\nI also pointed out dispatch_once(), which even it doesn’t make sense for swift where the globals already have the proper semantics, is still useful as the compiler can still implement various optimizations in how the block captures its variables (it is okay to use the things where they are on the stack as opposed to have to create a real state for the block).\n\n> I provided a preliminary implementation at https://github.com/apple/swift-corelibs-libdispatch/pull/6 <https://github.com/apple/swift-corelibs-libdispatch/pull/6>, but it needs refinement. Tony Parker mentioned commented that there might be similar changes to make for the swift-corelibs-foundation project.\n> \n> Thoughts?\n> \n> Question: does __attribute__((noescape)) have the same meaning when applied to C function pointers? Namely, does Swift understand @noescape as it applies to @convention(c)?\n> \n> Jacob Bandes-Storch\n>  _______________________________________________\n> swift-corelibs-dev mailing list\n> swift-corelibs-dev at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-corelibs-dev" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000437.html" , "inReplyTo" : "CADcs6kN-D2ETv-Uqhkm8KH9g5N3rWrjNDR77-EK4_w-kVa8F-A@mail.gmail.com" , "date" : { "$date" : 1449351543000} , "subject" : "[swift-evolution] [swift-corelibs-dev] Proposal: add `noescape` attribute to public API (particularly libdispatch)" , "references" : [ "CADcs6kN-D2ETv-Uqhkm8KH9g5N3rWrjNDR77-EK4_w-kVa8F-A@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/E5B092E4-2635-4217-8946-7A374CD29F53@apple.com"}} , "_id" : "E5B092E4-2635-4217-8946-7A374CD29F53@apple.com" , "from" : "anthony.parker at apple.com (Tony Parker)" , "mailingList" : "swift-evolution" , "content" : "Hi Jacob,\n\nThanks for bringing the discussion on this topic here.\n\nOne topic I wanted to discuss was finding a comprehensive list of API that needs the attribute. The next step after that is figuring out how to get this attribute to be consistent across Darwin and Swift open source.\n\nOne option was to use the API notes feature of the compiler to annotate these APIs as part of the import into Swift. Another is to get the C headers changed (on Darwin too) to add the attribute. We may want to do one approach in the short term and another in the long term.\n\n- Tony\n\n> On Dec 5, 2015, at 12:53 PM, Jacob Bandes-Storch via swift-corelibs-dev <swift-corelibs-dev at swift.org> wrote:\n> \n> There are several functions in public API, such as dispatch_sync and dispatch_apply, which do not allow their block parameters to escape the function call.\n> \n> However, they are not currently exposed to Swift as @noescape, meaning that users are required to specify \"self.\" or \"[weak self]\" in their closures.\n> \n> The instances I can think of:\n> \n> - dispatch_sync\n> - dispatch_barrier_sync\n> - dispatch_apply\n> - dispatch_block_perform (thanks to Pierre Habouzit for pointing this out)\n> \n> I provided a preliminary implementation at https://github.com/apple/swift-corelibs-libdispatch/pull/6 <https://github.com/apple/swift-corelibs-libdispatch/pull/6>, but it needs refinement. Tony Parker mentioned commented that there might be similar changes to make for the swift-corelibs-foundation project.\n> \n> Thoughts?\n> \n> Question: does __attribute__((noescape)) have the same meaning when applied to C function pointers? Namely, does Swift understand @noescape as it applies to @convention(c)?\n> \n> Jacob Bandes-Storch\n>  _______________________________________________\n> swift-corelibs-dev mailing list\n> swift-corelibs-dev at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-corelibs-dev" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000438.html" , "inReplyTo" : "CADcs6kN-D2ETv-Uqhkm8KH9g5N3rWrjNDR77-EK4_w-kVa8F-A@mail.gmail.com" , "date" : { "$date" : 1449351617000} , "subject" : "[swift-evolution] [swift-corelibs-dev] Proposal: add `noescape` attribute to public API (particularly libdispatch)" , "references" : [ "CADcs6kN-D2ETv-Uqhkm8KH9g5N3rWrjNDR77-EK4_w-kVa8F-A@mail.gmail.com"] , "descendants" : [ "CADcs6kMh=7p+sLe7pPH253OTw4N=d5s3nWaT_pom42CsSMi4Fg@mail.gmail.com" , "D1CECE38-501F-4F12-8B89-43A849393285@apple.com" , "CADcs6kMYVPfbUeh9+obGhm45ao9Bo-JWSG22CdgfwkcsfmtW0w@mail.gmail.com" , "5585D80C-4127-4FD2-B405-F135400D823C@apple.com" , "CADcs6kP_v1E6FFwvrho4GsZQYqFhPu2ASKFVSXfpJYKbQQqYug@mail.gmail.com" , "CADcs6kNhrkOYJs2ZZ05WPYPnnf9jtE6UWNZbg2FSYqtjr701zQ@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CADcs6kMYVPfbUeh9+obGhm45ao9Bo-JWSG22CdgfwkcsfmtW0w@mail.gmail.com"}} , "_id" : "CADcs6kMYVPfbUeh9+obGhm45ao9Bo-JWSG22CdgfwkcsfmtW0w@mail.gmail.com" , "from" : "jtbandes at gmail.com (Jacob Bandes-Storch)" , "mailingList" : "swift-evolution" , "content" : ">\n> One option was to use the API notes feature of the compiler to annotate\n> these APIs as part of the import into Swift. Another is to get the C\n> headers changed (on Darwin too) to add the attribute. We may want to do one\n> approach in the short term and another in the long term.\n>\n\nI've been operating under the assumption that __attribute__((noescape))\nwill eventually be deeply understood by clang, and allow the same elision\nof \"self\" in Objective-C that @noescape does in Swift. (I filed\n<rdar://19914650> for this some time ago.)\n\nThus, I think it makes the most sense to change the C headers.\n\nHowever, if swift-corelibs-libdispatch isn't going to affect the Swift\nversions that ship with Xcode in the near future, then I guess amending the\nAPI notes is a good idea, so the @noescape versions can get into\ndevelopers' hands as soon as possible.\n\nJacob" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000439.html" , "inReplyTo" : "E5B092E4-2635-4217-8946-7A374CD29F53@apple.com" , "date" : { "$date" : 1449351873000} , "subject" : "[swift-evolution] [swift-corelibs-dev] Proposal: add `noescape` attribute to public API (particularly libdispatch)" , "references" : [ "CADcs6kN-D2ETv-Uqhkm8KH9g5N3rWrjNDR77-EK4_w-kVa8F-A@mail.gmail.com" , "E5B092E4-2635-4217-8946-7A374CD29F53@apple.com"] , "descendants" : [ "5585D80C-4127-4FD2-B405-F135400D823C@apple.com" , "CADcs6kNhrkOYJs2ZZ05WPYPnnf9jtE6UWNZbg2FSYqtjr701zQ@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/EF1675F6-7918-4262-B535-696104BFC405@apple.com"}} , "_id" : "EF1675F6-7918-4262-B535-696104BFC405@apple.com" , "from" : "rjmccall at apple.com (John McCall)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution <swift-evolution at swift.org> wrote:\n>> On Dec 4, 2015, at 11:37 PM, John Calsbeek <john.calsbeek+lists at gmail.com <mailto:john.calsbeek+lists at gmail.com>> wrote:\n>> `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.\n>> \n>> It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.\n> \n> Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.\n> \n> On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.\n\nOh, I see that Joe already brought this up, spelled “reswitch”.\n\nJohn.\n\n> \n> John.\n> \n>> \n>> One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).\n>> \n>> switch op {\n>> case LOAD_INDIRECT:\n>>    in0 = memory[in1]\n>>    fallthrough\n>> case LOAD:\n>>    out0 = memory[in0]\n>> //...\n>> }\n>> \n>> I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.\n>> \n>> Cheers,\n>> John\n>> \n>>> On Dec 4, 2015, at 2:42 PM, John McCall <rjmccall at apple.com <mailto:rjmccall at apple.com>> wrote:\n>>> \n>>>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard <kevin at sb.org <mailto:kevin at sb.org>> wrote:\n>>>> It's not actually Duff's Device. Duff's Device relies on the fact that C switch statements don't actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it's a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.\n>>> \n>>> To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.\n>>> \n>>> But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.\n>>> \n>>> John.\n>>> \n>>>>  \n>>>> Steve's code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It's a good example of one of the uses of `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's Device in Swift.\n>>>>  \n>>>> -Kevin Ballard\n>>>>  \n>>>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:\n>>>>> Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.\n>>>>>  \n>>>>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:\n>>>>>>  \n>>>>>> Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it. \n>>>>>>  \n>>>>>> True fact: On all of gist.github.com <http://gist.github.com/>, there are only 22 gist results for \"fallthrough language:swift\".\n>>>>>> Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:\n>>>>>> case .Enum1, .Enum2:\n>>>>>> expressed as \n>>>>>> case .Enum1: fallthrough\n>>>>>> case .Enum2:\n>>>>>>  \n>>>>>> And then there's streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea <https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea>   I'm pretty sure that ponies were harmed in the production of whatever that last bit is.\n>>>>>>  \n>>>>>>  \n>>>>>>  \n>>>>>>  \n>>>>>>> On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com <mailto:jalkut at red-sweater.com> wrote:\n>>>>>>>  \n>>>>>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the \"fallthrough\" keyword from the language?\n>>>>>>>  \n>>>>>>> My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.\n>>>>>>>  \n>>>>>>> The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:\n>>>>>>>  \n>>>>>>> \"The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.\"\n>>>>>>>  \n>>>>>>> To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.\n>>>>>>>  \n>>>>>>> I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.\n>>>>>>>  \n>>>>>>> In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.\n>>>>>>>  \n>>>>>>> Thoughts?\n>>>>>>>  \n>>>>>>> Daniel\n>>>>>>>  \n>>>>>>> _______________________________________________\n>>>>>>> swift-evolution mailing list\n>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>>> \n>>>>>>  \n>>>>>> \n>>>>>> _______________________________________________\n>>>>>> swift-evolution mailing list\n>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>> \n>>>>>  \n>>>>> \n>>>>> _______________________________________________\n>>>>> swift-evolution mailing list\n>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>  \n>>>> \n>>>> _______________________________________________\n>>>> swift-evolution mailing list\n>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>> \n>>>  _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>> \n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> \n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000440.html" , "inReplyTo" : "444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com" , "date" : { "$date" : 1449351933000} , "subject" : "[swift-evolution] Proposal: Remove the \"fallthrough\" keyword" , "references" : [ "3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com" , "AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com" , "8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com" , "1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com" , "02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com" , "E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com" , "444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com"] , "descendants" : [ "6CACDDEC-7FB7-433D-AFA1-15DD4208BE16@jacopo.giola.org" , "0FCA62AB-3FBE-472E-AD11-95E18DC650A9@apple.com" , "ECE284CE-EDE3-4071-ABB6-821820F1FC44@jacopo.giola.org" , "EF9FEF97-C7B8-4D54-B406-2B62FDD15B59@springsandstruts.com" , "98973CF0-B5A8-491F-A8D0-DA73456FF01B@jacopo.giola.org" , "CAKCGC8B0UPGUHeJ_1n8XsGoo+E6Anyj_+_R7WsT76rV1Q-qu2w@mail.gmail.com" , "E7877054-1CF7-4596-800A-0D3C578A0CF1@portableinnovations.de" , "CAKCGC8Cp52O7DX6wWSc3J6FR8Xmoo_WLBgjGBa6fSXzNHhdHEg@mail.gmail.com" , "D7B06EA6-A46C-4920-9E09-CB99B96242AA@jacopo.giola.org" , "1449442122.2380087.459714713.0AC4A201@webmail.messagingengine.com" , "D9340CB2-A696-478A-BAE7-F93ED39CB2DC@red-sweater.com" , "CEA837D7-E2B1-48DC-A53B-D216F96DD8DF@apple.com" , "2423784D-3B84-41CE-9BE2-0850BFE5A3C0@apple.com" , "2A8EA416-B4FF-45B3-9C6D-F94059151129@apple.com" , "82BBEAF7-A512-460A-998C-054AE6D70BEB@springsandstruts.com" , "9C8A3DCA-B80C-4D1F-9528-DD65C0020680@apple.com" , "CAKCGC8BL6SHkO0T_Rg6Ren-NfCLs+eGBb6Zm9aFuZ5rMkWJXtQ@mail.gmail.com" , "AC2407AD-ABFF-4657-A04C-F37E52466316@springsandstruts.com" , "1449524366.1229815.460824345.0E2309C2@webmail.messagingengine.com" , "1449524552.1230499.460828169.5289846B@webmail.messagingengine.com" , "6BABB1A5-55CD-43AF-8D5D-9758F55AD611@apple.com" , "266A61BA-1890-46D7-8969-4A0225EA60B4@springsandstruts.com" , "37FA3360-5F23-462D-BE9B-3743253D2693@apple.com" , "CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com" , "D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org" , "071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com" , "CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org" , "C19956A6-C9B2-45CC-8C91-DA2215EBEA5C@alkaline-solutions.com" , "6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com" , "6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org" , "A56C416E-E246-44FC-A681-3DD66171DF30@springsandstruts.com" , "CADQN+5atyJ78vi0xssjOxh2ka_-jZTaO3ZabxFdY80YqJHFmxg@mail.gmail.com" , "CAKCGC8DHCxwtiU82CjxChc6PaiB495WOCJBP0iq04uw7iWcQmA@mail.gmail.com" , "DEBE0A49-3E5A-431F-8559-63EBA7214068@jacopo.giola.org" , "CAKCGC8DbhMOX6bHtzXQcAhjHQSw1wSSoX-TBUtew0arWA=4pSw@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/5585D80C-4127-4FD2-B405-F135400D823C@apple.com"}} , "_id" : "5585D80C-4127-4FD2-B405-F135400D823C@apple.com" , "from" : "phabouzit at apple.com (Pierre Habouzit)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 5, 2015, at 1:44 PM, Jacob Bandes-Storch via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> One option was to use the API notes feature of the compiler to annotate these APIs as part of the import into Swift. Another is to get the C headers changed (on Darwin too) to add the attribute. We may want to do one approach in the short term and another in the long term.\n> \n> I've been operating under the assumption that __attribute__((noescape)) will eventually be deeply understood by clang, and allow the same elision of \"self\" in Objective-C that @noescape does in Swift. (I filed <rdar://19914650> for this some time ago.)\n> \n> Thus, I think it makes the most sense to change the C headers.\n\nI completely agree with that statement, and I think that this change should make it into Darwin and swift-corelibs-libdispatch both.\n\n-Pierre" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000441.html" , "inReplyTo" : "CADcs6kMYVPfbUeh9+obGhm45ao9Bo-JWSG22CdgfwkcsfmtW0w@mail.gmail.com" , "date" : { "$date" : 1449352207000} , "subject" : "[swift-evolution] [swift-corelibs-dev] Proposal: add `noescape` attribute to public API (particularly libdispatch)" , "references" : [ "CADcs6kN-D2ETv-Uqhkm8KH9g5N3rWrjNDR77-EK4_w-kVa8F-A@mail.gmail.com" , "E5B092E4-2635-4217-8946-7A374CD29F53@apple.com" , "CADcs6kMYVPfbUeh9+obGhm45ao9Bo-JWSG22CdgfwkcsfmtW0w@mail.gmail.com"] , "descendants" : [ "CADcs6kNhrkOYJs2ZZ05WPYPnnf9jtE6UWNZbg2FSYqtjr701zQ@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CADcs6kNhrkOYJs2ZZ05WPYPnnf9jtE6UWNZbg2FSYqtjr701zQ@mail.gmail.com"}} , "_id" : "CADcs6kNhrkOYJs2ZZ05WPYPnnf9jtE6UWNZbg2FSYqtjr701zQ@mail.gmail.com" , "from" : "jtbandes at gmail.com (Jacob Bandes-Storch)" , "mailingList" : "swift-evolution" , "content" : "On Sat, Dec 5, 2015 at 1:50 PM, Pierre Habouzit <phabouzit at apple.com> wrote:\n>\n>\n> I completely agree with that statement, and I think that this change\n> should make it into Darwin and swift-corelibs-libdispatch both.\n>\n> -Pierre\n>\n\nPardon my ignorance, but what is intended to be the difference between the\ntwo? Will they diverge?" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000442.html" , "inReplyTo" : "5585D80C-4127-4FD2-B405-F135400D823C@apple.com" , "date" : { "$date" : 1449352611000} , "subject" : "[swift-evolution] [swift-corelibs-dev] Proposal: add `noescape` attribute to public API (particularly libdispatch)" , "references" : [ "CADcs6kN-D2ETv-Uqhkm8KH9g5N3rWrjNDR77-EK4_w-kVa8F-A@mail.gmail.com" , "E5B092E4-2635-4217-8946-7A374CD29F53@apple.com" , "CADcs6kMYVPfbUeh9+obGhm45ao9Bo-JWSG22CdgfwkcsfmtW0w@mail.gmail.com" , "5585D80C-4127-4FD2-B405-F135400D823C@apple.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CADcs6kP_v1E6FFwvrho4GsZQYqFhPu2ASKFVSXfpJYKbQQqYug@mail.gmail.com"}} , "_id" : "CADcs6kP_v1E6FFwvrho4GsZQYqFhPu2ASKFVSXfpJYKbQQqYug@mail.gmail.com" , "from" : "jtbandes at gmail.com (Jacob Bandes-Storch)" , "mailingList" : "swift-evolution" , "content" : "On Sat, Dec 5, 2015 at 1:40 PM, Tony Parker <anthony.parker at apple.com>\nwrote:\n\n> One topic I wanted to discuss was finding a comprehensive list of API that\n> needs the attribute.\n>\n\nOn this subject, here are some other APIs which could use the annotation.\nAgain, I think these should be annotated even in the C/Objective-C headers,\nso they can benefit C/Objective-C callers as well.\n\n- bsearch, heapsort, qsort, mergesort, psort, and their _b variants\n\n\"passing test\" methods:\n- -[{NSArray,NSOrderedSet} indexOfObjectPassingTest:]\n- -[{NSArray,NSOrderedSet} indexesOfObjectsPassingTest:]\n- -[{NSArray,NSOrderedSet} indexOfObjectsAtIndexes:passingTest:]\n- -[{NSArray,NSOrderedSet} indexesOfObjectsAtIndexes:passingTest:]\n- -[SCNNode childNodesPassingTest:]\n- -[SCNSceneSource entriesPassingTest:]\n- -[AVAudioUnitComponentManager componentsPassingTest:]\n- -[NSIndexSet indexPassingTest:]\n- -[NSIndexSet indexWithOptions:passingTest:]\n- -[NSIndexSet indexesPassingTest:]\n- -[NSIndexSet indexesWithOptions:passingTest:]\n- -[NSIndexSet indexInRange:options:passingTest:]\n- -[NSIndexSet indexesInRange:options:passingTest:]\n- -[NSSet objectsPassingTest:]\n- -[NSSet objectsWithOptions:passingTest:]\n- -[NSDictionary keysOfEntriesPassingTest:]\n- -[NSDictionary keysOfEntriesWithOptions:passingTest:]\n\n\"using comparator\" methods:\n- -[NSArray indexOfObject:inSortedRange:options:usingComparator:]\n- -[NSArray sortedArrayUsingComparator:]\n- -[NSArray sortedArrayWithOptions:usingComparator:]\n- -[NSDictionary keysSortedByValueUsingComparator:]\n- -[NSDictionary keysSortedByValueWithOptions:usingComparator:]\n- -[NSMutableArray sortUsingComparator:]\n- -[NSMutableArray sortWithOptions:usingComparator:]\n- -[NSMutableOrderedSet sortWithOptions:usingComparator:]\n- -[NSMutableOrderedSet sortRange:options:usingComparator:]\n\n (and some of these have \"usingFunction\" variants)\n\n\"enumerate using block\" methods:\n- -[NSTableView enumerateAvailableRowViewsUsingBlock:]\n- -[SKPhysicsWorld enumerateBodiesAtPoint:usingBlock:]\n- -[SKPhysicsWorld enumerateBodiesInRect:usingBlock:]\n- -[NSData enumerateByteRangesUsingBlock:]\n- -[SCNNode enumerateChildNodesUsingBlock:]\n- -[SCNNode enumerateChildNodesWithName:usingBlock:]\n- -[NSIndexSet enumerateIndexesUsingBlock:]\n- -[NSIndexSet enumerateIndexesWithOptions:usingBlock:]\n- -[NSDictionary enumerateKeysAndObjectsUsingBlock:]\n- -[NSDictionary enumerateKeysAndObjectsWithOptions:usingBlock:]\n- -[NSString enumerateLinesUsingBlock:]\n- -[NSString enumerateSubstringsInRange:options:usingBlock:]\n- -[{NSArray,NSSet,NSOrderedSet} enumerateObjectsUsingBlock:]\n- -[{NSArray,NSSet,NSOrderedSet} enumerateObjectsWithOptions:usingBlock:]\n- -[NSIndexSet enumerateRangesUsingBlock:]\n- -[NSIndexSet enumerateRangesWithOptions:usingBlock:]\n- -[NSIndexSet enumerateRangesInRange:options:usingBlock:]\n- -[MPMediaEntity enumerateValuesForProperties:usingBlock:]\n- -[NSMetadataQuery enumerateResultsUsingBlock:]\n- -[NSMetadataQuery enumerateResultsWithOptions:usingBlock:]\n\nmisc:\n- -[NSDocument performSynchronousFileAccessUsingBlock:]\n\nWow, that's more than I expected to find! This is obviously beyond the\nscope of just libdispatch, and I think a lot of these should probably\nchange upstream, in their original frameworks, internally (not something\nthat community members can really contribute to).\n\nArguably, the \"enumerateXUsingBlock:\" pattern should be bridged to Swift as\nsomething SequenceType-ish which can be `for-in`ed.\n\nJacob Bandes-Storch" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000444.html" , "inReplyTo" : "E5B092E4-2635-4217-8946-7A374CD29F53@apple.com" , "date" : { "$date" : 1449354343000} , "subject" : "[swift-evolution] [swift-corelibs-dev] Proposal: add `noescape` attribute to public API (particularly libdispatch)" , "references" : [ "CADcs6kN-D2ETv-Uqhkm8KH9g5N3rWrjNDR77-EK4_w-kVa8F-A@mail.gmail.com" , "E5B092E4-2635-4217-8946-7A374CD29F53@apple.com"] , "descendants" : [ "CADcs6kMh=7p+sLe7pPH253OTw4N=d5s3nWaT_pom42CsSMi4Fg@mail.gmail.com" , "D1CECE38-501F-4F12-8B89-43A849393285@apple.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/63177F8D-6BA7-4B1E-9052-BA6D3ED6B0CC@architechies.com"}} , "_id" : "63177F8D-6BA7-4B1E-9052-BA6D3ED6B0CC@architechies.com" , "from" : "brent at architechies.com (Brent Royal-Gordon)" , "mailingList" : "swift-evolution" , "content" : "> Did you read through by reply to the original proposal?  I believe it provides the convenience you're looking for here while still allowing for the flexibility to avoid boilerplate in initializers that do more than just set properties.  \n\nI did, and I didn’t really like it. One of the syntaxes it proposed was strange and ad-hoc; the other was a fairly arbitrary overloading of parentheses, although it doesn’t actually conflict with anything since you can’t overload “calling parentheses” on a non-function.\n\nIt’s important to ensure that, when the implementation evolves, you can replace the initializer transparently. For instance, suppose I have a type which represents a player in a game. It uses a stored property called `points`:\n\n    class Player {\n        var name: String\n        private(set) var points: Int\n\n        func addPoints(additionalPoints: Int) {\n            points += additionalPoints\n        }\n        \n        // Creates init(name: String, score: Int)\n        init default()\n    }\n\nLater, I decide to add syncing, and realize I need to change this model. I need to add a sync identifier, and I want to change `points` to be computed from a series of `PointChange` objects. (This is a common strategy to avoid sync conflicts.) However, I don’t want to disrupt any of my existing code when I do this.\n\n    class Player {\n        let syncIdentifier = NSUUID()\n        var name: String\n        private var pointChanges: Set<PointChange>\n        \n        var points: Int {\n            get { return pointChanges.reduce(0, combine: +) }\n        }\n        \n        func addPoints(additionalPoints: Int) {\n            pointChanges.insert(PointChange(offset: additionalPoints)\n        }\n        \n        // We can no longer use init default(), but we can still create an initializer with the same signature\n        init(name: String, points: Int) {\n            self.name = name\n            pointChanges = [ PointChange(offset: score) ]\n        }\n    }\n\nBy *not* separating the properties into a different syntactical construct from the constructor parameters, I can update my type’s implementation without affecting its interface. If properties were separated syntactically from constructor parameters as you proposed, it would not be possible to change this seamlessly.\n\n> If you believe we should have a feature focused strictly on memberwise initializers and not also allow for less boilerplate in more sophisticated initializers I am interested to hear your rationale.\n\nHonestly, I would like to fix the boilerplate issue in more sophisticated initializers, but I don’t see a clean way to do that. The other proposals I’ve seen in this thread, along the lines of:\n\n\tinit(self.name, self.points) {}\n\nFrankly do too much violence to the parameter list. Swift’s declarations have a lovely feature where the declaration basically looks like the usage, except that the concrete values in the usage are replaced by types in the declaration. These proposals destroy that property—when I look at the declaration, I can no longer envision what the call site will look like.\n\nBasically, I focused on default initializers because they’re *really* easy to solve and cover a good portion of the common case. I really have no idea how to solve the larger problem, and I haven’t liked any of the other ideas in this thread, but I do know how to solve this more limited problem.\n\n-- \nBrent Royal-Gordon\nArchitechies" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000445.html" , "inReplyTo" : "9DC6F2A2-53E0-4DBB-AF5F-D51314AA49F7@anandabits.com" , "date" : { "$date" : 1449354671000} , "subject" : "[swift-evolution] Proposal: helpers for initializing properties of same name as parameters" , "references" : [ "CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com" , "4F8C6141-CEFA-43DA-8FD9-5C787789ED68@architechies.com" , "9DC6F2A2-53E0-4DBB-AF5F-D51314AA49F7@anandabits.com"] , "descendants" : [ "DB740B9C-987F-42BF-96DF-95570F070A89@architechies.com" , "C3D71715-4957-441C-B277-E8CC3BBE4CA0@alkaline-solutions.com" , "3925DEF8-2B69-4AB5-AD95-49BD2FE6401B@alkaline-solutions.com" , "FC624F3D-20B7-4F42-A04F-97AFDB0287CB@alkaline-solutions.com" , "CA+ddMk042v6whHcVu8kLZyAk1JaEQ3LYxttAbZfGq6KBvrcGNw@mail.gmail.com" , "CADcs6kN6MT3cbEsPjtiXbR1U6-YzwD8v_Rbiv0PLHsm6xFiiZg@mail.gmail.com" , "6935BB3A-2203-406C-9EC2-02FF7287767F@anandabits.com" , "E3BD5430-C4DF-4284-99FA-14B61512E74A@apple.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/4EBF960E-9FC8-4947-A9D7-3B6EEA864614@gbis.com"}} , "_id" : "4EBF960E-9FC8-4947-A9D7-3B6EEA864614@gbis.com" , "from" : "jhull at gbis.com (Jonathan Hull)" , "mailingList" : "swift-evolution" , "content" : "Hmm… that is really interesting.  I wonder if we can use optionals to make this work in an elegant way.\n\nForget about else for a second.  What if there is an operation which says, this is either this value or nil based on whether it meets a condition?  Then else (and else if) can be handled by a combination of that operation and the nil-coelecing operator.\n\nI once wrote a small DSL which had this behavior and it was really nice.\n\nWhat about something like:\n\n\tlet x = value if? condition\n\nx would have value if condition evaluates to true, or it would be nil. If I wanted an else statement:\n\n\tlet x = value if? condition ?? otherValue\n\nNow it works just like the ternary operator, but is IMHO more readable.  Note: these can also be chained to give you else if style behavior:\n\n\tlet x = value if? condition ?? otherValue if? otherCondition ?? evenMoreValue\n\nYou could optionally (ha!) put things in parentheses as well, which I always end up doing with the ternary:\n\n\tlet x = (value if? condition) ?? (otherValue if? otherCondition) ?? evenMoreValue\n\n\nNot a 100% there yet, but I do think it is a good start at something more elegant…\n\nThanks,\nJon\n\n\n\n> On Dec 5, 2015, at 10:29 AM, possen p <possen at gmail.com> wrote:\n> \n> The current ternary operator, for this example: \n> \n> let val = p == 5 ? 10 : 40               \n> \n> Which I have always thought was hard to read but I do like the functionality it provides. That is, in one expression you can compactly get two different values based upon a condition. Swift seems to have adopted the C style ternary operators probably to not completly change everytihg. Similar to the drop of the ++ and -- operator I am proposing that there is to replace the ternary operator to improve readability but continue to provide that functionality.  \n> \n> Recommendation: most readable but changes rules about if-else always having braces and puts the “if” at end. It is only a little bit longer than the original. I think it is clearer to have the conditional at the end so the assignment part is where the variable is assigned. This also does not introduce new keywords or operators. \n> \n> let val = 10 else 40 if p == 5\n> \n> In looking at the Nil-Coalescing operator there is a similar idea but it is really not the same. In that the left hand side of the ?? operator returns itself when non nil, and the behavior of the ternary operator is different. It is also harder to read. \n> \n> let val = 10 ?? 40 if p = 5\n> \n> I also considered a bunch of other possibilities like using “where\" or “when\" instead of “if”, the python of putting conditional in the middle or the ruby style of “if\" returning a value but did not like those. \n> \n> // python style\n> let  val = 10 if p == 5 else 40 \n> \n> // ruby style\n> let val = if p == 5 then 10 else 40  \n> \n> \n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000446.html" , "inReplyTo" : "C1A6C9E6-16CD-42EC-8301-6B8DC6042A3A@gmail.com" , "date" : { "$date" : 1449356978000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "C1A6C9E6-16CD-42EC-8301-6B8DC6042A3A@gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net"}} , "_id" : "909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net" , "from" : "ole at oleb.net (Ole Begemann)" , "mailingList" : "swift-evolution" , "content" : ">> This is subtle and requires thought\n> \n> What do you envision as the pitfalls of the design thinking behind if/switch expressions? I’m not a compiler programmer, but a prog-lang enthusiast. I wouldn’t mind a little nudge in the right direction.\n\nOne thing that comes to mind is that if \"if\" is an expression, every if needs an else branch. This makes it harder to use if to conditionally perform side effects. For example, this is currently valid:\n\nfunc doSomething() { ... }\n\nif condition {\n    doSomething()\n}\n\nShould this be allowed? You could argue that this should work because (a) the expression result is unused and (b) the return type of doSomething is Void, so the compiler could conceivably implicitly construct an else branch that returns (). But it would be inconsistent with other expressions. Disallowing this style could make writing typical \"imperative\" code harder.\n\n– Ole" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000447.html" , "inReplyTo" : "BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com" , "date" : { "$date" : 1449357164000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com" , "CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com" , "C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com" , "18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com" , "2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io" , "BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com" , "CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com" , "CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com" , "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com" , "BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com"] , "descendants" : [ "D381E334-74B7-41EC-90BF-544A925D2204@icloud.com" , "D9043847-2CF1-40A8-9BDD-2C0DCCAB5A38@supmenow.com" , "EAEE8B4A-12A2-4FD6-BA7B-B26071F08489@gmail.com" , "CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com" , "4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com" , "CAAcV4sbQxUywKAHE=3SCACEFH4YvUqjwEr_0=fjf59ndZtoedg@mail.gmail.com" , "07270E34-E284-4FF0-B2EA-6DBB54FF78B5@portableinnovations.de" , "67057217-F4BC-4584-8B52-8EBA2CFA8CC7@portableinnovations.de" , "45B71AF5-DD4F-4E9C-A128-5B8041917564@me.com" , "CAKCGC8BmmCk55=6UC_qk_C+ZNq2JfGpOPO5cJ=SK2784kmvbGg@mail.gmail.com" , "B6DDD94B-0755-4D40-94F0-D2469A644818@portableinnovations.de" , "CAKCGC8AerqpPTrwdmPAvhmp-fLt-v=LXw4z0t+2o93g9GmAaxw@mail.gmail.com" , "54E5D8F5-616D-41EB-A550-E639FE861575@gmail.com" , "CAKCGC8CsJ7g_Fu8fnQ5Mv=yAzbSvb0Z+iNmdXKnJaAcWR2UKuw@mail.gmail.com" , "6830F74D-78FC-4B20-A6D5-683185B30164@gmail.com" , "691A92C4-1A5F-4CAE-AF50-F6AAA3A3F32C@portableinnovations.de" , "D35074A6-1C34-4BA3-AAF1-8CFE1992A522@me.com" , "1EE735A6-FF0F-4E49-BE7D-AC7E6C8A87EC@tarantsov.com" , "3D250DE5-09BC-4A6B-AF59-E1D714DF709A@tarantsov.com" , "BB6A4434-E2B1-4192-8450-90D636E6A7F5@fastmail.fm" , "0ED79E6D-A89A-4F3E-9269-6216BD10EB22@sealedabstract.com" , "CAAcV4sb9eMhuLGL3QsBw4bFxj1FQrokCAanKjEFRNNReE8zWOQ@mail.gmail.com" , "7253CF12-DBD4-483D-941F-04851E5AD394@tarantsov.com" , "CAAcV4sbo4=Hdzp+yx-km-CnhNDm2uQ-gDJsvdug_Pg-MjTPC=Q@mail.gmail.com" , "CAAcV4sbAk_eSdjz7bQ6ggdZNE+thmj7-wT_pG2+eRMKDVba+wA@mail.gmail.com" , "B619CC7E-59A8-4B3C-8E46-FC7FD4C4C6E6@apple.com" , "2372BF92-E97D-40C3-8FEC-0CA9B00ACACE@icloud.com" , "BB1D04A8-2E17-497F-AE74-8FDE4AEC4D77@fastmail.fm" , "2F722DE2-D3AE-44D5-83BB-CBCD371801AD@icloud.com" , "7B70F158-5B8A-425B-980C-CD08210342D4@me.com" , "FDB72AC4-0B0A-4D0F-A9D2-FFE43A55362E@gmail.com" , "9E0141FF-8B3B-4736-88EE-11F05930D149@fastmail.fm" , "CAAcV4sba2j1hOrBJO1kmLpLcjwSQoE0LUejbdNxa05zFzUmi3g@mail.gmail.com" , "DE316C42-6FA7-4A60-80C2-AFF74844EF09@fastmail.fm" , "33B028BA-EB5F-4986-9F16-3057390C3F16@gmail.com" , "BB8653D1-400D-49BC-AA77-6ECC096747B3@icloud.com" , "54B5FAEC-8636-44C5-96A2-0401999DD5D2@gmail.com" , "D679F068-B7C8-4DF2-A7E6-4D78B74F6B17@tarantsov.com" , "DDCE4FC9-2DED-45E5-8D9B-CAB2AA8CF9E6@gmail.com" , "C1C319DB-3934-40B6-ABEE-51B07463E6EF@upzzle.com" , "1C3ADBD7-D4CD-417A-AC45-029D7A889812@fastmail.fm" , "39024D06-E664-42EB-9E68-4D3E5BDC577D@anandabits.com" , "CAE+=ROVg0cJVKnSdwB=KPrEtr=GYd+PMMaOvbCj=N0RtUT=Q6A@mail.gmail.com" , "CAE+=ROVUD1ECe9yHG8kMW0skCFV0=BK70rw+5V7rNHEfmGhNjQ@mail.gmail.com" , "C04621E1-91D2-4A7D-9F9C-58F862B38355@icloud.com" , "581FE433-8169-4D61-9C3F-D90DAD600B9B@icloud.com" , "DB890044-1DAF-4832-8380-F78F61FBC96D@uzh.ch" , "CAE+=ROXg+tM0VYn1bscairmM9sQQ0nh1tYb4SexyWnM7TbeyaA@mail.gmail.com" , "CAE+=ROX9M8XSU8reKMf=RNCwu4Xu95V0G9W9T=Xr0nc8KerHjw@mail.gmail.com" , "CAAcV4sZKJg+x0v4rc1h=ydKE+EFEjanyBnqm8BWO=za-fF+jXA@mail.gmail.com" , "B017EE8F-7732-448E-80AB-7694904D28B4@icloud.com" , "D6AA07FC-261F-4D09-BC32-9FF7792659EC@eggerapps.at" , "CAE+=ROWf2XT2mxM5uWJCjz1Q3wZB71w=svWmGgX5v2=Y2rLzNw@mail.gmail.com" , "EB862217-2E54-4503-9C0C-DD943D428880@gmail.com" , "E0FCC493-27B9-499C-9884-4E00DB831131@gmail.com" , "934A39F6-ECB6-405B-8EF6-97E3C55604AD@uzh.ch" , "5824A613-F216-400B-AD16-9D368FA3A397@gmail.com" , "29A77367-05BF-4667-B25F-C06F520D0CB5@fastmail.fm" , "5525CD3F-062A-4ECB-809F-1964AE645CFC@gmail.com" , "CALkjWZsKQUQc0oDMkru8YGRv5rqOeqXF=4HnU2V0wo_5Q8SjnQ@mail.gmail.com" , "047B4955-1E5A-4A77-BAE3-63E8633A3AE1@gmail.com" , "CAE+=ROWxmKEic9DxN+CXyf=O7AtxgoHox5tSM1SCy_6E0ODphQ@mail.gmail.com" , "A7043ACA-9CE9-4739-919F-93F65FE7273B@gmail.com" , "6137630B-E3E8-45C6-AB48-FABFE9586EA9@me.com" , "CBB03FEA-50E2-4D7B-92B5-FB8A74B6719A@icloud.com" , "28E69DC8-4663-4FB6-8F99-F645E5D3F960@gmail.com" , "CAAcV4sZRQkVeBSqHv8UE_SJh-oEzZ74W6zd+sYxwEKhYZYsfxA@mail.gmail.com" , "CAAcV4sbakzYnefbui=hYKRDTMkrN_s1hFTn3CLwZUzWWa0M3LA@mail.gmail.com" , "63683E0A-B1FE-42A1-9878-FFEA34D1B993@gmail.com" , "CAAcV4sY8O=z5TL41vMoW3rKCHEWH3ikD8ZVJu-AEgVBYx-JXsA@mail.gmail.com" , "CAAcV4sbgPfRGZcU2U3fHcN2nky_ZqhCspWkz9DXYCjXyZFhvOQ@mail.gmail.com" , "A97ACA91-183C-41D9-ACEF-61B74D51E5BA@icloud.com" , "A9768B92-225F-49C8-B2D1-D572E1BD93DB@gmail.com" , "3BBED4DB-4944-4D4D-8603-A9E122B108B9@fastmail.fm" , "4C94F89B-CEDF-4480-8043-ED80AE0EB76A@eggerapps.at" , "B834ABFE-0DB7-426F-B932-74CD7884E46F@icloud.com" , "D58261F7-759A-4B10-84BE-A7882D50C7A5@owensd.io" , "0FEC8813-07C3-48E2-8D76-D0EF7709DA8E@tarantsov.com" , "6C13EC21-3BF0-4633-ABAB-C91322598ABC@apple.com" , "50765AC5-1CFE-406D-9CB5-B28ABBEB84ED@fastmail.fm" , "C64EC68B-1BBE-498A-937A-257E01314DEB@apple.com" , "CALkjWZu1S0ykcnenz_Z0AEuaiyeyTpxSYRMwknqeRxJAxnJT7w@mail.gmail.com" , "CAPrQK3CZy45bfx7qTgJoCH6pkocd_9sPTc0CNrAvsrRM6Vixkg@mail.gmail.com" , "CAB056B2-A975-45B3-93BD-14DE06903042@gmail.com" , "6FDA08B7-192F-42F2-BD2F-F7980463C833@novafore.com" , "40273CEA-F386-47C3-9314-C355B2E320CB@gmail.com" , "CANGnqV1WfTHxgfk4PNTQozU31EAa7z4MZF7d0gc058F4_=EtcQ@mail.gmail.com" , "C9FD779C-AF2C-466C-B741-34D40FB47413@icloud.com" , "48DEE2AB-7D93-47AC-9296-42AD9DD987E2@gmail.com" , "A4DFD8C0-135E-4B40-A264-B7FBCD07D322@fastmail.fm" , "CALkjWZvopih52vGsUfsqzrsEPP-G02eDg=8+EKLrpCMNciW+gA@mail.gmail.com" , "CALkjWZsMC7daCZHg_SDw=EiySCZtN7knDqVhXiF6+3dKTZZTGA@mail.gmail.com" , "CAEEOKET4Ud0bbSW_-Ss6V08tLy2YhF3n1TvQ06Xk5Jjak5-GHg@mail.gmail.com" , "CAAcV4sYaK4=N=ePDkHKbiodYp3HfiHW2yFxWs0A9Rt7LJ8DYvg@mail.gmail.com" , "CAAcV4sbOpH=sbPePnKhcHNXFy-YbPubUvF5PDaoLN_Rs8yL_rw@mail.gmail.com" , "C0B48136-1470-48EB-89D8-CD1B6F8553B1@apple.com" , "7227A933-1AFF-4470-90CB-2880776CEF03@fastmail.fm" , "3017B038-022E-4E46-8ABD-74873DC4C14C@icloud.com" , "CAAcV4sZ=8N3FDgo5aJT50dPwBh=SjM5NTSFgiT6OgSGcbsdcKg@mail.gmail.com" , "A2116BA7-633C-40BA-B7EF-B6A69582C2A3@icloud.com" , "9B4EA1B7-9D30-4B60-9AD0-34119EB9837D@apple.com" , "4BBB2771-4817-4BF3-919D-D7E14826C38D@apple.com" , "D17C306A-4934-4D72-B4FA-E7897B8E82B1@gmail.com" , "99FBC506-E086-4609-8585-42CA7E7E9852@apple.com" , "CAB5C60u6fSAaFgWDw2MY-PP1sJDEDqGRObqF+WwiHoXYvTwwZg@mail.gmail.com" , "3F9131C9-B757-4211-AED4-8E71E3CE9810@anandabits.com" , "EC7C2819-0125-437D-8940-1E3F610B500D@icloud.com" , "38E32460-C46B-428A-91A1-37A74D863127@gmail.com" , "CAAcV4sZZt8mwh9_rixfQ3dAdrPV77=uuqsAvdBM5f90K8sb6hw@mail.gmail.com" , "473B2AAA-7AE4-4B09-B013-6EE9CA6AB2AA@gmail.com" , "32A23B96-9CCC-4114-8939-07EE62E7B6AC@apple.com" , "A5DF87B9-47F1-4A2D-A51B-27CB3221912D@apple.com" , "028924F8-3DD9-40F9-A907-C4DB2344043B@gmail.com" , "CAB5C60tv0=-aBnPzwDCAp8oE8Km+tB6huYPxTrZNi=ObBKXAww@mail.gmail.com" , "CAB5C60sGJPaYPFtEoKB0DC-6A11LogCQAOCeZ-C6dvkmMd2oyg@mail.gmail.com" , "277EE0B5-01B3-48CE-992F-AE838034C0F1@apple.com" , "897A3F1D-1BCB-41B3-9096-0E46DEFA844A@apple.com" , "CAB5C60vD=QyN6LqyKU431jUSQQbuBEJcGiHkwq=+nRmTFhbU9A@mail.gmail.com" , "F4ED804A-2DC1-48DE-AD7C-DBE2A0BEF047@apple.com" , "81AA5235-A524-4F1A-AAA0-EB44BFFB0FEC@architechies.com" , "34A6EE6D-AECF-4887-BEB8-0D841C7CB1F2@icloud.com" , "CAAcV4sYZ6JoLy+=XKStCyh-XTJVmttrBZvqTuNq=Decsv2NEzg@mail.gmail.com" , "F5E748B4-BD58-408D-9330-DE255B9531E9@icloud.com" , "CACOvyQXZ1-qfbz7=0R1iXudZQdFMHPPQ2GVv_5DKwFEvZEF2pA@mail.gmail.com" , "27C9213F-B866-4A98-B0DC-E1492700B28B@apple.com" , "AE17F2D6-0107-4F61-AE13-01E5236ED770@apple.com" , "C320EC78-2D4E-46A8-90ED-4175F5B80072@gmail.com" , "CAB5C60szP8_2p8qqX13ph3wDQU6iRM0P09hVmXu7ar9SvRN+vw@mail.gmail.com" , "15A5CF07-DAED-4B92-A983-D88C2FA6BC8E@gmail.com" , "2822BF6F-172E-4003-B1A4-FB1C518CB701@googlemail.com" , "414E3C0D-EEC1-4005-8D68-5CA91EBADD0F@gmail.com" , "72FA697D-D1C9-4E73-B554-7313DC940D4B@apple.com" , "63C561FE-B75F-4A9B-8DF6-B2335D4C03CB@apple.com" , "CAEEOKEQyUwgvkEvPu2Xv_xAEJWiMTgGtv=KdY-2gkzhJXR7D4A@mail.gmail.com" , "A5DE0BD4-E526-4682-82B0-9B541CEF1C15@gmail.com" , "CAB5C60tn=nNstD2ke_RACYJsmAVvWQx-vJV=PfhqsOgaKx9pfw@mail.gmail.com" , "30B4EAF6-C852-4691-B397-24086AE1F9D9@icloud.com" , "1E2BDCE0-2132-40E8-96BC-BA51233281C7@novafore.com" , "C5F7CACF-736F-4794-B38E-0BE409F96835@novafore.com" , "FAEB0D09-1CB7-4706-B4CC-43DF40A2D243@apple.com" , "03C1FF36-43C3-46D1-88A1-3ECDCBB56567@gmail.com" , "CAB5C60sXr46WbfmaUctNKfWk01G_4pHgktykf4dJQZDbQ1QPWA@mail.gmail.com" , "4FB8F138-A0EF-4DDF-9AAD-A7172195F469@novafore.com" , "0C330020-F7D9-45D0-9B2D-E4DAD3AE105C@anandabits.com" , "CAB5C60vXzip01M6r62uQdkrXCxfBaQPgU7tdHsz+0Tu0i4Zksw@mail.gmail.com" , "BED20179-20C3-4F3A-B5D5-5E09286333F5@anandabits.com" , "E09BFA74-9DDF-4607-B52B-6C8EEC931D1F@gmail.com" , "1449374024.2155187.459254033.067DF6CC@webmail.messagingengine.com" , "CADcs6kN7gAr8x9ZbHBSX9gpOoJps=21wi-9ZC7hbtHUtRp54HA@mail.gmail.com" , "1449377752.2181216.459275089.1BA7CBAC@webmail.messagingengine.com" , "D9EA05A0-B3E8-4437-A0D1-F1FC27B0E124@gmail.com" , "D14076A5-FF22-4708-BFB2-516699EC4520@web.de" , "CAKCGC8CWGc1L0fsc7TtzDeCqu5bxPX3q3MMZCw+2HPGuPHHC1A@mail.gmail.com" , "7D68F57E-C847-4E0D-AF3A-FD1F2DC928A9@icloud.com" , "1449429569.1342623.459603529.32C935BC@webmail.messagingengine.com" , "11462DA4-ACDD-4CF3-BD57-47886B655970@anandabits.com" , "CAKCGC8AVDe6W9X=XvFEnbkae8xom2Us8xczKFShqKu2+kPnRJA@mail.gmail.com" , "0DF0732F-0958-47C1-A6C3-62A8AB2F4386@icloud.com" , "CAKCGC8BEzyEPAFWCPKPiH+UL3KmZm7aM6KUPu-F9DKV-YvUbCA@mail.gmail.com" , "4A5C6452-0A1B-42A3-AFD4-3DEA04E310C6@icloud.com" , "6DA2FDFF-F978-4ECA-9E2B-F757F6D8BBF3@icloud.com" , "2116BFD1-25BC-4B9F-A3A6-08758782BB88@anandabits.com" , "C919D677-30C0-4F1E-B221-9B28365D67A9@gmail.com" , "CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com" , "49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net" , "49EEA2E6-55F2-49DE-A59F-A13017626370@web.de" , "0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAM4NbbywZMv2OkxJQvTKheUHV4LipUHUh-V4FSd58raNSsoqqw@mail.gmail.com"}} , "_id" : "CAM4NbbywZMv2OkxJQvTKheUHV4LipUHUh-V4FSd58raNSsoqqw@mail.gmail.com" , "from" : "tomas at linhart.me (=?UTF-8?B?VG9tw6HFoSBMaW5oYXJ0?=)" , "mailingList" : "swift-evolution" , "content" : "Hello,\n\nvery often, it is necessary to define stored properties in extensions. It\nis currently only possible in Swift that has access to ObjC runtime with\nassociated objects (in theory it might be possible with some global\ndictionary) and it requires a lot of boilerplate. Associated objects are\nused in UIKit quite heavily so it is something that authors of frameworks\nneed.\n\nIt would be nice to able to create properties in extensions natively in\nSwift without need of Objective-C and without a boilerplate. These\nproperties could be marked with some extra keyword/attribute so it is\nobvious they are different and they have a cost (depends on their\nimplementation).\n\nWhat do you think?\n\nTomáš" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000635.html" , "date" : { "$date" : 1449357592000} , "subject" : "[swift-evolution] Proposal: Stored properties in extensions" , "references" : [ ""] , "inReplyTo" :  null } , { "_links" : { "self" : { "href" : "/charter/emails/CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com"}} , "_id" : "CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com" , "from" : "scanon at apple.com (Steve Canon)" , "mailingList" : "swift-evolution" , "content" : "Very much thinking out loud and not really the implications, I wonder if we might just use \"continue\" instead of \"reswitch\".\n\nI very much like specifying what case to fall through into, no matter how we spell it.\n\n- Steve\n\n> On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution <swift-evolution at swift.org> wrote:\n> \n>>> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution <swift-evolution at swift.org> wrote:\n>>> On Dec 4, 2015, at 11:37 PM, John Calsbeek <john.calsbeek+lists at gmail.com> wrote:\n>>> `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.\n>>> \n>>> It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.\n>> \n>> Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.\n>> \n>> On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.\n> \n> Oh, I see that Joe already brought this up, spelled “reswitch”.\n> \n> John.\n> \n>> \n>> John.\n>> \n>>> \n>>> One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).\n>>> \n>>> switch op {\n>>> case LOAD_INDIRECT:\n>>>    in0 = memory[in1]\n>>>    fallthrough\n>>> case LOAD:\n>>>    out0 = memory[in0]\n>>> //...\n>>> }\n>>> \n>>> I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.\n>>> \n>>> Cheers,\n>>> John\n>>> \n>>>>> On Dec 4, 2015, at 2:42 PM, John McCall <rjmccall at apple.com> wrote:\n>>>>> \n>>>>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard <kevin at sb.org> wrote:\n>>>>> It's not actually Duff's Device. Duff's Device relies on the fact that C switch statements don't actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it's a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.\n>>>> \n>>>> To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.\n>>>> \n>>>> But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.\n>>>> \n>>>> John.\n>>>> \n>>>>>  \n>>>>> Steve's code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It's a good example of one of the uses of `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's Device in Swift.\n>>>>>  \n>>>>> -Kevin Ballard\n>>>>>  \n>>>>>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:\n>>>>>> Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.\n>>>>>>  \n>>>>>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun <erica at ericasadun.com> wrote:\n>>>>>>>  \n>>>>>>> Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it. \n>>>>>>>  \n>>>>>>> True fact: On all of gist.github.com, there are only 22 gist results for \"fallthrough language:swift\".\n>>>>>>> Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:\n>>>>>>> case .Enum1, .Enum2:\n>>>>>>> expressed as \n>>>>>>> case .Enum1: fallthrough\n>>>>>>> case .Enum2:\n>>>>>>>  \n>>>>>>> And then there's streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea   I'm pretty sure that ponies were harmed in the production of whatever that last bit is.\n>>>>>>>  \n>>>>>>>  \n>>>>>>>  \n>>>>>>>  \n>>>>>>>> On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com wrote:\n>>>>>>>>  \n>>>>>>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the \"fallthrough\" keyword from the language?\n>>>>>>>>  \n>>>>>>>> My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.\n>>>>>>>>  \n>>>>>>>> The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:\n>>>>>>>>  \n>>>>>>>> \"The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.\"\n>>>>>>>>  \n>>>>>>>> To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.\n>>>>>>>>  \n>>>>>>>> I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.\n>>>>>>>>  \n>>>>>>>> In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.\n>>>>>>>>  \n>>>>>>>> Thoughts?\n>>>>>>>>  \n>>>>>>>> Daniel\n>>>>>>>>  \n>>>>>>>> _______________________________________________\n>>>>>>>> swift-evolution mailing list\n>>>>>>>> swift-evolution at swift.org\n>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>>>>> \n>>>>>>>  \n>>>>>>> \n>>>>>>> _______________________________________________\n>>>>>>> swift-evolution mailing list\n>>>>>>> swift-evolution at swift.org\n>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>>>> \n>>>>>>  \n>>>>>> \n>>>>>> _______________________________________________\n>>>>>> swift-evolution mailing list\n>>>>>> swift-evolution at swift.org\n>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>>>  \n>>>>> \n>>>>> _______________________________________________\n>>>>> swift-evolution mailing list\n>>>>> swift-evolution at swift.org\n>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>> \n>>>>  _______________________________________________\n>>>> swift-evolution mailing list\n>>>> swift-evolution at swift.org\n>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>> \n>>> \n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>> \n>> \n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> \n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000448.html" , "inReplyTo" : "EF1675F6-7918-4262-B535-696104BFC405@apple.com" , "date" : { "$date" : 1449357808000} , "subject" : "[swift-evolution] Proposal: Remove the \"fallthrough\" keyword" , "references" : [ "3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com" , "AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com" , "8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com" , "1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com" , "02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com" , "E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com" , "444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com" , "EF1675F6-7918-4262-B535-696104BFC405@apple.com"] , "descendants" : [ "6CACDDEC-7FB7-433D-AFA1-15DD4208BE16@jacopo.giola.org" , "0FCA62AB-3FBE-472E-AD11-95E18DC650A9@apple.com" , "ECE284CE-EDE3-4071-ABB6-821820F1FC44@jacopo.giola.org" , "EF9FEF97-C7B8-4D54-B406-2B62FDD15B59@springsandstruts.com" , "98973CF0-B5A8-491F-A8D0-DA73456FF01B@jacopo.giola.org" , "CAKCGC8B0UPGUHeJ_1n8XsGoo+E6Anyj_+_R7WsT76rV1Q-qu2w@mail.gmail.com" , "E7877054-1CF7-4596-800A-0D3C578A0CF1@portableinnovations.de" , "CAKCGC8Cp52O7DX6wWSc3J6FR8Xmoo_WLBgjGBa6fSXzNHhdHEg@mail.gmail.com" , "D7B06EA6-A46C-4920-9E09-CB99B96242AA@jacopo.giola.org" , "1449442122.2380087.459714713.0AC4A201@webmail.messagingengine.com" , "D9340CB2-A696-478A-BAE7-F93ED39CB2DC@red-sweater.com" , "CEA837D7-E2B1-48DC-A53B-D216F96DD8DF@apple.com" , "2423784D-3B84-41CE-9BE2-0850BFE5A3C0@apple.com" , "2A8EA416-B4FF-45B3-9C6D-F94059151129@apple.com" , "82BBEAF7-A512-460A-998C-054AE6D70BEB@springsandstruts.com" , "9C8A3DCA-B80C-4D1F-9528-DD65C0020680@apple.com" , "CAKCGC8BL6SHkO0T_Rg6Ren-NfCLs+eGBb6Zm9aFuZ5rMkWJXtQ@mail.gmail.com" , "AC2407AD-ABFF-4657-A04C-F37E52466316@springsandstruts.com" , "1449524366.1229815.460824345.0E2309C2@webmail.messagingengine.com" , "1449524552.1230499.460828169.5289846B@webmail.messagingengine.com" , "6BABB1A5-55CD-43AF-8D5D-9758F55AD611@apple.com" , "266A61BA-1890-46D7-8969-4A0225EA60B4@springsandstruts.com" , "37FA3360-5F23-462D-BE9B-3743253D2693@apple.com" , "D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org" , "071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com" , "CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org" , "C19956A6-C9B2-45CC-8C91-DA2215EBEA5C@alkaline-solutions.com" , "6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com" , "6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org" , "A56C416E-E246-44FC-A681-3DD66171DF30@springsandstruts.com" , "CADQN+5atyJ78vi0xssjOxh2ka_-jZTaO3ZabxFdY80YqJHFmxg@mail.gmail.com" , "CAKCGC8DHCxwtiU82CjxChc6PaiB495WOCJBP0iq04uw7iWcQmA@mail.gmail.com" , "DEBE0A49-3E5A-431F-8559-63EBA7214068@jacopo.giola.org" , "CAKCGC8DbhMOX6bHtzXQcAhjHQSw1wSSoX-TBUtew0arWA=4pSw@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/852EF944-A503-4021-8A7F-AE6876438981@gbis.com"}} , "_id" : "852EF944-A503-4021-8A7F-AE6876438981@gbis.com" , "from" : "jhull at gbis.com (Jonathan Hull)" , "mailingList" : "swift-evolution" , "content" : "I think I have a solution for the ternary part, but I am not sure I fully understand what is being asked for in the case of switch.  Could someone clarify?\n\nThere is another thread which goes into the idea a little more, but the basic idea is that we replace the ternary operator with ‘if?'\n\nlet x = value if? condition\n\n\nIf condition is true, then x is value… otherwise it is nil.  You can combine with the nil-coalescing operator to get else and else if style behavior:\n\nlet x = valueA if? conditionA ?? valueB if? conditionB ?? valueC\n\n\nThanks,\nJon\n\n\n> On Dec 5, 2015, at 9:09 AM, Chris Lattner <clattner at apple.com> wrote:\n> \n> \n>> On Dec 4, 2015, at 11:43 AM, J. Cheyo Jimenez <cheyo at masters3d.com <mailto:cheyo at masters3d.com>> wrote:\n>> \n>> I'd like some feedback from the core team to see if eliminating the ternary operator and replacing it with if-else is even proposal worthy. \n>> \n>> Some interesting code in the standard library that uses the ternary operator quite a bit. \n>> \n>> https://gist.github.com/masters3d/7b0c6f3653368afe4357 <https://gist.github.com/masters3d/7b0c6f3653368afe4357>\n> \n> FWIW, I have no love for the ternary operator (it is totally \"bizarre C magic”), but it does solve a problem that Swift currently otherwise has no solution for.\n> \n> If you’re interested in pursuing this, then the right path forward is to build a holistic proposal to turn statements (like if and switch) into expressions.  This is subtle and requires thought, but is widely desired and if someone were interested in driving the design and implementation, then I’d be interested to see it happen.\n> \n> -Chris\n> \n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000449.html" , "inReplyTo" : "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com" , "date" : { "$date" : 1449358101000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com" , "CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com" , "C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com" , "18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com" , "2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io" , "BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com" , "CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com" , "CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com" , "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com"] , "descendants" : [ "1FDCAD5A-9937-4464-BD6A-ABECAE2BB853@web.de" , "CAKCGC8ACsCsX1VvEpStXFOD10gw308+RqVe01VxkUh0q5j_9tA@mail.gmail.com" , "C3E05739-7629-4A8D-9C51-DBE6F87833EA@gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAEryqghYNO4JKWRGkF_qFTew7cGPtG7iNP32DndN1dOHLkjATQ@mail.gmail.com"}} , "_id" : "CAEryqghYNO4JKWRGkF_qFTew7cGPtG7iNP32DndN1dOHLkjATQ@mail.gmail.com" , "from" : "christopheramanse at gmail.com (Chris Amanse)" , "mailingList" : "swift-evolution" , "content" : "Hello Swift Developers,\n\nI think it's a good idea to conform NSDate to the Comparable protocol, so\ninstead of using:\n\nif someDate.compare(today) == .OrderedAscending { }\n\nDevelopers can easily compare using compare dates using comparison\noperators:\n\nif someDate < today { }\n\nIn my opinion, the code is still readable if developers use comparison\noperators on NSDates.\n\nHere's a quick implementation from my swift-corelibs-foundation fork:\nhttps://github.com/chrisamanse/swift-corelibs-foundation/commit/3c4eff643c5271de5bec2461798051347be13916\n\nThank you." , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000450.html" , "date" : { "$date" : 1449358612000} , "subject" : "[swift-evolution] Proposal: Conforming NSDate to Comparable" , "references" : [ ""] , "inReplyTo" :  null  , "descendants" : [ "1449373366.2149969.459249705.7F8B4291@webmail.messagingengine.com" , "0C687B3C-4916-458B-86F0-16B3A9261941@apple.com" , "4CF9AAE7-812C-4F95-A8D8-62B74701957D@alkaline-solutions.com" , "74FC29AE-AF91-4360-BDA1-EF54AA6A74F8@architechies.com" , "CE57813E-C13D-47C6-9CEA-32B26789A0BE@apple.com" , "90204A78-4C14-4A1E-9F99-4FFF1FDDFCC2@gmail.com" , "CAEryqghXu8EGTjWcsPjk5tUbYDfC0E1xTD_rBT=hY7uR1aO7pg@mail.gmail.com" , "97EB190C-895B-4698-A93E-C1050B92520B@architechies.com" , "CAEryqgjxxcHrPeP7rHYV--77upw_KzoiJSKQVR3K8GYeSo1FPA@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/26C0DF64-7EE4-4F56-BC99-2C8EAF9D8781@me.com"}} , "_id" : "26C0DF64-7EE4-4F56-BC99-2C8EAF9D8781@me.com" , "from" : "adrian.kashivskyy at me.com (Adrian Kashivskyy)" , "mailingList" : "swift-evolution" , "content" : "How would you do code review then? ;)\n\nRegards,\nAdrian Kashivskyy\niOS Developer at Netguru\n\n> Wiadomość napisana przez Brent Royal-Gordon <brent at architechies.com> w dniu 05.12.2015, o godz. 22:10:\n> \n>>>> SwiftLint looks really nice, but one thing I'd really like is automatic formatting.\n>>> \n>>> That's a feature of IDE, not the language itself.\n>> \n>> Not necessarily. The existence of \"go fmt\" has resulted in teams running it as a pre-commit translation and as a way of standardising across all users, regardless of IDEs. Otherwise you end up with multiple IDEs (like Eclipse and IntelliJ) which do formatting slightly differently and lead to all manner of pointless arguments. \n>> \n>> Letting \"the IDE\" do formatting is fine provided there is a maximum of one IDE. \n> \n> This is perhaps out of scope for this group, but I’ve actually long wanted languages to move in a direction where indentation is not present at all in the source file—your git repo might never have an instance of /\\n[ \\t]/ in it. Instead, it’s automatically added by the IDE while displaying the code, based on the block beginnings and endings present in the actual source. This would make incorrectly indented code a thing of the past; it would also be obvious when you’re missing a curly bracket, because your code would be indented all wrong. And it would end the destructive whitespace wars, because everyone could just set their IDE to do whatever they liked best.\n> \n> -- \n> Brent Royal-Gordon\n> Architechies\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000451.html" , "inReplyTo" : "63A9B880-DBDC-4566-80F4-A02CCBFD0EFD@architechies.com" , "date" : { "$date" : 1449358956000} , "subject" : "[swift-evolution] \"bad smells\" should be compiler errors with suggestions on how to fix them" , "references" : [ "557CCA5F-E52F-439C-B224-AC4990140373@gmail.com" , "1449324589110.9d79fd62@Nodemailer" , "CF5C0804-061E-487B-9030-005E76177BD1@harlanhaskins.com" , "E4BE1F82-1BCB-4E27-B2E5-CDBE673EF7B8@me.com" , "49EF0786-90E4-4748-B532-E4C68D33458D@gmail.com" , "63A9B880-DBDC-4566-80F4-A02CCBFD0EFD@architechies.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/7240610C-B5DA-41B8-909A-D138404C6799@me.com"}} , "_id" : "7240610C-B5DA-41B8-909A-D138404C6799@me.com" , "from" : "adrian.kashivskyy at me.com (Adrian Kashivskyy)" , "mailingList" : "swift-evolution" , "content" : "I can't believe I'm seeing a proposal to remove type safety, one of the fundamental features of Swift...\n\nRegards,\nAdrian Kashivskyy\niOS Developer at Netguru\n\n> Wiadomość napisana przez Amir Michail via swift-evolution <swift-evolution at swift.org> w dniu 05.12.2015, o godz. 20:51:\n> \n> Python is still easier than Swift for beginning programmers. But maybe such a mode can allow Swift to be used by beginners also? _____________________________________________ swift-evolution mailing list swift-evolution at swift.org https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000452.html" , "inReplyTo" : "5E968E10-2DBD-4999-978C-B398BC446A21@me.com" , "date" : { "$date" : 1449359422000} , "subject" : "[swift-evolution] A mode with no type checking to compete with Python." , "references" : [ "5E968E10-2DBD-4999-978C-B398BC446A21@me.com"] , "descendants" : [ "CAL-BAQv_62_FfxbD2f3jmvz=fMVFKT7z1_T-Epe=TGgyyNhOew@mail.gmail.com" , "F0885284-6615-4EEC-89BF-38B8A10EF3AA@me.com" , "0CFEA686-79B9-4B51-A984-7C706879BB5D@klundberg.com" , "8E150B28-BDE3-4289-8515-3110150B269C@me.com" , "F648DD81-C548-4B5A-BF45-890CA34B71FE@architechies.com" , "7F08A62B-6FD7-4AF2-A939-EF1D3CD71BD7@me.com" , "E2C52ABB-8CD4-4D5C-BFA3-F3EA995AC6FC@gmail.com" , "B3DEBE77-A879-4A1E-BC4D-1F028E6D326A@gmail.com" , "etPan.56637dbe.227d026a.10e90@Manav-Gabhawalas-MacBook-Pro.local" , "11A9AA09-5F9E-4AF7-8CE1-82BAB42E896A@jonshier.com" , "9354DB3D-8EFE-4AA9-B372-1FBB575381D7@web.de" , "CAKCGC8Dcw0w-vzR=vmHN2ik9GTjiaZmRiGqdnF8Kq7xhX7+m7A@mail.gmail.com" , "75B91A7D-2A61-471C-BA61-D3F92EEACC89@pobox.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/97EB190C-895B-4698-A93E-C1050B92520B@architechies.com"}} , "_id" : "97EB190C-895B-4698-A93E-C1050B92520B@architechies.com" , "from" : "brent at architechies.com (Brent Royal-Gordon)" , "mailingList" : "swift-evolution" , "content" : "> I think it's a good idea to conform NSDate to the Comparable protocol, so instead of using:\n> \n> if someDate.compare(today) == .OrderedAscending { }\n> \n> Developers can easily compare using compare dates using comparison operators:\n> \n> if someDate < today { }\n\nI would also suggest we add Strideable, which would allow you to add and subtract NSTimeIntervals, plus subtract two NSDates to get the NSTimeInterval between them.\n\nhttps://gist.github.com/brentdax/11b3275424d0833cfd99\n\n-- \nBrent Royal-Gordon\nArchitechies" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000453.html" , "inReplyTo" : "CAEryqghYNO4JKWRGkF_qFTew7cGPtG7iNP32DndN1dOHLkjATQ@mail.gmail.com" , "date" : { "$date" : 1449359508000} , "subject" : "[swift-evolution] Proposal: Conforming NSDate to Comparable" , "references" : [ "CAEryqghYNO4JKWRGkF_qFTew7cGPtG7iNP32DndN1dOHLkjATQ@mail.gmail.com"] , "descendants" : [ "1449373366.2149969.459249705.7F8B4291@webmail.messagingengine.com" , "0C687B3C-4916-458B-86F0-16B3A9261941@apple.com" , "4CF9AAE7-812C-4F95-A8D8-62B74701957D@alkaline-solutions.com" , "74FC29AE-AF91-4360-BDA1-EF54AA6A74F8@architechies.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/F0885284-6615-4EEC-89BF-38B8A10EF3AA@me.com"}} , "_id" : "F0885284-6615-4EEC-89BF-38B8A10EF3AA@me.com" , "from" : "a.michail at me.com (Amir Michail)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 5, 2015, at 6:50 PM, Adrian Kashivskyy <adrian.kashivskyy at me.com> wrote:\n> \n> I can't believe I'm seeing a proposal to remove type safety, one of the fundamental features of Swift...\n> \n\nDoesn’t Apple want to teach young people programming as one of its goals? If so, having a mode without type safety would be ideal for that.\n\n> Regards,\n> Adrian Kashivskyy\n> iOS Developer at Netguru\n> \n>> Wiadomość napisana przez Amir Michail via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> w dniu 05.12.2015, o godz. 20:51:\n>> \n>> Python is still easier than Swift for beginning programmers. But maybe such a mode can allow Swift to be used by beginners also? _____________________________________________ swift-evolution mailing list swift-evolution at swift.org <mailto:swift-evolution at swift.org> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000454.html" , "inReplyTo" : "7240610C-B5DA-41B8-909A-D138404C6799@me.com" , "date" : { "$date" : 1449359730000} , "subject" : "[swift-evolution] A mode with no type checking to compete with Python." , "references" : [ "5E968E10-2DBD-4999-978C-B398BC446A21@me.com" , "7240610C-B5DA-41B8-909A-D138404C6799@me.com"] , "descendants" : [ "CAL-BAQv_62_FfxbD2f3jmvz=fMVFKT7z1_T-Epe=TGgyyNhOew@mail.gmail.com" , "F648DD81-C548-4B5A-BF45-890CA34B71FE@architechies.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/A289D8DB-F4F0-43B6-9F05-C57B04478A4A@apple.com"}} , "_id" : "A289D8DB-F4F0-43B6-9F05-C57B04478A4A@apple.com" , "from" : "ndevries at apple.com (Nathan de Vries)" , "mailingList" : "swift-evolution" , "content" : "It's currently possible to define either or both of the following observers on a property:\nwillSet, called just before the value is stored\ndidSet, called immediately after the new value is stored\nI'm finding myself using didSet extensively, but almost always guard my didSet with a clause to see if the value has changed:\n\n    class CustomView : UIView {\n        var state : CustomViewState = false {\n            didSet {\n                guard state != oldValue else { return }\n                // Act on the new state.\n            }\n        }\n    }\n\nGiven the frequency of use, it would be great if I could strip this boilerplate altogether and simply rewrite this as:\n\n    class CustomView : UIView {\n        var state : CustomViewState = false {\n            didChange {\n                // Act on the new state.\n            }\n        }\n    }\n\nProperty types conforming to Equatable would be checked for the implicit guard via ==, otherwise it would fall back on the identity operator (===) for value and reference types that don't conform to Equatable.\n\nThis would mean the following observers could be defined on a property:\nwillSet, called just before the value is stored\nwillChange, called just before the value is stored if the value is different to the previous value\ndidSet, called immediately after the new value is stored\ndidChange, called immediately after the new value is stored if the new value is different to the previous value\n—Nathan" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000455.html" , "date" : { "$date" : 1449360038000} , "subject" : "[swift-evolution] Proposal: Allow willChange and didChange observers on a property" , "references" : [ ""] , "inReplyTo" :  null  , "descendants" : [ "9AC32EEA-ED5F-421E-9B75-E2BB0516667C@apple.com" , "6B38C1F5-9623-4706-BC2A-F9A5F9665AB6@apple.com" , "D52D800E-1C86-4B3C-94BC-55D28396EC5A@apple.com" , "3534A06A-23BD-4040-942C-216F12A9D5D3@icloud.com" , "CAA60hjLpFH3u_eQVQvOjZ+gvOa++VdALYUbSGiNCwKQcyO+QFA@mail.gmail.com" , "9D162271-E4B5-45D9-AEC5-60405A70C1EF@apple.com" , "014D53AE-029B-40BE-8C7B-A7ED7FBDA81C@hartbit.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/0CFEA686-79B9-4B51-A984-7C706879BB5D@klundberg.com"}} , "_id" : "0CFEA686-79B9-4B51-A984-7C706879BB5D@klundberg.com" , "from" : "kevin at klundberg.com (Kevin Lundberg)" , "mailingList" : "swift-evolution" , "content" : "This is somewhat possible today on Apple platforms with AnyObject. You can call any objc-visible method on AnyObject and it will compile, and the return type will also be AnyObject (I don't recall if the return type is optional as well or not). This doesn't work with value types, but neither does id in objc.\n\nHaving a more complete lax typed mode similar to Python or php I think is of limited usefulness, would add too much complexity to the language, and yield too much uncertainty about any given piece of swift code. \n\n--\nKevin Lundberg\n\n> On Dec 5, 2015, at 6:50 PM, Adrian Kashivskyy via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> I can't believe I'm seeing a proposal to remove type safety, one of the fundamental features of Swift...\n> \n> Regards,\n> Adrian Kashivskyy\n> iOS Developer at Netguru\n> \n>> Wiadomość napisana przez Amir Michail via swift-evolution <swift-evolution at swift.org> w dniu 05.12.2015, o godz. 20:51:\n>> \n>> Python is still easier than Swift for beginning programmers. But maybe such a mode can allow Swift to be used by beginners also? _____________________________________________ swift-evolution mailing list swift-evolution at swift.org https://lists.swift.org/mailman/listinfo/swift-evolution\n>> \n>> \n> \n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000456.html" , "inReplyTo" : "7240610C-B5DA-41B8-909A-D138404C6799@me.com" , "date" : { "$date" : 1449360119000} , "subject" : "[swift-evolution] A mode with no type checking to compete with Python." , "references" : [ "5E968E10-2DBD-4999-978C-B398BC446A21@me.com" , "7240610C-B5DA-41B8-909A-D138404C6799@me.com"] , "descendants" : [ "8E150B28-BDE3-4289-8515-3110150B269C@me.com" , "7F08A62B-6FD7-4AF2-A939-EF1D3CD71BD7@me.com" , "E2C52ABB-8CD4-4D5C-BFA3-F3EA995AC6FC@gmail.com" , "B3DEBE77-A879-4A1E-BC4D-1F028E6D326A@gmail.com" , "etPan.56637dbe.227d026a.10e90@Manav-Gabhawalas-MacBook-Pro.local" , "11A9AA09-5F9E-4AF7-8CE1-82BAB42E896A@jonshier.com" , "9354DB3D-8EFE-4AA9-B372-1FBB575381D7@web.de" , "CAKCGC8Dcw0w-vzR=vmHN2ik9GTjiaZmRiGqdnF8Kq7xhX7+m7A@mail.gmail.com" , "75B91A7D-2A61-471C-BA61-D3F92EEACC89@pobox.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/8E150B28-BDE3-4289-8515-3110150B269C@me.com"}} , "_id" : "8E150B28-BDE3-4289-8515-3110150B269C@me.com" , "from" : "a.michail at me.com (Amir Michail)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 5, 2015, at 7:01 PM, Kevin Lundberg <kevin at klundberg.com> wrote:\n> \n> This is somewhat possible today on Apple platforms with AnyObject. You can call any objc-visible method on AnyObject and it will compile, and the return type will also be AnyObject (I don't recall if the return type is optional as well or not). This doesn't work with value types, but neither does id in objc.\n> \n> Having a more complete lax typed mode similar to Python or php I think is of limited usefulness, would add too much complexity to the language, and yield too much uncertainty about any given piece of swift code. \n> \n\nApple need not accept apps written in this mode for the App Store. But it would be great for educational purposes.\n\n> --\n> Kevin Lundberg\n> \n> On Dec 5, 2015, at 6:50 PM, Adrian Kashivskyy via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n> \n>> I can't believe I'm seeing a proposal to remove type safety, one of the fundamental features of Swift...\n>> \n>> Regards,\n>> Adrian Kashivskyy\n>> iOS Developer at Netguru\n>> \n>>> Wiadomość napisana przez Amir Michail via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> w dniu 05.12.2015, o godz. 20:51:\n>>> \n>>> Python is still easier than Swift for beginning programmers. But maybe such a mode can allow Swift to be used by beginners also? _____________________________________________ swift-evolution mailing list swift-evolution at swift.org <mailto:swift-evolution at swift.org> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>> \n>> \n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000457.html" , "inReplyTo" : "0CFEA686-79B9-4B51-A984-7C706879BB5D@klundberg.com" , "date" : { "$date" : 1449360314000} , "subject" : "[swift-evolution] A mode with no type checking to compete with Python." , "references" : [ "5E968E10-2DBD-4999-978C-B398BC446A21@me.com" , "7240610C-B5DA-41B8-909A-D138404C6799@me.com" , "0CFEA686-79B9-4B51-A984-7C706879BB5D@klundberg.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/F648DD81-C548-4B5A-BF45-890CA34B71FE@architechies.com"}} , "_id" : "F648DD81-C548-4B5A-BF45-890CA34B71FE@architechies.com" , "from" : "brent at architechies.com (Brent Royal-Gordon)" , "mailingList" : "swift-evolution" , "content" : "> Doesn’t Apple want to teach young people programming as one of its goals? If so, having a mode without type safety would be ideal for that.\n\nFrankly, I can’t even imagine what Swift would look or act like without its type system. Would overloading work? What would happen if you added a String and an Int? What if you called a method that didn’t exist? Is it really better for learning to half-run the code and then crash instead of pointing out the mistake up front? Couldn’t you simulate half-running anyway by replacing syntax errors with `fatalError(“compiler error goes here”)` and running the code?\n\n-- \nBrent Royal-Gordon\nArchitechies" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000458.html" , "inReplyTo" : "F0885284-6615-4EEC-89BF-38B8A10EF3AA@me.com" , "date" : { "$date" : 1449360323000} , "subject" : "[swift-evolution] A mode with no type checking to compete with Python." , "references" : [ "5E968E10-2DBD-4999-978C-B398BC446A21@me.com" , "7240610C-B5DA-41B8-909A-D138404C6799@me.com" , "F0885284-6615-4EEC-89BF-38B8A10EF3AA@me.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/E2C52ABB-8CD4-4D5C-BFA3-F3EA995AC6FC@gmail.com"}} , "_id" : "E2C52ABB-8CD4-4D5C-BFA3-F3EA995AC6FC@gmail.com" , "from" : "austinzheng at gmail.com (Austin Zheng)" , "mailingList" : "swift-evolution" , "content" : "I disagree with the idea that a type system is too much of a hurdle for beginner programmers to overcome.\n\nAustin\n\n> On Dec 5, 2015, at 4:01 PM, Kevin Lundberg via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> This is somewhat possible today on Apple platforms with AnyObject. You can call any objc-visible method on AnyObject and it will compile, and the return type will also be AnyObject (I don't recall if the return type is optional as well or not). This doesn't work with value types, but neither does id in objc.\n> \n> Having a more complete lax typed mode similar to Python or php I think is of limited usefulness, would add too much complexity to the language, and yield too much uncertainty about any given piece of swift code. \n> \n> --\n> Kevin Lundberg\n> \n> On Dec 5, 2015, at 6:50 PM, Adrian Kashivskyy via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n> \n>> I can't believe I'm seeing a proposal to remove type safety, one of the fundamental features of Swift...\n>> \n>> Regards,\n>> Adrian Kashivskyy\n>> iOS Developer at Netguru\n>> \n>>> Wiadomość napisana przez Amir Michail via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> w dniu 05.12.2015, o godz. 20:51:\n>>> \n>>> Python is still easier than Swift for beginning programmers. But maybe such a mode can allow Swift to be used by beginners also? _____________________________________________ swift-evolution mailing list swift-evolution at swift.org <mailto:swift-evolution at swift.org> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>> \n>> \n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000459.html" , "inReplyTo" : "0CFEA686-79B9-4B51-A984-7C706879BB5D@klundberg.com" , "date" : { "$date" : 1449360331000} , "subject" : "[swift-evolution] A mode with no type checking to compete with Python." , "references" : [ "5E968E10-2DBD-4999-978C-B398BC446A21@me.com" , "7240610C-B5DA-41B8-909A-D138404C6799@me.com" , "0CFEA686-79B9-4B51-A984-7C706879BB5D@klundberg.com"] , "descendants" : [ "7F08A62B-6FD7-4AF2-A939-EF1D3CD71BD7@me.com" , "B3DEBE77-A879-4A1E-BC4D-1F028E6D326A@gmail.com" , "etPan.56637dbe.227d026a.10e90@Manav-Gabhawalas-MacBook-Pro.local" , "11A9AA09-5F9E-4AF7-8CE1-82BAB42E896A@jonshier.com" , "9354DB3D-8EFE-4AA9-B372-1FBB575381D7@web.de" , "CAKCGC8Dcw0w-vzR=vmHN2ik9GTjiaZmRiGqdnF8Kq7xhX7+m7A@mail.gmail.com" , "75B91A7D-2A61-471C-BA61-D3F92EEACC89@pobox.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/7F08A62B-6FD7-4AF2-A939-EF1D3CD71BD7@me.com"}} , "_id" : "7F08A62B-6FD7-4AF2-A939-EF1D3CD71BD7@me.com" , "from" : "a.michail at me.com (Amir Michail)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 5, 2015, at 7:05 PM, Austin Zheng via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> ml>\n> I disagree with the idea that a type system is too much of a hurdle for beginner programmers to overcome.\n\nDon’t you think that Python currently provides a better introduction to programming due to its simplicity?\n\n> \n> Austin\n> \n>> On Dec 5, 2015, at 4:01 PM, Kevin Lundberg via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>> \n>> This is somewhat possible today on Apple platforms with AnyObject. You can call any objc-visible method on AnyObject and it will compile, and the return type will also be AnyObject (I don't recall if the return type is optional as well or not). This doesn't work with value types, but neither does id in objc.\n>> \n>> Having a more complete lax typed mode similar to Python or php I think is of limited usefulness, would add too much complexity to the language, and yield too much uncertainty about any given piece of swift code. \n>> \n>> --\n>> Kevin Lundberg\n>> \n>> On Dec 5, 2015, at 6:50 PM, Adrian Kashivskyy via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>> \n>>> I can't believe I'm seeing a proposal to remove type safety, one of the fundamental features of Swift...\n>>> \n>>> Regards,\n>>> Adrian Kashivskyy\n>>> iOS Developer at Netguru\n>>> \n>>>> Wiadomość napisana przez Amir Michail via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> w dniu 05.12.2015, o godz. 20:51:\n>>>> \n>>>> Python is still easier than Swift for beginning programmers. But maybe such a mode can allow Swift to be used by beginners also? _____________________________________________ swift-evolution mailing list swift-evolution at swift.org <mailto:swift-evolution at swift.org> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>> \n>>> \n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>> \n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> \n> \n> --rbÚḟîẁ\n> íz{CÊhĠ+bḃx§)Ŷ_______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/ma" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000460.html" , "inReplyTo" : "E2C52ABB-8CD4-4D5C-BFA3-F3EA995AC6FC@gmail.com" , "date" : { "$date" : 1449360571000} , "subject" : "[swift-evolution] A mode with no type checking to compete with Python." , "references" : [ "5E968E10-2DBD-4999-978C-B398BC446A21@me.com" , "7240610C-B5DA-41B8-909A-D138404C6799@me.com" , "0CFEA686-79B9-4B51-A984-7C706879BB5D@klundberg.com" , "E2C52ABB-8CD4-4D5C-BFA3-F3EA995AC6FC@gmail.com"] , "descendants" : [ "B3DEBE77-A879-4A1E-BC4D-1F028E6D326A@gmail.com" , "etPan.56637dbe.227d026a.10e90@Manav-Gabhawalas-MacBook-Pro.local" , "11A9AA09-5F9E-4AF7-8CE1-82BAB42E896A@jonshier.com" , "9354DB3D-8EFE-4AA9-B372-1FBB575381D7@web.de" , "CAKCGC8Dcw0w-vzR=vmHN2ik9GTjiaZmRiGqdnF8Kq7xhX7+m7A@mail.gmail.com" , "75B91A7D-2A61-471C-BA61-D3F92EEACC89@pobox.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/C3E05739-7629-4A8D-9C51-DBE6F87833EA@gmail.com"}} , "_id" : "C3E05739-7629-4A8D-9C51-DBE6F87833EA@gmail.com" , "from" : "alexl.mail at gmail.com (Alex Lew)" , "mailingList" : "swift-evolution" , "content" : "I believe the idea with switch is that it would be nice to be able to do something like\n\n// make sure we have different favorite colors\nlet myFavoriteColor = \n\tswitch yourFavoriteColor {\n\t\tcase .Red:\n\t\treturn .Blue\n\t\tcase .Green:\n\t\treturn .Red\n\t\tcase .Blue:\n\t\treturn .Green\n\t}\n\nThis is useful and exists in other functional languages. For example, ML has “case … of …”, Coq has “match…with…end”, etc.\n\nThis is similar to what you are proposing with if:\n\nlet x = if (condition) { return value } else { return otherValue }\n\nbecause in both cases you are taking what is currently a statement in Swift and enabling it to be used as an expression. (Of course, the syntax would ideally be nicer — maybe we limit each case’s body to be a single expression and get rid of the return keyword, for example.) Worth noting that in both cases, the type-checker needs to ensure that the type of each result is the same.\n\nThe semantics of what you’re now proposing — an if? binary operator that evaluates a condition then evaluates to either nil (if false) or some value (if true) — is slightly different. I’m not sure I love it — the general use case would be something like “if __ then ___ else ___” and I don’t think it reads that way. It also doesn’t allow for pattern matching (though to be fair, neither does the ternary operator) — it could be cool to see something like\n\nlet greeting = “Hello, \\(name),” if let name = optionalName else “To Whom It May Concern:”\n\n-Alex\n\n> On Dec 5, 2015, at 6:28 PM, Jonathan Hull via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> I think I have a solution for the ternary part, but I am not sure I fully understand what is being asked for in the case of switch.  Could someone clarify?\n> \n> There is another thread which goes into the idea a little more, but the basic idea is that we replace the ternary operator with ‘if?'\n> \n> let x = value if? condition\n> \n> \n> If condition is true, then x is value… otherwise it is nil.  You can combine with the nil-coalescing operator to get else and else if style behavior:\n> \n> let x = valueA if? conditionA ?? valueB if? conditionB ?? valueC\n> \n> \n> Thanks,\n> Jon\n> \n> \n>> On Dec 5, 2015, at 9:09 AM, Chris Lattner < clattner at apple.com <mailto:clattner at apple.com>> wrote:\n>> \n>> \n>>> On Dec 4, 2015, at 11:43 AM, J. Cheyo Jimenez < cheyo at masters3d.com <mailto:cheyo at masters3d.com>> wrote:\n>>> \n>>> I'd like some feedback from the core team to see if eliminating the ternary operator and replacing it with if-else is even proposal worthy. \n>>> \n>>> Some interesting code in the standard library that uses the ternary operator quite a bit. \n>>> \n>>> https://gist.github.com/masters3d/7b0c6f3653368afe4357 <https://gist.github.com/masters3d/7b0c6f3653368afe4357> \n>> \n>> FWIW, I have no love for the ternary operator (it is totally \"bizarre C magic”), but it does solve a problem that Swift currently otherwise has no solution for.\n>> \n>> If you’re interested in pursuing this, then the right path forward is to build a holistic proposal to turn statements (like if and switch) into expressions.  This is subtle and requires thought, but is widely desired and if someone were interested in driving the design and implementation, then I’d be interested to see it happen.\n>> \n>> -Chris\n>> \n>> _______________________________________________ \n>> swift-evolution mailing list \n>> swift-evolution at swift.org <mailto:swift-evolution at swift.org> \n>> https://lists.swift.org/mailman/listinfo/swift-evolution \n> \n> Untracked with Trackbuster <https://trackbuster.com/?sig>_______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000636.html" , "inReplyTo" : "852EF944-A503-4021-8A7F-AE6876438981@gbis.com" , "date" : { "$date" : 1449360586000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com" , "CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com" , "C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com" , "18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com" , "2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io" , "BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com" , "CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com" , "CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com" , "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com" , "852EF944-A503-4021-8A7F-AE6876438981@gbis.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAKCGC8ACsCsX1VvEpStXFOD10gw308+RqVe01VxkUh0q5j_9tA@mail.gmail.com"}} , "_id" : "CAKCGC8ACsCsX1VvEpStXFOD10gw308+RqVe01VxkUh0q5j_9tA@mail.gmail.com" , "from" : "alexl.mail+swift at gmail.com (Alex Lew)" , "mailingList" : "swift-evolution" , "content" : "I believe the idea with switch is that it would be nice to be able to do\nsomething like\n\n// make sure we have different favorite colors\nlet myFavoriteColor =\nswitch yourFavoriteColor {\ncase .Red:\nreturn .Blue\ncase .Green:\nreturn .Red\ncase .Blue:\nreturn .Green\n}\n\nThis is useful and exists in other functional languages. For example, ML\nhas “case … of …”, Coq has “match…with…end”, etc.\n\nThis is similar to what you are proposing with if:\n\nlet x = if (condition) { return value } else { return otherValue }\n\nbecause in both cases you are taking what is currently a statement in Swift\nand enabling it to be used as an expression. (Of course, the syntax would\nideally be nicer — maybe we limit each case’s body to be a single\nexpression and get rid of the return keyword, for example.) Worth noting\nthat in both cases, the type-checker needs to ensure that the type of each\nresult is the same.\n\nThe semantics of what you’re now proposing — an if? binary operator that\nevaluates a condition then evaluates to either nil (if false) or some value\n(if true) — is slightly different. I’m not sure I love it — the general use\ncase would be something like “if __ then ___ else ___” and I don’t think it\nreads that way. It also doesn’t allow for pattern matching (though to be\nfair, neither does the ternary operator) — it could be cool to see\nsomething like\n\nlet greeting = “Hello, \\(name),” if let name = optionalName else “To Whom\nIt May Concern:”\n\n-Alex\n\nOn Sat, Dec 5, 2015 at 6:28 PM, Jonathan Hull via swift-evolution <\nswift-evolution at swift.org> wrote:\n\n> I think I have a solution for the ternary part, but I am not sure I fully\n> understand what is being asked for in the case of switch.  Could someone\n> clarify?\n>\n> There is another thread which goes into the idea a little more, but the\n> basic idea is that we replace the ternary operator with ‘if?'\n>\n> let x = value if? condition\n>\n>\n> If condition is true, then x is value… otherwise it is nil.  You can\n> combine with the nil-coalescing operator to get else and else if style\n> behavior:\n>\n> let x = valueA if? conditionA ?? valueB if? conditionB ?? valueC\n>\n>\n> Thanks,\n> Jon\n>\n>\n> On Dec 5, 2015, at 9:09 AM, Chris Lattner < clattner at apple.com> wrote:\n>\n>\n> On Dec 4, 2015, at 11:43 AM, J. Cheyo Jimenez < cheyo at masters3d.com>\n> wrote:\n>\n> I'd like some feedback from the core team to see if eliminating\n> the ternary operator and replacing it with if-else is even proposal\n> worthy.\n>\n> Some interesting code in the standard library that uses the ternary\n> operator quite a bit.\n>\n> https://gist.github.com/masters3d/7b0c6f3653368afe4357\n>\n>\n> FWIW, I have no love for the ternary operator (it is totally \"bizarre C\n> magic”), but it does solve a problem that Swift currently otherwise has no\n> solution for.\n>\n> If you’re interested in pursuing this, then the right path forward is to\n> build a holistic proposal to turn statements (like if and switch) into\n> expressions.  This is subtle and requires thought, but is widely desired\n> and if someone were interested in driving the design and implementation,\n> then I’d be interested to see it happen.\n>\n> -Chris\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>\n> Untracked with Trackbuster <https://trackbuster.com/?sig>\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000461.html" , "inReplyTo" : "852EF944-A503-4021-8A7F-AE6876438981@gbis.com" , "date" : { "$date" : 1449360769000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com" , "CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com" , "C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com" , "18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com" , "2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io" , "BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com" , "CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com" , "CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com" , "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com" , "852EF944-A503-4021-8A7F-AE6876438981@gbis.com"] , "descendants" : [ "1FDCAD5A-9937-4464-BD6A-ABECAE2BB853@web.de"]} , { "_links" : { "self" : { "href" : "/charter/emails/etPan.56637dbe.227d026a.10e90@Manav-Gabhawalas-MacBook-Pro.local"}} , "_id" : "etPan.56637dbe.227d026a.10e90@Manav-Gabhawalas-MacBook-Pro.local" , "from" : "manav1907 at gmail.com (Manav Gabhawala)" , "mailingList" : "swift-evolution" , "content" : "On December 5, 2015 at 7:09:51 PM, Amir Michail via swift-evolution (swift-evolution at swift.org) wrote:\n\nOn Dec 5, 2015, at 7:05 PM, Austin Zheng via swift-evolution <swift-evolution at swift.org> wrote:\n\nml>\nI disagree with the idea that a type system is too much of a hurdle for beginner programmers to overcome.\n\nDon’t you think that Python currently provides a better introduction to programming due to its simplicity?\nI disagree. The only reason people think Python is a simpler introduction language is because so far Swift has only been used to teach iOS and OS X programming never as a programming language in itself. And if you decide to introduce someone to programming and have them jump into iOS or OS X programming they have to learn a new way of thinking (programming) as well as all the underlying complexities of building an app like the view controller lifecycle, run loops, target action, MVC, etc. If swift were taught as a pure programming language I think it would serve as a far superior introduction to programming than Python, or any other programming language that currently exists for that matter.\n\n\n\n\nAustin\n\nOn Dec 5, 2015, at 4:01 PM, Kevin Lundberg via swift-evolution <swift-evolution at swift.org> wrote:\n\nThis is somewhat possible today on Apple platforms with AnyObject. You can call any objc-visible method on AnyObject and it will compile, and the return type will also be AnyObject (I don't recall if the return type is optional as well or not). This doesn't work with value types, but neither does id in objc.\n\nHaving a more complete lax typed mode similar to Python or php I think is of limited usefulness, would add too much complexity to the language, and yield too much uncertainty about any given piece of swift code. \n\n--\nKevin Lundberg\n\nOn Dec 5, 2015, at 6:50 PM, Adrian Kashivskyy via swift-evolution <swift-evolution at swift.org> wrote:\n\nI can't believe I'm seeing a proposal to remove type safety, one of the fundamental features of Swift...\n\nRegards,\nAdrian Kashivskyy\niOS Developer at Netguru\n\nWiadomość napisana przez Amir Michail via swift-evolution <swift-evolution at swift.org> w dniu 05.12.2015, o godz. 20:51:\n\nPython is still easier than Swift for beginning programmers. But maybe such a mode can allow Swift to be used by beginners also? _____________________________________________ swift-evolution mailing list swift-evolution at swift.org https://lists.swift.org/mailman/listinfo/swift-evolution\n\n\n\n\n_______________________________________________\nswift-evolution mailing list\nswift-evolution at swift.org\nhttps://lists.swift.org/mailman/listinfo/swift-evolution\n\n_______________________________________________\nswift-evolution mailing list\nswift-evolution at swift.org\nhttps://lists.swift.org/mailman/listinfo/swift-evolution\n\n\n--rbÚḟîẁ\níz{CÊhĠ+bḃx§)Ŷ_______________________________________________\nswift-evolution mailing list\nswift-evolution at swift.org\nhttps://lists.swift.org/ma\n\n _______________________________________________\nswift-evolution mailing list\nswift-evolution at swift.org\nhttps://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000462.html" , "inReplyTo" : "7F08A62B-6FD7-4AF2-A939-EF1D3CD71BD7@me.com" , "date" : { "$date" : 1449360830000} , "subject" : "[swift-evolution] A mode with no type checking to compete with Python." , "references" : [ "5E968E10-2DBD-4999-978C-B398BC446A21@me.com" , "7240610C-B5DA-41B8-909A-D138404C6799@me.com" , "0CFEA686-79B9-4B51-A984-7C706879BB5D@klundberg.com" , "E2C52ABB-8CD4-4D5C-BFA3-F3EA995AC6FC@gmail.com" , "7F08A62B-6FD7-4AF2-A939-EF1D3CD71BD7@me.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/B3DEBE77-A879-4A1E-BC4D-1F028E6D326A@gmail.com"}} , "_id" : "B3DEBE77-A879-4A1E-BC4D-1F028E6D326A@gmail.com" , "from" : "austinzheng at gmail.com (Austin Zheng)" , "mailingList" : "swift-evolution" , "content" : "No, I don't. I think Python's biggest appeal to new programmers is the fact that it has such a great standard library, making it really easy to do whatever you want to do without figuring out how to find or add in external dependencies.\n\nAnyways, mistyped Python code still breaks, it just breaks at runtime instead of compile time. In fact, I'd argue that this is even less beginner friendly, since you might write a function that works with some inputs and then inexplicably breaks with others.\n\nAustin\n\n> On Dec 5, 2015, at 4:09 PM, Amir Michail <a.michail at me.com> wrote:\n> \n> \n>> On Dec 5, 2015, at 7:05 PM, Austin Zheng via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>> \n>> ml>\n>> I disagree with the idea that a type system is too much of a hurdle for beginner programmers to overcome.\n> \n> Don’t you think that Python currently provides a better introduction to programming due to its simplicity?\n> \n>> \n>> Austin\n>> \n>>> On Dec 5, 2015, at 4:01 PM, Kevin Lundberg via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>> \n>>> This is somewhat possible today on Apple platforms with AnyObject. You can call any objc-visible method on AnyObject and it will compile, and the return type will also be AnyObject (I don't recall if the return type is optional as well or not). This doesn't work with value types, but neither does id in objc.\n>>> \n>>> Having a more complete lax typed mode similar to Python or php I think is of limited usefulness, would add too much complexity to the language, and yield too much uncertainty about any given piece of swift code. \n>>> \n>>> --\n>>> Kevin Lundberg\n>>> \n>>> On Dec 5, 2015, at 6:50 PM, Adrian Kashivskyy via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>> \n>>>> I can't believe I'm seeing a proposal to remove type safety, one of the fundamental features of Swift...\n>>>> \n>>>> Regards,\n>>>> Adrian Kashivskyy\n>>>> iOS Developer at Netguru\n>>>> \n>>>>> Wiadomość napisana przez Amir Michail via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> w dniu 05.12.2015, o godz. 20:51:\n>>>>> \n>>>>> Python is still easier than Swift for beginning programmers. But maybe such a mode can allow Swift to be used by beginners also? _____________________________________________ swift-evolution mailing list swift-evolution at swift.org <mailto:swift-evolution at swift.org> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>> \n>>>> \n>>>> _______________________________________________\n>>>> swift-evolution mailing list\n>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>> \n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>> \n>> \n>> --rbÚḟîẁ\n>> íz{CÊhĠ+bḃx§)Ŷ_______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>> https://lists.swift.org/ma\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000463.html" , "inReplyTo" : "7F08A62B-6FD7-4AF2-A939-EF1D3CD71BD7@me.com" , "date" : { "$date" : 1449360839000} , "subject" : "[swift-evolution] A mode with no type checking to compete with Python." , "references" : [ "5E968E10-2DBD-4999-978C-B398BC446A21@me.com" , "7240610C-B5DA-41B8-909A-D138404C6799@me.com" , "0CFEA686-79B9-4B51-A984-7C706879BB5D@klundberg.com" , "E2C52ABB-8CD4-4D5C-BFA3-F3EA995AC6FC@gmail.com" , "7F08A62B-6FD7-4AF2-A939-EF1D3CD71BD7@me.com"] , "descendants" : [ "11A9AA09-5F9E-4AF7-8CE1-82BAB42E896A@jonshier.com" , "9354DB3D-8EFE-4AA9-B372-1FBB575381D7@web.de" , "CAKCGC8Dcw0w-vzR=vmHN2ik9GTjiaZmRiGqdnF8Kq7xhX7+m7A@mail.gmail.com" , "75B91A7D-2A61-471C-BA61-D3F92EEACC89@pobox.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com"}} , "_id" : "CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com" , "from" : "ilya.nikokoshev at gmail.com (ilya)" , "mailingList" : "swift-evolution" , "content" : "> PROBLEM: With many Apple-supplied classes, typical initializers fail to\nfully set up an instance for use.  Here's one example: ...\n\nFWIW, I created a configuration operator more then a year ago, and use it\nin all of my Swift projects:\n\nlet task = NSTask() +=+ {\n    $0.launchPath = \"/usr/bin/mdfind\"\n    $0.arguments = [\"kMDItemDisplayName == *.playground\"]\n    $0.standardOutput = pipe\n}\n\nNote you can also use the configured object in the rhs:\n\nlet questionLabel = UILabel() +=+ {\n    $0.textAlignment = .Center\n    $0.font =  UIFont(name:\"DnealianManuscript\", size: 72)\n    $0.text = currentQuestion.questionText\n    $0.numberOfLines = 0\n    view.addSubview($0)\n}\n\nThis $0. certainly looks ugly and it would be great to be able to simplify\nthis. I don't llike the following much though (dot-syntax can be ambiguos\nhere, and using simply a method name is even worse):\n\nlet questionLabel = UILabel() +=+ {\n    .textAlignment = .Center\n    .font =  UIFont(name:\"DnealianManuscript\", size: 72)\n    .text = currentQuestion.questionText\n    .numberOfLines = 0\n    view.addSubview($0)\n}\n\nActually I would be happy with something like\n\nlet questionLabel = UILabel() .{\n    ..textAlignment = .Center\n    ..font = UIFont(name:\"DnealianManuscript\", size: 72)\n    ..text = currentQuestion.questionText\n    ..numberOfLines = 0\n    view.addSubview($0)\n}\n\nOther thoughts?" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000464.html" , "date" : { "$date" : 1449360980000} , "subject" : "[swift-evolution] Request for Discussion: Setup closures" , "references" : [ ""] , "inReplyTo" :  null  , "descendants" : [ "F77586E8-94BF-48F3-A379-0088A02C135D@gbis.com" , "CDAFBA7E-E9E9-443F-BB82-B76ACEBF54E6@web.de" , "8837F311-F6F8-462E-90E0-88981C537EFD@ericasadun.com" , "F757A1B0-69AA-40E0-BB72-9A043CE6D93D@ericasadun.com" , "F833B947-4FFD-485E-912A-31B50140660F@anandabits.com" , "F6635EA0-2342-451E-8675-FF1819BD715C@anandabits.com" , "2F1E045F-3242-4943-9471-B40D6B476C97@anandabits.com" , "35BE2387-2F9C-491F-B71F-1635243ABADA@ericasadun.com" , "38E11489-CE79-4690-8567-98FD7793B4FF@gmail.com" , "159233D0-A835-4435-840E-A9594DDCA37D@ericasadun.com" , "CAKCGC8AOx_ffGe1AjpQJt9ULr3zwTBsnphJCht92se7-Hfi_+g@mail.gmail.com" , "DC82287B-4583-47F3-9389-B756C91436F5@alkaline-solutions.com" , "CC9D9491-212A-4D20-8CC2-34FD984F6463@portableinnovations.de" , "EF05B911-5728-47F4-AB13-F960FF2B21A4@portableinnovations.de" , "F379B44A-9B6F-47BD-95B0-9FC795BC035B@architechies.com" , "BB9D9FE2-F252-41F4-A3EA-2D8053A7579C@gmx.de" , "1F3D7F58-0EC6-4541-9734-A95CE62BAF6E@anandabits.com" , "2139FFE7-79C5-4981-A036-250F2D5EF0A4@ericasadun.com" , "24FE9022-00E3-459C-8A71-540BCF436286@apple.com" , "E904EA6A-6422-49F6-9C5E-07BCDC7D3543@gmx.de" , "98A80B8C-AC32-408D-AD8F-CDE0EB782B4C@apple.com" , "03F8648F-236A-46A5-8D21-CA066DBA1932@anandabits.com" , "D49345E8-5E22-46C8-9EF2-EF0DB4D32D87@apple.com" , "77AE5195-4E57-4814-A228-AF23723C853B@ericasadun.com" , "B818E6F9-1526-4725-BCDA-AB8C36F3CED7@maven.de" , "6A18AB5F-3794-42A6-8142-AAA7B2B61000@apple.com" , "9520AAC7-B49D-4CB7-96EE-E9891BAC9268@ericasadun.com" , "5981B70E-98D3-4A99-AF49-106254DFEB54@apple.com" , "86e837d7-cac3-438b-8297-4f6f401b641f@Spark" , "315B39D9-AE33-438B-8EFF-CC4796EECAAF@pobox.com" , "731CB499-F42F-45D4-8A3B-8D7B963D3709@monod-broca.fr" , "CADcs6kNOmo32YcBHOjmsV3eKiJ4yo0nDxz+5mjWNtp3JG0FsOA@mail.gmail.com" , "616C48D0-D626-487E-861C-CF125879BABB@ericasadun.com" , "3A77268A-D52E-4821-9488-671491506835@monod-broca.fr" , "B5AE3C08-FB9F-4024-B6BF-ECAADC1196E8@pobox.com" , "52D7FF3E-4E16-447D-AFCF-6915ABF999C1@gmx.de" , "98E5A56D-2912-4725-8E5E-14F25153B184@gmx.de" , "3C9B366C-D4A8-4777-8CF9-E46B52F806E2@pobox.com" , "849CDDCE-CC11-4DA1-A8D4-F0440049231C@anandabits.com" , "etPan.56642314.20830c9b.1f6@mscience.fritz.box" , "0413C70D-A999-46F1-8D46-FEEC93F2C2FC@gmail.com" , "AA0220E6-BD02-4B04-98DF-C73C00F8FB0C@anandabits.com" , "4CCD3C85-FC9C-4509-B2A9-2D761A6A9921@ericasadun.com" , "F3860C6E-19F2-4E01-AF30-1CC813893B1C@anandabits.com" , "DD7C743B-5E22-4603-AA6A-AF3F75B4DE62@ericasadun.com" , "CAPh90aE1m68_kDFqOGuO-u6qP3WKtqSJS9XMU-KKrO0N3yV0kg@mail.gmail.com" , "0674FFD1-76FB-4376-9F34-0FF8B7560798@anandabits.com" , "5B0D18B8-0255-4F2E-86E3-253058585BDB@fifthace.com" , "512C0649-506C-41B3-BBB9-BBF6B80437FE@ericasadun.com" , "CADcs6kOfPJ73WdN-UHTZAPs7Zx_MmSUjrKy6r=EMphLdGfti8w@mail.gmail.com" , "ED9A9872-62B4-4957-B708-94F3015365C5@alkaline-solutions.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com"}} , "_id" : "0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com" , "from" : "adam at lickel.com (Adam C. Lickel)" , "mailingList" : "swift-evolution" , "content" : "In that situation, the if statement could return a Void? where the else implicitly returns nil\n\n> On Dec 5, 2015, at 3:12 PM, Ole Begemann via swift-evolution <swift-evolution at swift.org> wrote:\n> \n>>> This is subtle and requires thought\n>> \n>> What do you envision as the pitfalls of the design thinking behind if/switch expressions? I’m not a compiler programmer, but a prog-lang enthusiast. I wouldn’t mind a little nudge in the right direction.\n> \n> One thing that comes to mind is that if \"if\" is an expression, every if needs an else branch. This makes it harder to use if to conditionally perform side effects. For example, this is currently valid:\n> \n> func doSomething() { ... }\n> \n> if condition {\n>    doSomething()\n> }\n> \n> Should this be allowed? You could argue that this should work because (a) the expression result is unused and (b) the return type of doSomething is Void, so the compiler could conceivably implicitly construct an else branch that returns (). But it would be inconsistent with other expressions. Disallowing this style could make writing typical \"imperative\" code harder.\n> \n> – Ole\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000465.html" , "inReplyTo" : "909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net" , "date" : { "$date" : 1449361359000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com" , "CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com" , "C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com" , "18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com" , "2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io" , "BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com" , "CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com" , "CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com" , "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com" , "BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com" , "909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net"] , "descendants" : [ "D381E334-74B7-41EC-90BF-544A925D2204@icloud.com" , "D9043847-2CF1-40A8-9BDD-2C0DCCAB5A38@supmenow.com" , "EAEE8B4A-12A2-4FD6-BA7B-B26071F08489@gmail.com" , "CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com" , "4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com" , "CAAcV4sbQxUywKAHE=3SCACEFH4YvUqjwEr_0=fjf59ndZtoedg@mail.gmail.com" , "07270E34-E284-4FF0-B2EA-6DBB54FF78B5@portableinnovations.de" , "67057217-F4BC-4584-8B52-8EBA2CFA8CC7@portableinnovations.de" , "45B71AF5-DD4F-4E9C-A128-5B8041917564@me.com" , "CAKCGC8BmmCk55=6UC_qk_C+ZNq2JfGpOPO5cJ=SK2784kmvbGg@mail.gmail.com" , "B6DDD94B-0755-4D40-94F0-D2469A644818@portableinnovations.de" , "CAKCGC8AerqpPTrwdmPAvhmp-fLt-v=LXw4z0t+2o93g9GmAaxw@mail.gmail.com" , "54E5D8F5-616D-41EB-A550-E639FE861575@gmail.com" , "CAKCGC8CsJ7g_Fu8fnQ5Mv=yAzbSvb0Z+iNmdXKnJaAcWR2UKuw@mail.gmail.com" , "6830F74D-78FC-4B20-A6D5-683185B30164@gmail.com" , "691A92C4-1A5F-4CAE-AF50-F6AAA3A3F32C@portableinnovations.de" , "D35074A6-1C34-4BA3-AAF1-8CFE1992A522@me.com" , "1EE735A6-FF0F-4E49-BE7D-AC7E6C8A87EC@tarantsov.com" , "3D250DE5-09BC-4A6B-AF59-E1D714DF709A@tarantsov.com" , "BB6A4434-E2B1-4192-8450-90D636E6A7F5@fastmail.fm" , "0ED79E6D-A89A-4F3E-9269-6216BD10EB22@sealedabstract.com" , "CAAcV4sb9eMhuLGL3QsBw4bFxj1FQrokCAanKjEFRNNReE8zWOQ@mail.gmail.com" , "7253CF12-DBD4-483D-941F-04851E5AD394@tarantsov.com" , "CAAcV4sbo4=Hdzp+yx-km-CnhNDm2uQ-gDJsvdug_Pg-MjTPC=Q@mail.gmail.com" , "CAAcV4sbAk_eSdjz7bQ6ggdZNE+thmj7-wT_pG2+eRMKDVba+wA@mail.gmail.com" , "B619CC7E-59A8-4B3C-8E46-FC7FD4C4C6E6@apple.com" , "2372BF92-E97D-40C3-8FEC-0CA9B00ACACE@icloud.com" , "BB1D04A8-2E17-497F-AE74-8FDE4AEC4D77@fastmail.fm" , "2F722DE2-D3AE-44D5-83BB-CBCD371801AD@icloud.com" , "7B70F158-5B8A-425B-980C-CD08210342D4@me.com" , "FDB72AC4-0B0A-4D0F-A9D2-FFE43A55362E@gmail.com" , "9E0141FF-8B3B-4736-88EE-11F05930D149@fastmail.fm" , "CAAcV4sba2j1hOrBJO1kmLpLcjwSQoE0LUejbdNxa05zFzUmi3g@mail.gmail.com" , "DE316C42-6FA7-4A60-80C2-AFF74844EF09@fastmail.fm" , "33B028BA-EB5F-4986-9F16-3057390C3F16@gmail.com" , "BB8653D1-400D-49BC-AA77-6ECC096747B3@icloud.com" , "54B5FAEC-8636-44C5-96A2-0401999DD5D2@gmail.com" , "D679F068-B7C8-4DF2-A7E6-4D78B74F6B17@tarantsov.com" , "DDCE4FC9-2DED-45E5-8D9B-CAB2AA8CF9E6@gmail.com" , "C1C319DB-3934-40B6-ABEE-51B07463E6EF@upzzle.com" , "1C3ADBD7-D4CD-417A-AC45-029D7A889812@fastmail.fm" , "39024D06-E664-42EB-9E68-4D3E5BDC577D@anandabits.com" , "CAE+=ROVg0cJVKnSdwB=KPrEtr=GYd+PMMaOvbCj=N0RtUT=Q6A@mail.gmail.com" , "CAE+=ROVUD1ECe9yHG8kMW0skCFV0=BK70rw+5V7rNHEfmGhNjQ@mail.gmail.com" , "C04621E1-91D2-4A7D-9F9C-58F862B38355@icloud.com" , "581FE433-8169-4D61-9C3F-D90DAD600B9B@icloud.com" , "DB890044-1DAF-4832-8380-F78F61FBC96D@uzh.ch" , "CAE+=ROXg+tM0VYn1bscairmM9sQQ0nh1tYb4SexyWnM7TbeyaA@mail.gmail.com" , "CAE+=ROX9M8XSU8reKMf=RNCwu4Xu95V0G9W9T=Xr0nc8KerHjw@mail.gmail.com" , "CAAcV4sZKJg+x0v4rc1h=ydKE+EFEjanyBnqm8BWO=za-fF+jXA@mail.gmail.com" , "B017EE8F-7732-448E-80AB-7694904D28B4@icloud.com" , "D6AA07FC-261F-4D09-BC32-9FF7792659EC@eggerapps.at" , "CAE+=ROWf2XT2mxM5uWJCjz1Q3wZB71w=svWmGgX5v2=Y2rLzNw@mail.gmail.com" , "EB862217-2E54-4503-9C0C-DD943D428880@gmail.com" , "E0FCC493-27B9-499C-9884-4E00DB831131@gmail.com" , "934A39F6-ECB6-405B-8EF6-97E3C55604AD@uzh.ch" , "5824A613-F216-400B-AD16-9D368FA3A397@gmail.com" , "29A77367-05BF-4667-B25F-C06F520D0CB5@fastmail.fm" , "5525CD3F-062A-4ECB-809F-1964AE645CFC@gmail.com" , "CALkjWZsKQUQc0oDMkru8YGRv5rqOeqXF=4HnU2V0wo_5Q8SjnQ@mail.gmail.com" , "047B4955-1E5A-4A77-BAE3-63E8633A3AE1@gmail.com" , "CAE+=ROWxmKEic9DxN+CXyf=O7AtxgoHox5tSM1SCy_6E0ODphQ@mail.gmail.com" , "A7043ACA-9CE9-4739-919F-93F65FE7273B@gmail.com" , "6137630B-E3E8-45C6-AB48-FABFE9586EA9@me.com" , "CBB03FEA-50E2-4D7B-92B5-FB8A74B6719A@icloud.com" , "28E69DC8-4663-4FB6-8F99-F645E5D3F960@gmail.com" , "CAAcV4sZRQkVeBSqHv8UE_SJh-oEzZ74W6zd+sYxwEKhYZYsfxA@mail.gmail.com" , "CAAcV4sbakzYnefbui=hYKRDTMkrN_s1hFTn3CLwZUzWWa0M3LA@mail.gmail.com" , "63683E0A-B1FE-42A1-9878-FFEA34D1B993@gmail.com" , "CAAcV4sY8O=z5TL41vMoW3rKCHEWH3ikD8ZVJu-AEgVBYx-JXsA@mail.gmail.com" , "CAAcV4sbgPfRGZcU2U3fHcN2nky_ZqhCspWkz9DXYCjXyZFhvOQ@mail.gmail.com" , "A97ACA91-183C-41D9-ACEF-61B74D51E5BA@icloud.com" , "A9768B92-225F-49C8-B2D1-D572E1BD93DB@gmail.com" , "3BBED4DB-4944-4D4D-8603-A9E122B108B9@fastmail.fm" , "4C94F89B-CEDF-4480-8043-ED80AE0EB76A@eggerapps.at" , "B834ABFE-0DB7-426F-B932-74CD7884E46F@icloud.com" , "D58261F7-759A-4B10-84BE-A7882D50C7A5@owensd.io" , "0FEC8813-07C3-48E2-8D76-D0EF7709DA8E@tarantsov.com" , "6C13EC21-3BF0-4633-ABAB-C91322598ABC@apple.com" , "50765AC5-1CFE-406D-9CB5-B28ABBEB84ED@fastmail.fm" , "C64EC68B-1BBE-498A-937A-257E01314DEB@apple.com" , "CALkjWZu1S0ykcnenz_Z0AEuaiyeyTpxSYRMwknqeRxJAxnJT7w@mail.gmail.com" , "CAPrQK3CZy45bfx7qTgJoCH6pkocd_9sPTc0CNrAvsrRM6Vixkg@mail.gmail.com" , "CAB056B2-A975-45B3-93BD-14DE06903042@gmail.com" , "6FDA08B7-192F-42F2-BD2F-F7980463C833@novafore.com" , "40273CEA-F386-47C3-9314-C355B2E320CB@gmail.com" , "CANGnqV1WfTHxgfk4PNTQozU31EAa7z4MZF7d0gc058F4_=EtcQ@mail.gmail.com" , "C9FD779C-AF2C-466C-B741-34D40FB47413@icloud.com" , "48DEE2AB-7D93-47AC-9296-42AD9DD987E2@gmail.com" , "A4DFD8C0-135E-4B40-A264-B7FBCD07D322@fastmail.fm" , "CALkjWZvopih52vGsUfsqzrsEPP-G02eDg=8+EKLrpCMNciW+gA@mail.gmail.com" , "CALkjWZsMC7daCZHg_SDw=EiySCZtN7knDqVhXiF6+3dKTZZTGA@mail.gmail.com" , "CAEEOKET4Ud0bbSW_-Ss6V08tLy2YhF3n1TvQ06Xk5Jjak5-GHg@mail.gmail.com" , "CAAcV4sYaK4=N=ePDkHKbiodYp3HfiHW2yFxWs0A9Rt7LJ8DYvg@mail.gmail.com" , "CAAcV4sbOpH=sbPePnKhcHNXFy-YbPubUvF5PDaoLN_Rs8yL_rw@mail.gmail.com" , "C0B48136-1470-48EB-89D8-CD1B6F8553B1@apple.com" , "7227A933-1AFF-4470-90CB-2880776CEF03@fastmail.fm" , "3017B038-022E-4E46-8ABD-74873DC4C14C@icloud.com" , "CAAcV4sZ=8N3FDgo5aJT50dPwBh=SjM5NTSFgiT6OgSGcbsdcKg@mail.gmail.com" , "A2116BA7-633C-40BA-B7EF-B6A69582C2A3@icloud.com" , "9B4EA1B7-9D30-4B60-9AD0-34119EB9837D@apple.com" , "4BBB2771-4817-4BF3-919D-D7E14826C38D@apple.com" , "D17C306A-4934-4D72-B4FA-E7897B8E82B1@gmail.com" , "99FBC506-E086-4609-8585-42CA7E7E9852@apple.com" , "CAB5C60u6fSAaFgWDw2MY-PP1sJDEDqGRObqF+WwiHoXYvTwwZg@mail.gmail.com" , "3F9131C9-B757-4211-AED4-8E71E3CE9810@anandabits.com" , "EC7C2819-0125-437D-8940-1E3F610B500D@icloud.com" , "38E32460-C46B-428A-91A1-37A74D863127@gmail.com" , "CAAcV4sZZt8mwh9_rixfQ3dAdrPV77=uuqsAvdBM5f90K8sb6hw@mail.gmail.com" , "473B2AAA-7AE4-4B09-B013-6EE9CA6AB2AA@gmail.com" , "32A23B96-9CCC-4114-8939-07EE62E7B6AC@apple.com" , "A5DF87B9-47F1-4A2D-A51B-27CB3221912D@apple.com" , "028924F8-3DD9-40F9-A907-C4DB2344043B@gmail.com" , "CAB5C60tv0=-aBnPzwDCAp8oE8Km+tB6huYPxTrZNi=ObBKXAww@mail.gmail.com" , "CAB5C60sGJPaYPFtEoKB0DC-6A11LogCQAOCeZ-C6dvkmMd2oyg@mail.gmail.com" , "277EE0B5-01B3-48CE-992F-AE838034C0F1@apple.com" , "897A3F1D-1BCB-41B3-9096-0E46DEFA844A@apple.com" , "CAB5C60vD=QyN6LqyKU431jUSQQbuBEJcGiHkwq=+nRmTFhbU9A@mail.gmail.com" , "F4ED804A-2DC1-48DE-AD7C-DBE2A0BEF047@apple.com" , "81AA5235-A524-4F1A-AAA0-EB44BFFB0FEC@architechies.com" , "34A6EE6D-AECF-4887-BEB8-0D841C7CB1F2@icloud.com" , "CAAcV4sYZ6JoLy+=XKStCyh-XTJVmttrBZvqTuNq=Decsv2NEzg@mail.gmail.com" , "F5E748B4-BD58-408D-9330-DE255B9531E9@icloud.com" , "CACOvyQXZ1-qfbz7=0R1iXudZQdFMHPPQ2GVv_5DKwFEvZEF2pA@mail.gmail.com" , "27C9213F-B866-4A98-B0DC-E1492700B28B@apple.com" , "AE17F2D6-0107-4F61-AE13-01E5236ED770@apple.com" , "C320EC78-2D4E-46A8-90ED-4175F5B80072@gmail.com" , "CAB5C60szP8_2p8qqX13ph3wDQU6iRM0P09hVmXu7ar9SvRN+vw@mail.gmail.com" , "15A5CF07-DAED-4B92-A983-D88C2FA6BC8E@gmail.com" , "2822BF6F-172E-4003-B1A4-FB1C518CB701@googlemail.com" , "414E3C0D-EEC1-4005-8D68-5CA91EBADD0F@gmail.com" , "72FA697D-D1C9-4E73-B554-7313DC940D4B@apple.com" , "63C561FE-B75F-4A9B-8DF6-B2335D4C03CB@apple.com" , "CAEEOKEQyUwgvkEvPu2Xv_xAEJWiMTgGtv=KdY-2gkzhJXR7D4A@mail.gmail.com" , "A5DE0BD4-E526-4682-82B0-9B541CEF1C15@gmail.com" , "CAB5C60tn=nNstD2ke_RACYJsmAVvWQx-vJV=PfhqsOgaKx9pfw@mail.gmail.com" , "30B4EAF6-C852-4691-B397-24086AE1F9D9@icloud.com" , "1E2BDCE0-2132-40E8-96BC-BA51233281C7@novafore.com" , "C5F7CACF-736F-4794-B38E-0BE409F96835@novafore.com" , "FAEB0D09-1CB7-4706-B4CC-43DF40A2D243@apple.com" , "03C1FF36-43C3-46D1-88A1-3ECDCBB56567@gmail.com" , "CAB5C60sXr46WbfmaUctNKfWk01G_4pHgktykf4dJQZDbQ1QPWA@mail.gmail.com" , "4FB8F138-A0EF-4DDF-9AAD-A7172195F469@novafore.com" , "0C330020-F7D9-45D0-9B2D-E4DAD3AE105C@anandabits.com" , "CAB5C60vXzip01M6r62uQdkrXCxfBaQPgU7tdHsz+0Tu0i4Zksw@mail.gmail.com" , "BED20179-20C3-4F3A-B5D5-5E09286333F5@anandabits.com" , "E09BFA74-9DDF-4607-B52B-6C8EEC931D1F@gmail.com" , "1449374024.2155187.459254033.067DF6CC@webmail.messagingengine.com" , "CADcs6kN7gAr8x9ZbHBSX9gpOoJps=21wi-9ZC7hbtHUtRp54HA@mail.gmail.com" , "1449377752.2181216.459275089.1BA7CBAC@webmail.messagingengine.com" , "D9EA05A0-B3E8-4437-A0D1-F1FC27B0E124@gmail.com" , "CAKCGC8CWGc1L0fsc7TtzDeCqu5bxPX3q3MMZCw+2HPGuPHHC1A@mail.gmail.com" , "7D68F57E-C847-4E0D-AF3A-FD1F2DC928A9@icloud.com" , "1449429569.1342623.459603529.32C935BC@webmail.messagingengine.com" , "11462DA4-ACDD-4CF3-BD57-47886B655970@anandabits.com" , "CAKCGC8AVDe6W9X=XvFEnbkae8xom2Us8xczKFShqKu2+kPnRJA@mail.gmail.com" , "0DF0732F-0958-47C1-A6C3-62A8AB2F4386@icloud.com" , "CAKCGC8BEzyEPAFWCPKPiH+UL3KmZm7aM6KUPu-F9DKV-YvUbCA@mail.gmail.com" , "4A5C6452-0A1B-42A3-AFD4-3DEA04E310C6@icloud.com" , "6DA2FDFF-F978-4ECA-9E2B-F757F6D8BBF3@icloud.com" , "2116BFD1-25BC-4B9F-A3A6-08758782BB88@anandabits.com" , "C919D677-30C0-4F1E-B221-9B28365D67A9@gmail.com" , "CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com" , "49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net" , "49EEA2E6-55F2-49DE-A59F-A13017626370@web.de"]} , { "_links" : { "self" : { "href" : "/charter/emails/49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net"}} , "_id" : "49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net" , "from" : "ole at oleb.net (Ole Begemann)" , "mailingList" : "swift-evolution" , "content" : "Yeah, returning an optional is a good idea.\n\n> On 06 Dec 2015, at 01:22, Adam C. Lickel <adam at lickel.com> wrote:\n> \n> In that situation, the if statement could return a Void? where the else implicitly returns nil\n> \n>> On Dec 5, 2015, at 3:12 PM, Ole Begemann via swift-evolution <swift-evolution at swift.org> wrote:\n>> \n>>>> This is subtle and requires thought\n>>> \n>>> What do you envision as the pitfalls of the design thinking behind if/switch expressions? I’m not a compiler programmer, but a prog-lang enthusiast. I wouldn’t mind a little nudge in the right direction.\n>> \n>> One thing that comes to mind is that if \"if\" is an expression, every if needs an else branch. This makes it harder to use if to conditionally perform side effects. For example, this is currently valid:\n>> \n>> func doSomething() { ... }\n>> \n>> if condition {\n>>   doSomething()\n>> }\n>> \n>> Should this be allowed? You could argue that this should work because (a) the expression result is unused and (b) the return type of doSomething is Void, so the compiler could conceivably implicitly construct an else branch that returns (). But it would be inconsistent with other expressions. Disallowing this style could make writing typical \"imperative\" code harder.\n>> \n>> – Ole" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000466.html" , "inReplyTo" : "0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com" , "date" : { "$date" : 1449361460000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com" , "CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com" , "C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com" , "18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com" , "2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io" , "BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com" , "CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com" , "CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com" , "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com" , "BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com" , "909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net" , "0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com"] , "descendants" : [ "D381E334-74B7-41EC-90BF-544A925D2204@icloud.com" , "D9043847-2CF1-40A8-9BDD-2C0DCCAB5A38@supmenow.com" , "EAEE8B4A-12A2-4FD6-BA7B-B26071F08489@gmail.com" , "CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com" , "4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com" , "CAAcV4sbQxUywKAHE=3SCACEFH4YvUqjwEr_0=fjf59ndZtoedg@mail.gmail.com" , "07270E34-E284-4FF0-B2EA-6DBB54FF78B5@portableinnovations.de" , "67057217-F4BC-4584-8B52-8EBA2CFA8CC7@portableinnovations.de" , "45B71AF5-DD4F-4E9C-A128-5B8041917564@me.com" , "CAKCGC8BmmCk55=6UC_qk_C+ZNq2JfGpOPO5cJ=SK2784kmvbGg@mail.gmail.com" , "B6DDD94B-0755-4D40-94F0-D2469A644818@portableinnovations.de" , "CAKCGC8AerqpPTrwdmPAvhmp-fLt-v=LXw4z0t+2o93g9GmAaxw@mail.gmail.com" , "54E5D8F5-616D-41EB-A550-E639FE861575@gmail.com" , "CAKCGC8CsJ7g_Fu8fnQ5Mv=yAzbSvb0Z+iNmdXKnJaAcWR2UKuw@mail.gmail.com" , "6830F74D-78FC-4B20-A6D5-683185B30164@gmail.com" , "691A92C4-1A5F-4CAE-AF50-F6AAA3A3F32C@portableinnovations.de" , "D35074A6-1C34-4BA3-AAF1-8CFE1992A522@me.com" , "1EE735A6-FF0F-4E49-BE7D-AC7E6C8A87EC@tarantsov.com" , "3D250DE5-09BC-4A6B-AF59-E1D714DF709A@tarantsov.com" , "BB6A4434-E2B1-4192-8450-90D636E6A7F5@fastmail.fm" , "0ED79E6D-A89A-4F3E-9269-6216BD10EB22@sealedabstract.com" , "CAAcV4sb9eMhuLGL3QsBw4bFxj1FQrokCAanKjEFRNNReE8zWOQ@mail.gmail.com" , "7253CF12-DBD4-483D-941F-04851E5AD394@tarantsov.com" , "CAAcV4sbo4=Hdzp+yx-km-CnhNDm2uQ-gDJsvdug_Pg-MjTPC=Q@mail.gmail.com" , "CAAcV4sbAk_eSdjz7bQ6ggdZNE+thmj7-wT_pG2+eRMKDVba+wA@mail.gmail.com" , "B619CC7E-59A8-4B3C-8E46-FC7FD4C4C6E6@apple.com" , "2372BF92-E97D-40C3-8FEC-0CA9B00ACACE@icloud.com" , "BB1D04A8-2E17-497F-AE74-8FDE4AEC4D77@fastmail.fm" , "2F722DE2-D3AE-44D5-83BB-CBCD371801AD@icloud.com" , "7B70F158-5B8A-425B-980C-CD08210342D4@me.com" , "FDB72AC4-0B0A-4D0F-A9D2-FFE43A55362E@gmail.com" , "9E0141FF-8B3B-4736-88EE-11F05930D149@fastmail.fm" , "CAAcV4sba2j1hOrBJO1kmLpLcjwSQoE0LUejbdNxa05zFzUmi3g@mail.gmail.com" , "DE316C42-6FA7-4A60-80C2-AFF74844EF09@fastmail.fm" , "33B028BA-EB5F-4986-9F16-3057390C3F16@gmail.com" , "BB8653D1-400D-49BC-AA77-6ECC096747B3@icloud.com" , "54B5FAEC-8636-44C5-96A2-0401999DD5D2@gmail.com" , "D679F068-B7C8-4DF2-A7E6-4D78B74F6B17@tarantsov.com" , "DDCE4FC9-2DED-45E5-8D9B-CAB2AA8CF9E6@gmail.com" , "C1C319DB-3934-40B6-ABEE-51B07463E6EF@upzzle.com" , "1C3ADBD7-D4CD-417A-AC45-029D7A889812@fastmail.fm" , "39024D06-E664-42EB-9E68-4D3E5BDC577D@anandabits.com" , "CAE+=ROVg0cJVKnSdwB=KPrEtr=GYd+PMMaOvbCj=N0RtUT=Q6A@mail.gmail.com" , "CAE+=ROVUD1ECe9yHG8kMW0skCFV0=BK70rw+5V7rNHEfmGhNjQ@mail.gmail.com" , "C04621E1-91D2-4A7D-9F9C-58F862B38355@icloud.com" , "581FE433-8169-4D61-9C3F-D90DAD600B9B@icloud.com" , "DB890044-1DAF-4832-8380-F78F61FBC96D@uzh.ch" , "CAE+=ROXg+tM0VYn1bscairmM9sQQ0nh1tYb4SexyWnM7TbeyaA@mail.gmail.com" , "CAE+=ROX9M8XSU8reKMf=RNCwu4Xu95V0G9W9T=Xr0nc8KerHjw@mail.gmail.com" , "CAAcV4sZKJg+x0v4rc1h=ydKE+EFEjanyBnqm8BWO=za-fF+jXA@mail.gmail.com" , "B017EE8F-7732-448E-80AB-7694904D28B4@icloud.com" , "D6AA07FC-261F-4D09-BC32-9FF7792659EC@eggerapps.at" , "CAE+=ROWf2XT2mxM5uWJCjz1Q3wZB71w=svWmGgX5v2=Y2rLzNw@mail.gmail.com" , "EB862217-2E54-4503-9C0C-DD943D428880@gmail.com" , "E0FCC493-27B9-499C-9884-4E00DB831131@gmail.com" , "934A39F6-ECB6-405B-8EF6-97E3C55604AD@uzh.ch" , "5824A613-F216-400B-AD16-9D368FA3A397@gmail.com" , "29A77367-05BF-4667-B25F-C06F520D0CB5@fastmail.fm" , "5525CD3F-062A-4ECB-809F-1964AE645CFC@gmail.com" , "CALkjWZsKQUQc0oDMkru8YGRv5rqOeqXF=4HnU2V0wo_5Q8SjnQ@mail.gmail.com" , "047B4955-1E5A-4A77-BAE3-63E8633A3AE1@gmail.com" , "CAE+=ROWxmKEic9DxN+CXyf=O7AtxgoHox5tSM1SCy_6E0ODphQ@mail.gmail.com" , "A7043ACA-9CE9-4739-919F-93F65FE7273B@gmail.com" , "6137630B-E3E8-45C6-AB48-FABFE9586EA9@me.com" , "CBB03FEA-50E2-4D7B-92B5-FB8A74B6719A@icloud.com" , "28E69DC8-4663-4FB6-8F99-F645E5D3F960@gmail.com" , "CAAcV4sZRQkVeBSqHv8UE_SJh-oEzZ74W6zd+sYxwEKhYZYsfxA@mail.gmail.com" , "CAAcV4sbakzYnefbui=hYKRDTMkrN_s1hFTn3CLwZUzWWa0M3LA@mail.gmail.com" , "63683E0A-B1FE-42A1-9878-FFEA34D1B993@gmail.com" , "CAAcV4sY8O=z5TL41vMoW3rKCHEWH3ikD8ZVJu-AEgVBYx-JXsA@mail.gmail.com" , "CAAcV4sbgPfRGZcU2U3fHcN2nky_ZqhCspWkz9DXYCjXyZFhvOQ@mail.gmail.com" , "A97ACA91-183C-41D9-ACEF-61B74D51E5BA@icloud.com" , "A9768B92-225F-49C8-B2D1-D572E1BD93DB@gmail.com" , "3BBED4DB-4944-4D4D-8603-A9E122B108B9@fastmail.fm" , "4C94F89B-CEDF-4480-8043-ED80AE0EB76A@eggerapps.at" , "B834ABFE-0DB7-426F-B932-74CD7884E46F@icloud.com" , "D58261F7-759A-4B10-84BE-A7882D50C7A5@owensd.io" , "0FEC8813-07C3-48E2-8D76-D0EF7709DA8E@tarantsov.com" , "6C13EC21-3BF0-4633-ABAB-C91322598ABC@apple.com" , "50765AC5-1CFE-406D-9CB5-B28ABBEB84ED@fastmail.fm" , "C64EC68B-1BBE-498A-937A-257E01314DEB@apple.com" , "CALkjWZu1S0ykcnenz_Z0AEuaiyeyTpxSYRMwknqeRxJAxnJT7w@mail.gmail.com" , "CAPrQK3CZy45bfx7qTgJoCH6pkocd_9sPTc0CNrAvsrRM6Vixkg@mail.gmail.com" , "CAB056B2-A975-45B3-93BD-14DE06903042@gmail.com" , "6FDA08B7-192F-42F2-BD2F-F7980463C833@novafore.com" , "40273CEA-F386-47C3-9314-C355B2E320CB@gmail.com" , "CANGnqV1WfTHxgfk4PNTQozU31EAa7z4MZF7d0gc058F4_=EtcQ@mail.gmail.com" , "C9FD779C-AF2C-466C-B741-34D40FB47413@icloud.com" , "48DEE2AB-7D93-47AC-9296-42AD9DD987E2@gmail.com" , "A4DFD8C0-135E-4B40-A264-B7FBCD07D322@fastmail.fm" , "CALkjWZvopih52vGsUfsqzrsEPP-G02eDg=8+EKLrpCMNciW+gA@mail.gmail.com" , "CALkjWZsMC7daCZHg_SDw=EiySCZtN7knDqVhXiF6+3dKTZZTGA@mail.gmail.com" , "CAEEOKET4Ud0bbSW_-Ss6V08tLy2YhF3n1TvQ06Xk5Jjak5-GHg@mail.gmail.com" , "CAAcV4sYaK4=N=ePDkHKbiodYp3HfiHW2yFxWs0A9Rt7LJ8DYvg@mail.gmail.com" , "CAAcV4sbOpH=sbPePnKhcHNXFy-YbPubUvF5PDaoLN_Rs8yL_rw@mail.gmail.com" , "C0B48136-1470-48EB-89D8-CD1B6F8553B1@apple.com" , "7227A933-1AFF-4470-90CB-2880776CEF03@fastmail.fm" , "3017B038-022E-4E46-8ABD-74873DC4C14C@icloud.com" , "CAAcV4sZ=8N3FDgo5aJT50dPwBh=SjM5NTSFgiT6OgSGcbsdcKg@mail.gmail.com" , "A2116BA7-633C-40BA-B7EF-B6A69582C2A3@icloud.com" , "9B4EA1B7-9D30-4B60-9AD0-34119EB9837D@apple.com" , "4BBB2771-4817-4BF3-919D-D7E14826C38D@apple.com" , "D17C306A-4934-4D72-B4FA-E7897B8E82B1@gmail.com" , "99FBC506-E086-4609-8585-42CA7E7E9852@apple.com" , "CAB5C60u6fSAaFgWDw2MY-PP1sJDEDqGRObqF+WwiHoXYvTwwZg@mail.gmail.com" , "3F9131C9-B757-4211-AED4-8E71E3CE9810@anandabits.com" , "EC7C2819-0125-437D-8940-1E3F610B500D@icloud.com" , "38E32460-C46B-428A-91A1-37A74D863127@gmail.com" , "CAAcV4sZZt8mwh9_rixfQ3dAdrPV77=uuqsAvdBM5f90K8sb6hw@mail.gmail.com" , "473B2AAA-7AE4-4B09-B013-6EE9CA6AB2AA@gmail.com" , "32A23B96-9CCC-4114-8939-07EE62E7B6AC@apple.com" , "A5DF87B9-47F1-4A2D-A51B-27CB3221912D@apple.com" , "028924F8-3DD9-40F9-A907-C4DB2344043B@gmail.com" , "CAB5C60tv0=-aBnPzwDCAp8oE8Km+tB6huYPxTrZNi=ObBKXAww@mail.gmail.com" , "CAB5C60sGJPaYPFtEoKB0DC-6A11LogCQAOCeZ-C6dvkmMd2oyg@mail.gmail.com" , "277EE0B5-01B3-48CE-992F-AE838034C0F1@apple.com" , "897A3F1D-1BCB-41B3-9096-0E46DEFA844A@apple.com" , "CAB5C60vD=QyN6LqyKU431jUSQQbuBEJcGiHkwq=+nRmTFhbU9A@mail.gmail.com" , "F4ED804A-2DC1-48DE-AD7C-DBE2A0BEF047@apple.com" , "81AA5235-A524-4F1A-AAA0-EB44BFFB0FEC@architechies.com" , "34A6EE6D-AECF-4887-BEB8-0D841C7CB1F2@icloud.com" , "CAAcV4sYZ6JoLy+=XKStCyh-XTJVmttrBZvqTuNq=Decsv2NEzg@mail.gmail.com" , "F5E748B4-BD58-408D-9330-DE255B9531E9@icloud.com" , "CACOvyQXZ1-qfbz7=0R1iXudZQdFMHPPQ2GVv_5DKwFEvZEF2pA@mail.gmail.com" , "27C9213F-B866-4A98-B0DC-E1492700B28B@apple.com" , "AE17F2D6-0107-4F61-AE13-01E5236ED770@apple.com" , "C320EC78-2D4E-46A8-90ED-4175F5B80072@gmail.com" , "CAB5C60szP8_2p8qqX13ph3wDQU6iRM0P09hVmXu7ar9SvRN+vw@mail.gmail.com" , "15A5CF07-DAED-4B92-A983-D88C2FA6BC8E@gmail.com" , "2822BF6F-172E-4003-B1A4-FB1C518CB701@googlemail.com" , "414E3C0D-EEC1-4005-8D68-5CA91EBADD0F@gmail.com" , "72FA697D-D1C9-4E73-B554-7313DC940D4B@apple.com" , "63C561FE-B75F-4A9B-8DF6-B2335D4C03CB@apple.com" , "CAEEOKEQyUwgvkEvPu2Xv_xAEJWiMTgGtv=KdY-2gkzhJXR7D4A@mail.gmail.com" , "A5DE0BD4-E526-4682-82B0-9B541CEF1C15@gmail.com" , "CAB5C60tn=nNstD2ke_RACYJsmAVvWQx-vJV=PfhqsOgaKx9pfw@mail.gmail.com" , "30B4EAF6-C852-4691-B397-24086AE1F9D9@icloud.com" , "1E2BDCE0-2132-40E8-96BC-BA51233281C7@novafore.com" , "C5F7CACF-736F-4794-B38E-0BE409F96835@novafore.com" , "FAEB0D09-1CB7-4706-B4CC-43DF40A2D243@apple.com" , "03C1FF36-43C3-46D1-88A1-3ECDCBB56567@gmail.com" , "CAB5C60sXr46WbfmaUctNKfWk01G_4pHgktykf4dJQZDbQ1QPWA@mail.gmail.com" , "4FB8F138-A0EF-4DDF-9AAD-A7172195F469@novafore.com" , "0C330020-F7D9-45D0-9B2D-E4DAD3AE105C@anandabits.com" , "CAB5C60vXzip01M6r62uQdkrXCxfBaQPgU7tdHsz+0Tu0i4Zksw@mail.gmail.com" , "BED20179-20C3-4F3A-B5D5-5E09286333F5@anandabits.com" , "E09BFA74-9DDF-4607-B52B-6C8EEC931D1F@gmail.com" , "1449374024.2155187.459254033.067DF6CC@webmail.messagingengine.com" , "CADcs6kN7gAr8x9ZbHBSX9gpOoJps=21wi-9ZC7hbtHUtRp54HA@mail.gmail.com" , "1449377752.2181216.459275089.1BA7CBAC@webmail.messagingengine.com" , "D9EA05A0-B3E8-4437-A0D1-F1FC27B0E124@gmail.com" , "CAKCGC8CWGc1L0fsc7TtzDeCqu5bxPX3q3MMZCw+2HPGuPHHC1A@mail.gmail.com" , "7D68F57E-C847-4E0D-AF3A-FD1F2DC928A9@icloud.com" , "1449429569.1342623.459603529.32C935BC@webmail.messagingengine.com" , "11462DA4-ACDD-4CF3-BD57-47886B655970@anandabits.com" , "CAKCGC8AVDe6W9X=XvFEnbkae8xom2Us8xczKFShqKu2+kPnRJA@mail.gmail.com" , "0DF0732F-0958-47C1-A6C3-62A8AB2F4386@icloud.com" , "CAKCGC8BEzyEPAFWCPKPiH+UL3KmZm7aM6KUPu-F9DKV-YvUbCA@mail.gmail.com" , "4A5C6452-0A1B-42A3-AFD4-3DEA04E310C6@icloud.com" , "6DA2FDFF-F978-4ECA-9E2B-F757F6D8BBF3@icloud.com" , "2116BFD1-25BC-4B9F-A3A6-08758782BB88@anandabits.com" , "C919D677-30C0-4F1E-B221-9B28365D67A9@gmail.com" , "CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com" , "49EEA2E6-55F2-49DE-A59F-A13017626370@web.de"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com"}} , "_id" : "CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com" , "from" : "alexl.mail+swift at gmail.com (Alex Lew)" , "mailingList" : "swift-evolution" , "content" : "I don't think you can just get rid of the if statement in favor of an\nexpression. You still want to be able to do this:\n\nif (condition) {\n    funcWithSideEffectsThatReturnsInt()\n} else {\n    funcWithSideEffectsThatReturnsString()\n}\n\nbut that's not a valid expression (what is its type?).\n\nOn Sat, Dec 5, 2015 at 7:24 PM, Ole Begemann via swift-evolution <\nswift-evolution at swift.org> wrote:\n\n> Yeah, returning an optional is a good idea.\n>\n> > On 06 Dec 2015, at 01:22, Adam C. Lickel <adam at lickel.com> wrote:\n> >\n> > In that situation, the if statement could return a Void? where the else\n> implicitly returns nil\n> >\n> >> On Dec 5, 2015, at 3:12 PM, Ole Begemann via swift-evolution <\n> swift-evolution at swift.org> wrote:\n> >>\n> >>>> This is subtle and requires thought\n> >>>\n> >>> What do you envision as the pitfalls of the design thinking behind\n> if/switch expressions? I’m not a compiler programmer, but a prog-lang\n> enthusiast. I wouldn’t mind a little nudge in the right direction.\n> >>\n> >> One thing that comes to mind is that if \"if\" is an expression, every if\n> needs an else branch. This makes it harder to use if to conditionally\n> perform side effects. For example, this is currently valid:\n> >>\n> >> func doSomething() { ... }\n> >>\n> >> if condition {\n> >>   doSomething()\n> >> }\n> >>\n> >> Should this be allowed? You could argue that this should work because\n> (a) the expression result is unused and (b) the return type of doSomething\n> is Void, so the compiler could conceivably implicitly construct an else\n> branch that returns (). But it would be inconsistent with other\n> expressions. Disallowing this style could make writing typical \"imperative\"\n> code harder.\n> >>\n> >> – Ole\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000467.html" , "inReplyTo" : "49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net" , "date" : { "$date" : 1449361690000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com" , "CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com" , "C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com" , "18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com" , "2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io" , "BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com" , "CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com" , "CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com" , "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com" , "BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com" , "909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net" , "0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com" , "49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net"] , "descendants" : [ "D381E334-74B7-41EC-90BF-544A925D2204@icloud.com" , "D9043847-2CF1-40A8-9BDD-2C0DCCAB5A38@supmenow.com" , "EAEE8B4A-12A2-4FD6-BA7B-B26071F08489@gmail.com" , "CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com" , "4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com" , "CAAcV4sbQxUywKAHE=3SCACEFH4YvUqjwEr_0=fjf59ndZtoedg@mail.gmail.com" , "07270E34-E284-4FF0-B2EA-6DBB54FF78B5@portableinnovations.de" , "67057217-F4BC-4584-8B52-8EBA2CFA8CC7@portableinnovations.de" , "45B71AF5-DD4F-4E9C-A128-5B8041917564@me.com" , "CAKCGC8BmmCk55=6UC_qk_C+ZNq2JfGpOPO5cJ=SK2784kmvbGg@mail.gmail.com" , "B6DDD94B-0755-4D40-94F0-D2469A644818@portableinnovations.de" , "CAKCGC8AerqpPTrwdmPAvhmp-fLt-v=LXw4z0t+2o93g9GmAaxw@mail.gmail.com" , "54E5D8F5-616D-41EB-A550-E639FE861575@gmail.com" , "CAKCGC8CsJ7g_Fu8fnQ5Mv=yAzbSvb0Z+iNmdXKnJaAcWR2UKuw@mail.gmail.com" , "6830F74D-78FC-4B20-A6D5-683185B30164@gmail.com" , "691A92C4-1A5F-4CAE-AF50-F6AAA3A3F32C@portableinnovations.de" , "D35074A6-1C34-4BA3-AAF1-8CFE1992A522@me.com" , "1EE735A6-FF0F-4E49-BE7D-AC7E6C8A87EC@tarantsov.com" , "3D250DE5-09BC-4A6B-AF59-E1D714DF709A@tarantsov.com" , "BB6A4434-E2B1-4192-8450-90D636E6A7F5@fastmail.fm" , "0ED79E6D-A89A-4F3E-9269-6216BD10EB22@sealedabstract.com" , "CAAcV4sb9eMhuLGL3QsBw4bFxj1FQrokCAanKjEFRNNReE8zWOQ@mail.gmail.com" , "7253CF12-DBD4-483D-941F-04851E5AD394@tarantsov.com" , "CAAcV4sbo4=Hdzp+yx-km-CnhNDm2uQ-gDJsvdug_Pg-MjTPC=Q@mail.gmail.com" , "CAAcV4sbAk_eSdjz7bQ6ggdZNE+thmj7-wT_pG2+eRMKDVba+wA@mail.gmail.com" , "B619CC7E-59A8-4B3C-8E46-FC7FD4C4C6E6@apple.com" , "2372BF92-E97D-40C3-8FEC-0CA9B00ACACE@icloud.com" , "BB1D04A8-2E17-497F-AE74-8FDE4AEC4D77@fastmail.fm" , "2F722DE2-D3AE-44D5-83BB-CBCD371801AD@icloud.com" , "7B70F158-5B8A-425B-980C-CD08210342D4@me.com" , "FDB72AC4-0B0A-4D0F-A9D2-FFE43A55362E@gmail.com" , "9E0141FF-8B3B-4736-88EE-11F05930D149@fastmail.fm" , "CAAcV4sba2j1hOrBJO1kmLpLcjwSQoE0LUejbdNxa05zFzUmi3g@mail.gmail.com" , "DE316C42-6FA7-4A60-80C2-AFF74844EF09@fastmail.fm" , "33B028BA-EB5F-4986-9F16-3057390C3F16@gmail.com" , "BB8653D1-400D-49BC-AA77-6ECC096747B3@icloud.com" , "54B5FAEC-8636-44C5-96A2-0401999DD5D2@gmail.com" , "D679F068-B7C8-4DF2-A7E6-4D78B74F6B17@tarantsov.com" , "DDCE4FC9-2DED-45E5-8D9B-CAB2AA8CF9E6@gmail.com" , "C1C319DB-3934-40B6-ABEE-51B07463E6EF@upzzle.com" , "1C3ADBD7-D4CD-417A-AC45-029D7A889812@fastmail.fm" , "39024D06-E664-42EB-9E68-4D3E5BDC577D@anandabits.com" , "CAE+=ROVg0cJVKnSdwB=KPrEtr=GYd+PMMaOvbCj=N0RtUT=Q6A@mail.gmail.com" , "CAE+=ROVUD1ECe9yHG8kMW0skCFV0=BK70rw+5V7rNHEfmGhNjQ@mail.gmail.com" , "C04621E1-91D2-4A7D-9F9C-58F862B38355@icloud.com" , "581FE433-8169-4D61-9C3F-D90DAD600B9B@icloud.com" , "DB890044-1DAF-4832-8380-F78F61FBC96D@uzh.ch" , "CAE+=ROXg+tM0VYn1bscairmM9sQQ0nh1tYb4SexyWnM7TbeyaA@mail.gmail.com" , "CAE+=ROX9M8XSU8reKMf=RNCwu4Xu95V0G9W9T=Xr0nc8KerHjw@mail.gmail.com" , "CAAcV4sZKJg+x0v4rc1h=ydKE+EFEjanyBnqm8BWO=za-fF+jXA@mail.gmail.com" , "B017EE8F-7732-448E-80AB-7694904D28B4@icloud.com" , "D6AA07FC-261F-4D09-BC32-9FF7792659EC@eggerapps.at" , "CAE+=ROWf2XT2mxM5uWJCjz1Q3wZB71w=svWmGgX5v2=Y2rLzNw@mail.gmail.com" , "EB862217-2E54-4503-9C0C-DD943D428880@gmail.com" , "E0FCC493-27B9-499C-9884-4E00DB831131@gmail.com" , "934A39F6-ECB6-405B-8EF6-97E3C55604AD@uzh.ch" , "5824A613-F216-400B-AD16-9D368FA3A397@gmail.com" , "29A77367-05BF-4667-B25F-C06F520D0CB5@fastmail.fm" , "5525CD3F-062A-4ECB-809F-1964AE645CFC@gmail.com" , "CALkjWZsKQUQc0oDMkru8YGRv5rqOeqXF=4HnU2V0wo_5Q8SjnQ@mail.gmail.com" , "047B4955-1E5A-4A77-BAE3-63E8633A3AE1@gmail.com" , "CAE+=ROWxmKEic9DxN+CXyf=O7AtxgoHox5tSM1SCy_6E0ODphQ@mail.gmail.com" , "A7043ACA-9CE9-4739-919F-93F65FE7273B@gmail.com" , "6137630B-E3E8-45C6-AB48-FABFE9586EA9@me.com" , "CBB03FEA-50E2-4D7B-92B5-FB8A74B6719A@icloud.com" , "28E69DC8-4663-4FB6-8F99-F645E5D3F960@gmail.com" , "CAAcV4sZRQkVeBSqHv8UE_SJh-oEzZ74W6zd+sYxwEKhYZYsfxA@mail.gmail.com" , "CAAcV4sbakzYnefbui=hYKRDTMkrN_s1hFTn3CLwZUzWWa0M3LA@mail.gmail.com" , "63683E0A-B1FE-42A1-9878-FFEA34D1B993@gmail.com" , "CAAcV4sY8O=z5TL41vMoW3rKCHEWH3ikD8ZVJu-AEgVBYx-JXsA@mail.gmail.com" , "CAAcV4sbgPfRGZcU2U3fHcN2nky_ZqhCspWkz9DXYCjXyZFhvOQ@mail.gmail.com" , "A97ACA91-183C-41D9-ACEF-61B74D51E5BA@icloud.com" , "A9768B92-225F-49C8-B2D1-D572E1BD93DB@gmail.com" , "3BBED4DB-4944-4D4D-8603-A9E122B108B9@fastmail.fm" , "4C94F89B-CEDF-4480-8043-ED80AE0EB76A@eggerapps.at" , "B834ABFE-0DB7-426F-B932-74CD7884E46F@icloud.com" , "D58261F7-759A-4B10-84BE-A7882D50C7A5@owensd.io" , "0FEC8813-07C3-48E2-8D76-D0EF7709DA8E@tarantsov.com" , "6C13EC21-3BF0-4633-ABAB-C91322598ABC@apple.com" , "50765AC5-1CFE-406D-9CB5-B28ABBEB84ED@fastmail.fm" , "C64EC68B-1BBE-498A-937A-257E01314DEB@apple.com" , "CALkjWZu1S0ykcnenz_Z0AEuaiyeyTpxSYRMwknqeRxJAxnJT7w@mail.gmail.com" , "CAPrQK3CZy45bfx7qTgJoCH6pkocd_9sPTc0CNrAvsrRM6Vixkg@mail.gmail.com" , "CAB056B2-A975-45B3-93BD-14DE06903042@gmail.com" , "6FDA08B7-192F-42F2-BD2F-F7980463C833@novafore.com" , "40273CEA-F386-47C3-9314-C355B2E320CB@gmail.com" , "CANGnqV1WfTHxgfk4PNTQozU31EAa7z4MZF7d0gc058F4_=EtcQ@mail.gmail.com" , "C9FD779C-AF2C-466C-B741-34D40FB47413@icloud.com" , "48DEE2AB-7D93-47AC-9296-42AD9DD987E2@gmail.com" , "A4DFD8C0-135E-4B40-A264-B7FBCD07D322@fastmail.fm" , "CALkjWZvopih52vGsUfsqzrsEPP-G02eDg=8+EKLrpCMNciW+gA@mail.gmail.com" , "CALkjWZsMC7daCZHg_SDw=EiySCZtN7knDqVhXiF6+3dKTZZTGA@mail.gmail.com" , "CAEEOKET4Ud0bbSW_-Ss6V08tLy2YhF3n1TvQ06Xk5Jjak5-GHg@mail.gmail.com" , "CAAcV4sYaK4=N=ePDkHKbiodYp3HfiHW2yFxWs0A9Rt7LJ8DYvg@mail.gmail.com" , "CAAcV4sbOpH=sbPePnKhcHNXFy-YbPubUvF5PDaoLN_Rs8yL_rw@mail.gmail.com" , "C0B48136-1470-48EB-89D8-CD1B6F8553B1@apple.com" , "7227A933-1AFF-4470-90CB-2880776CEF03@fastmail.fm" , "3017B038-022E-4E46-8ABD-74873DC4C14C@icloud.com" , "CAAcV4sZ=8N3FDgo5aJT50dPwBh=SjM5NTSFgiT6OgSGcbsdcKg@mail.gmail.com" , "A2116BA7-633C-40BA-B7EF-B6A69582C2A3@icloud.com" , "9B4EA1B7-9D30-4B60-9AD0-34119EB9837D@apple.com" , "4BBB2771-4817-4BF3-919D-D7E14826C38D@apple.com" , "D17C306A-4934-4D72-B4FA-E7897B8E82B1@gmail.com" , "99FBC506-E086-4609-8585-42CA7E7E9852@apple.com" , "CAB5C60u6fSAaFgWDw2MY-PP1sJDEDqGRObqF+WwiHoXYvTwwZg@mail.gmail.com" , "3F9131C9-B757-4211-AED4-8E71E3CE9810@anandabits.com" , "EC7C2819-0125-437D-8940-1E3F610B500D@icloud.com" , "38E32460-C46B-428A-91A1-37A74D863127@gmail.com" , "CAAcV4sZZt8mwh9_rixfQ3dAdrPV77=uuqsAvdBM5f90K8sb6hw@mail.gmail.com" , "473B2AAA-7AE4-4B09-B013-6EE9CA6AB2AA@gmail.com" , "32A23B96-9CCC-4114-8939-07EE62E7B6AC@apple.com" , "A5DF87B9-47F1-4A2D-A51B-27CB3221912D@apple.com" , "028924F8-3DD9-40F9-A907-C4DB2344043B@gmail.com" , "CAB5C60tv0=-aBnPzwDCAp8oE8Km+tB6huYPxTrZNi=ObBKXAww@mail.gmail.com" , "CAB5C60sGJPaYPFtEoKB0DC-6A11LogCQAOCeZ-C6dvkmMd2oyg@mail.gmail.com" , "277EE0B5-01B3-48CE-992F-AE838034C0F1@apple.com" , "897A3F1D-1BCB-41B3-9096-0E46DEFA844A@apple.com" , "CAB5C60vD=QyN6LqyKU431jUSQQbuBEJcGiHkwq=+nRmTFhbU9A@mail.gmail.com" , "F4ED804A-2DC1-48DE-AD7C-DBE2A0BEF047@apple.com" , "81AA5235-A524-4F1A-AAA0-EB44BFFB0FEC@architechies.com" , "34A6EE6D-AECF-4887-BEB8-0D841C7CB1F2@icloud.com" , "CAAcV4sYZ6JoLy+=XKStCyh-XTJVmttrBZvqTuNq=Decsv2NEzg@mail.gmail.com" , "F5E748B4-BD58-408D-9330-DE255B9531E9@icloud.com" , "CACOvyQXZ1-qfbz7=0R1iXudZQdFMHPPQ2GVv_5DKwFEvZEF2pA@mail.gmail.com" , "27C9213F-B866-4A98-B0DC-E1492700B28B@apple.com" , "AE17F2D6-0107-4F61-AE13-01E5236ED770@apple.com" , "C320EC78-2D4E-46A8-90ED-4175F5B80072@gmail.com" , "CAB5C60szP8_2p8qqX13ph3wDQU6iRM0P09hVmXu7ar9SvRN+vw@mail.gmail.com" , "15A5CF07-DAED-4B92-A983-D88C2FA6BC8E@gmail.com" , "2822BF6F-172E-4003-B1A4-FB1C518CB701@googlemail.com" , "414E3C0D-EEC1-4005-8D68-5CA91EBADD0F@gmail.com" , "72FA697D-D1C9-4E73-B554-7313DC940D4B@apple.com" , "63C561FE-B75F-4A9B-8DF6-B2335D4C03CB@apple.com" , "CAEEOKEQyUwgvkEvPu2Xv_xAEJWiMTgGtv=KdY-2gkzhJXR7D4A@mail.gmail.com" , "A5DE0BD4-E526-4682-82B0-9B541CEF1C15@gmail.com" , "CAB5C60tn=nNstD2ke_RACYJsmAVvWQx-vJV=PfhqsOgaKx9pfw@mail.gmail.com" , "30B4EAF6-C852-4691-B397-24086AE1F9D9@icloud.com" , "1E2BDCE0-2132-40E8-96BC-BA51233281C7@novafore.com" , "C5F7CACF-736F-4794-B38E-0BE409F96835@novafore.com" , "FAEB0D09-1CB7-4706-B4CC-43DF40A2D243@apple.com" , "03C1FF36-43C3-46D1-88A1-3ECDCBB56567@gmail.com" , "CAB5C60sXr46WbfmaUctNKfWk01G_4pHgktykf4dJQZDbQ1QPWA@mail.gmail.com" , "4FB8F138-A0EF-4DDF-9AAD-A7172195F469@novafore.com" , "0C330020-F7D9-45D0-9B2D-E4DAD3AE105C@anandabits.com" , "CAB5C60vXzip01M6r62uQdkrXCxfBaQPgU7tdHsz+0Tu0i4Zksw@mail.gmail.com" , "BED20179-20C3-4F3A-B5D5-5E09286333F5@anandabits.com" , "E09BFA74-9DDF-4607-B52B-6C8EEC931D1F@gmail.com" , "1449374024.2155187.459254033.067DF6CC@webmail.messagingengine.com" , "CADcs6kN7gAr8x9ZbHBSX9gpOoJps=21wi-9ZC7hbtHUtRp54HA@mail.gmail.com" , "1449377752.2181216.459275089.1BA7CBAC@webmail.messagingengine.com" , "D9EA05A0-B3E8-4437-A0D1-F1FC27B0E124@gmail.com" , "CAKCGC8CWGc1L0fsc7TtzDeCqu5bxPX3q3MMZCw+2HPGuPHHC1A@mail.gmail.com" , "7D68F57E-C847-4E0D-AF3A-FD1F2DC928A9@icloud.com" , "1449429569.1342623.459603529.32C935BC@webmail.messagingengine.com" , "11462DA4-ACDD-4CF3-BD57-47886B655970@anandabits.com" , "CAKCGC8AVDe6W9X=XvFEnbkae8xom2Us8xczKFShqKu2+kPnRJA@mail.gmail.com" , "0DF0732F-0958-47C1-A6C3-62A8AB2F4386@icloud.com" , "CAKCGC8BEzyEPAFWCPKPiH+UL3KmZm7aM6KUPu-F9DKV-YvUbCA@mail.gmail.com" , "4A5C6452-0A1B-42A3-AFD4-3DEA04E310C6@icloud.com" , "6DA2FDFF-F978-4ECA-9E2B-F757F6D8BBF3@icloud.com" , "2116BFD1-25BC-4B9F-A3A6-08758782BB88@anandabits.com" , "C919D677-30C0-4F1E-B221-9B28365D67A9@gmail.com" , "49EEA2E6-55F2-49DE-A59F-A13017626370@web.de"]} , { "_links" : { "self" : { "href" : "/charter/emails/E09BFA74-9DDF-4607-B52B-6C8EEC931D1F@gmail.com"}} , "_id" : "E09BFA74-9DDF-4607-B52B-6C8EEC931D1F@gmail.com" , "from" : "ahti333 at gmail.com (Lukas Stabe)" , "mailingList" : "swift-evolution" , "content" : "> I don't think you can just get rid of the if statement in favor of an expression. You still want to be able to do this:\n> \n> if (condition) {\n>     funcWithSideEffectsThatReturnsInt()\n> } else {\n>     funcWithSideEffectsThatReturnsString()\n> }\n> \n> but that's not a valid expression (what is its type?).\n\nAn if statement with two different types could just have the closes common ancestor or Any as type.\n\n> Yeah, returning an optional is a good idea.\n\nThis would, interestingly, make the else statement very similar to the optional-chaining operator ?? with the small difference that the second argument is a block (and does ?? autoclosure the second arg?)." , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000468.html" , "inReplyTo" : "CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com" , "date" : { "$date" : 1449361971000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com" , "CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com" , "C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com" , "18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com" , "2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io" , "BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com" , "CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com" , "CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com" , "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com" , "BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com" , "909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net" , "0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com" , "49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net" , "CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com"] , "descendants" : [ "1449374024.2155187.459254033.067DF6CC@webmail.messagingengine.com" , "CADcs6kN7gAr8x9ZbHBSX9gpOoJps=21wi-9ZC7hbtHUtRp54HA@mail.gmail.com" , "1449377752.2181216.459275089.1BA7CBAC@webmail.messagingengine.com" , "D9EA05A0-B3E8-4437-A0D1-F1FC27B0E124@gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAM4Nbbyi_icanvi5Nv-3pGUnd9kTWr7wdb4Qbvx+Mp=j+j6u-Q@mail.gmail.com"}} , "_id" : "CAM4Nbbyi_icanvi5Nv-3pGUnd9kTWr7wdb4Qbvx+Mp=j+j6u-Q@mail.gmail.com" , "from" : "tomas at linhart.me (=?UTF-8?B?VG9tw6HFoSBMaW5oYXJ0?=)" , "mailingList" : "swift-evolution" , "content" : "Hello,\n\nvery often, it is necessary to define stored properties in extensions. It\nis currently only possible in Swift that has access to ObjC runtime with\nassociated objects (in theory it might be possible with some global\ndictionary) and it requires a lot of boilerplate. Associated objects are\nused in UIKit quite heavily so it is something that authors of frameworks\nneed.\n\nIt would be nice to able to create properties in extensions natively in\nSwift without need of Objective-C and without a boilerplate. These\nproperties could be marked with some extra keyword/attribute so it is\nobvious they are different and they have a cost (depends on their\nimplementation).\n\nWhat do you think?\nTomáš" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000469.html" , "date" : { "$date" : 1449362043000} , "subject" : "[swift-evolution] Proposal: Stored properties in extensions" , "references" : [ ""] , "inReplyTo" :  null  , "descendants" : [ "CADcs6kO6y75x5JM+YFKy6UjV_VLbrGjZNGCE+gopp8sdLAKx5Q@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com"}} , "_id" : "C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com" , "from" : "loiclecrenier at icloud.com (=?utf-8?Q?Lo=C3=AFc_Lecrenier?=)" , "mailingList" : "swift-evolution" , "content" : "Hi everyone :)\n\nI propose introducing a new \"associated_type\" keyword that will replace \"typealias\" for declaring associated types in protocols.\nI remember being confused by associated types when I started using Swift, and I think one reason why was the use of the typealias keyword to define them.\nOne reason was that I thought I knew what typealias did, and so I didn't stop to learn what it did inside a protocol. An other reason was the difficulty of finding help when searching for \"typealias\" instead of \"associated types\".\nThen, when I thought I understood it, I started building an excessively protocol-oriented program as an exercise. And I still lost a lot of time fighting Swift by trying to use \"real\" typealias-es inside of protocols.\n\nConceptually, I had something like this:\n\nprotocol ProtA {\n   typealias Container : SequenceType\n}\nprotocol ProtB {\n   typealias AnOtherAssocType : ProtA\n   func foo(x: AnOtherAssocType.Container.Generator.Element, y: AnOtherAssocType.Container.Generator.Element) -> AnOtherAssocType.Container.Generator.Element\n}\n\nThe function foo is very difficult to read, so I wanted to use a shortcut to Element by doing this:\n\nprotocol ProtB {\n   typealias A : ProtA\n   typealias Element = A.Container.Generator.Element\n   func foo(x: Element, y: Element) -> Element\n}\n\nBut by doing so, I didn't create a shortcut to Element, but an associated type with a default value of Element. (right?)\nThen I tried to write extensions to ProtB where Element conforms to, say, Equatable, and couldn't make it work because A.Container.Generator.Element didn't conform to Equatable.\n\nSo, that was a rather long explanation of the reasons I think we should replace the typealias keyword by associated_type, and allow \"real\" typealias-es inside protocols.\n\nIdeally, I would write\n\nprotocol ProtB {\n   associated_type AnOtherAssocType : ProtA\n   typealias Element = AnOtherAssocType.Container.Generator.Element\n   func foo(x: Element, y: Element) -> Element\n}\n\nand it would be exactly the same as\n\nprotocol ProtB {\n   associated_type AnOtherAssocType : ProtA\n   func foo(x: A.Container.Generator.Element, y: A.Container.Generator.Element) -> A.Container.Generator.Element\n}\n\nThere are probably some problems created by this proposal, but right now I can't see any :/\n\nThanks,\n\nLoïc" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000470.html" , "date" : { "$date" : 1449362149000} , "subject" : "[swift-evolution] Introduce \"associated_type\" keyword" , "references" : [ ""] , "inReplyTo" :  null  , "descendants" : [ "6407A281-C936-40E3-B882-1E63279F4755@gmail.com" , "22C9CF03-BE4B-4F57-9009-042A9E582C80@icloud.com" , "A85887DB-0FD2-4B0A-B00A-79CA918DD532@icloud.com" , "CA+Y5xYfKpkHNwivagTALSqMc=WnGp=k7JxrMFV_-nGt2UiAsjA@mail.gmail.com" , "FE7A4F85-6EAD-42D4-8781-19F38941A70D@web.de" , "CAOFcyhuEjDgx-eVzvfujQAQx7A7uMRT6D-B+qi=9ZCduFt-xWg@mail.gmail.com" , "80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com" , "8A11B43C-8FB7-417C-B251-D63812545AE4@apple.com" , "BD192734-066B-4907-887C-0286D799CBE1@klundberg.com" , "554F869D-D9A3-4672-B0BA-3153B644C65B@gmail.com" , "64E52217-017C-437E-96BA-041FED8B923C@anandabits.com" , "CA+Y5xYfsqnR9JW4Xyo-R=HjryFW-1AjiUXmeZPVaeLiCZ0APeg@mail.gmail.com" , "B0BBB895-7654-489D-B36D-07F7F7B98B4F@icloud.com" , "3FE1A475-EEF7-460A-B841-F94D6C0EB3B4@alkaline-solutions.com" , "6BCA9015-28F4-4B1B-8AF5-84DFA9256949@icloud.com" , "3A2C2956-0C24-4838-84C0-B171C8F39F6F@icloud.com" , "9D8DFC81-ECB0-490A-82B0-3E3D01BF35A1@gmail.com" , "CAKCGC8Dr29Reis3NnK-MLE3MpswCC9fEU7=Eh3VTCOmj3TfAJw@mail.gmail.com" , "2FC53481-EF6F-4B06-92FB-283A65F000E3@icloud.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CADcs6kO6y75x5JM+YFKy6UjV_VLbrGjZNGCE+gopp8sdLAKx5Q@mail.gmail.com"}} , "_id" : "CADcs6kO6y75x5JM+YFKy6UjV_VLbrGjZNGCE+gopp8sdLAKx5Q@mail.gmail.com" , "from" : "jtbandes at gmail.com (Jacob Bandes-Storch)" , "mailingList" : "swift-evolution" , "content" : "Sometimes it's desirable to break up a type's implementation into multiple\nfiles, within the same module. So for this simple case, it make sense for\nstored properties to be allowed (within the same module), treating them as\ncontinuations of the original class/struct declaration with no additional\noverhead.\nOn Sat, Dec 5, 2015 at 4:34 PM Tomáš Linhart <swift-evolution at swift.org>\nwrote:\n\n> Hello,\n>\n> very often, it is necessary to define stored properties in extensions. It\n> is currently only possible in Swift that has access to ObjC runtime with\n> associated objects (in theory it might be possible with some global\n> dictionary) and it requires a lot of boilerplate. Associated objects are\n> used in UIKit quite heavily so it is something that authors of frameworks\n> need.\n>\n> It would be nice to able to create properties in extensions natively in\n> Swift without need of Objective-C and without a boilerplate. These\n> properties could be marked with some extra keyword/attribute so it is\n> obvious they are different and they have a cost (depends on their\n> implementation).\n>\n> What do you think?\n> Tomáš\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000471.html" , "inReplyTo" : "CAM4Nbbyi_icanvi5Nv-3pGUnd9kTWr7wdb4Qbvx+Mp=j+j6u-Q@mail.gmail.com" , "date" : { "$date" : 1449362642000} , "subject" : "[swift-evolution] Proposal: Stored properties in extensions" , "references" : [ "CAM4Nbbyi_icanvi5Nv-3pGUnd9kTWr7wdb4Qbvx+Mp=j+j6u-Q@mail.gmail.com"] , "descendants" : [ "1449367270928.62d8b65@Nodemailer"]} , { "_links" : { "self" : { "href" : "/charter/emails/80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com"}} , "_id" : "80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com" , "from" : "rjmccall at apple.com (John McCall)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 5, 2015, at 4:35 PM, Loïc Lecrenier via swift-evolution <swift-evolution at swift.org> wrote:\n> Hi everyone :)\n> \n> I propose introducing a new \"associated_type\" keyword that will replace \"typealias\" for declaring associated types in protocols.\n> I remember being confused by associated types when I started using Swift, and I think one reason why was the use of the typealias keyword to define them.\n> One reason was that I thought I knew what typealias did, and so I didn't stop to learn what it did inside a protocol. An other reason was the difficulty of finding help when searching for \"typealias\" instead of \"associated types\".\n> Then, when I thought I understood it, I started building an excessively protocol-oriented program as an exercise. And I still lost a lot of time fighting Swift by trying to use \"real\" typealias-es inside of protocols.\n> \n> Conceptually, I had something like this:\n> \n> protocol ProtA {\n>   typealias Container : SequenceType\n> }\n> protocol ProtB {\n>   typealias AnOtherAssocType : ProtA\n>   func foo(x: AnOtherAssocType.Container.Generator.Element, y: AnOtherAssocType.Container.Generator.Element) -> AnOtherAssocType.Container.Generator.Element\n> }\n> \n> The function foo is very difficult to read, so I wanted to use a shortcut to Element by doing this:\n> \n> protocol ProtB {\n>   typealias A : ProtA\n>   typealias Element = A.Container.Generator.Element\n>   func foo(x: Element, y: Element) -> Element\n> }\n> \n> But by doing so, I didn't create a shortcut to Element, but an associated type with a default value of Element. (right?)\n> Then I tried to write extensions to ProtB where Element conforms to, say, Equatable, and couldn't make it work because A.Container.Generator.Element didn't conform to Equatable.\n> \n> So, that was a rather long explanation of the reasons I think we should replace the typealias keyword by associated_type, and allow \"real\" typealias-es inside protocols.\n\nI think this is a great idea; re-using typealias for associated types was a mistake.\n\nJohn.\n\n> \n> Ideally, I would write\n> \n> protocol ProtB {\n>   associated_type AnOtherAssocType : ProtA\n>   typealias Element = AnOtherAssocType.Container.Generator.Element\n>   func foo(x: Element, y: Element) -> Element\n> }\n> \n> and it would be exactly the same as\n> \n> protocol ProtB {\n>   associated_type AnOtherAssocType : ProtA\n>   func foo(x: A.Container.Generator.Element, y: A.Container.Generator.Element) -> A.Container.Generator.Element\n> }\n> \n> There are probably some problems created by this proposal, but right now I can't see any :/\n> \n> Thanks,\n> \n> Loïc\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000472.html" , "inReplyTo" : "C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com" , "date" : { "$date" : 1449362896000} , "subject" : "[swift-evolution] Introduce \"associated_type\" keyword" , "references" : [ "C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com"] , "descendants" : [ "6407A281-C936-40E3-B882-1E63279F4755@gmail.com" , "22C9CF03-BE4B-4F57-9009-042A9E582C80@icloud.com" , "A85887DB-0FD2-4B0A-B00A-79CA918DD532@icloud.com" , "CA+Y5xYfKpkHNwivagTALSqMc=WnGp=k7JxrMFV_-nGt2UiAsjA@mail.gmail.com" , "FE7A4F85-6EAD-42D4-8781-19F38941A70D@web.de" , "CAOFcyhuEjDgx-eVzvfujQAQx7A7uMRT6D-B+qi=9ZCduFt-xWg@mail.gmail.com" , "8A11B43C-8FB7-417C-B251-D63812545AE4@apple.com" , "BD192734-066B-4907-887C-0286D799CBE1@klundberg.com" , "554F869D-D9A3-4672-B0BA-3153B644C65B@gmail.com" , "64E52217-017C-437E-96BA-041FED8B923C@anandabits.com" , "CA+Y5xYfsqnR9JW4Xyo-R=HjryFW-1AjiUXmeZPVaeLiCZ0APeg@mail.gmail.com" , "B0BBB895-7654-489D-B36D-07F7F7B98B4F@icloud.com" , "3FE1A475-EEF7-460A-B841-F94D6C0EB3B4@alkaline-solutions.com" , "6BCA9015-28F4-4B1B-8AF5-84DFA9256949@icloud.com" , "3A2C2956-0C24-4838-84C0-B171C8F39F6F@icloud.com" , "9D8DFC81-ECB0-490A-82B0-3E3D01BF35A1@gmail.com" , "CAKCGC8Dr29Reis3NnK-MLE3MpswCC9fEU7=Eh3VTCOmj3TfAJw@mail.gmail.com" , "2FC53481-EF6F-4B06-92FB-283A65F000E3@icloud.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAEryqgjxxcHrPeP7rHYV--77upw_KzoiJSKQVR3K8GYeSo1FPA@mail.gmail.com"}} , "_id" : "CAEryqgjxxcHrPeP7rHYV--77upw_KzoiJSKQVR3K8GYeSo1FPA@mail.gmail.com" , "from" : "christopheramanse at gmail.com (Chris Amanse)" , "mailingList" : "swift-evolution" , "content" : "Here's a draft of the the proposal:\nhttps://gist.github.com/chrisamanse/2ab39e31e93d5c11d0b5\n\nOn Sun, Dec 6, 2015 at 7:52 AM Philippe Hausler <phausler at apple.com> wrote:\n\n> In all that seems like a pretty reasonable concept. Foundation is going to\n> be using the same evolution template as the rest of the Swift evolution\n> process; could you fill out a draft of that and I can help campion your\n> proposal to the component owner for NSDate and we can see how this will\n> fair with the rest of the Darwin side of things.\n>\n> As you can probably guess; operators are not taken lightly since they\n> exist in the global scope and it is good to consider the ramifications of\n> what even something as simple as comparison of dates has in general.\n>\n> On Dec 5, 2015, at 3:36 PM, Chris Amanse via swift-corelibs-dev <\n> swift-corelibs-dev at swift.org> wrote:\n>\n> Hello Swift Developers,\n>\n> I think it's a good idea to conform NSDate to the Comparable protocol, so\n> instead of using:\n>\n> if someDate.compare(today) == .OrderedAscending { }\n>\n> Developers can easily compare using compare dates using comparison\n> operators:\n>\n> if someDate < today { }\n>\n> In my opinion, the code is still readable if developers use comparison\n> operators on NSDates.\n>\n> Here's a quick implementation from my swift-corelibs-foundation fork:\n> https://github.com/chrisamanse/swift-corelibs-foundation/commit/3c4eff643c5271de5bec2461798051347be13916\n>\n> Thank you.\n>\n> _______________________________________________\n> swift-corelibs-dev mailing list\n> swift-corelibs-dev at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-corelibs-dev\n>\n>\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000473.html" , "inReplyTo" : "BFD76E85-4D4B-41C8-8457-4C438FBF7F8E@apple.com" , "date" : { "$date" : 1449362910000} , "subject" : "[swift-evolution] [swift-corelibs-dev] Proposal: Conforming NSDate to Comparable" , "references" : [ "CAEryqghYNO4JKWRGkF_qFTew7cGPtG7iNP32DndN1dOHLkjATQ@mail.gmail.com" , "BFD76E85-4D4B-41C8-8457-4C438FBF7F8E@apple.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/BD192734-066B-4907-887C-0286D799CBE1@klundberg.com"}} , "_id" : "BD192734-066B-4907-887C-0286D799CBE1@klundberg.com" , "from" : "kevin at klundberg.com (Kevin Lundberg)" , "mailingList" : "swift-evolution" , "content" : "Is it possible to do away with associated types and just use plain generic type declarations instead? This is one thing that kind of confuses me about the generics system. Coming from Java and c#, interfaces there are generic in the same way that classes (and structs in c#) are, and there are a lot of nice things we could get along with that if protocols were generic as part of their type declaration. Is there a compelling (technical or otherwise) reason to keep associated types as they are (to the exclusion of generic parameters) today that I'm missing?\n\nIf we must keep this concept, I would prefer something without an underscore for the keyword, like \"associatedtype\" or perhaps \"typeassociation\"\n--\nKevin Lundberg\n\nOn Dec 5, 2015, at 7:48 PM, John McCall via swift-evolution <swift-evolution at swift.org> wrote:\n\n>> On Dec 5, 2015, at 4:35 PM, Loïc Lecrenier via swift-evolution <swift-evolution at swift.org> wrote:\n>> Hi everyone :)\n>> \n>> I propose introducing a new \"associated_type\" keyword that will replace \"typealias\" for declaring associated types in protocols.\n>> I remember being confused by associated types when I started using Swift, and I think one reason why was the use of the typealias keyword to define them.\n>> One reason was that I thought I knew what typealias did, and so I didn't stop to learn what it did inside a protocol. An other reason was the difficulty of finding help when searching for \"typealias\" instead of \"associated types\".\n>> Then, when I thought I understood it, I started building an excessively protocol-oriented program as an exercise. And I still lost a lot of time fighting Swift by trying to use \"real\" typealias-es inside of protocols.\n>> \n>> Conceptually, I had something like this:\n>> \n>> protocol ProtA {\n>>  typealias Container : SequenceType\n>> }\n>> protocol ProtB {\n>>  typealias AnOtherAssocType : ProtA\n>>  func foo(x: AnOtherAssocType.Container.Generator.Element, y: AnOtherAssocType.Container.Generator.Element) -> AnOtherAssocType.Container.Generator.Element\n>> }\n>> \n>> The function foo is very difficult to read, so I wanted to use a shortcut to Element by doing this:\n>> \n>> protocol ProtB {\n>>  typealias A : ProtA\n>>  typealias Element = A.Container.Generator.Element\n>>  func foo(x: Element, y: Element) -> Element\n>> }\n>> \n>> But by doing so, I didn't create a shortcut to Element, but an associated type with a default value of Element. (right?)\n>> Then I tried to write extensions to ProtB where Element conforms to, say, Equatable, and couldn't make it work because A.Container.Generator.Element didn't conform to Equatable.\n>> \n>> So, that was a rather long explanation of the reasons I think we should replace the typealias keyword by associated_type, and allow \"real\" typealias-es inside protocols.\n> \n> I think this is a great idea; re-using typealias for associated types was a mistake.\n> \n> John.\n> \n>> \n>> Ideally, I would write\n>> \n>> protocol ProtB {\n>>  associated_type AnOtherAssocType : ProtA\n>>  typealias Element = AnOtherAssocType.Container.Generator.Element\n>>  func foo(x: Element, y: Element) -> Element\n>> }\n>> \n>> and it would be exactly the same as\n>> \n>> protocol ProtB {\n>>  associated_type AnOtherAssocType : ProtA\n>>  func foo(x: A.Container.Generator.Element, y: A.Container.Generator.Element) -> A.Container.Generator.Element\n>> }\n>> \n>> There are probably some problems created by this proposal, but right now I can't see any :/\n>> \n>> Thanks,\n>> \n>> Loïc\n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000474.html" , "inReplyTo" : "80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com" , "date" : { "$date" : 1449364302000} , "subject" : "[swift-evolution] Introduce \"associated_type\" keyword" , "references" : [ "C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com" , "80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com"] , "descendants" : [ "6407A281-C936-40E3-B882-1E63279F4755@gmail.com" , "22C9CF03-BE4B-4F57-9009-042A9E582C80@icloud.com" , "A85887DB-0FD2-4B0A-B00A-79CA918DD532@icloud.com" , "CA+Y5xYfKpkHNwivagTALSqMc=WnGp=k7JxrMFV_-nGt2UiAsjA@mail.gmail.com" , "FE7A4F85-6EAD-42D4-8781-19F38941A70D@web.de" , "CAOFcyhuEjDgx-eVzvfujQAQx7A7uMRT6D-B+qi=9ZCduFt-xWg@mail.gmail.com" , "554F869D-D9A3-4672-B0BA-3153B644C65B@gmail.com" , "64E52217-017C-437E-96BA-041FED8B923C@anandabits.com" , "CA+Y5xYfsqnR9JW4Xyo-R=HjryFW-1AjiUXmeZPVaeLiCZ0APeg@mail.gmail.com" , "B0BBB895-7654-489D-B36D-07F7F7B98B4F@icloud.com" , "3FE1A475-EEF7-460A-B841-F94D6C0EB3B4@alkaline-solutions.com" , "9D8DFC81-ECB0-490A-82B0-3E3D01BF35A1@gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/8A11B43C-8FB7-417C-B251-D63812545AE4@apple.com"}} , "_id" : "8A11B43C-8FB7-417C-B251-D63812545AE4@apple.com" , "from" : "clattner at apple.com (Chris Lattner)" , "mailingList" : "swift-evolution" , "content" : "On Dec 5, 2015, at 4:48 PM, John McCall via swift-evolution <swift-evolution at swift.org> wrote:\n\n>> On Dec 5, 2015, at 4:35 PM, Loïc Lecrenier via swift-evolution <swift-evolution at swift.org> wrote:\n>> Hi everyone :)\n>> \n>> I propose introducing a new \"associated_type\" keyword that will replace \"typealias\" for declaring associated types in protocols.\n>> I remember being confused by associated types when I started using Swift, and I think one reason why was the use of the typealias keyword to define them.\n>> One reason was that I thought I knew what typealias did, and so I didn't stop to learn what it did inside a protocol. An other reason was the difficulty of finding help when searching for \"typealias\" instead of \"associated types\".\n>> Then, when I thought I understood it, I started building an excessively protocol-oriented program as an exercise. And I still lost a lot of time fighting Swift by trying to use \"real\" typealias-es inside of protocols.\n>> \n>> Conceptually, I had something like this:\n>> \n>> protocol ProtA {\n>>  typealias Container : SequenceType\n>> }\n>> protocol ProtB {\n>>  typealias AnOtherAssocType : ProtA\n>>  func foo(x: AnOtherAssocType.Container.Generator.Element, y: AnOtherAssocType.Container.Generator.Element) -> AnOtherAssocType.Container.Generator.Element\n>> }\n>> \n>> The function foo is very difficult to read, so I wanted to use a shortcut to Element by doing this:\n>> \n>> protocol ProtB {\n>>  typealias A : ProtA\n>>  typealias Element = A.Container.Generator.Element\n>>  func foo(x: Element, y: Element) -> Element\n>> }\n>> \n>> But by doing so, I didn't create a shortcut to Element, but an associated type with a default value of Element. (right?)\n>> Then I tried to write extensions to ProtB where Element conforms to, say, Equatable, and couldn't make it work because A.Container.Generator.Element didn't conform to Equatable.\n>> \n>> So, that was a rather long explanation of the reasons I think we should replace the typealias keyword by associated_type, and allow \"real\" typealias-es inside protocols.\n> \n> I think this is a great idea; re-using typealias for associated types was a mistake.\n\nAgreed.\n\n-Chris\n\n\n\n\n> John.\n> \n>> \n>> Ideally, I would write\n>> \n>> protocol ProtB {\n>>  associated_type AnOtherAssocType : ProtA\n>>  typealias Element = AnOtherAssocType.Container.Generator.Element\n>>  func foo(x: Element, y: Element) -> Element\n>> }\n>> \n>> and it would be exactly the same as\n>> \n>> protocol ProtB {\n>>  associated_type AnOtherAssocType : ProtA\n>>  func foo(x: A.Container.Generator.Element, y: A.Container.Generator.Element) -> A.Container.Generator.Element\n>> }\n>> \n>> There are probably some problems created by this proposal, but right now I can't see any :/\n>> \n>> Thanks,\n>> \n>> Loïc\n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000475.html" , "inReplyTo" : "80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com" , "date" : { "$date" : 1449365601000} , "subject" : "[swift-evolution] Introduce \"associated_type\" keyword" , "references" : [ "C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com" , "80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/6407A281-C936-40E3-B882-1E63279F4755@gmail.com"}} , "_id" : "6407A281-C936-40E3-B882-1E63279F4755@gmail.com" , "from" : "stephen.celis at gmail.com (Stephen Celis)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 5, 2015, at 8:11 PM, Kevin Lundberg via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> If we must keep this concept, I would prefer something without an underscore for the keyword, like \"associatedtype\" or perhaps \"typeassociation\"\n\nOr merely \"associated\"." , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000476.html" , "inReplyTo" : "BD192734-066B-4907-887C-0286D799CBE1@klundberg.com" , "date" : { "$date" : 1449366229000} , "subject" : "[swift-evolution] Introduce \"associated_type\" keyword" , "references" : [ "C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com" , "80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com" , "BD192734-066B-4907-887C-0286D799CBE1@klundberg.com"] , "descendants" : [ "22C9CF03-BE4B-4F57-9009-042A9E582C80@icloud.com" , "A85887DB-0FD2-4B0A-B00A-79CA918DD532@icloud.com" , "CA+Y5xYfKpkHNwivagTALSqMc=WnGp=k7JxrMFV_-nGt2UiAsjA@mail.gmail.com" , "FE7A4F85-6EAD-42D4-8781-19F38941A70D@web.de" , "CAOFcyhuEjDgx-eVzvfujQAQx7A7uMRT6D-B+qi=9ZCduFt-xWg@mail.gmail.com" , "554F869D-D9A3-4672-B0BA-3153B644C65B@gmail.com" , "64E52217-017C-437E-96BA-041FED8B923C@anandabits.com" , "CA+Y5xYfsqnR9JW4Xyo-R=HjryFW-1AjiUXmeZPVaeLiCZ0APeg@mail.gmail.com" , "B0BBB895-7654-489D-B36D-07F7F7B98B4F@icloud.com" , "3FE1A475-EEF7-460A-B841-F94D6C0EB3B4@alkaline-solutions.com" , "9D8DFC81-ECB0-490A-82B0-3E3D01BF35A1@gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/554F869D-D9A3-4672-B0BA-3153B644C65B@gmail.com"}} , "_id" : "554F869D-D9A3-4672-B0BA-3153B644C65B@gmail.com" , "from" : "austinzheng at gmail.com (Austin Zheng)" , "mailingList" : "swift-evolution" , "content" : "I like \"associated\". Or maybe \"withtype\". Anything clear and without underscore.\n\nprotocol Foo {\n   associated T\n}\n\nprotocol Foo {\n  withtype T\n}\n\n> On Dec 5, 2015, at 5:43 PM, Stephen Celis via swift-evolution <swift-evolution at swift.org> wrote:\n> \n>> On Dec 5, 2015, at 8:11 PM, Kevin Lundberg via swift-evolution <swift-evolution at swift.org> wrote:\n>> \n>> If we must keep this concept, I would prefer something without an underscore for the keyword, like \"associatedtype\" or perhaps \"typeassociation\"\n> \n> Or merely \"associated\".\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000477.html" , "inReplyTo" : "6407A281-C936-40E3-B882-1E63279F4755@gmail.com" , "date" : { "$date" : 1449366412000} , "subject" : "[swift-evolution] Introduce \"associated_type\" keyword" , "references" : [ "C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com" , "80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com" , "BD192734-066B-4907-887C-0286D799CBE1@klundberg.com" , "6407A281-C936-40E3-B882-1E63279F4755@gmail.com"] , "descendants" : [ "FE7A4F85-6EAD-42D4-8781-19F38941A70D@web.de" , "64E52217-017C-437E-96BA-041FED8B923C@anandabits.com" , "B0BBB895-7654-489D-B36D-07F7F7B98B4F@icloud.com" , "9D8DFC81-ECB0-490A-82B0-3E3D01BF35A1@gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/92C8AF30-9249-4152-A24E-86496425BD4D@apple.com"}} , "_id" : "92C8AF30-9249-4152-A24E-86496425BD4D@apple.com" , "from" : "jgroff at apple.com (Joe Groff)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 5, 2015, at 12:35 PM, Kevin Ballard <kevin at sb.org> wrote:\n> \n> On Sat, Dec 5, 2015, at 04:30 AM, Michel Fortin wrote:\n>> Like this:\n>> \n>> \tview.action = \"_doSomething_UniqueSelector1234_currentModuleName_blahblah\"\n>> \n>> \textension NSObject {\n>> \t\tfunc _doSomething_UniqueSelector1234_currentModuleName_blahblah() {\n>> \t\t\tlet target = self\n>> \t\t\t(target as! MyObject).doSomething()\n>> \t\t}\n>> \t}\n>> \n>> (Joe Groff suggested it first.) This simply assumes the receiver will\n>> derive from NSObject. You also need to set a non-nil target. And note\n>> that the closure is context-free, meaning you can't capture variables\n>> with it.\n> \n> How is this type-safe? You're using as! in there (and silently ignoring\n> the message if the receiver is wrong wouldn't be any better). If I send\n> a selector to the wrong receiver, it's still going to crash.\n\nI think this would be better emitted like a category on MyObject than on NSObject.\n\n> This comes back to my fundamental argument, which is that\n> @convention(selector) looks like it's type-safe, but there's so many\n> holes and so many implicit coercions that need to be added that you can\n> drive a gigantic truck full of unsafety right through it without even\n> noticing.\n\nThere's plenty of useful space between \"no type safety\" and \"perfect type safety\", IMO.\n\n-Joe" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000479.html" , "inReplyTo" : "1449347746.2071795.459083425.1FD398E4@webmail.messagingengine.com" , "date" : { "$date" : 1449367236000} , "subject" : "[swift-evolution] Type-safe selectors" , "references" : [ "B4E7896A-ACC6-49C0-8E15-47418D012C0B@michelf.ca" , "2CA0197A-B5E5-466B-AF27-C552A998764E@apple.com" , "1449271642.2877123.458487961.609100F1@webmail.messagingengine.com" , "B70B24CB-485C-4A9B-8575-E391FBC8C263@apple.com" , "1449296613.1919415.458667425.16848C1F@webmail.messagingengine.com" , "8508E135-791E-4B88-A758-9208388DA878@michelf.ca" , "1449347746.2071795.459083425.1FD398E4@webmail.messagingengine.com"] , "descendants" : [ "1449372912.2146477.459241273.0F8138F3@webmail.messagingengine.com" , "1A62EBA8-4AC4-4F05-B486-F90194FE5740@michelf.ca"]} , { "_links" : { "self" : { "href" : "/charter/emails/1449367270928.62d8b65@Nodemailer"}} , "_id" : "1449367270928.62d8b65@Nodemailer" , "from" : "paulyoungonline at gmail.com (Paul Young)" , "mailingList" : "swift-evolution" , "content" : "There was some discussion about this recently on Twitter: https://twitter.com/jckarter/status/664257829633568768\n\nOn Sun, Dec 6, 2015 at 12:44 AM, Jacob Bandes-Storch via swift-evolution\n<swift-evolution at swift.org> wrote:\n\n> Sometimes it's desirable to break up a type's implementation into multiple\n> files, within the same module. So for this simple case, it make sense for\n> stored properties to be allowed (within the same module), treating them as\n> continuations of the original class/struct declaration with no additional\n> overhead.\n> On Sat, Dec 5, 2015 at 4:34 PM Tomáš Linhart <swift-evolution at swift.org>\n> wrote:\n>> Hello,\n>>\n>> very often, it is necessary to define stored properties in extensions. It\n>> is currently only possible in Swift that has access to ObjC runtime with\n>> associated objects (in theory it might be possible with some global\n>> dictionary) and it requires a lot of boilerplate. Associated objects are\n>> used in UIKit quite heavily so it is something that authors of frameworks\n>> need.\n>>\n>> It would be nice to able to create properties in extensions natively in\n>> Swift without need of Objective-C and without a boilerplate. These\n>> properties could be marked with some extra keyword/attribute so it is\n>> obvious they are different and they have a cost (depends on their\n>> implementation).\n>>\n>> What do you think?\n>> Tomáš\n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000478.html" , "inReplyTo" : "CADcs6kO6y75x5JM+YFKy6UjV_VLbrGjZNGCE+gopp8sdLAKx5Q@mail.gmail.com" , "date" : { "$date" : 1449367271000} , "subject" : "[swift-evolution] Proposal: Stored properties in extensions" , "references" : [ "CADcs6kO6y75x5JM+YFKy6UjV_VLbrGjZNGCE+gopp8sdLAKx5Q@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/64E52217-017C-437E-96BA-041FED8B923C@anandabits.com"}} , "_id" : "64E52217-017C-437E-96BA-041FED8B923C@anandabits.com" , "from" : "matthew at anandabits.com (Anandabits)" , "mailingList" : "swift-evolution" , "content" : "I like the proposal in general, but the snake case feels decidedly un-Swifty (although I like snake case personally it isn't the Swift convention and I do like strong conventions).\n\nSent from my iPad\n\n> On Dec 5, 2015, at 7:46 PM, Austin Zheng via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> I like \"associated\". Or maybe \"withtype\". Anything clear and without underscore.\n> \n> protocol Foo {\n>   associated T\n> }\n> \n> protocol Foo {\n>  withtype T\n> }\n> \n>>> On Dec 5, 2015, at 5:43 PM, Stephen Celis via swift-evolution <swift-evolution at swift.org> wrote:\n>>> \n>>> On Dec 5, 2015, at 8:11 PM, Kevin Lundberg via swift-evolution <swift-evolution at swift.org> wrote:\n>>> \n>>> If we must keep this concept, I would prefer something without an underscore for the keyword, like \"associatedtype\" or perhaps \"typeassociation\"\n>> \n>> Or merely \"associated\".\n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000480.html" , "inReplyTo" : "554F869D-D9A3-4672-B0BA-3153B644C65B@gmail.com" , "date" : { "$date" : 1449367698000} , "subject" : "[swift-evolution] Introduce \"associated_type\" keyword" , "references" : [ "C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com" , "80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com" , "BD192734-066B-4907-887C-0286D799CBE1@klundberg.com" , "6407A281-C936-40E3-B882-1E63279F4755@gmail.com" , "554F869D-D9A3-4672-B0BA-3153B644C65B@gmail.com"] , "descendants" : [ "B0BBB895-7654-489D-B36D-07F7F7B98B4F@icloud.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/90FCCED1-02A8-4842-8467-20B31D23AF63@apple.com"}} , "_id" : "90FCCED1-02A8-4842-8467-20B31D23AF63@apple.com" , "from" : "jgroff at apple.com (Joe Groff)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 5, 2015, at 11:34 AM, plx via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> Swift’s standard library's core collections' value-like, copy-on-write behavior is handy in the small, but they compose rather poorly with each other: if you have e.g. [K:Set<V>], and plan to mutate the “inner\" sets, it seems at present as if there is no way to avoid an unnecessary transient copy of each set for each mutation you perform upon it.\n> \n> Various workarounds/solutions exist but all are full of unfortunate tradeoffs and/or limited further composability; in concrete cases you can do alright, but it’s hard to craft a generic solution that doesn’t inadvertently reintroduce the problem you started-out trying to solve.\n> \n> Is anything currently on the roadmap to address this specifically — whether optimizer improvements, extended APIs, implementation adjustments, a `borrow` construct, or some other approach?\n> \n\nDo you have specific examples of problems you're trying to solve?\n\n-Joe" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000481.html" , "inReplyTo" : "C6420D4E-B7FF-4A40-B9CE-2FC92EEC6EFF@icloud.com" , "date" : { "$date" : 1449367808000} , "subject" : "[swift-evolution] Inquiry: Improved Composability of stdlib Collections?" , "references" : [ "C6420D4E-B7FF-4A40-B9CE-2FC92EEC6EFF@icloud.com"] , "descendants" : [ "A3773EB7-8ED6-4576-97BE-329A3BFB5CF4@icloud.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/B0BBB895-7654-489D-B36D-07F7F7B98B4F@icloud.com"}} , "_id" : "B0BBB895-7654-489D-B36D-07F7F7B98B4F@icloud.com" , "from" : "loiclecrenier at icloud.com (=?utf-8?Q?Lo=C3=AFc_Lecrenier?=)" , "mailingList" : "swift-evolution" , "content" : "Right. I proposed associated_type simply because that's what SIL calls them, but it is a bad name for Swift. I like associated and withtype though. \n\nLoïc\n\n> On Dec 6, 2015, at 3:08 AM, Anandabits <matthew at anandabits.com> wrote:\n> \n> I like the proposal in general, but the snake case feels decidedly un-Swifty (although I like snake case personally it isn't the Swift convention and I do like strong conventions).\n> \n> Sent from my iPad\n> \n>> On Dec 5, 2015, at 7:46 PM, Austin Zheng via swift-evolution <swift-evolution at swift.org> wrote:\n>> \n>> I like \"associated\". Or maybe \"withtype\". Anything clear and without underscore.\n>> \n>> protocol Foo {\n>>  associated T\n>> }\n>> \n>> protocol Foo {\n>> withtype T\n>> }\n>> \n>>>> On Dec 5, 2015, at 5:43 PM, Stephen Celis via swift-evolution <swift-evolution at swift.org> wrote:\n>>>> \n>>>> On Dec 5, 2015, at 8:11 PM, Kevin Lundberg via swift-evolution <swift-evolution at swift.org> wrote:\n>>>> \n>>>> If we must keep this concept, I would prefer something without an underscore for the keyword, like \"associatedtype\" or perhaps \"typeassociation\"\n>>> \n>>> Or merely \"associated\".\n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>> \n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000482.html" , "inReplyTo" : "64E52217-017C-437E-96BA-041FED8B923C@anandabits.com" , "date" : { "$date" : 1449368033000} , "subject" : "[swift-evolution] Introduce \"associated_type\" keyword" , "references" : [ "C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com" , "80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com" , "BD192734-066B-4907-887C-0286D799CBE1@klundberg.com" , "6407A281-C936-40E3-B882-1E63279F4755@gmail.com" , "554F869D-D9A3-4672-B0BA-3153B644C65B@gmail.com" , "64E52217-017C-437E-96BA-041FED8B923C@anandabits.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CA+Y5xYfsqnR9JW4Xyo-R=HjryFW-1AjiUXmeZPVaeLiCZ0APeg@mail.gmail.com"}} , "_id" : "CA+Y5xYfsqnR9JW4Xyo-R=HjryFW-1AjiUXmeZPVaeLiCZ0APeg@mail.gmail.com" , "from" : "gribozavr at gmail.com (Dmitri Gribenko)" , "mailingList" : "swift-evolution" , "content" : "On Sat, Dec 5, 2015 at 5:43 PM, Stephen Celis via swift-evolution\n<swift-evolution at swift.org> wrote:\n>> On Dec 5, 2015, at 8:11 PM, Kevin Lundberg via swift-evolution <swift-evolution at swift.org> wrote:\n>>\n>> If we must keep this concept, I would prefer something without an underscore for the keyword, like \"associatedtype\" or perhaps \"typeassociation\"\n>\n> Or merely \"associated\".\n\n+1 to the proposal, emphasizing the distinction is important; and I\nlike \"associated\" as the keyword for this purpose, too.\n\nDmitri\n\n-- \nmain(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if\n(j){printf(\"%d\\n\",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000483.html" , "inReplyTo" : "6407A281-C936-40E3-B882-1E63279F4755@gmail.com" , "date" : { "$date" : 1449368418000} , "subject" : "[swift-evolution] Introduce \"associated_type\" keyword" , "references" : [ "C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com" , "80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com" , "BD192734-066B-4907-887C-0286D799CBE1@klundberg.com" , "6407A281-C936-40E3-B882-1E63279F4755@gmail.com"] , "descendants" : [ "22C9CF03-BE4B-4F57-9009-042A9E582C80@icloud.com" , "A85887DB-0FD2-4B0A-B00A-79CA918DD532@icloud.com" , "CA+Y5xYfKpkHNwivagTALSqMc=WnGp=k7JxrMFV_-nGt2UiAsjA@mail.gmail.com" , "CAOFcyhuEjDgx-eVzvfujQAQx7A7uMRT6D-B+qi=9ZCduFt-xWg@mail.gmail.com" , "3FE1A475-EEF7-460A-B841-F94D6C0EB3B4@alkaline-solutions.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/FC624F3D-20B7-4F42-A04F-97AFDB0287CB@alkaline-solutions.com"}} , "_id" : "FC624F3D-20B7-4F42-A04F-97AFDB0287CB@alkaline-solutions.com" , "from" : "david at alkaline-solutions.com (David Waite)" , "mailingList" : "swift-evolution" , "content" : "A possible syntax, then:\n\n\tinit(set name:String, set score:Int) { }\n\nset would be a fourth parameter modifier alongside let, var, and inout - only valid on initializers (not as useful and likely confusing in other contexts). The local name has to match a parameter on the type. Like let/var (but unlike inout) usage of ‘set’ on a initializer parameter does not affect the caller or prototype conformance.\n\n-DW\n\n> On Dec 5, 2015, at 3:31 PM, Brent Royal-Gordon via swift-evolution <swift-evolution at swift.org> wrote:\n> \n>> Did you read through by reply to the original proposal?  I believe it provides the convenience you're looking for here while still allowing for the flexibility to avoid boilerplate in initializers that do more than just set properties.  \n> \n> I did, and I didn’t really like it. One of the syntaxes it proposed was strange and ad-hoc; the other was a fairly arbitrary overloading of parentheses, although it doesn’t actually conflict with anything since you can’t overload “calling parentheses” on a non-function.\n> \n> It’s important to ensure that, when the implementation evolves, you can replace the initializer transparently. For instance, suppose I have a type which represents a player in a game. It uses a stored property called `points`:" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000484.html" , "inReplyTo" : "63177F8D-6BA7-4B1E-9052-BA6D3ED6B0CC@architechies.com" , "date" : { "$date" : 1449368645000} , "subject" : "[swift-evolution] Proposal: helpers for initializing properties of same name as parameters" , "references" : [ "CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com" , "4F8C6141-CEFA-43DA-8FD9-5C787789ED68@architechies.com" , "9DC6F2A2-53E0-4DBB-AF5F-D51314AA49F7@anandabits.com" , "63177F8D-6BA7-4B1E-9052-BA6D3ED6B0CC@architechies.com"] , "descendants" : [ "DB740B9C-987F-42BF-96DF-95570F070A89@architechies.com" , "C3D71715-4957-441C-B277-E8CC3BBE4CA0@alkaline-solutions.com" , "3925DEF8-2B69-4AB5-AD95-49BD2FE6401B@alkaline-solutions.com" , "CA+ddMk042v6whHcVu8kLZyAk1JaEQ3LYxttAbZfGq6KBvrcGNw@mail.gmail.com" , "CADcs6kN6MT3cbEsPjtiXbR1U6-YzwD8v_Rbiv0PLHsm6xFiiZg@mail.gmail.com" , "E3BD5430-C4DF-4284-99FA-14B61512E74A@apple.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CA+ddMk042v6whHcVu8kLZyAk1JaEQ3LYxttAbZfGq6KBvrcGNw@mail.gmail.com"}} , "_id" : "CA+ddMk042v6whHcVu8kLZyAk1JaEQ3LYxttAbZfGq6KBvrcGNw@mail.gmail.com" , "from" : "me at tal.by (Tal Atlas)" , "mailingList" : "swift-evolution" , "content" : "This syntax is confusing with that of defining the external keyword for the\nparameter.\n\nOn Sat, Dec 5, 2015 at 9:24 PM David Waite via swift-evolution <\nswift-evolution at swift.org> wrote:\n\n> A possible syntax, then:\n>\n>         init(set name:String, set score:Int) { }\n>\n> set would be a fourth parameter modifier alongside let, var, and inout -\n> only valid on initializers (not as useful and likely confusing in other\n> contexts). The local name has to match a parameter on the type. Like\n> let/var (but unlike inout) usage of ‘set’ on a initializer parameter does\n> not affect the caller or prototype conformance.\n>\n> -DW\n>\n> > On Dec 5, 2015, at 3:31 PM, Brent Royal-Gordon via swift-evolution <\n> swift-evolution at swift.org> wrote:\n> >\n> >> Did you read through by reply to the original proposal?  I believe it\n> provides the convenience you're looking for here while still allowing for\n> the flexibility to avoid boilerplate in initializers that do more than just\n> set properties.\n> >\n> > I did, and I didn’t really like it. One of the syntaxes it proposed was\n> strange and ad-hoc; the other was a fairly arbitrary overloading of\n> parentheses, although it doesn’t actually conflict with anything since you\n> can’t overload “calling parentheses” on a non-function.\n> >\n> > It’s important to ensure that, when the implementation evolves, you can\n> replace the initializer transparently. For instance, suppose I have a type\n> which represents a player in a game. It uses a stored property called\n> `points`:\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000485.html" , "inReplyTo" : "FC624F3D-20B7-4F42-A04F-97AFDB0287CB@alkaline-solutions.com" , "date" : { "$date" : 1449368758000} , "subject" : "[swift-evolution] Proposal: helpers for initializing properties of same name as parameters" , "references" : [ "CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com" , "4F8C6141-CEFA-43DA-8FD9-5C787789ED68@architechies.com" , "9DC6F2A2-53E0-4DBB-AF5F-D51314AA49F7@anandabits.com" , "63177F8D-6BA7-4B1E-9052-BA6D3ED6B0CC@architechies.com" , "FC624F3D-20B7-4F42-A04F-97AFDB0287CB@alkaline-solutions.com"] , "descendants" : [ "DB740B9C-987F-42BF-96DF-95570F070A89@architechies.com" , "C3D71715-4957-441C-B277-E8CC3BBE4CA0@alkaline-solutions.com" , "3925DEF8-2B69-4AB5-AD95-49BD2FE6401B@alkaline-solutions.com" , "CADcs6kN6MT3cbEsPjtiXbR1U6-YzwD8v_Rbiv0PLHsm6xFiiZg@mail.gmail.com" , "E3BD5430-C4DF-4284-99FA-14B61512E74A@apple.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/22C9CF03-BE4B-4F57-9009-042A9E582C80@icloud.com"}} , "_id" : "22C9CF03-BE4B-4F57-9009-042A9E582C80@icloud.com" , "from" : "loiclecrenier at icloud.com (=?utf-8?Q?Lo=C3=AFc_Lecrenier?=)" , "mailingList" : "swift-evolution" , "content" : "Great :)\n\nAlso, this hasn't been explicitly discussed yet. But do you all agree about adding \"real\" typealias declarations (with the typealias keyword) inside protocols? \n\nLoïc\n\n> On Dec 6, 2015, at 3:20 AM, Dmitri Gribenko <gribozavr at gmail.com> wrote:\n> \n> On Sat, Dec 5, 2015 at 5:43 PM, Stephen Celis via swift-evolution\n> <swift-evolution at swift.org> wrote:\n>>> On Dec 5, 2015, at 8:11 PM, Kevin Lundberg via swift-evolution <swift-evolution at swift.org> wrote:\n>>> \n>>> If we must keep this concept, I would prefer something without an underscore for the keyword, like \"associatedtype\" or perhaps \"typeassociation\"\n>> \n>> Or merely \"associated\".\n> \n> +1 to the proposal, emphasizing the distinction is important; and I\n> like \"associated\" as the keyword for this purpose, too.\n> \n> Dmitri\n> \n> -- \n> main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if\n> (j){printf(\"%d\\n\",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000486.html" , "inReplyTo" : "CA+Y5xYfsqnR9JW4Xyo-R=HjryFW-1AjiUXmeZPVaeLiCZ0APeg@mail.gmail.com" , "date" : { "$date" : 1449368844000} , "subject" : "[swift-evolution] Introduce \"associated_type\" keyword" , "references" : [ "C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com" , "80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com" , "BD192734-066B-4907-887C-0286D799CBE1@klundberg.com" , "6407A281-C936-40E3-B882-1E63279F4755@gmail.com" , "CA+Y5xYfsqnR9JW4Xyo-R=HjryFW-1AjiUXmeZPVaeLiCZ0APeg@mail.gmail.com"] , "descendants" : [ "A85887DB-0FD2-4B0A-B00A-79CA918DD532@icloud.com" , "CA+Y5xYfKpkHNwivagTALSqMc=WnGp=k7JxrMFV_-nGt2UiAsjA@mail.gmail.com" , "CAOFcyhuEjDgx-eVzvfujQAQx7A7uMRT6D-B+qi=9ZCduFt-xWg@mail.gmail.com" , "3FE1A475-EEF7-460A-B841-F94D6C0EB3B4@alkaline-solutions.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CA+Y5xYfKpkHNwivagTALSqMc=WnGp=k7JxrMFV_-nGt2UiAsjA@mail.gmail.com"}} , "_id" : "CA+Y5xYfKpkHNwivagTALSqMc=WnGp=k7JxrMFV_-nGt2UiAsjA@mail.gmail.com" , "from" : "gribozavr at gmail.com (Dmitri Gribenko)" , "mailingList" : "swift-evolution" , "content" : "On Sat, Dec 5, 2015 at 6:27 PM, Loïc Lecrenier <loiclecrenier at icloud.com> wrote:\n> Great :)\n>\n> Also, this hasn't been explicitly discussed yet. But do you all agree about adding \"real\" typealias declarations (with the typealias keyword) inside protocols?\n\nConcrete typealieases are not requirements, so they shouldn't be\ndefined inside of a protocol.  Instead, they should be defined in the\nprotocol extension.  In fact, this has been a plan of record for some\ntime, but it wasn't implemented.\n\nextension SequenceType {\n  typealias Element = Generator.Element\n}\n\nDmitri\n\n-- \nmain(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if\n(j){printf(\"%d\\n\",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000487.html" , "inReplyTo" : "22C9CF03-BE4B-4F57-9009-042A9E582C80@icloud.com" , "date" : { "$date" : 1449368970000} , "subject" : "[swift-evolution] Introduce \"associated_type\" keyword" , "references" : [ "C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com" , "80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com" , "BD192734-066B-4907-887C-0286D799CBE1@klundberg.com" , "6407A281-C936-40E3-B882-1E63279F4755@gmail.com" , "CA+Y5xYfsqnR9JW4Xyo-R=HjryFW-1AjiUXmeZPVaeLiCZ0APeg@mail.gmail.com" , "22C9CF03-BE4B-4F57-9009-042A9E582C80@icloud.com"] , "descendants" : [ "A85887DB-0FD2-4B0A-B00A-79CA918DD532@icloud.com" , "CAOFcyhuEjDgx-eVzvfujQAQx7A7uMRT6D-B+qi=9ZCduFt-xWg@mail.gmail.com" , "3FE1A475-EEF7-460A-B841-F94D6C0EB3B4@alkaline-solutions.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/A85887DB-0FD2-4B0A-B00A-79CA918DD532@icloud.com"}} , "_id" : "A85887DB-0FD2-4B0A-B00A-79CA918DD532@icloud.com" , "from" : "loiclecrenier at icloud.com (=?utf-8?Q?Lo=C3=AFc_Lecrenier?=)" , "mailingList" : "swift-evolution" , "content" : "This makes sense. Thanks for the quick reply. \n\nLoïc\n\n> On Dec 6, 2015, at 3:29 AM, Dmitri Gribenko <gribozavr at gmail.com> wrote:\n> \n>> On Sat, Dec 5, 2015 at 6:27 PM, Loïc Lecrenier <loiclecrenier at icloud.com> wrote:\n>> Great :)\n>> \n>> Also, this hasn't been explicitly discussed yet. But do you all agree about adding \"real\" typealias declarations (with the typealias keyword) inside protocols?\n> \n> Concrete typealieases are not requirements, so they shouldn't be\n> defined inside of a protocol.  Instead, they should be defined in the\n> protocol extension.  In fact, this has been a plan of record for some\n> time, but it wasn't implemented.\n> \n> extension SequenceType {\n>  typealias Element = Generator.Element\n> }\n> \n> Dmitri\n> \n> -- \n> main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if\n> (j){printf(\"%d\\n\",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000488.html" , "inReplyTo" : "CA+Y5xYfKpkHNwivagTALSqMc=WnGp=k7JxrMFV_-nGt2UiAsjA@mail.gmail.com" , "date" : { "$date" : 1449369101000} , "subject" : "[swift-evolution] Introduce \"associated_type\" keyword" , "references" : [ "C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com" , "80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com" , "BD192734-066B-4907-887C-0286D799CBE1@klundberg.com" , "6407A281-C936-40E3-B882-1E63279F4755@gmail.com" , "CA+Y5xYfsqnR9JW4Xyo-R=HjryFW-1AjiUXmeZPVaeLiCZ0APeg@mail.gmail.com" , "22C9CF03-BE4B-4F57-9009-042A9E582C80@icloud.com" , "CA+Y5xYfKpkHNwivagTALSqMc=WnGp=k7JxrMFV_-nGt2UiAsjA@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/3925DEF8-2B69-4AB5-AD95-49BD2FE6401B@alkaline-solutions.com"}} , "_id" : "3925DEF8-2B69-4AB5-AD95-49BD2FE6401B@alkaline-solutions.com" , "from" : "david at alkaline-solutions.com (David Waite)" , "mailingList" : "swift-evolution" , "content" : "I don’t believe any more so than for let or var, which this effectively is a complement for.\n\nfunc foo(var externalName internalName:String) { print(internalName) }\n\n-DW\n\n> On Dec 5, 2015, at 7:25 PM, Tal Atlas <me at tal.by> wrote:\n> \n> This syntax is confusing with that of defining the external keyword for the parameter.\n> \n> On Sat, Dec 5, 2015 at 9:24 PM David Waite via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n> A possible syntax, then:\n> \n>         init(set name:String, set score:Int) { }\n> \n> set would be a fourth parameter modifier alongside let, var, and inout - only valid on initializers (not as useful and likely confusing in other contexts). The local name has to match a parameter on the type. Like let/var (but unlike inout) usage of ‘set’ on a initializer parameter does not affect the caller or prototype conformance.\n> \n> -DW" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000489.html" , "inReplyTo" : "CA+ddMk042v6whHcVu8kLZyAk1JaEQ3LYxttAbZfGq6KBvrcGNw@mail.gmail.com" , "date" : { "$date" : 1449369986000} , "subject" : "[swift-evolution] Proposal: helpers for initializing properties of same name as parameters" , "references" : [ "CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com" , "4F8C6141-CEFA-43DA-8FD9-5C787789ED68@architechies.com" , "9DC6F2A2-53E0-4DBB-AF5F-D51314AA49F7@anandabits.com" , "63177F8D-6BA7-4B1E-9052-BA6D3ED6B0CC@architechies.com" , "FC624F3D-20B7-4F42-A04F-97AFDB0287CB@alkaline-solutions.com" , "CA+ddMk042v6whHcVu8kLZyAk1JaEQ3LYxttAbZfGq6KBvrcGNw@mail.gmail.com"] , "descendants" : [ "DB740B9C-987F-42BF-96DF-95570F070A89@architechies.com" , "C3D71715-4957-441C-B277-E8CC3BBE4CA0@alkaline-solutions.com" , "CADcs6kN6MT3cbEsPjtiXbR1U6-YzwD8v_Rbiv0PLHsm6xFiiZg@mail.gmail.com" , "E3BD5430-C4DF-4284-99FA-14B61512E74A@apple.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/3FE1A475-EEF7-460A-B841-F94D6C0EB3B4@alkaline-solutions.com"}} , "_id" : "3FE1A475-EEF7-460A-B841-F94D6C0EB3B4@alkaline-solutions.com" , "from" : "david at alkaline-solutions.com (David Waite)" , "mailingList" : "swift-evolution" , "content" : "However, if a protocol wished to use type aliases not as part of a contract but for clarity, this would still need to be defined within the protocol in order for the associated types to be used in the typealias declarations.\n\n-DW\n\n> On Dec 5, 2015, at 7:29 PM, Dmitri Gribenko via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> On Sat, Dec 5, 2015 at 6:27 PM, Loïc Lecrenier <loiclecrenier at icloud.com> wrote:\n>> Great :)\n>> \n>> Also, this hasn't been explicitly discussed yet. But do you all agree about adding \"real\" typealias declarations (with the typealias keyword) inside protocols?\n> \n> Concrete typealieases are not requirements, so they shouldn't be\n> defined inside of a protocol.  Instead, they should be defined in the\n> protocol extension.  In fact, this has been a plan of record for some\n> time, but it wasn't implemented.\n> \n> extension SequenceType {\n>  typealias Element = Generator.Element\n> }\n> \n> Dmitri\n> \n> -- \n> main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if\n> (j){printf(\"%d\\n\",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000490.html" , "inReplyTo" : "CA+Y5xYfKpkHNwivagTALSqMc=WnGp=k7JxrMFV_-nGt2UiAsjA@mail.gmail.com" , "date" : { "$date" : 1449370146000} , "subject" : "[swift-evolution] Introduce \"associated_type\" keyword" , "references" : [ "C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com" , "80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com" , "BD192734-066B-4907-887C-0286D799CBE1@klundberg.com" , "6407A281-C936-40E3-B882-1E63279F4755@gmail.com" , "CA+Y5xYfsqnR9JW4Xyo-R=HjryFW-1AjiUXmeZPVaeLiCZ0APeg@mail.gmail.com" , "22C9CF03-BE4B-4F57-9009-042A9E582C80@icloud.com" , "CA+Y5xYfKpkHNwivagTALSqMc=WnGp=k7JxrMFV_-nGt2UiAsjA@mail.gmail.com"] , "descendants" : [ "CAOFcyhuEjDgx-eVzvfujQAQx7A7uMRT6D-B+qi=9ZCduFt-xWg@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CADcs6kN6MT3cbEsPjtiXbR1U6-YzwD8v_Rbiv0PLHsm6xFiiZg@mail.gmail.com"}} , "_id" : "CADcs6kN6MT3cbEsPjtiXbR1U6-YzwD8v_Rbiv0PLHsm6xFiiZg@mail.gmail.com" , "from" : "jtbandes at gmail.com (Jacob Bandes-Storch)" , "mailingList" : "swift-evolution" , "content" : "The ability to use `var` in parameter lists / pattern matching is being\nremoved:\nhttps://github.com/apple/swift-evolution/blob/7dc4dc47c43647dd1e60fe17074959dc3f056468/proposals/0003-remove-var-parameters-patterns.md\n\nJacob\n\nOn Sat, Dec 5, 2015 at 6:46 PM, David Waite via swift-evolution <\nswift-evolution at swift.org> wrote:\n\n> I don’t believe any more so than for let or var, which this effectively is\n> a complement for.\n>\n> func foo(var externalName internalName:String) { print(internalName) }\n>\n>\n> -DW\n>\n> On Dec 5, 2015, at 7:25 PM, Tal Atlas <me at tal.by> wrote:\n>\n> This syntax is confusing with that of defining the external keyword for\n> the parameter.\n>\n> On Sat, Dec 5, 2015 at 9:24 PM David Waite via swift-evolution <\n> swift-evolution at swift.org> wrote:\n>\n>> A possible syntax, then:\n>>\n>>         init(set name:String, set score:Int) { }\n>>\n>> set would be a fourth parameter modifier alongside let, var, and inout -\n>> only valid on initializers (not as useful and likely confusing in other\n>> contexts). The local name has to match a parameter on the type. Like\n>> let/var (but unlike inout) usage of ‘set’ on a initializer parameter does\n>> not affect the caller or prototype conformance.\n>>\n>> -DW\n>>\n>\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000491.html" , "inReplyTo" : "3925DEF8-2B69-4AB5-AD95-49BD2FE6401B@alkaline-solutions.com" , "date" : { "$date" : 1449370194000} , "subject" : "[swift-evolution] Proposal: helpers for initializing properties of same name as parameters" , "references" : [ "CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com" , "4F8C6141-CEFA-43DA-8FD9-5C787789ED68@architechies.com" , "9DC6F2A2-53E0-4DBB-AF5F-D51314AA49F7@anandabits.com" , "63177F8D-6BA7-4B1E-9052-BA6D3ED6B0CC@architechies.com" , "FC624F3D-20B7-4F42-A04F-97AFDB0287CB@alkaline-solutions.com" , "CA+ddMk042v6whHcVu8kLZyAk1JaEQ3LYxttAbZfGq6KBvrcGNw@mail.gmail.com" , "3925DEF8-2B69-4AB5-AD95-49BD2FE6401B@alkaline-solutions.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/DB740B9C-987F-42BF-96DF-95570F070A89@architechies.com"}} , "_id" : "DB740B9C-987F-42BF-96DF-95570F070A89@architechies.com" , "from" : "brent at architechies.com (Brent Royal-Gordon)" , "mailingList" : "swift-evolution" , "content" : "> I don’t believe any more so than for let or var, which this effectively is a complement for.\n\nThere is no Let or Var type in the standard library, but there is a Set type. “Set” has many meanings, and some of them are relatively likely to be used as parameter keywords.\n\n-- \nBrent Royal-Gordon\nArchitechies" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000492.html" , "inReplyTo" : "3925DEF8-2B69-4AB5-AD95-49BD2FE6401B@alkaline-solutions.com" , "date" : { "$date" : 1449370299000} , "subject" : "[swift-evolution] Proposal: helpers for initializing properties of same name as parameters" , "references" : [ "CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com" , "4F8C6141-CEFA-43DA-8FD9-5C787789ED68@architechies.com" , "9DC6F2A2-53E0-4DBB-AF5F-D51314AA49F7@anandabits.com" , "63177F8D-6BA7-4B1E-9052-BA6D3ED6B0CC@architechies.com" , "FC624F3D-20B7-4F42-A04F-97AFDB0287CB@alkaline-solutions.com" , "CA+ddMk042v6whHcVu8kLZyAk1JaEQ3LYxttAbZfGq6KBvrcGNw@mail.gmail.com" , "3925DEF8-2B69-4AB5-AD95-49BD2FE6401B@alkaline-solutions.com"] , "descendants" : [ "C3D71715-4957-441C-B277-E8CC3BBE4CA0@alkaline-solutions.com" , "E3BD5430-C4DF-4284-99FA-14B61512E74A@apple.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/C3D71715-4957-441C-B277-E8CC3BBE4CA0@alkaline-solutions.com"}} , "_id" : "C3D71715-4957-441C-B277-E8CC3BBE4CA0@alkaline-solutions.com" , "from" : "david at alkaline-solutions.com (David Waite)" , "mailingList" : "swift-evolution" , "content" : "There is also a set keyword in the language already, although today its use is limited such that it may still be used as an identifier in non-conflicting contexts.\n\n-DW\n\n> On Dec 5, 2015, at 7:51 PM, Brent Royal-Gordon <brent at architechies.com> wrote:\n> \n>> I don’t believe any more so than for let or var, which this effectively is a complement for.\n> \n> There is no Let or Var type in the standard library, but there is a Set type. “Set” has many meanings, and some of them are relatively likely to be used as parameter keywords.\n> \n> -- \n> Brent Royal-Gordon\n> Architechies\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000493.html" , "inReplyTo" : "DB740B9C-987F-42BF-96DF-95570F070A89@architechies.com" , "date" : { "$date" : 1449370700000} , "subject" : "[swift-evolution] Proposal: helpers for initializing properties of same name as parameters" , "references" : [ "CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com" , "4F8C6141-CEFA-43DA-8FD9-5C787789ED68@architechies.com" , "9DC6F2A2-53E0-4DBB-AF5F-D51314AA49F7@anandabits.com" , "63177F8D-6BA7-4B1E-9052-BA6D3ED6B0CC@architechies.com" , "FC624F3D-20B7-4F42-A04F-97AFDB0287CB@alkaline-solutions.com" , "CA+ddMk042v6whHcVu8kLZyAk1JaEQ3LYxttAbZfGq6KBvrcGNw@mail.gmail.com" , "3925DEF8-2B69-4AB5-AD95-49BD2FE6401B@alkaline-solutions.com" , "DB740B9C-987F-42BF-96DF-95570F070A89@architechies.com"] , "descendants" : [ "E3BD5430-C4DF-4284-99FA-14B61512E74A@apple.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CANhuES0ZoHNV5YXzS2UyUcqE=quzBXz7bHBrpNA=do-_LVNLOg@mail.gmail.com"}} , "_id" : "CANhuES0ZoHNV5YXzS2UyUcqE=quzBXz7bHBrpNA=do-_LVNLOg@mail.gmail.com" , "from" : "nvazquez1297 at gmail.com (Nikolai Vazquez)" , "mailingList" : "swift-evolution" , "content" : "One of the aspects of Swift that I like is computed properties for\nstructures and classes. It allows for adding logic when obtaining values or\nfor having the returned value be dependent on another.\n\nAs of the `ErrorType` protocol introduction in Swift 2, we can throw errors\nwhen it comes to functions and initializers. However, this does not apply\nto getters and setters.\n\n```swift\nstruct File<Data> {\n    var contents: Data {\n        get throws { ... }\n        set throws { ... }\n    }\n}\n```\n\nA better example would be getting and setting the current working directory\nof the process:\n\n```swift\nimport Foundation\n\nextension Process {\n    static var workingDirectory: String {\n        get {\n            let fileManager = NSFileManager.defaultManager()\n            return fileManager.currentDirectoryPath\n        }\n        set throws {\n            let fileManager = NSFileManager.defaultManager()\n            guard fileManager.changeCurrentDirectoryPath(newValue) else {\n                throw Error(\"...\")\n            }\n        }\n    }\n}\n\n\n\n```" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000494.html" , "date" : { "$date" : 1449371310000} , "subject" : "[swift-evolution] Proposal: Allow Getters and Setters to Throw" , "references" : [ ""] , "inReplyTo" :  null  , "descendants" : [ "CAOFcyhsX__8shDyX6Zk369Z15-LC1KJ=E=bXqWo99JNCKvs-Gw@mail.gmail.com" , "CAAdsSdrj_WW_h4nDOct-CquOY-ae8Nm40r-DqjV0wpYfAcq84A@mail.gmail.com" , "CFF2227E-9D6E-42A8-B93C-8535E5E805E0@apple.com" , "24BDC987-94C6-4DF0-916E-6A850F37BA70@me.com" , "C921EDDA-EDB2-421D-B100-353E53554BB8@architechies.com" , "1BC45BCB-552C-4D24-B451-64C706B4AA97@apple.com" , "F51E44A3-B1CE-4FB7-9F02-5B18F1EEB17F@architechies.com" , "DB6756E4-1448-4517-88B2-06FF1578D440@anandabits.com" , "E205F705-1A64-4F4E-B838-EF81DEC56554@apple.com" , "E3A71685-F75F-46A5-8A35-3ACF38B1C791@anandabits.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/0C687B3C-4916-458B-86F0-16B3A9261941@apple.com"}} , "_id" : "0C687B3C-4916-458B-86F0-16B3A9261941@apple.com" , "from" : "phabouzit at apple.com (Pierre Habouzit)" , "mailingList" : "swift-evolution" , "content" : "-Pierre\n\n> On Dec 5, 2015, at 3:51 PM, Brent Royal-Gordon via swift-corelibs-dev <swift-corelibs-dev at swift.org> wrote:\n> \n>> I think it's a good idea to conform NSDate to the Comparable protocol, so instead of using:\n>> \n>> if someDate.compare(today) == .OrderedAscending { }\n>> \n>> Developers can easily compare using compare dates using comparison operators:\n>> \n>> if someDate < today { }\n> \n> I would also suggest we add Strideable, which would allow you to add and subtract NSTimeIntervals, plus subtract two NSDates to get the NSTimeInterval between them.\n> \n> https://gist.github.com/brentdax/11b3275424d0833cfd99\n\nNSDate (and dates/timestamps in general) is a poor choice for Strideable, because, DST.\nA Calendar using this interface for a repeating event would be broken using this. Or you would break anyone who really wants to iterate every fixed 86400 seconds.\n\n-Pierre" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000497.html" , "inReplyTo" : "97EB190C-895B-4698-A93E-C1050B92520B@architechies.com" , "date" : { "$date" : 1449371438000} , "subject" : "[swift-evolution] [swift-corelibs-dev] Proposal: Conforming NSDate to Comparable" , "references" : [ "CAEryqghYNO4JKWRGkF_qFTew7cGPtG7iNP32DndN1dOHLkjATQ@mail.gmail.com" , "97EB190C-895B-4698-A93E-C1050B92520B@architechies.com"] , "descendants" : [ "1449373366.2149969.459249705.7F8B4291@webmail.messagingengine.com" , "4CF9AAE7-812C-4F95-A8D8-62B74701957D@alkaline-solutions.com" , "74FC29AE-AF91-4360-BDA1-EF54AA6A74F8@architechies.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/B47BE4E1-F761-4452-8CF2-7A9CFB0D3613@anandabits.com"}} , "_id" : "B47BE4E1-F761-4452-8CF2-7A9CFB0D3613@anandabits.com" , "from" : "matthew at anandabits.com (Matthew Johnson)" , "mailingList" : "swift-evolution" , "content" : "> There’s a problem with that:\n> \n> \t 24> Int.min...Int.max\n> \tfatal error: Range end index has no valid successor\n> \n> The problem is that Int.min … Int.max is actually represented as Int.min ..< Int.max.successor(), which is obviously not going to work.\n\nThat’s embarrassing.  I should have known better than to post code that should work without trying it out first!  Thanks for pointing that out.  It looks like ClosedInterval is indeed what I should have used.  \n\nprotocol ClosedIntervalType {\n\tstatic var closedInterval: ClosedInterval<Self> { get }\n}\n\nextension Int: ClosedIntervalType {\n\tstatic let closedInterval: ClosedInterval <Int> = Int.min…Int.max\n}\n\nextension Float: ClosedIntervalType {\n\t// not sure it would be better to use -Float. greatestFiniteMagnitude..Float. greatestFiniteMagnitude here or not\n\tstatic let closedInterval: ClosedInterval <Float> = -Float.infinity...Float.infinity\n}\n\n\nI think having something like this in the standard library would be quite useful.  All numeric types could conform as could \n\n> Floats don’t currently conform to the IndexType protocols because there’s no *natural* interval for them to use. nextUp/nextDown are rarely what you want in practice, while 1 breaks down at large sizes.\n\nnextUp/nextDown may be rarely needed, they do seem to me to be a “natural” interval for floating point numbers.  Natural because successor and predecessor imply stepping through a discrete sequence of values one-by-one and any other interval would necessarily skip values.\n\nI did run into a scenario where nextUp/nextDown were precisely what I needed which is what lead me to write a conformance of Float and Double to BidirectionalIndexType.  I didn’t actually need BidirectionalIndexType conformance - just the successor and predecessor (nextUp/nextDown) functions - it just seemed most natural to conform to the protocol that defined them functions that do precisely this.\n\nI think it would be perfectly natural for floating point types to conform to BidirectionalIndexType but I admit it would probably not be used often." , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000495.html" , "inReplyTo" : "76657877-5D42-4486-AD4B-79BFC8677941@architechies.com" , "date" : { "$date" : 1449371699000} , "subject" : "[swift-evolution] Proposal: floating point static min / max properties" , "references" : [ "36C3F015-B77D-4256-9FAB-2853218D5973@anandabits.com" , "9060D0D4-BB70-47FE-A3F7-A572ACE8BD64@apple.com" , "981D5E32-8D9D-4B24-8085-04E7C8DBC81A@anandabits.com" , "76657877-5D42-4486-AD4B-79BFC8677941@architechies.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/DB6756E4-1448-4517-88B2-06FF1578D440@anandabits.com"}} , "_id" : "DB6756E4-1448-4517-88B2-06FF1578D440@anandabits.com" , "from" : "matthew at anandabits.com (Matthew Johnson)" , "mailingList" : "swift-evolution" , "content" : "+1 to this.  Subscripts should also be able to throw and currently cannot.\n\n\n> On Dec 5, 2015, at 9:08 PM, Nikolai Vazquez via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> One of the aspects of Swift that I like is computed properties for structures and classes. It allows for adding logic when obtaining values or for having the returned value be dependent on another.\n> \n> As of the `ErrorType` protocol introduction in Swift 2, we can throw errors when it comes to functions and initializers. However, this does not apply to getters and setters.\n> \n> ```swift\n> struct File<Data> {\n>     var contents: Data {\n>         get throws { ... }\n>         set throws { ... }\n>     }\n> }\n> ```\n> \n> A better example would be getting and setting the current working directory of the process:\n> \n> ```swift\n> import Foundation\n> \n> extension Process {\n>     static var workingDirectory: String {\n>         get {\n>             let fileManager = NSFileManager.defaultManager()\n>             return fileManager.currentDirectoryPath\n>         }\n>         set throws {\n>             let fileManager = NSFileManager.defaultManager()\n>             guard fileManager.changeCurrentDirectoryPath(newValue) else {\n>                 throw Error(\"...\")\n>             }\n>         }\n>     }\n> }\n> \n> \n> \n> ```\n> \n> \n>  _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000496.html" , "inReplyTo" : "CANhuES0ZoHNV5YXzS2UyUcqE=quzBXz7bHBrpNA=do-_LVNLOg@mail.gmail.com" , "date" : { "$date" : 1449371863000} , "subject" : "[swift-evolution] Proposal: Allow Getters and Setters to Throw" , "references" : [ "CANhuES0ZoHNV5YXzS2UyUcqE=quzBXz7bHBrpNA=do-_LVNLOg@mail.gmail.com"] , "descendants" : [ "CAOFcyhsX__8shDyX6Zk369Z15-LC1KJ=E=bXqWo99JNCKvs-Gw@mail.gmail.com" , "CAAdsSdrj_WW_h4nDOct-CquOY-ae8Nm40r-DqjV0wpYfAcq84A@mail.gmail.com" , "E205F705-1A64-4F4E-B838-EF81DEC56554@apple.com" , "E3A71685-F75F-46A5-8A35-3ACF38B1C791@anandabits.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/1449372912.2146477.459241273.0F8138F3@webmail.messagingengine.com"}} , "_id" : "1449372912.2146477.459241273.0F8138F3@webmail.messagingengine.com" , "from" : "kevin at sb.org (Kevin Ballard)" , "mailingList" : "swift-evolution" , "content" : "On Sat, Dec 5, 2015, at 06:00 PM, Joe Groff wrote:\n> > How is this type-safe? You're using as! in there (and silently ignoring\n> > the message if the receiver is wrong wouldn't be any better). If I send\n> > a selector to the wrong receiver, it's still going to crash.\n> \n> I think this would be better emitted like a category on MyObject than on\n> NSObject.\n\nGoing back and reading your original suggestion about generating\nclosures, I think we're talking about this differently. If I understand\nit right, your original suggestion for generating closures basically\njust solves the problem of forgetting to mark a method as @objc, right?\nIn that case, putting the category on MyObject instead of NSObject is\nabsolutely the right thing to do. My arguments here are actually about\nMichel Fortin's claim:\n\n> The fact that the selector lives separately from its target object makes things difficult because the expected target type is almost always going to be AnyObject. Implicit conversions cannot happen safely in the direction SubType to BaseType for the arguments, including the target object. That makes Joe Groff's approach the only type-safe solution: make an extension of the base object and generate a method that does what you want.\n\nWhich is in the context of the fact that @convention(selector) MyObject\n-> Args -> Ret encodes the receiver type, but the problem is the\nselector is sent to AnyObject, so having the receiver type in there is\nbasically false type-safety (it looks like it's strongly-typed but it's\nactually not as that type information will be thrown away before the\nselector is used). I'm not really sure why Michel claimed that your\nclosure suggestion was a solution to this problem, because the only\nreasonable behavior one can use in such a category emitted on\nAnyObject/swift base class is to fatalError, which is no better than\nwhat happens if the selector simply isn't implemented.\n\nUltimately, given the premise that @convention(selector) T -> Args ->\nRet exists, generating those methods on the receiver type with mangled\nselector names seems like reasonable behavior. I just don't think\n@convention(selector) should exist.\n\n> There's plenty of useful space between \"no type safety\" and \"perfect type safety\", IMO.\n\nIn principle I agree. My basic argument here is that\n@convention(selector) provides so little actual type safety that it's\nnot worth the language complexity. And I also worry that providing\nfunctionality that appears to be strongly-typed but doesn't actually\nprovide any typing guarantees in practice will end up as a safety hazard\nfor unwary programmers.\n\nIt's also worth pointing out that my alternative suggestion of simply\nproviding some syntax to explicitly get a Selector from a method could\nstill use your closure-generating idea to work for non- at objc methods.\nHeck, we don't even really need syntax for this, we could just say that\nunbound method references can resolve to Selectors in addition to\nfunction types (just as the primary suggestion here allows method\nreferences to resolve to @convention(selector) functions in addition to\n@convention(swift) functions).\n\n-Kevin Ballard" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000498.html" , "inReplyTo" : "92C8AF30-9249-4152-A24E-86496425BD4D@apple.com" , "date" : { "$date" : 1449372912000} , "subject" : "[swift-evolution] Type-safe selectors" , "references" : [ "B4E7896A-ACC6-49C0-8E15-47418D012C0B@michelf.ca" , "2CA0197A-B5E5-466B-AF27-C552A998764E@apple.com" , "1449271642.2877123.458487961.609100F1@webmail.messagingengine.com" , "B70B24CB-485C-4A9B-8575-E391FBC8C263@apple.com" , "1449296613.1919415.458667425.16848C1F@webmail.messagingengine.com" , "8508E135-791E-4B88-A758-9208388DA878@michelf.ca" , "1449347746.2071795.459083425.1FD398E4@webmail.messagingengine.com" , "92C8AF30-9249-4152-A24E-86496425BD4D@apple.com"] , "descendants" : [ "1A62EBA8-4AC4-4F05-B486-F90194FE5740@michelf.ca"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAOFcyhuEjDgx-eVzvfujQAQx7A7uMRT6D-B+qi=9ZCduFt-xWg@mail.gmail.com"}} , "_id" : "CAOFcyhuEjDgx-eVzvfujQAQx7A7uMRT6D-B+qi=9ZCduFt-xWg@mail.gmail.com" , "from" : "ilya.belenkiy at gmail.com (Ilya Belenkiy)" , "mailingList" : "swift-evolution" , "content" : "+1 for using a distinct keyword for associated types\n\nOn Sat, Dec 5, 2015 at 9:49 PM David Waite via swift-evolution <\nswift-evolution at swift.org> wrote:\n\n> However, if a protocol wished to use type aliases not as part of a\n> contract but for clarity, this would still need to be defined within the\n> protocol in order for the associated types to be used in the typealias\n> declarations.\n>\n> -DW\n>\n> > On Dec 5, 2015, at 7:29 PM, Dmitri Gribenko via swift-evolution <\n> swift-evolution at swift.org> wrote:\n> >\n> > On Sat, Dec 5, 2015 at 6:27 PM, Loïc Lecrenier <loiclecrenier at icloud.com>\n> wrote:\n> >> Great :)\n> >>\n> >> Also, this hasn't been explicitly discussed yet. But do you all agree\n> about adding \"real\" typealias declarations (with the typealias keyword)\n> inside protocols?\n> >\n> > Concrete typealieases are not requirements, so they shouldn't be\n> > defined inside of a protocol.  Instead, they should be defined in the\n> > protocol extension.  In fact, this has been a plan of record for some\n> > time, but it wasn't implemented.\n> >\n> > extension SequenceType {\n> >  typealias Element = Generator.Element\n> > }\n> >\n> > Dmitri\n> >\n> > --\n> > main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if\n> > (j){printf(\"%d\\n\",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/\n> > _______________________________________________\n> > swift-evolution mailing list\n> > swift-evolution at swift.org\n> > https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000637.html" , "inReplyTo" : "3FE1A475-EEF7-460A-B841-F94D6C0EB3B4@alkaline-solutions.com" , "date" : { "$date" : 1449373224000} , "subject" : "[swift-evolution] Introduce \"associated_type\" keyword" , "references" : [ "C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com" , "80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com" , "BD192734-066B-4907-887C-0286D799CBE1@klundberg.com" , "6407A281-C936-40E3-B882-1E63279F4755@gmail.com" , "CA+Y5xYfsqnR9JW4Xyo-R=HjryFW-1AjiUXmeZPVaeLiCZ0APeg@mail.gmail.com" , "22C9CF03-BE4B-4F57-9009-042A9E582C80@icloud.com" , "CA+Y5xYfKpkHNwivagTALSqMc=WnGp=k7JxrMFV_-nGt2UiAsjA@mail.gmail.com" , "3FE1A475-EEF7-460A-B841-F94D6C0EB3B4@alkaline-solutions.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/1449373366.2149969.459249705.7F8B4291@webmail.messagingengine.com"}} , "_id" : "1449373366.2149969.459249705.7F8B4291@webmail.messagingengine.com" , "from" : "kevin at sb.org (Kevin Ballard)" , "mailingList" : "swift-evolution" , "content" : "On Sat, Dec 5, 2015, at 07:10 PM, Pierre Habouzit via swift-evolution\nwrote:\n> NSDate (and dates/timestamps in general) is a poor choice for Strideable,\n> because, DST.\n> A Calendar using this interface for a repeating event would be broken\n> using this. Or you would break anyone who really wants to iterate every\n> fixed 86400 seconds.\n\nThat's not a problem with Strideable. Making NSDate conform to\nStrideable does nothing to encourage people as treating 86400 seconds as\nbeing equal to 1 day. NSDate already has methods for measuring and\noffsetting, the only difference with conforming to Strideable is the\nname.\n\n-Kevin Ballard" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000499.html" , "inReplyTo" : "0C687B3C-4916-458B-86F0-16B3A9261941@apple.com" , "date" : { "$date" : 1449373366000} , "subject" : "[swift-evolution] [swift-corelibs-dev] Proposal: Conforming NSDate to Comparable" , "references" : [ "CAEryqghYNO4JKWRGkF_qFTew7cGPtG7iNP32DndN1dOHLkjATQ@mail.gmail.com" , "97EB190C-895B-4698-A93E-C1050B92520B@architechies.com" , "0C687B3C-4916-458B-86F0-16B3A9261941@apple.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAOFcyhsX__8shDyX6Zk369Z15-LC1KJ=E=bXqWo99JNCKvs-Gw@mail.gmail.com"}} , "_id" : "CAOFcyhsX__8shDyX6Zk369Z15-LC1KJ=E=bXqWo99JNCKvs-Gw@mail.gmail.com" , "from" : "ilya.belenkiy at gmail.com (Ilya Belenkiy)" , "mailingList" : "swift-evolution" , "content" : "+1\n\nOn Sat, Dec 5, 2015 at 10:17 PM Matthew Johnson via swift-evolution <\nswift-evolution at swift.org> wrote:\n\n> +1 to this.  Subscripts should also be able to throw and currently cannot.\n>\n>\n> On Dec 5, 2015, at 9:08 PM, Nikolai Vazquez via swift-evolution <\n> swift-evolution at swift.org> wrote:\n>\n> One of the aspects of Swift that I like is computed properties for\n> structures and classes. It allows for adding logic when obtaining values or\n> for having the returned value be dependent on another.\n>\n> As of the `ErrorType` protocol introduction in Swift 2, we can throw\n> errors when it comes to functions and initializers. However, this does not\n> apply to getters and setters.\n>\n> ```swift\n> struct File<Data> {\n>     var contents: Data {\n>         get throws { ... }\n>         set throws { ... }\n>     }\n> }\n> ```\n>\n> A better example would be getting and setting the current working\n> directory of the process:\n>\n> ```swift\n> import Foundation\n>\n> extension Process {\n>     static var workingDirectory: String {\n>         get {\n>             let fileManager = NSFileManager.defaultManager()\n>             return fileManager.currentDirectoryPath\n>         }\n>         set throws {\n>             let fileManager = NSFileManager.defaultManager()\n>             guard fileManager.changeCurrentDirectoryPath(newValue) else {\n>                 throw Error(\"...\")\n>             }\n>         }\n>     }\n> }\n>\n>\n>\n> ```\n>\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000638.html" , "inReplyTo" : "DB6756E4-1448-4517-88B2-06FF1578D440@anandabits.com" , "date" : { "$date" : 1449373402000} , "subject" : "[swift-evolution] Proposal: Allow Getters and Setters to Throw" , "references" : [ "CANhuES0ZoHNV5YXzS2UyUcqE=quzBXz7bHBrpNA=do-_LVNLOg@mail.gmail.com" , "DB6756E4-1448-4517-88B2-06FF1578D440@anandabits.com"] , "descendants" : [ "CAAdsSdrj_WW_h4nDOct-CquOY-ae8Nm40r-DqjV0wpYfAcq84A@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/4CF9AAE7-812C-4F95-A8D8-62B74701957D@alkaline-solutions.com"}} , "_id" : "4CF9AAE7-812C-4F95-A8D8-62B74701957D@alkaline-solutions.com" , "from" : "david at alkaline-solutions.com (David Waite)" , "mailingList" : "swift-evolution" , "content" : "Both NSDate nor NSTimeInterval represent instants in time, not time within a calendaring system. Assuming 86400 seconds is a calendar day is a bug, same as assuming 365 days is a calendar year. That they are using the wrong time primitive doesn’t seem to be affected by whether NSDate implements Strideable or not.\n\n(That there isn’t a comprehensive time system is another problem)\n\n-DW\n\n> On Dec 5, 2015, at 8:10 PM, Pierre Habouzit via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> \n> NSDate (and dates/timestamps in general) is a poor choice for Strideable, because, DST.\n> A Calendar using this interface for a repeating event would be broken using this. Or you would break anyone who really wants to iterate every fixed 86400 seconds.\n> \n> -Pierre" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000500.html" , "inReplyTo" : "0C687B3C-4916-458B-86F0-16B3A9261941@apple.com" , "date" : { "$date" : 1449373694000} , "subject" : "[swift-evolution] [swift-corelibs-dev] Proposal: Conforming NSDate to Comparable" , "references" : [ "CAEryqghYNO4JKWRGkF_qFTew7cGPtG7iNP32DndN1dOHLkjATQ@mail.gmail.com" , "97EB190C-895B-4698-A93E-C1050B92520B@architechies.com" , "0C687B3C-4916-458B-86F0-16B3A9261941@apple.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/1449374024.2155187.459254033.067DF6CC@webmail.messagingengine.com"}} , "_id" : "1449374024.2155187.459254033.067DF6CC@webmail.messagingengine.com" , "from" : "kevin at sb.org (Kevin Ballard)" , "mailingList" : "swift-evolution" , "content" : "On Sat, Dec 5, 2015, at 04:32 PM, Lukas Stabe via swift-evolution wrote:\n>\n>> I don't think you can just get rid of the if statement in favor of an\n>> expression. You still want to be able to do this:\n>>\n>> if (condition) {    funcWithSideEffectsThatReturnsInt() } else {\n>> funcWithSideEffectsThatReturnsString() }\n>>\n>> but that's not a valid expression (what is its type?).\n>\n> An if statement with two different types could just have the closes\n> common ancestor or Any as type.\n\nThat's a great way to cause confusion.\n\nRust has this feature (all statements are expressions), and it requires\nif statements to have an else branch with the same type unless the type\nis `()`. It's solution to the issue of the branches returning unwanted\nvalues is that Rust uses semicolons, and the semicolon acts sort of like\nan operator that consumes any value and returns `()`, so if you\nterminate the last statement of the branch with a semicolon, the whole\nbranch returns `()`, and if you leave it off, the branch returns a\nvalue. It's actually very elegant and straightforward.\n\nThat said, proposing that Swift introduce this same rule for semicolons\nis probably not a good idea. We certainly could declare that an explicit\nsemicolon has this behavior, so you'd see people writing code like\n\nif condition {    funcWithSideEffectsThatReturnsInt(); }\n\nbut it would be confusing because semicolons are almost never\nused in Swift.\n\nAn alternative that would work today is just relying on assignment\nreturning Void, so you can write\n\nif condition {    _ = funcWithSideEffectsThatReturnsInt() }\n\nbut that looks kind of weird and would probably also be confusing.\nBetter than the semicolon rule I think, but still not great.\n\nAnother option is to check if the return value is actually used\nanywhere, and if it's not, then silently coerce it to Void. This way\nyou can write\n\nif condition {    funcWithSideEffectsThatReturnsInt() } else {\nfuncWithSideEffectsThatReturnsString() }\n\nand it would be fine but writing\n\nlet foo = if condition {    funcWithSideEffectsThatReturnsInt() } else {\nfuncWithSideEffectsThatReturnsString() }\n\nwould fail with a type error.\n\nI suspect that this is the right approach, but it does involve a\nbit of magic.\n\n-Kevin" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000501.html" , "inReplyTo" : "E09BFA74-9DDF-4607-B52B-6C8EEC931D1F@gmail.com" , "date" : { "$date" : 1449374024000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com" , "CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com" , "C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com" , "18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com" , "2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io" , "BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com" , "CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com" , "CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com" , "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com" , "BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com" , "909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net" , "0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com" , "49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net" , "CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com" , "E09BFA74-9DDF-4607-B52B-6C8EEC931D1F@gmail.com"] , "descendants" : [ "CADcs6kN7gAr8x9ZbHBSX9gpOoJps=21wi-9ZC7hbtHUtRp54HA@mail.gmail.com" , "1449377752.2181216.459275089.1BA7CBAC@webmail.messagingengine.com" , "D9EA05A0-B3E8-4437-A0D1-F1FC27B0E124@gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/849CDDCE-CC11-4DA1-A8D4-F0440049231C@anandabits.com"}} , "_id" : "849CDDCE-CC11-4DA1-A8D4-F0440049231C@anandabits.com" , "from" : "matthew at anandabits.com (Matthew Johnson)" , "mailingList" : "swift-evolution" , "content" : "As stated previously, I think a more specific solution is the best way to address the initialization / setup / configuration problem. While that is the case I did think some more about the ideas in this thread.\n\nI believe two things are being proposed here:\n\n1. The ability to append a trailing closure to any initializer (that doesn’t already declare one itself) that accepts a single argument of the initialized type.  If the caller supplies such a closure, the compiler performs a code transformation as follows:\n\nlet questionLabel = UILabel() {\n\t$0.textAlignment = .Center\n\t$0.font =  UIFont(name:\"DnealianManuscript\", size: 72)\n\t$0.numberOfLines = 0\n}\n\nbecomes something like this (which is valid Swift today:\n\nlet questionLabel = UILabel(); {\n\t$0.textAlignment = .Center\n\t$0.font =  UIFont(name:\"DnealianManuscript\", size: 72)\n\t$0.numberOfLines = 0\n}(questionLabel)\n\nThe code transformation doesn’t actually buy us much.  I’m a big believer in removing the need for clutter and boilerplate as much as possible, but even I must admit that the difference is really small and can be reduced a bit further using currently valid Swift code as demonstrated by the “configuration operator” mentioned in the previous post.\n\n2. A new abbreviation of the $0 shorthand that would be valid only as the first characters on a line of code.  For consistency this shorthand should work in any closure, not just in “setup closures”.  I agree that $0 is uglier than necessary in this use case which would be relatively common in Cocoa code if this pattern becomes common.\n\nThe biggest drawback I can think of to a feature like this is that it is a feature specifically designed to make the use of var members more convenient.  It might be a good thing that “setup closures\" are a little bit ugly given that they are only able to “setup\" mutable members and require those members to be initialized to potentially meaningless default values (or worse, IUO members defaulted to nil!).  \n\nIdeally an instance would be configured correctly when the initializer completes and we should work to find language solutions to make this safe and convenient.  Once we have the right language solutions ideally we can use them in new types and retrofit existing types to use them over time, thus eliminating the need for “setup closures” alltogether.\n\n\n> On Dec 5, 2015, at 6:16 PM, ilya via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> > PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.  Here's one example: ...\n> \n> FWIW, I created a configuration operator more then a year ago, and use it in all of my Swift projects:\n> \n> let task = NSTask() +=+ {\n>     $0.launchPath = \"/usr/bin/mdfind\"\n>     $0.arguments = [\"kMDItemDisplayName == *.playground\"]\n>     $0.standardOutput = pipe\n> }\n> \n> Note you can also use the configured object in the rhs:\n> \n> let questionLabel = UILabel() +=+ {\n>     $0.textAlignment = .Center\n>     $0.font =  UIFont(name:\"DnealianManuscript\", size: 72)\n>     $0.text = currentQuestion.questionText\n>     $0.numberOfLines = 0\n>     view.addSubview($0)\n> }\n> \n> This $0. certainly looks ugly and it would be great to be able to simplify this. I don't llike the following much though (dot-syntax can be ambiguos here, and using simply a method name is even worse):\n> \n> let questionLabel = UILabel() +=+ {\n>     .textAlignment = .Center\n>     .font =  UIFont(name:\"DnealianManuscript\", size: 72)\n>     .text = currentQuestion.questionText\n>     .numberOfLines = 0\n>     view.addSubview($0)\n> }\n> \n> Actually I would be happy with something like\n> \n> let questionLabel = UILabel() .{\n>     ..textAlignment = .Center\n>     ..font = UIFont(name:\"DnealianManuscript\", size: 72)\n>     ..text = currentQuestion.questionText\n>     ..numberOfLines = 0\n>     view.addSubview($0)\n> }\n> \n> Other thoughts?\n> \n>   \n>  _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000502.html" , "inReplyTo" : "CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com" , "date" : { "$date" : 1449376264000} , "subject" : "[swift-evolution] Request for Discussion: Setup closures" , "references" : [ "CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com"] , "descendants" : [ "0413C70D-A999-46F1-8D46-FEEC93F2C2FC@gmail.com" , "AA0220E6-BD02-4B04-98DF-C73C00F8FB0C@anandabits.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAOFcyhsDudbUDgn=+=hMDapzmPVj-ZYcSh+DnSY8f-grAvWewA@mail.gmail.com"}} , "_id" : "CAOFcyhsDudbUDgn=+=hMDapzmPVj-ZYcSh+DnSY8f-grAvWewA@mail.gmail.com" , "from" : "ilya at harmonicsense.com (Ilya)" , "mailingList" : "swift-evolution" , "content" : "I think the it would help a great deal to have an access level modifier\nthat is really private and visible only inside the class itself. Right now,\nthe only way to hide implementation details for a class is to hide the\nclass code in a separate file, which is very inconvenient for several\nreasons:\n\n1) the meaning of the code changes depending on which file the class is in.\nIt's very easy to accidentally expose class internal details and then call\nclass elements that are meant to be used only inside the class. Having a\nkeyword for class internals will allow the compiler to ensure that only the\npublic API for the class is used from the outside world. The user can check\ntypes on his own, but it's better that the compiler does it automatically.\nSimilarly, the user can check that only the proper APIs are called, but\nit's better that the compiler does it automatically.\n\n2) accessibility by file structure may cause some really short files.\n\n3) It's impossible to group related classes in one file but still hide\nimplementation details inside each class\n\nI think that it the best solution is to make private keyword do what it\nstates -- keep the class element private to the class. But if it's really\nimportant to have a separate keyword for backward compatibility, it would\nbe the next best thing.\n\n--\nIlya Belenkiy" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000503.html" , "date" : { "$date" : 1449376788000} , "subject" : "[swift-evolution] access control proposal" , "references" : [ ""] , "inReplyTo" :  null  , "descendants" : [ "1449386582.2217334.459315937.637FDF9A@webmail.messagingengine.com" , "49615F0C-DAC5-4976-A6EF-E471DA77E3F1@apple.com" , "CAOFcyhsEx-kWP556A9vHAmvtzVaZ7qMq2ZZ5wryCyMprqiBTkA@mail.gmail.com" , "CAOFcyht_Bb87-E1mmAQ6Jiz8wN+3yQcA+3LbQRbXrCGqtArc0w@mail.gmail.com" , "B2A2287F-7593-46ED-8F4E-0C3AA4CC2594@anandabits.com" , "86AD0BF2-C94C-4E31-9FDA-7A5769C2E754@anandabits.com" , "CAOFcyhuvYPAmJTrCkNAP7beYYpnXEPS8kqjWvR_cwwyvPcMH6g@mail.gmail.com" , "CAOFcyhsaYCvKoG-jrBv19RJFQTc0cvBOCKandd_ZVQXL2rPJSw@mail.gmail.com" , "2F8056F5-0055-40F5-9512-91F0C98AB0AD@anandabits.com" , "5BF684E3-E1AB-4CA7-B6C8-C8A211D2047D@portableinnovations.de" , "D0C68B63-3842-4672-9A9E-E0DEC279DD65@me.com" , "D795A846-6300-402C-949D-7D4827A1C392@me.com" , "328765B7-815B-412F-9F30-8C53C59B39F7@apple.com" , "669E96AD-55C1-4767-B1C9-002327AE553B@me.com" , "4A58C621-9533-40E8-A612-BA1FFB4C3C48@me.com" , "56F6A7FA-DE72-4874-A6F9-3F69BA9CC3EC@me.com" , "82B91DE8-DF15-47AF-AD27-3311DBC72954@me.com" , "CAOFcyhs+uDXaauag-bH9Lo+Gcbn6EToQO6VbJo5+_yysMpfPzg@mail.gmail.com" , "1FEB1C9E-BC89-4D12-BD82-C43890EDB285@gmail.com" , "8E9F78CB-B987-44C9-9CC8-67732F86D26B@apple.com" , "9C610699-EF57-4475-8634-5E1219DB1D46@anandabits.com" , "151A33C4-25AC-4D27-ADD3-3FCBE9B39054@anandabits.com" , "3A96EDCC-44A1-4C97-A2E0-4339EA1515D9@apple.com" , "7133805B-A7BE-4184-80BA-08537DE842D3@apple.com" , "1C3C1B92-AD86-4A6F-81E5-309D2E0898AF@anandabits.com" , "CA849834-49D0-4301-A443-8F1D9716364C@apple.com" , "FB30E04F-D6A4-448D-A6B4-895DC49623A1@anandabits.com" , "CAOFcyhtNXGS3UOHPMwAxNahfh0zHkTtr2X3OowUYkHHq0U7dUw@mail.gmail.com" , "CAOFcyhv-zMy3s+76HOBEWDK6wte3oBeG79CHvPv941=5q3w4YQ@mail.gmail.com" , "A9F1223B-5CB4-404D-98BD-F9F7A0E1EE54@anandabits.com" , "159055DF-A191-4A0C-84E0-8F8581728668@anandabits.com" , "24273422-F7C8-4F56-8B31-4563FC0BC21A@apple.com" , "BEAFB1A1-75C6-4330-9DFC-2E240E44F949@tarantsov.com" , "DD29A18B-55A6-4619-A268-342BAA8AADA9@tarantsov.com" , "1D8D398C-149B-4396-B870-539DBFE202C9@me.com" , "056EDFCA-6808-4D22-9066-62A41D43B1D1@me.com" , "A41CF69D-BEC6-4C57-BE13-131B4878C255@me.com" , "1B7B1E10-5264-425F-B65A-6018ACD7C172@me.com" , "8BF47384-249E-46FE-9022-CC5EB248E8C8@me.com" , "36F67EA0-94E3-408F-A9BF-96FF2CC3A50A@xenonium.com" , "2F2369F7-0741-46A9-A29A-6094B8B2815C@me.com" , "6C7D37B1-7BB2-4152-AF95-A45C39F17F6C@apple.com" , "4086B4E1-022C-4075-856A-075A3D571D8A@me.com" , "F324E954-1F60-410A-A716-EEAA9617D3B8@apple.com" , "CANhuES2UxBj5vpbFOENGxRBNU5EMD_XqBYBC+QkfYRwsMpHvgA@mail.gmail.com" , "B6DC456F-C246-4511-BBE3-4FB1C612B3DE@owensd.io" , "CAOFcyhuUn_MdAogsUPVTKNmfG_3=CRSL9PS1r1UQbj+06ejqww@mail.gmail.com" , "958F9EE3-A4F1-4021-8A8D-6A51328226FB@icloud.com" , "CAOFcyhvhJrOYN7mYrOhDoNxixMEsi3YFCR25eMy5Y4pF6XEBkg@mail.gmail.com" , "328DA9F6-28F1-4666-9E1A-35786BF26C83@anandabits.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/11A9AA09-5F9E-4AF7-8CE1-82BAB42E896A@jonshier.com"}} , "_id" : "11A9AA09-5F9E-4AF7-8CE1-82BAB42E896A@jonshier.com" , "from" : "jon at jonshier.com (Jon Shier)" , "mailingList" : "swift-evolution" , "content" : "\tSwift’s biggest issue preventing it from being a good teaching or learning language is its still rather poor error messaging, especially when the compiler becomes confused about types. Aside from that, type inference serves to remove the immediate need to learn about types for the beginner.\n\n\nJon Shier\n\n\n> On Dec 5, 2015, at 7:13 PM, Austin Zheng via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> No, I don't. I think Python's biggest appeal to new programmers is the fact that it has such a great standard library, making it really easy to do whatever you want to do without figuring out how to find or add in external dependencies.\n> \n> Anyways, mistyped Python code still breaks, it just breaks at runtime instead of compile time. In fact, I'd argue that this is even less beginner friendly, since you might write a function that works with some inputs and then inexplicably breaks with others.\n> \n> Austin\n> \n>> On Dec 5, 2015, at 4:09 PM, Amir Michail <a.michail at me.com <mailto:a.michail at me.com>> wrote:\n>> \n>> \n>>> On Dec 5, 2015, at 7:05 PM, Austin Zheng via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>> \n>>> ml>\n>>> I disagree with the idea that a type system is too much of a hurdle for beginner programmers to overcome.\n>> \n>> Don’t you think that Python currently provides a better introduction to programming due to its simplicity?\n>> \n>>> \n>>> Austin\n>>> \n>>>> On Dec 5, 2015, at 4:01 PM, Kevin Lundberg via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>>> \n>>>> This is somewhat possible today on Apple platforms with AnyObject. You can call any objc-visible method on AnyObject and it will compile, and the return type will also be AnyObject (I don't recall if the return type is optional as well or not). This doesn't work with value types, but neither does id in objc.\n>>>> \n>>>> Having a more complete lax typed mode similar to Python or php I think is of limited usefulness, would add too much complexity to the language, and yield too much uncertainty about any given piece of swift code. \n>>>> \n>>>> --\n>>>> Kevin Lundberg\n>>>> \n>>>> On Dec 5, 2015, at 6:50 PM, Adrian Kashivskyy via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>>> \n>>>>> I can't believe I'm seeing a proposal to remove type safety, one of the fundamental features of Swift...\n>>>>> \n>>>>> Regards,\n>>>>> Adrian Kashivskyy\n>>>>> iOS Developer at Netguru\n>>>>> \n>>>>>> Wiadomość napisana przez Amir Michail via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> w dniu 05.12.2015, o godz. 20:51:\n>>>>>> \n>>>>>> Python is still easier than Swift for beginning programmers. But maybe such a mode can allow Swift to be used by beginners also? _____________________________________________ swift-evolution mailing list swift-evolution at swift.org <mailto:swift-evolution at swift.org> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>> _______________________________________________\n>>>>> swift-evolution mailing list\n>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>> _______________________________________________\n>>>> swift-evolution mailing list\n>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>> \n>>> --rbÚḟîẁ\n>>> íz{CÊhĠ+bḃx§)Ŷ_______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>> https://lists.swift.org/ma <https://lists.swift.org/ma>\n> \n>  _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000504.html" , "inReplyTo" : "B3DEBE77-A879-4A1E-BC4D-1F028E6D326A@gmail.com" , "date" : { "$date" : 1449376878000} , "subject" : "[swift-evolution] A mode with no type checking to compete with Python." , "references" : [ "5E968E10-2DBD-4999-978C-B398BC446A21@me.com" , "7240610C-B5DA-41B8-909A-D138404C6799@me.com" , "0CFEA686-79B9-4B51-A984-7C706879BB5D@klundberg.com" , "E2C52ABB-8CD4-4D5C-BFA3-F3EA995AC6FC@gmail.com" , "7F08A62B-6FD7-4AF2-A939-EF1D3CD71BD7@me.com" , "B3DEBE77-A879-4A1E-BC4D-1F028E6D326A@gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CADcs6kN7gAr8x9ZbHBSX9gpOoJps=21wi-9ZC7hbtHUtRp54HA@mail.gmail.com"}} , "_id" : "CADcs6kN7gAr8x9ZbHBSX9gpOoJps=21wi-9ZC7hbtHUtRp54HA@mail.gmail.com" , "from" : "jtbandes at gmail.com (Jacob Bandes-Storch)" , "mailingList" : "swift-evolution" , "content" : "That approach seems fine to me; I don't think it seems like magic.\n\n\"if x { returnsAnInt() } else { returnsAString() }\"  would have type Any,\nbut would only emit a warning if you actually tried to *use* the value.\nMuch like the current warning, \"*X inferred to have type Any, which may be\nunexpected*\".\n\nJacob Bandes-Storch\n\nOn Sat, Dec 5, 2015 at 7:53 PM, Kevin Ballard via swift-evolution <\nswift-evolution at swift.org> wrote:\n\n> On Sat, Dec 5, 2015, at 04:32 PM, Lukas Stabe via swift-evolution wrote:\n>\n>\n>\n> I don't think you can just get rid of the if statement in favor of an\n> expression. You still want to be able to do this:\n>\n> if (condition) {\n>     funcWithSideEffectsThatReturnsInt()\n> } else {\n>     funcWithSideEffectsThatReturnsString()\n> }\n>\n> but that's not a valid expression (what is its type?).\n>\n>\n> An if statement with two different types could just have the closes common\n> ancestor or Any as type.\n>\n>\n> That's a great way to cause confusion.\n>\n> Rust has this feature (all statements are expressions), and it requires if\n> statements to have an else branch with the same type unless the type is\n> `()`. It's solution to the issue of the branches returning unwanted values\n> is that Rust uses semicolons, and the semicolon acts sort of like an\n> operator that consumes any value and returns `()`, so if you terminate the\n> last statement of the branch with a semicolon, the whole branch returns\n> `()`, and if you leave it off, the branch returns a value. It's actually\n> very elegant and straightforward.\n>\n> That said, proposing that Swift introduce this same rule for semicolons is\n> probably not a good idea. We certainly could declare that an explicit\n> semicolon has this behavior, so you'd see people writing code like\n>\n> if condition {\n>     funcWithSideEffectsThatReturnsInt();\n> }\n>\n> but it would be confusing because semicolons are almost never used in\n> Swift.\n>\n> An alternative that would work today is just relying on assignment\n> returning Void, so you can write\n>\n> if condition {\n>     _ = funcWithSideEffectsThatReturnsInt()\n> }\n>\n> but that looks kind of weird and would probably also be confusing. Better\n> than the semicolon rule I think, but still not great.\n>\n> Another option is to check if the return value is actually used anywhere,\n> and if it's not, then silently coerce it to Void. This way you can write\n>\n> if condition {\n>     funcWithSideEffectsThatReturnsInt()\n> } else {\n>     funcWithSideEffectsThatReturnsString()\n> }\n>\n> and it would be fine but writing\n>\n> let foo = if condition {\n>     funcWithSideEffectsThatReturnsInt()\n> } else {\n>     funcWithSideEffectsThatReturnsString()\n> }\n>\n> would fail with a type error.\n>\n> I suspect that this is the right approach, but it does involve a bit of\n> magic.\n>\n> -Kevin\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000505.html" , "inReplyTo" : "1449374024.2155187.459254033.067DF6CC@webmail.messagingengine.com" , "date" : { "$date" : 1449377178000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com" , "CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com" , "C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com" , "18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com" , "2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io" , "BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com" , "CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com" , "CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com" , "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com" , "BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com" , "909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net" , "0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com" , "49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net" , "CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com" , "E09BFA74-9DDF-4607-B52B-6C8EEC931D1F@gmail.com" , "1449374024.2155187.459254033.067DF6CC@webmail.messagingengine.com"] , "descendants" : [ "1449377752.2181216.459275089.1BA7CBAC@webmail.messagingengine.com" , "D9EA05A0-B3E8-4437-A0D1-F1FC27B0E124@gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/D9EA05A0-B3E8-4437-A0D1-F1FC27B0E124@gmail.com"}} , "_id" : "D9EA05A0-B3E8-4437-A0D1-F1FC27B0E124@gmail.com" , "from" : "ahti333 at gmail.com (Lukas Stabe)" , "mailingList" : "swift-evolution" , "content" : "I agree.\n\nI’m sure there are use-cases where the different branches return different types, both conforming to some protocol. Since we’d need to support these cases, this approach is also pretty clean, because Any is just another protocol.\n\nThe warning emitted should be silenceable by explicitly declaring the variable being assigned to as Any.\n\nLukas\n\n> On 06 Dec 2015, at 05:46, Jacob Bandes-Storch via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> That approach seems fine to me; I don't think it seems like magic.\n> \n> \"if x { returnsAnInt() } else { returnsAString() }\"  would have type Any, but would only emit a warning if you actually tried to use the value. Much like the current warning, \"X inferred to have type Any, which may be unexpected\".\n> \n> Jacob Bandes-Storch\n> \n> On Sat, Dec 5, 2015 at 7:53 PM, Kevin Ballard via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n> On Sat, Dec 5, 2015, at 04:32 PM, Lukas Stabe via swift-evolution wrote:\n>>  \n>>> I don't think you can just get rid of the if statement in favor of an expression. You still want to be able to do this:\n>>>  \n>>> if (condition) {\n>>>     funcWithSideEffectsThatReturnsInt()\n>>> } else {\n>>>     funcWithSideEffectsThatReturnsString()\n>>> }\n>>>  \n>>> but that's not a valid expression (what is its type?).\n>>  \n>> An if statement with two different types could just have the closes common ancestor or Any as type.\n>  \n> That's a great way to cause confusion.\n>  \n> Rust has this feature (all statements are expressions), and it requires if statements to have an else branch with the same type unless the type is `()`. It's solution to the issue of the branches returning unwanted values is that Rust uses semicolons, and the semicolon acts sort of like an operator that consumes any value and returns `()`, so if you terminate the last statement of the branch with a semicolon, the whole branch returns `()`, and if you leave it off, the branch returns a value. It's actually very elegant and straightforward.\n>  \n> That said, proposing that Swift introduce this same rule for semicolons is probably not a good idea. We certainly could declare that an explicit semicolon has this behavior, so you'd see people writing code like\n>  \n> if condition {\n>     funcWithSideEffectsThatReturnsInt();\n> }\n>  \n> but it would be confusing because semicolons are almost never used in Swift.\n>  \n> An alternative that would work today is just relying on assignment returning Void, so you can write\n>  \n> if condition {\n>     _ = funcWithSideEffectsThatReturnsInt()\n> }\n>  \n> but that looks kind of weird and would probably also be confusing. Better than the semicolon rule I think, but still not great.\n>  \n> Another option is to check if the return value is actually used anywhere, and if it's not, then silently coerce it to Void. This way you can write\n>  \n> if condition {\n>     funcWithSideEffectsThatReturnsInt()\n> } else {\n>     funcWithSideEffectsThatReturnsString()\n> }\n>  \n> and it would be fine but writing\n>  \n> let foo = if condition {\n>     funcWithSideEffectsThatReturnsInt()\n> } else {\n>     funcWithSideEffectsThatReturnsString()\n> }\n>  \n> would fail with a type error.\n>  \n> I suspect that this is the right approach, but it does involve a bit of magic.\n>  \n> -Kevin\n> \n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n> \n> \n>  _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000506.html" , "inReplyTo" : "CADcs6kN7gAr8x9ZbHBSX9gpOoJps=21wi-9ZC7hbtHUtRp54HA@mail.gmail.com" , "date" : { "$date" : 1449377692000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com" , "CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com" , "C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com" , "18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com" , "2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io" , "BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com" , "CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com" , "CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com" , "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com" , "BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com" , "909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net" , "0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com" , "49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net" , "CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com" , "E09BFA74-9DDF-4607-B52B-6C8EEC931D1F@gmail.com" , "1449374024.2155187.459254033.067DF6CC@webmail.messagingengine.com" , "CADcs6kN7gAr8x9ZbHBSX9gpOoJps=21wi-9ZC7hbtHUtRp54HA@mail.gmail.com" , ""]} , { "_links" : { "self" : { "href" : "/charter/emails/1449377752.2181216.459275089.1BA7CBAC@webmail.messagingengine.com"}} , "_id" : "1449377752.2181216.459275089.1BA7CBAC@webmail.messagingengine.com" , "from" : "kevin at sb.org (Kevin Ballard)" , "mailingList" : "swift-evolution" , "content" : "If it's defined as type Any, then we'd also need a guaranteed compiler\noptimization (preferably one that happens in debug builds too) that\nomits the creation of the `Any` value if it's unused.\n\n-Kevin\n\nOn Sat, Dec 5, 2015, at 08:46 PM, Jacob Bandes-Storch wrote:\n> That approach seems fine to me; I don't think it seems like magic.\n>\n> \"if x { returnsAnInt() } else { returnsAString() }\"  would have type\n> Any, but would only emit a warning if you actually tried to *use* the\n> value. Much like the current warning, \"*X inferred to have type Any,\n> which may be unexpected*\".\n>\n> Jacob Bandes-Storch\n>\n> On Sat, Dec 5, 2015 at 7:53 PM, Kevin Ballard via swift-evolution <swift-\n> evolution at swift.org> wrote:\n>> __\n>>\n>> On Sat, Dec 5, 2015, at 04:32 PM, Lukas Stabe via swift-\n>> evolution wrote:\n>>>\n>>>> I don't think you can just get rid of the if statement in favor of\n>>>> an expression. You still want to be able to do this:\n>>>>\n>>>> if (condition) {    funcWithSideEffectsThatReturnsInt() } else {\n>>>> funcWithSideEffectsThatReturnsString() }\n>>>>\n>>>> but that's not a valid expression (what is its type?).\n>>>\n>>> An if statement with two different types could just have the closes\n>>> common ancestor or Any as type.\n>>\n>>\n>> That's a great way to cause confusion.\n>>\n>> Rust has this feature (all statements are expressions), and it\n>> requires if statements to have an else branch with the same type\n>> unless the type is `()`. It's solution to the issue of the branches\n>> returning unwanted values is that Rust uses semicolons, and the\n>> semicolon acts sort of like an operator that consumes any value and\n>> returns `()`, so if you terminate the last statement of the branch\n>> with a semicolon, the whole branch returns `()`, and if you leave it\n>> off, the branch returns a value. It's actually very elegant and\n>> straightforward.\n>>\n>> That said, proposing that Swift introduce this same rule for\n>> semicolons is probably not a good idea. We certainly could declare\n>> that an explicit semicolon has this behavior, so you'd see people\n>> writing code like\n>>\n>> if condition {    funcWithSideEffectsThatReturnsInt(); }\n>>\n>> but it would be confusing because semicolons are almost never used\n>> in Swift.\n>>\n>> An alternative that would work today is just relying on assignment\n>> returning Void, so you can write\n>>\n>> if condition {    _ = funcWithSideEffectsThatReturnsInt() }\n>>\n>> but that looks kind of weird and would probably also be confusing.\n>> Better than the semicolon rule I think, but still not great.\n>>\n>> Another option is to check if the return value is actually used\n>> anywhere, and if it's not, then silently coerce it to Void. This way\n>> you can write\n>>\n>> if condition {    funcWithSideEffectsThatReturnsInt() } else {\n>> funcWithSideEffectsThatReturnsString() }\n>>\n>> and it would be fine but writing\n>>\n>> let foo = if condition {    funcWithSideEffectsThatReturnsInt() }\n>> else {    funcWithSideEffectsThatReturnsString() }\n>>\n>> would fail with a type error.\n>>\n>> I suspect that this is the right approach, but it does involve a bit\n>> of magic.\n>>\n>> -Kevin\n>>\n>>\n>> _______________________________________________\n>>\nswift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000507.html" , "inReplyTo" : "CADcs6kN7gAr8x9ZbHBSX9gpOoJps=21wi-9ZC7hbtHUtRp54HA@mail.gmail.com" , "date" : { "$date" : 1449377752000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com" , "CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com" , "C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com" , "18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com" , "2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io" , "BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com" , "CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com" , "CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com" , "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com" , "BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com" , "909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net" , "0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com" , "49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net" , "CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com" , "E09BFA74-9DDF-4607-B52B-6C8EEC931D1F@gmail.com" , "1449374024.2155187.459254033.067DF6CC@webmail.messagingengine.com" , "CADcs6kN7gAr8x9ZbHBSX9gpOoJps=21wi-9ZC7hbtHUtRp54HA@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CANhuES2UxBj5vpbFOENGxRBNU5EMD_XqBYBC+QkfYRwsMpHvgA@mail.gmail.com"}} , "_id" : "CANhuES2UxBj5vpbFOENGxRBNU5EMD_XqBYBC+QkfYRwsMpHvgA@mail.gmail.com" , "from" : "nvazquez1297 at gmail.com (Nikolai Vazquez)" , "mailingList" : "swift-evolution" , "content" : "I agree that there should be an access level that hides implementation\ndetails from other types in the same file. However, it shouldn’t replace\nprivate, because 1) helper types might benefit from private elements and 2)\nlike you said, backwards compatibility.\n\nOn Sat, Dec 5, 2015 at 11:40 PM Ilya via swift-evolution <\nswift-evolution at swift.org> wrote:\n\nI think the it would help a great deal to have an access level modifier\n> that is really private and visible only inside the class itself. Right now,\n> the only way to hide implementation details for a class is to hide the\n> class code in a separate file, which is very inconvenient for several\n> reasons:\n>\n> 1) the meaning of the code changes depending on which file the class is\n> in. It's very easy to accidentally expose class internal details and then\n> call class elements that are meant to be used only inside the class. Having\n> a keyword for class internals will allow the compiler to ensure that only\n> the public API for the class is used from the outside world. The user can\n> check types on his own, but it's better that the compiler does it\n> automatically. Similarly, the user can check that only the proper APIs are\n> called, but it's better that the compiler does it automatically.\n>\n> 2) accessibility by file structure may cause some really short files.\n>\n> 3) It's impossible to group related classes in one file but still hide\n> implementation details inside each class\n>\n> I think that it the best solution is to make private keyword do what it\n> states -- keep the class element private to the class. But if it's really\n> important to have a separate keyword for backward compatibility, it would\n> be the next best thing.\n>\n> --\n> Ilya Belenkiy\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000508.html" , "inReplyTo" : "CAOFcyhsDudbUDgn=+=hMDapzmPVj-ZYcSh+DnSY8f-grAvWewA@mail.gmail.com" , "date" : { "$date" : 1449378250000} , "subject" : "[swift-evolution] access control proposal" , "references" : [ "CAOFcyhsDudbUDgn=+=hMDapzmPVj-ZYcSh+DnSY8f-grAvWewA@mail.gmail.com"] , "descendants" : [ "1449386582.2217334.459315937.637FDF9A@webmail.messagingengine.com" , "B6DC456F-C246-4511-BBE3-4FB1C612B3DE@owensd.io"]} , { "_links" : { "self" : { "href" : "/charter/emails/74FC29AE-AF91-4360-BDA1-EF54AA6A74F8@architechies.com"}} , "_id" : "74FC29AE-AF91-4360-BDA1-EF54AA6A74F8@architechies.com" , "from" : "brent at architechies.com (Brent Royal-Gordon)" , "mailingList" : "swift-evolution" , "content" : "> NSDate (and dates/timestamps in general) is a poor choice for Strideable, because, DST.\n> A Calendar using this interface for a repeating event would be broken using this. Or you would break anyone who really wants to iterate every fixed 86400 seconds.\n\nSometimes you want to add an interval of time according to the user’s clock; NSTimeInterval/NSDate math will do the wrong thing there. But sometimes you just want to get an NSDate thirty seconds from now, and for all you care the user can fly to Timbuktu during that time. That’s the sort of thing I’m using this for:\n\n\t// Don’t add to undo manager if we’re too close to the last change\n\tguard now - lastChangeDate > undoCoalescingTimespan else { return } \n\nIt is simply not the case that *all* arithmetic on NSDates is incorrect unless it involves NSCalendar and NSDateComponents.\n\n-- \nBrent Royal-Gordon\nArchitechies" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000509.html" , "inReplyTo" : "0C687B3C-4916-458B-86F0-16B3A9261941@apple.com" , "date" : { "$date" : 1449378614000} , "subject" : "[swift-evolution] [swift-corelibs-dev] Proposal: Conforming NSDate to Comparable" , "references" : [ "CAEryqghYNO4JKWRGkF_qFTew7cGPtG7iNP32DndN1dOHLkjATQ@mail.gmail.com" , "97EB190C-895B-4698-A93E-C1050B92520B@architechies.com" , "0C687B3C-4916-458B-86F0-16B3A9261941@apple.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/6935BB3A-2203-406C-9EC2-02FF7287767F@anandabits.com"}} , "_id" : "6935BB3A-2203-406C-9EC2-02FF7287767F@anandabits.com" , "from" : "matthew at anandabits.com (Matthew Johnson)" , "mailingList" : "swift-evolution" , "content" : "Thank you for taking the time to provide this feedback!  \n\nI was trying to focus more on the problem we need to solve and just quickly sketch something that would solve it by building on the previous proposal.  I agree the syntax (and likely semantics) left a lot to be desired and should be vastly improved.  I was primarily demonstrating that is *possible* to solve the problem, we just need to find the right solution.  \n\nI’m glad to hear you also believe it’s a problem worth solving and just didn’t like specific details of the solution.  I do think it’s worth solving the more general problem even though a good solution may be more difficult to find.  If we adopt a simpler solution like the one you propose for default initializers it is likely to significantly constrain our options for solving the more general problem (in order to play nice with the simpler solution you propose).\n\nI also believe that this problem is intimately related to the problem addressed in the “setup closures” thread as a general solution would supersede the need for “setup closures\".\n\nI would like to try coming at this problem from a different angle and see if that solution feels any better to us.  Let’s consider an @initializable attribute for members:\n\n@initializable members that are set by the initializer are not generated as parameters by the compiler as the body of the initializer is taking responsibility for initializing that member.  The initializer is free to manually declare the a parameter with the name of the member it is initializing and use that if desired but it is not required to do so.  This will ensure boilerplate still works as expected when a programmer provides it.\n\n@initializable members not set in the implementation of an initializer are generated as parameters automatically by the compiler at the end of the argument list (but before any variadic or trailing closure arguments) in the order the members are declared in the type itself.  If the member declares a default value, the compiler uses that as the default value for the argument.  Ideally the caller can re-order the labeled arguments as desired.\n\nPrivate members are allowed to be @initializable and may be exposed through internal or public initializers.  The member itself is still hidden outside the scope of the file but any internal or public initializers should still be able to accept an initial value from a caller if desired, just as is possible with manual boilerplate today.\n\nThe general form of an initializer with automatically generated parameters would look something like this:\n\ninit() {\n    // Compiler generated code to set the members for which it generated parameters.\n\n    // The initializer is now free to access the value proved by the caller by accessing the member which has now been initialized by the compiler generated code.\n\n    // The initializer sets any members it needs to directly.\n    // This includes all members not marked @initializable that do not have default values.\n}\n\nThere are probably some additional details to work out in relative to two-phase initialization of classes, but I think this conveys the basic idea.  \n\nHere is an example:\n\nstruct S {\n    @initializable let i: Int\n    @initializable private let s: String = “s”\n    let f: Float = 1\n    let d: Double\n\n    // i must be provided by the caller\n    // s may be provided by the caller but is not required as there is a default value of “s”\n    // f may be initialized directly but does not need to be as there is a default value of 1\n    // d must be initialized directly by the initializer\n    // callers see init(i: Int, s: String = “s\")\n    init() {\n        // the initializer is free to read both i and s as the compiler automatically initializes them \n        // with the value provided by the caller or the default value before the body of the initializer is entered\n        d = Double(i)\n        // f is initialized by the compiler to its default value\n    }\n\n    // s may be provided by the caller but is not required as there is a default value of “s”\n    // callers see init(i: Int, j: Int, d: Double, s: String = “s\")\n    init(i: Int, j: Int, d: Double) {\n        // the initializer is free to read s as the compiler automatically initializes it automatically\n        // with the value provided by the caller or the default value before the body of the initializer is entered\n        // this initializer may not read the value of i because the compiler does not automatically generate \n        // an initializer for it as is initialized directly\n\n        // the i parameter does not need to be used to directly initialize self.i and can be used to perform computation\n        // if desired in order to provide backwards compatibility with existing code\n        self.i = i + j\n        self.d = d\n        // f is initialized by the compiler to its default value\n    }\n}\n\nOne drawback to a solution like this is that it could result in the compiler generating parameters for an initializer that the developer did not intend but “forgot\" to initialize directly.  \n\nWhen it does so for a member that does not contain a default value, tests and calling code should fail to compile calling attention to the problem.  In this case the problem is not too severe.  \n\nOn the other hand, if the member declares a default value calling code would still compile and the member would be initialized to the default value.  This is identical to the behavior of member not marked @initializable that a developer “forgets” to initialize if it declares a default value (i.e. the correct behavior for the initializer would require a value different than the default).  The primary difference is the compiler generated parameter for the @initializable member that the implementer “forgot” to initialize, potentially allowing a caller to provide a value and initialize the instance in an incorrect way that is *different* than the default value which should not have been used by the initializer.\n\nAnother drawback to this approach is that it is not explicitly clear when reading an initializer’s parameter list.  One way to mitigate this would be to require the initializer itself to be marked with @initializable in order to opt-in to the compiler generated parameters.  This at least alerts the reader that they exist.  It provides less information than the \"init default()” approach as some @initializable members might be initialized directly in the initializer body which would suppress the compiler generated parameter.  However, the semantics of @initializable are pretty straightforward so I don’t think this would cause too much confusion.\n\nDocumentation generated for the initializer, autocomplete, etc would all expose the full parameter including the parameters the compiler generated for @initializable members.\n\nI would like to revisit the Player example to see how it would fare using this approach:\n\n   class Player {\n       @initializable var name: String\n       @initializable private(set) var points: Int\n\n       func addPoints(additionalPoints: Int) {\n           points += additionalPoints\n       }\n\n       // the previous post stated ‘Creates init(name: String, score: Int)' which does not match the members\n       // this has been modified to match the members as was likely intended\n       // Creates init(name: String, points: Int) \n       init() {}\n   }\n\nlater in Player’s life:\n\n   class Player {\n       let syncIdentifier = NSUUID()\n       var name: String\n       private var pointChanges: Set<PointChange>\n\n       var points: Int {\n           get { return pointChanges.reduce(0, combine: +) }\n       }\n\n       func addPoints(additionalPoints: Int) {\n           pointChanges.insert(PointChange(offset: additionalPoints)\n       }\n\n       // We can no longer use the compiler generated parameters, but we can still create an initializer with the same signature.\n       // Furthermore, if we do not need to be concerned about the declaration order of keyword arguments\n       // we can now leave off the boilerplate for “name” and allow the compiler to generate it\n       // without requiring any changes to call sites.\n       init(name: String, points: Int) {\n           self.name = name\n           pointChanges = [ PointChange(offset: points) ] // the original post had score here which did not match the parameter name\n       }\n   }\n\nDoes this solution look any better to you than the previous idea?\n\n\n\n> On Dec 5, 2015, at 4:31 PM, Brent Royal-Gordon <brent at architechies.com> wrote:\n> \n>> Did you read through by reply to the original proposal?  I believe it provides the convenience you're looking for here while still allowing for the flexibility to avoid boilerplate in initializers that do more than just set properties.  \n> \n> I did, and I didn’t really like it. One of the syntaxes it proposed was strange and ad-hoc; the other was a fairly arbitrary overloading of parentheses, although it doesn’t actually conflict with anything since you can’t overload “calling parentheses” on a non-function.\n> \n> It’s important to ensure that, when the implementation evolves, you can replace the initializer transparently. For instance, suppose I have a type which represents a player in a game. It uses a stored property called `points`:\n> \n>    class Player {\n>        var name: String\n>        private(set) var points: Int\n> \n>        func addPoints(additionalPoints: Int) {\n>            points += additionalPoints\n>        }\n> \n>        // Creates init(name: String, score: Int)\n>        init default()\n>    }\n> \n> Later, I decide to add syncing, and realize I need to change this model. I need to add a sync identifier, and I want to change `points` to be computed from a series of `PointChange` objects. (This is a common strategy to avoid sync conflicts.) However, I don’t want to disrupt any of my existing code when I do this.\n> \n>    class Player {\n>        let syncIdentifier = NSUUID()\n>        var name: String\n>        private var pointChanges: Set<PointChange>\n> \n>        var points: Int {\n>            get { return pointChanges.reduce(0, combine: +) }\n>        }\n> \n>        func addPoints(additionalPoints: Int) {\n>            pointChanges.insert(PointChange(offset: additionalPoints)\n>        }\n> \n>        // We can no longer use init default(), but we can still create an initializer with the same signature\n>        init(name: String, points: Int) {\n>            self.name = name\n>            pointChanges = [ PointChange(offset: score) ]\n>        }\n>    }\n> \n> By *not* separating the properties into a different syntactical construct from the constructor parameters, I can update my type’s implementation without affecting its interface. If properties were separated syntactically from constructor parameters as you proposed, it would not be possible to change this seamlessly.\n> \n>> If you believe we should have a feature focused strictly on memberwise initializers and not also allow for less boilerplate in more sophisticated initializers I am interested to hear your rationale.\n> \n> Honestly, I would like to fix the boilerplate issue in more sophisticated initializers, but I don’t see a clean way to do that. The other proposals I’ve seen in this thread, along the lines of:\n> \n> \tinit(self.name, self.points) {}\n> \n> Frankly do too much violence to the parameter list. Swift’s declarations have a lovely feature where the declaration basically looks like the usage, except that the concrete values in the usage are replaced by types in the declaration. These proposals destroy that property—when I look at the declaration, I can no longer envision what the call site will look like.\n> \n> Basically, I focused on default initializers because they’re *really* easy to solve and cover a good portion of the common case. I really have no idea how to solve the larger problem, and I haven’t liked any of the other ideas in this thread, but I do know how to solve this more limited problem.\n> \n> -- \n> Brent Royal-Gordon\n> Architechies\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000510.html" , "inReplyTo" : "63177F8D-6BA7-4B1E-9052-BA6D3ED6B0CC@architechies.com" , "date" : { "$date" : 1449379910000} , "subject" : "[swift-evolution] Proposal: helpers for initializing properties of same name as parameters" , "references" : [ "CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com" , "4F8C6141-CEFA-43DA-8FD9-5C787789ED68@architechies.com" , "9DC6F2A2-53E0-4DBB-AF5F-D51314AA49F7@anandabits.com" , "63177F8D-6BA7-4B1E-9052-BA6D3ED6B0CC@architechies.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CA+Y5xYeW972FCuwPUFzT4tpADyHDjJsymqZ-a5rt7vKitDPXfw@mail.gmail.com"}} , "_id" : "CA+Y5xYeW972FCuwPUFzT4tpADyHDjJsymqZ-a5rt7vKitDPXfw@mail.gmail.com" , "from" : "gribozavr at gmail.com (Dmitri Gribenko)" , "mailingList" : "swift-evolution" , "content" : "On Fri, Dec 4, 2015 at 6:13 AM, Vinicius Vendramini\n<vinivendra at gmail.com> wrote:\n>\n> If Swift’s Ints may go up to 2048 bits, I’d agree that they probably cover most cases. That’s not to say a big int would be useless, just that I think it should be separate, meant to be used by those who actually need it rather than interfering with normal Int logic, which is likely to be used more often.\n\nSwift's 'Int's are pointer-sized.  Swift's integer literals can be up\nto 2048 bits, which allows one to write types (e.g., BigInt) that can\nbe initialized from large literals.\n\nDmitri\n\n-- \nmain(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if\n(j){printf(\"%d\\n\",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000511.html" , "inReplyTo" : "028CF26F-131D-48DD-9B70-39A507E1E352@gmail.com" , "date" : { "$date" : 1449381425000} , "subject" : "[swift-evolution] Expanded support for numeric types in stdlib?" , "references" : [ "CANGnqV1qNjcU8w07c2S_dEiedBxpdeKcpk8Evc7uXJwfc4YG-w@mail.gmail.com" , "CA+Y5xYeByUL4b_KvVo5ooRM_FWuTPGakOAh-UT+LPk9JMySACQ@mail.gmail.com" , "CANGnqV1OL+FZnotT6ENrM9M6OBVhEcV2dkXjckd=whY4G1168A@mail.gmail.com" , "CANGnqV1vdDGHqNYkxjN=GR3-Jn0voGCfGdCA8YTEgjKf_q6F_g@mail.gmail.com" , "CA+Y5xYdoF-c=AqP9TyAtt95FZz2Tdph9r+cPb9fyK+nkA6u0Bw@mail.gmail.com" , "7630D974-9311-4D15-B318-631EBF3FEB47@sb.org" , "CANGnqV2RiaLCg=YLnQtH_dm58x54+9hxxCQ+=vA3c=m+qeF6iw@mail.gmail.com" , "028CF26F-131D-48DD-9B70-39A507E1E352@gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/E205F705-1A64-4F4E-B838-EF81DEC56554@apple.com"}} , "_id" : "E205F705-1A64-4F4E-B838-EF81DEC56554@apple.com" , "from" : "clattner at apple.com (Chris Lattner)" , "mailingList" : "swift-evolution" , "content" : ">> On Dec 5, 2015, at 9:08 PM, Nikolai Vazquez via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>> \n>> One of the aspects of Swift that I like is computed properties for structures and classes. It allows for adding logic when obtaining values or for having the returned value be \n> On Dec 5, 2015, at 7:17 PM, Matthew Johnson via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> +1 to this.  Subscripts should also be able to throw and currently cannot.\n\n+1 from me as well.  Subscripts also currently cannot be generic.\n\nI consider all of these implementation limitations, not intentional parts of the design of Swift.  Patches would be very very welcome to help improve these areas.\n\n-Chris\n\n\n> \n> dependent on another.\n>> \n>> As of the `ErrorType` protocol introduction in Swift 2, we can throw errors when it comes to functions and initializers. However, this does not apply to getters and setters.\n>> \n>> ```swift\n>> struct File<Data> {\n>>     var contents: Data {\n>>         get throws { ... }\n>>         set throws { ... }\n>>     }\n>> }\n>> ```\n>> \n>> A better example would be getting and setting the current working directory of the process:\n>> \n>> ```swift\n>> import Foundation\n>> \n>> extension Process {\n>>     static var workingDirectory: String {\n>>         get {\n>>             let fileManager = NSFileManager.defaultManager()\n>>             return fileManager.currentDirectoryPath\n>>         }\n>>         set throws {\n>>             let fileManager = NSFileManager.defaultManager()\n>>             guard fileManager.changeCurrentDirectoryPath(newValue) else {\n>>                 throw Error(\"...\")\n>>             }\n>>         }\n>>     }\n>> }\n>> \n>> \n>> \n>> ```\n>> \n>> \n>>  _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n> \n>  _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000512.html" , "inReplyTo" : "DB6756E4-1448-4517-88B2-06FF1578D440@anandabits.com" , "date" : { "$date" : 1449382047000} , "subject" : "[swift-evolution] Proposal: Allow Getters and Setters to Throw" , "references" : [ "CANhuES0ZoHNV5YXzS2UyUcqE=quzBXz7bHBrpNA=do-_LVNLOg@mail.gmail.com" , "DB6756E4-1448-4517-88B2-06FF1578D440@anandabits.com"] , "descendants" : [ "E3A71685-F75F-46A5-8A35-3ACF38B1C791@anandabits.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/9AC32EEA-ED5F-421E-9B75-E2BB0516667C@apple.com"}} , "_id" : "9AC32EEA-ED5F-421E-9B75-E2BB0516667C@apple.com" , "from" : "clattner at apple.com (Chris Lattner)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 5, 2015, at 4:00 PM, Nathan de Vries via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> It's currently possible to define either or both of the following observers on a property:\n> willSet, called just before the value is stored\n> didSet, called immediately after the new value is stored\n...\n\n> This would mean the following observers could be defined on a property:\n> willSet, called just before the value is stored\n> willChange, called just before the value is stored if the value is different to the previous value\n> didSet, called immediately after the new value is stored\n> didChange, called immediately after the new value is stored if the new value is different to the previous value\n\nI’m open to consider a change along these lines, but the proposal would have to be fleshed out more.  Presumably it would only work for equatable types, right?  Also, can a property have these observers as well as the existing ones?  Would it be possible to add *one of* didChange or willChange - since less is better?\n\n-Chris" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000513.html" , "inReplyTo" : "A289D8DB-F4F0-43B6-9F05-C57B04478A4A@apple.com" , "date" : { "$date" : 1449382281000} , "subject" : "[swift-evolution] Proposal: Allow willChange and didChange observers on a property" , "references" : [ "A289D8DB-F4F0-43B6-9F05-C57B04478A4A@apple.com"] , "descendants" : [ "6B38C1F5-9623-4706-BC2A-F9A5F9665AB6@apple.com" , "D52D800E-1C86-4B3C-94BC-55D28396EC5A@apple.com" , "3534A06A-23BD-4040-942C-216F12A9D5D3@icloud.com" , "CAA60hjLpFH3u_eQVQvOjZ+gvOa++VdALYUbSGiNCwKQcyO+QFA@mail.gmail.com" , "9D162271-E4B5-45D9-AEC5-60405A70C1EF@apple.com" , "014D53AE-029B-40BE-8C7B-A7ED7FBDA81C@hartbit.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/4F75A42F-4721-4932-85B7-912DFCA57C2D@apple.com"}} , "_id" : "4F75A42F-4721-4932-85B7-912DFCA57C2D@apple.com" , "from" : "clattner at apple.com (Chris Lattner)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 5, 2015, at 12:54 PM, Alex Blewitt via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> \n> \n> Sent from my iPhat 6\n> \n> On 5 Dec 2015, at 19:23, Adrian Kashivskyy <adrian.kashivskyy at me.com <mailto:adrian.kashivskyy at me.com>> wrote:\n> \n>>> SwiftLint looks really nice, but one thing I'd really like is automatic formatting.\n>> \n>> That's a feature of IDE, not the language itself.\n> \n> Not necessarily. The existence of \"go fmt\" has resulted in teams running it as a pre-commit translation and as a way of standardising across all users, regardless of IDEs. Otherwise you end up with multiple IDEs (like Eclipse and IntelliJ) which do formatting slightly differently and lead to all manner of pointless arguments. \n> \n> Letting \"the IDE\" do formatting is fine provided there is a maximum of one IDE. \n\nJust to chime in on this thread with some guidelines for thought:\n\n1) The compiler does have some code smell warnings (e.g. unmutated var -> let).\n2) It is really important that these be warnings, not errors.  Turning them into errors makes refactoring code a pain (as commonly complained about in the go community).\n3) By doing these sorts of things, the compiler needs to be conservative in its policies - the policies that it enforces has to be unquestionably the right thing to do.\n\nSeparate from compiler-enforced policies, I’d *love* to see someone tackle implementing a \"go fmt” analog that reformats Swift code into a standard style, as well as a “clang format”  tool that could be used by IDEs for on-the-fly editing of code, as well as a “linter” / static analysis tool which can flag potential issues while having a higher tolerance for false positives.  These should be separate from the “always on” compiler diagnostics though.\n\n-Chris" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000514.html" , "inReplyTo" : "49EF0786-90E4-4748-B532-E4C68D33458D@gmail.com" , "date" : { "$date" : 1449382514000} , "subject" : "[swift-evolution] \"bad smells\" should be compiler errors with suggestions on how to fix them" , "references" : [ "557CCA5F-E52F-439C-B224-AC4990140373@gmail.com" , "1449324589110.9d79fd62@Nodemailer" , "CF5C0804-061E-487B-9030-005E76177BD1@harlanhaskins.com" , "E4BE1F82-1BCB-4E27-B2E5-CDBE673EF7B8@me.com" , "49EF0786-90E4-4748-B532-E4C68D33458D@gmail.com"] , "descendants" : [ "9D5E0564-E4A2-4F64-8741-526CF79959F4@ericasadun.com" , "CACyzo1jKFZZ2TLTxXYyd_o1j9d5HBAKmg3Doz7QN9O=JGViOtA@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/B13A0695-75A2-445C-858F-7D854C19C326@apple.com"}} , "_id" : "B13A0695-75A2-445C-858F-7D854C19C326@apple.com" , "from" : "clattner at apple.com (Chris Lattner)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 5, 2015, at 11:24 AM, Alexander Kolov via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> Hi everyone,\n> \n> Coming from a short discussion in swift-corelibs-dev, I’m investigating the need of a standard logging API as a part of core libraries.\n> \n> The motivation behind this would be having a unified and configurable set of APIs between all first-party modules and third party applications and libraries.\n> I think this will help each of us since right now we’re inventing our own solutions as well many bigger third-party library providers have formats and facilities of their own.\n> \n> As I currently see it would be somewhat similar to python logging and possibly even structlog (http://www.structlog.org/en/stable/ <http://www.structlog.org/en/stable/>), with configurable formatters and handlers, including and not limited to remote loggers and syslog support.\n> \n> I’d love to hear your opinions and feedback on this and possibly start with some more formalized proposal and implementation if there’s enough support and need.\n\nHi Alex,\n\nAt this point, we’d prefer that major new features like these be explored and developed as independent projects outside the official Swift repos.  There are a *ton* of really interesting library features that we could add, but for now at least, we’re keeping the Swift standard library laser focused on its “language features + core data structures & algorithms” focus, and keeping the CoreLibs work focused on achieving parity with the Apple implementations of these libraries.\n\nWe simply don’t have bandwidth to review and design higher level features at this time.  One of the goals of the Swift package manager is to make it super easy to reuse people’s code, even if it isn’t part of the swift distro.\n\n-Chris" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000515.html" , "inReplyTo" : "BD305678-84D8-49BF-AC25-8F3492044536@alexkolov.com" , "date" : { "$date" : 1449382805000} , "subject" : "[swift-evolution] Proposal: standard logging facility" , "references" : [ "BD305678-84D8-49BF-AC25-8F3492044536@alexkolov.com"] , "descendants" : [ "A1E5FCF7-C4EF-4126-BB2A-C39028773A18@alexkolov.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/8FB8385B-F55C-4DB0-B4F8-626D3FAB9AF6@apple.com"}} , "_id" : "8FB8385B-F55C-4DB0-B4F8-626D3FAB9AF6@apple.com" , "from" : "clattner at apple.com (Chris Lattner)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 5, 2015, at 11:51 AM, Amir Michail via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> Python is still easier than Swift for beginning programmers. But maybe such a mode can allow Swift to be used by beginners also?\n> \nHi Amir,\n\nWe’re not interested in fragmenting Swift into related-but-different dialects.\n\n-Chris" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000516.html" , "inReplyTo" : "5E968E10-2DBD-4999-978C-B398BC446A21@me.com" , "date" : { "$date" : 1449382917000} , "subject" : "[swift-evolution] A mode with no type checking to compete with Python." , "references" : [ "5E968E10-2DBD-4999-978C-B398BC446A21@me.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/4998B6F2-B53E-451A-8DDA-353C631562D1@apple.com"}} , "_id" : "4998B6F2-B53E-451A-8DDA-353C631562D1@apple.com" , "from" : "clattner at apple.com (Chris Lattner)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 5, 2015, at 11:40 AM, David Hart <david at hartbit.com> wrote:\n> \n>> This is subtle and requires thought\n> \n> What do you envision as the pitfalls of the design thinking behind if/switch expressions? I’m not a compiler programmer, but a prog-lang enthusiast. I wouldn’t mind a little nudge in the right direction.\n\nI responded with some concerns and thoughts on the \"Control Flow Expressions” thread.\n\n-Chris" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000517.html" , "inReplyTo" : "BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com" , "date" : { "$date" : 1449382965000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com" , "CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com" , "C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com" , "18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com" , "2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io" , "BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com" , "CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com" , "CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com" , "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com" , "BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com"] , "descendants" : [ "A8D2920B-554C-4495-A6E1-B797802C42A3@gmail.com" , "B35331BD-313C-4B83-ADA1-9A8DBA287715@gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/819785E7-2803-4A65-882F-DB1A9EC0483B@apple.com"}} , "_id" : "819785E7-2803-4A65-882F-DB1A9EC0483B@apple.com" , "from" : "clattner at apple.com (Chris Lattner)" , "mailingList" : "swift-evolution" , "content" : "On Dec 5, 2015, at 1:03 PM, Brent Royal-Gordon via swift-evolution <swift-evolution at swift.org> wrote:\n>> There’s lots of boilerplate of initializing structs with stored properties and initializer parameters. I’d like to create a syntax for alleviating that in the 90% case.\n\nAs a general comment, at this point, I’d personally prefer to stay away from purely syntactic sugar syntax optimizations, unless they are very broadly applicable across the language.  There are a ton of core things still missing from the swift language and type system, and I’d prefer that we stay focused on that.  Post-Swift 3 we can consider adding a hygienic macro system, and the baking out of other language features may lead to the eliminate for some of the sugar that would otherwise be added.\n\n> I’d like to propose an alternative approach.\n> \n> Swift already generates a default initializer for structs that don’t have any initializers explicitly defined. However, the moment you write init(, that initializer disappears. It’s also never available on classes, because they have to dispatch to another initializer.\n\nYes, this is really unfortunate.  The default memberwise initializer behavior of Swift has at least these deficiencies (IMO):\n\n1) Defining a custom init in a struct disables the memberwise initializer, and there is no easy way to get it back.\n2) Access control + the memberwise init often requires you to implement it yourself.\n3) We don’t get memberwise inits for classes.\n4) var properties with default initializers should have their parameter to the synthesized initializer defaulted.\n5) lazy properties with memberwise initializers have problems (the memberwise init eagerly touches it).\n\nOne of the things missing is the ability to “utter” the memberwise initializer, I’d suggest syntax along the lines of:\n\n  memberwise init()    // memberwise is a \"decl modifier\"\n\nSo you could say:\n\n  public memberwise init()\n\nto specifically say you want the default one given public access control (for example).\n\n\nIt would be really great for someone to tackle these problems holistically! \n\n-Chris" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000518.html" , "inReplyTo" : "4F8C6141-CEFA-43DA-8FD9-5C787789ED68@architechies.com" , "date" : { "$date" : 1449383663000} , "subject" : "[swift-evolution] Proposal: helpers for initializing properties of same name as parameters" , "references" : [ "CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com" , "4F8C6141-CEFA-43DA-8FD9-5C787789ED68@architechies.com"] , "descendants" : [ "5B57FA0A-C205-4937-8005-94DD2F69806A@dimsumthinking.com" , "6F2EF9CF-2E73-4470-9AA7-93DFE00FEA6D@apple.com" , "CA+ddMk2uvrEwLZf4fcsYxDbFnagOcywttsdC7HRB9jkeVdZ=zA@mail.gmail.com" , "475AB355-591C-42D9-A43B-1ED8D02BA1C3@anandabits.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/E3BD5430-C4DF-4284-99FA-14B61512E74A@apple.com"}} , "_id" : "E3BD5430-C4DF-4284-99FA-14B61512E74A@apple.com" , "from" : "clattner at apple.com (Chris Lattner)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 5, 2015, at 6:58 PM, David Waite via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> There is also a set keyword in the language already, although today its use is limited such that it may still be used as an identifier in non-conflicting contexts.\n\nFWIW, “set” is a context sensitive keyword, not an actual keyword.  You can see the list of actual keywords here:\n\nhttps://github.com/apple/swift/blob/master/include/swift/Parse/Tokens.def\n\n-Chris\n\n> \n> -DW\n> \n>> On Dec 5, 2015, at 7:51 PM, Brent Royal-Gordon <brent at architechies.com> wrote:\n>> \n>>> I don’t believe any more so than for let or var, which this effectively is a complement for.\n>> \n>> There is no Let or Var type in the standard library, but there is a Set type. “Set” has many meanings, and some of them are relatively likely to be used as parameter keywords.\n>> \n>> -- \n>> Brent Royal-Gordon\n>> Architechies\n>> \n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000519.html" , "inReplyTo" : "C3D71715-4957-441C-B277-E8CC3BBE4CA0@alkaline-solutions.com" , "date" : { "$date" : 1449383695000} , "subject" : "[swift-evolution] Proposal: helpers for initializing properties of same name as parameters" , "references" : [ "CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com" , "4F8C6141-CEFA-43DA-8FD9-5C787789ED68@architechies.com" , "9DC6F2A2-53E0-4DBB-AF5F-D51314AA49F7@anandabits.com" , "63177F8D-6BA7-4B1E-9052-BA6D3ED6B0CC@architechies.com" , "FC624F3D-20B7-4F42-A04F-97AFDB0287CB@alkaline-solutions.com" , "CA+ddMk042v6whHcVu8kLZyAk1JaEQ3LYxttAbZfGq6KBvrcGNw@mail.gmail.com" , "3925DEF8-2B69-4AB5-AD95-49BD2FE6401B@alkaline-solutions.com" , "DB740B9C-987F-42BF-96DF-95570F070A89@architechies.com" , "C3D71715-4957-441C-B277-E8CC3BBE4CA0@alkaline-solutions.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/C18D130A-F4B5-42A0-8CAA-9B5137B69DB7@qq.com"}} , "_id" : "C18D130A-F4B5-42A0-8CAA-9B5137B69DB7@qq.com" , "from" : "286224043 at qq.com (QQ Mail)" , "mailingList" : "swift-evolution" , "content" : "Currently possible to add extension to class, so we can separate the implementation to different class files. In some situation this still have some limitations, \nFor example: \n\npublic class Racer {\n\n    public var name:String\n\n    public init(name:String) {\n        self.name = name\n    }\n}\n\npublic extension Racer {\n\n    public var winTimes:Int {\n        // requires access local variable\n    }\n\n    public func win() {\n        // need to update local variable\n    }\n}\n\nthe method in the extension sometimes need add another variable to store values, if you are extending the system class, that will be very hard to make this happen\n\nSo I am thinking, can we add another namespace “external” besides “public, private, internal”, with this we can define a “external var” inside the extension scope.\nthe variable needs a default value, and only can accessed in the extension scope, the implementation for the example will like this: \n\n\npublic class Racer {\n\n    public var name:String\n\n    public init(name:String) {\n        self.name = name\n    }\n}\n\npublic extension Racer {\n\n    external var _winTimes:Int = 0\n\n    public var winTimes:Int {\n        return _winTimes\n    }\n\n    public func win() {\n        _winTimes++\n    }\n}\n <https://github.com/chenyunguiMilook/swift-evolution#impact-on-existing-code>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000520.html" , "date" : { "$date" : 1449384163000} , "subject" : "[swift-evolution] Proposal: External variable in extension" , "references" : [ ""] , "inReplyTo" :  null } , { "_links" : { "self" : { "href" : "/charter/emails/CAA60hjLpFH3u_eQVQvOjZ+gvOa++VdALYUbSGiNCwKQcyO+QFA@mail.gmail.com"}} , "_id" : "CAA60hjLpFH3u_eQVQvOjZ+gvOa++VdALYUbSGiNCwKQcyO+QFA@mail.gmail.com" , "from" : "elagha2 at illinois.edu (Mosab Elagha)" , "mailingList" : "swift-evolution" , "content" : "+1. This feature would allow for a more clean approach in checking the\nexisting state of a value.\n\n> Also, can a property have these observers as well as the existing ones?\n\nI'm not really familiar with the implementation of the observers, but why\nwouldn't it be able to? Maybe didSet can precede didChange in order of\nexecution if both are implemented, so you can have default behavior when\naccessing a value but certain other behavior if it has changed. Or maybe\nhave willChange/didChange be a property that can be accessed within\nwillSet/didSet (like oldValue).\n\n\n\n-Mosab Elagha\n\nOn Sun, Dec 6, 2015 at 12:11 AM, Chris Lattner via swift-evolution <\nswift-evolution at swift.org> wrote:\n\n>\n> On Dec 5, 2015, at 4:00 PM, Nathan de Vries via swift-evolution <\n> swift-evolution at swift.org> wrote:\n>\n> It's currently possible to define either or both of the following\n> observers on a property:\n>\n>    - *willSet*, called just before the value is stored\n>    - *didSet*, called immediately after the new value is stored\n>\n> ...\n>\n> This would mean the following observers could be defined on a property:\n>\n>    - *willSet*, called just before the value is stored\n>    - *willChange*, called just before the value is stored if the value is\n>    different to the previous value\n>    - *didSet*, called immediately after the new value is stored\n>    - *didChange*, called immediately after the new value is stored if the\n>    new value is different to the previous value\n>\n> I’m open to consider a change along these lines, but the proposal would\n> have to be fleshed out more.  Presumably it would only work for equatable\n> types, right?  Also, can a property have these observers as well as the\n> existing ones?  Would it be possible to add *one of* didChange or\n> willChange - since less is better?\n>\n> -Chris\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000521.html" , "inReplyTo" : "9AC32EEA-ED5F-421E-9B75-E2BB0516667C@apple.com" , "date" : { "$date" : 1449384167000} , "subject" : "[swift-evolution] Proposal: Allow willChange and didChange observers on a property" , "references" : [ "A289D8DB-F4F0-43B6-9F05-C57B04478A4A@apple.com" , "9AC32EEA-ED5F-421E-9B75-E2BB0516667C@apple.com"] , "descendants" : [ "6B38C1F5-9623-4706-BC2A-F9A5F9665AB6@apple.com" , "9D162271-E4B5-45D9-AEC5-60405A70C1EF@apple.com" , "014D53AE-029B-40BE-8C7B-A7ED7FBDA81C@hartbit.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAL-BAQv_62_FfxbD2f3jmvz=fMVFKT7z1_T-Epe=TGgyyNhOew@mail.gmail.com"}} , "_id" : "CAL-BAQv_62_FfxbD2f3jmvz=fMVFKT7z1_T-Epe=TGgyyNhOew@mail.gmail.com" , "from" : "bee.ography at gmail.com (Bee)" , "mailingList" : "swift-evolution" , "content" : "On Sun, Dec 6, 2015 at 6:55 AM, Amir Michail via swift-evolution <\nswift-evolution at swift.org> wrote:\n\n>\n> Doesn’t Apple want to teach young people programming as one of its goals?\n> If so, having a mode without type safety would be ideal for that.\n>\n\nApple want to teach young people programming, properly. There, I fix it for\nyou. :)\n\n-- \n-Bee-" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000522.html" , "inReplyTo" : "F0885284-6615-4EEC-89BF-38B8A10EF3AA@me.com" , "date" : { "$date" : 1449384559000} , "subject" : "[swift-evolution] A mode with no type checking to compete with Python." , "references" : [ "5E968E10-2DBD-4999-978C-B398BC446A21@me.com" , "7240610C-B5DA-41B8-909A-D138404C6799@me.com" , "F0885284-6615-4EEC-89BF-38B8A10EF3AA@me.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/9D162271-E4B5-45D9-AEC5-60405A70C1EF@apple.com"}} , "_id" : "9D162271-E4B5-45D9-AEC5-60405A70C1EF@apple.com" , "from" : "clattner at apple.com (Chris Lattner)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 5, 2015, at 10:42 PM, Mosab Elagha <elagha2 at illinois.edu> wrote:\n> \n> +1. This feature would allow for a more clean approach in checking the existing state of a value. \n> \n> > Also, can a property have these observers as well as the existing ones?\n> \n> I'm not really familiar with the implementation of the observers, but why wouldn't it be able to? Maybe didSet can precede didChange in order of execution if both are implemented, so you can have default behavior when accessing a value but certain other behavior if it has changed. Or maybe have willChange/didChange be a property that can be accessed within willSet/didSet (like oldValue).\n\nI believe it is possible to implement, I’m just trying to give guidance on the sorts of things a formal proposal should address.\n\n-Chris\n\n> \n> \n> \n> -Mosab Elagha\n> \n> On Sun, Dec 6, 2015 at 12:11 AM, Chris Lattner via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n> \n>> On Dec 5, 2015, at 4:00 PM, Nathan de Vries via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>> \n>> It's currently possible to define either or both of the following observers on a property:\n>> willSet, called just before the value is stored\n>> didSet, called immediately after the new value is stored\n> \n> ...\n> \n>> This would mean the following observers could be defined on a property:\n>> willSet, called just before the value is stored\n>> willChange, called just before the value is stored if the value is different to the previous value\n>> didSet, called immediately after the new value is stored\n>> didChange, called immediately after the new value is stored if the new value is different to the previous value\n> \n> I’m open to consider a change along these lines, but the proposal would have to be fleshed out more.  Presumably it would only work for equatable types, right?  Also, can a property have these observers as well as the existing ones?  Would it be possible to add *one of* didChange or willChange - since less is better?\n> \n> -Chris\n> \n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n> \n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000523.html" , "inReplyTo" : "CAA60hjLpFH3u_eQVQvOjZ+gvOa++VdALYUbSGiNCwKQcyO+QFA@mail.gmail.com" , "date" : { "$date" : 1449384737000} , "subject" : "[swift-evolution] Proposal: Allow willChange and didChange observers on a property" , "references" : [ "A289D8DB-F4F0-43B6-9F05-C57B04478A4A@apple.com" , "9AC32EEA-ED5F-421E-9B75-E2BB0516667C@apple.com" , "CAA60hjLpFH3u_eQVQvOjZ+gvOa++VdALYUbSGiNCwKQcyO+QFA@mail.gmail.com"] , "descendants" : [ "6B38C1F5-9623-4706-BC2A-F9A5F9665AB6@apple.com" , "014D53AE-029B-40BE-8C7B-A7ED7FBDA81C@hartbit.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/B6DC456F-C246-4511-BBE3-4FB1C612B3DE@owensd.io"}} , "_id" : "B6DC456F-C246-4511-BBE3-4FB1C612B3DE@owensd.io" , "from" : "david at owensd.io (David Owens II)" , "mailingList" : "swift-evolution" , "content" : "I tend to disagree with this whole concept of access modifiers; what we have today is at least somewhat sane and consistent across all constructs.\n\nAs for your example, if other code within your file is leveraging these “private” pieces, doesn’t that suggest that your API model is already wrong? After all, those pieces wouldn’t be used if they weren’t needed. I’m also hard pressed to believe that this is solving a problem that isn’t purely academic.\n\nI’d actually prefer the opposite extreme: I want everything public unless it’s prefixed with an _. To me, the _ prefix adds significantly more contextual awareness that I’m venturing into parts of the construct that are not intended for general use. It has the add benefit that it makes these types of uses grepable within the codebase so audits are quite trivial.\n\n    struct F {\n        func _privateUsage() {}\n        func publicUsage() {}\n    }\n\nRight now, I find having to prefix nearly everything with public is extremely annoying.\n\nHumorously enough, I’m actually running into issues with this right now. I’m looking into fixing some of the NSNumber functionality in corelib and the fact that some of the internal state is marked as private means it’s not readably testable nor easy to inspect to validate is doing the right thing.\n\n-David\n\n> On Dec 5, 2015, at 9:04 PM, Nikolai Vazquez via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> I agree that there should be an access level that hides implementation details from other types in the same file. However, it shouldn’t replace private, because 1) helper types might benefit from private elements and 2) like you said, backwards compatibility.\n> \n> On Sat, Dec 5, 2015 at 11:40 PM Ilya via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n> \n> \n> \n> I think the it would help a great deal to have an access level modifier that is really private and visible only inside the class itself. Right now, the only way to hide implementation details for a class is to hide the class code in a separate file, which is very inconvenient for several reasons:\n> \n> 1) the meaning of the code changes depending on which file the class is in. It's very easy to accidentally expose class internal details and then call class elements that are meant to be used only inside the class. Having a keyword for class internals will allow the compiler to ensure that only the public API for the class is used from the outside world. The user can check types on his own, but it's better that the compiler does it automatically. Similarly, the user can check that only the proper APIs are called, but it's better that the compiler does it automatically.\n> \n> 2) accessibility by file structure may cause some really short files. \n> \n> 3) It's impossible to group related classes in one file but still hide implementation details inside each class\n> \n> I think that it the best solution is to make private keyword do what it states -- keep the class element private to the class. But if it's really important to have a separate keyword for backward compatibility, it would be the next best thing.\n> \n> --\n> Ilya Belenkiy\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n> \n> \n>  _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000524.html" , "inReplyTo" : "CANhuES2UxBj5vpbFOENGxRBNU5EMD_XqBYBC+QkfYRwsMpHvgA@mail.gmail.com" , "date" : { "$date" : 1449385158000} , "subject" : "[swift-evolution] access control proposal" , "references" : [ "CAOFcyhsDudbUDgn=+=hMDapzmPVj-ZYcSh+DnSY8f-grAvWewA@mail.gmail.com" , "CANhuES2UxBj5vpbFOENGxRBNU5EMD_XqBYBC+QkfYRwsMpHvgA@mail.gmail.com"] , "descendants" : [ "1449386582.2217334.459315937.637FDF9A@webmail.messagingengine.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/B4EA93B4-3A45-4203-A79A-0E959B3CC634@apple.com"}} , "_id" : "B4EA93B4-3A45-4203-A79A-0E959B3CC634@apple.com" , "from" : "clattner at apple.com (Chris Lattner)" , "mailingList" : "swift-evolution" , "content" : "On Dec 5, 2015, at 4:27 AM, Jonathan Hull <jhull at gbis.com> wrote:\n> I understand why you can’t auto-convert from a Double to a Float or Int32 to Int8.  It is good that we have to add the cast explicitly and think though the implications.\n> \n> …but I don’t think through the implications because we currently have a boy who cried wolf situation where we have to explicitly cast everything (even the safe stuff).\n> \n> \n> I think all of the numeric types should be able to auto-convert if the conversion is safe (without loss of precision or overflow).\n> \n> For example:\n> • If an Int is casting to a larger size (Int16 -> Int32)\n> • Float -> Double\n> • Float -> CGFloat\n> • Int -> Float, Double, or CGFloat (but not the other way)\n> \n> I don’t see why these aren’t allowed. The forced casts make my code much less readable.  Are the casts above dangerous in a way I am not aware of?\n\nI agree that the current Swift numerics model is suboptimal, I personally would like to see small integers implicitly promote to large integers (when they are known lossless), have Float promote to Double, and have both Float and Double promote to CGFloat (yes, I know that the Double -> CGFloat promotion would be lossy on 32-bit apple platforms).  I personally don’t think that integer -> floating point promotions are a good idea even if value preserving, since their domains are so different.\n\nThe problem with doing this today is that there are a lot of dependencies we need to get resolved first.\n\n1. The type checker is really slow, partially because of too-many and too-crazy implicit conversions.  We also get very surprising behavior when they kick in. Specifically, IMO, we need to reevaluate the T! <-> T and T to T? conversions.  We have thoughts on this, but should be discussed in a separate thread if you’re interested.\n\n2. These promotions should be expressible in the library, not hard coded into the compiler.  This means that we would need a language feature to (e.g.) be able to define subtype relationships between structs.  Such a feature would be generally useful and could allow us to push some of our existing compiler magic out to the stdlib.\n\n3. We want the existing work to revise the numerics protocols to be better understood and hopefully implemented.\n\nThere are also a ton of unrelated specific problems that should be addressed in various ways: e.g. macros like M_PI get imported as Double instead of a typeless literal, forcing tons of casts in code that wants to use it (e.g.) with Floats.  These issues are separable, and blocked on things like generic properties not being in place.\n\nIt would be great for interested contributors to start pushing on any of the above issues to help unblock progress on improving the numerics model.\n\n-Chris" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000525.html" , "inReplyTo" : "7E236CA1-A390-4B64-950C-14987C1E1D87@gbis.com" , "date" : { "$date" : 1449385367000} , "subject" : "[swift-evolution] Proposal: Auto-convert for numbers when safe" , "references" : [ "7E236CA1-A390-4B64-950C-14987C1E1D87@gbis.com"] , "descendants" : [ "8BC56862-79DB-43B7-985C-0EF8E2C68142@apple.com" , "etPan.5663e1dc.2776e37.10e90@Manav-Gabhawalas-MacBook-Pro.local" , "45715663-0EFA-45BA-8738-3085413B89CD@apple.com" , "8CE71278-5DEC-4C9A-BDFF-A03C47A2FCA6@anandabits.com" , "etPan.566539dc.4f3b19ea.10e90@Manav-Gabhawalas-MacBook-Pro.local"]} , { "_links" : { "self" : { "href" : "/charter/emails/1165FC40-5573-48E9-AD8B-894A2D699693@apple.com"}} , "_id" : "1165FC40-5573-48E9-AD8B-894A2D699693@apple.com" , "from" : "clattner at apple.com (Chris Lattner)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 4, 2015, at 8:36 PM, Bill Abt <babt at me.com> wrote:\n> \n> The fcntl() API is a variadic standard “C” library and as such not supported currently by Swift.  Any visit to GitHub looking for a socket implementation will invariably find a .c or .mm file included that exposes fcntl() to Swift via a shim.  There are only 3 forms of this API, all returning int.  The first takes 2 integers and sets the 3rd to 0.  The second takes 3 integers.  The last and final form take 2 integers and a void pointer.  Looking at the standard library source, it’s trivial to implement.  It’ll take longer to write the tests than it will to write the functions.  Once implemented, it would eliminate the need for shims for this API.\n> \n> This seems like one of those obvious things that just haven’t been implemented yet, no?\n\nHi Bill,\n\nThe Swift standard library doesn’t provide this sort of functionality, but I agree that it makes sense for the Darwin/Glibc modules to provide this interface.  We have a system of “overlays” to provide functionality that the clang importer can’t do automatically.  For example, the Glibc overlay is here:\nhttps://github.com/apple/swift/blob/master/stdlib/public/Glibc/Glibc.swift <https://github.com/apple/swift/blob/master/stdlib/public/Glibc/Glibc.swift>\n\nThe darwin overlay is more filled out:\nhttps://github.com/apple/swift/blob/master/stdlib/public/SDK/Darwin/Darwin.swift <https://github.com/apple/swift/blob/master/stdlib/public/SDK/Darwin/Darwin.swift>\n\nIt doesn’t look like it provides fcntl specifically, but it does provide open, which has the same varargs sort of implementation issues.  Adding support for fcntl to the overlays makes sense in principle to me.\n\n-Chris" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000526.html" , "inReplyTo" : "BFC1C4B7-37FE-4C60-A169-793F48823609@me.com" , "date" : { "$date" : 1449385901000} , "subject" : "[swift-evolution] fcntl() should be added to the standard library." , "references" : [ "BFC1C4B7-37FE-4C60-A169-793F48823609@me.com"] , "descendants" : [ "39CEB5B9-BBC8-4E77-A1FE-39EEF8096466@apple.com" , "69E140FF-8B8A-42FB-B157-557D87CECB63@me.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/78E72933-1ABE-4930-9213-C18CF258DA2D@qq.com"}} , "_id" : "78E72933-1ABE-4930-9213-C18CF258DA2D@qq.com" , "from" : "286224043 at qq.com (QQ Mail)" , "mailingList" : "swift-evolution" , "content" : "If typealias support protocol constraint, I think we can reuse a lot of code, also more readable\n\nFor Example: \n\ntypealias PointCollection = protocol<T:CollectionType where T.Generator.Element == CGPoint>\n\npublic extension PointCollection {\n    \n    \n    \n}" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000527.html" , "date" : { "$date" : 1449386254000} , "subject" : "[swift-evolution] Proposal: typealias support protocol constraint" , "references" : [ ""] , "inReplyTo" :  null  , "descendants" : [ "DF17297E-E77E-4CAF-851E-2F5E5CACCDCB@qq.com" , "F54D886C-4283-4DE3-BDA3-6E1947A20233@me.com" , "C03532DB-388E-46DE-A34B-7C3572DED0C8@anandabits.com" , "FE41B04C-014E-43E7-9F5E-4826380542F9@anandabits.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/etPan.5663e1dc.2776e37.10e90@Manav-Gabhawalas-MacBook-Pro.local"}} , "_id" : "etPan.5663e1dc.2776e37.10e90@Manav-Gabhawalas-MacBook-Pro.local" , "from" : "manav1907 at gmail.com (Manav Gabhawala)" , "mailingList" : "swift-evolution" , "content" : "One suggestion of a way to get around the problem of promotions could be implicit initializers. So you could have one parameter initializers that can be marked with a keyword/attribute like implicit and the compiler can automatically insert the right the initializer in place (kind of like C++ does it except the keyword implicit would be an antonym to the explicit keyword in C++). This could potentially solve the type checker speed and also allow you to move this implementation to the stdlib. It could also potentially have some interesting use cases outside of the std library too. We would also have to consider whether implicit initializers could throw errors and whether they could be failable or not.\nIMO implicit initializers should not be able to throw but should be allowed to be failable. For instance, one could have an implicit initializer from a String to NSURL but have it failable too and use a guard let/if let to bind to it (see example later)\n\nSo something along the lines of:\n\n\t\t\nclass Double {\n\timplicit init(_ f: Float) {\n\t\t// initializes a double from a float.\n\t}\n}\n\n// For the String -> NSURL\nclass NSURL { \n\timplicit init?(_ str: String) {\n\t\t// initializes the usual way.\n\t}\n}\n// And then in at the call site\nguard let URL : NSURL = someString\nelse { return  }\n// Do something with someString.\n\n\nHowever, because of how Swift is structured and its emphasis on being explicit (which is a great thing), this should only be used sparingly and should be discouraged unless it absolutely makes sense.\n\nRegards,\nManav Gabhawala\n\nOn December 6, 2015 at 2:02:51 AM, Chris Lattner via swift-evolution (swift-evolution at swift.org) wrote:\n\nOn Dec 5, 2015, at 4:27 AM, Jonathan Hull <jhull at gbis.com> wrote:\n> I understand why you can’t auto-convert from a Double to a Float or Int32 to Int8. It is good that we have to add the cast explicitly and think though the implications.\n>  \n> …but I don’t think through the implications because we currently have a boy who cried wolf situation where we have to explicitly cast everything (even the safe stuff).\n>  \n>  \n> I think all of the numeric types should be able to auto-convert if the conversion is safe (without loss of precision or overflow).\n>  \n> For example:\n> • If an Int is casting to a larger size (Int16 -> Int32)\n> • Float -> Double\n> • Float -> CGFloat\n> • Int -> Float, Double, or CGFloat (but not the other way)\n>  \n> I don’t see why these aren’t allowed. The forced casts make my code much less readable. Are the casts above dangerous in a way I am not aware of?\n\nI agree that the current Swift numerics model is suboptimal, I personally would like to see small integers implicitly promote to large integers (when they are known lossless), have Float promote to Double, and have both Float and Double promote to CGFloat (yes, I know that the Double -> CGFloat promotion would be lossy on 32-bit apple platforms). I personally don’t think that integer -> floating point promotions are a good idea even if value preserving, since their domains are so different.\n\nThe problem with doing this today is that there are a lot of dependencies we need to get resolved first.\n\n1. The type checker is really slow, partially because of too-many and too-crazy implicit conversions. We also get very surprising behavior when they kick in. Specifically, IMO, we need to reevaluate the T! <-> T and T to T? conversions. We have thoughts on this, but should be discussed in a separate thread if you’re interested.\n\n2. These promotions should be expressible in the library, not hard coded into the compiler. This means that we would need a language feature to (e.g.) be able to define subtype relationships between structs. Such a feature would be generally useful and could allow us to push some of our existing compiler magic out to the stdlib.\n\n3. We want the existing work to revise the numerics protocols to be better understood and hopefully implemented.\n\nThere are also a ton of unrelated specific problems that should be addressed in various ways: e.g. macros like M_PI get imported as Double instead of a typeless literal, forcing tons of casts in code that wants to use it (e.g.) with Floats. These issues are separable, and blocked on things like generic properties not being in place.\n\nIt would be great for interested contributors to start pushing on any of the above issues to help unblock progress on improving the numerics model.\n\n-Chris\n\n_______________________________________________\nswift-evolution mailing list\nswift-evolution at swift.org\nhttps://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000528.html" , "inReplyTo" : "B4EA93B4-3A45-4203-A79A-0E959B3CC634@apple.com" , "date" : { "$date" : 1449386460000} , "subject" : "[swift-evolution] Proposal: Auto-convert for numbers when safe" , "references" : [ "7E236CA1-A390-4B64-950C-14987C1E1D87@gbis.com" , "B4EA93B4-3A45-4203-A79A-0E959B3CC634@apple.com" , "B4EA93B4-3A45-4203-A79A-0E959B3CC634@apple.com"] , "descendants" : [ "45715663-0EFA-45BA-8738-3085413B89CD@apple.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/1449386582.2217334.459315937.637FDF9A@webmail.messagingengine.com"}} , "_id" : "1449386582.2217334.459315937.637FDF9A@webmail.messagingengine.com" , "from" : "kevin at sb.org (Kevin Ballard)" , "mailingList" : "swift-evolution" , "content" : "On Sat, Dec 5, 2015, at 10:59 PM, David Owens II via swift-evolution wrote:\n> I’d actually prefer the opposite extreme: I want everything public unless it’s prefixed with an _. To me, the _ prefix adds significantly more contextual awareness that I’m venturing into parts of the construct that are not intended for general use. It has the add benefit that it makes these types of uses grepable within the codebase so audits are quite trivial.\n\nYou can already use a _ prefix today to mark any function/property that\nis not meant for general use, even within the confines of the file.\nThat's what I do; private methods/properties are fair game (if\naccessible), but anything that's considered an implementation detail\ngets a _ prefix. Applying your proposed rule would actually remove the\nability to use _ to distinguish things like this (and you'd start seeing\n__ instead, which is even uglier).\n\n-Kevin Ballard" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000529.html" , "inReplyTo" : "B6DC456F-C246-4511-BBE3-4FB1C612B3DE@owensd.io" , "date" : { "$date" : 1449386582000} , "subject" : "[swift-evolution] access control proposal" , "references" : [ "CAOFcyhsDudbUDgn=+=hMDapzmPVj-ZYcSh+DnSY8f-grAvWewA@mail.gmail.com" , "CANhuES2UxBj5vpbFOENGxRBNU5EMD_XqBYBC+QkfYRwsMpHvgA@mail.gmail.com" , "B6DC456F-C246-4511-BBE3-4FB1C612B3DE@owensd.io"]} , { "_links" : { "self" : { "href" : "/charter/emails/C7B2EEB8-0B36-4930-B011-034548511656@apple.com"}} , "_id" : "C7B2EEB8-0B36-4930-B011-034548511656@apple.com" , "from" : "clattner at apple.com (Chris Lattner)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 4, 2015, at 5:40 AM, David Hart <david at hartbit.com> wrote:\n> \n> In Objective-C, I often used the lazy initialization pattern to implement a cache for expensive operations. For exemple, here is an often used scenario in a project where objects behind foreign keys in a database ORM are only fetched when necessary:\n> \n> When thinking about it, I came to the conclusion that the use cases of lazy seem very narrow compared to how useful the lazy initialization pattern was in Objective-C.\n> I want your opinion on three alternatives:\n> \n> 1- Do nothing, and use the slightly uglier Swift example when using a cache.\n> 2- Modify lazy semantics to re-calculates when nil (I think this is the worst solution).\n> 3- Add a cache modifier that re-calcualtes when nil.\n\nHi David,\n\nMy preference is:\n4) Kick lazy out of the compiler and make it a standard library feature instead, allowing it to be extended in lots of ways.\n\nThe existing lazy behavior was added as a very narrow solution to a common scenario that would otherwise required optional machinations everywhere.  It succeeded in that goal, but it is super narrow, and the implementation has a number of bugs (e.g. you can’t have a lazy local variable).\n\nIn terms of its narrowness, it has the limitations you describe, but it also doesn’t solve other common problems.  For example, many people complain about properties that are initialized only in a second phase of initialization (e.g. awakeFromNib) and right now, most folks resort to using typing their properties as ImplicitlyUnwrappedOptional to avoid using ! at every use site.  A natural solution to that is to introduce a concept of a “delayed var x : T” which does not need initialization in init(), and runtime traps if it is read before initialized.  This provides similar semantics to T!, but without infecting the type system.  Better than T!, a “delayed let x : T” would allow exactly one runtime initialization of the property.\n\nThe problem with this line of thinking is that - if we kept going down this path - we’d end up adding a ton of very narrow solutions for specific problems, adding language complexity all the way.  This is pretty dissatisfying for a number of reasons. :-)\n\nA different approach is to introduce a single language feature that would allow you to define customization behavior for properties in a library, which would be a general solution to these sorts of issues.  Joe Groff is working on a proposal to do just this, similar to the idea of Kotlin property delegates (https://kotlinlang.org/docs/reference/delegated-properties.html).\n\nWe’ve been a bit busy lately :-) but I’m hoping that he’ll send this proposal out in the next few weeks.  Assuming that proposal works out, I expect lazy to get ripped out of the language, and *that* discussion can reopen detailed debate about what the replacement should look like.\n\n-Chris" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000530.html" , "inReplyTo" : "C9BBB9E4-F2E9-4514-926F-8669DC731128@hartbit.com" , "date" : { "$date" : 1449386840000} , "subject" : "[swift-evolution] lazy keyword vs lazy initialization pattern" , "references" : [ "C9BBB9E4-F2E9-4514-926F-8669DC731128@hartbit.com"] , "descendants" : [ "546CDC6C-6D6E-41F6-B506-77C617575DAF@apple.com" , "99C3AE06-9BA8-4F46-B67A-88AB0D8A3748@hartbit.com" , "57598505-6076-4C78-8D09-7F7C01B0D18B@web.de" , "543A1A03-A23B-42D1-96DA-DC7C3F81E49A@anandabits.com" , "87303129-BC13-487E-908D-7D2CC498CDF0@web.de"]} , { "_links" : { "self" : { "href" : "/charter/emails/45715663-0EFA-45BA-8738-3085413B89CD@apple.com"}} , "_id" : "45715663-0EFA-45BA-8738-3085413B89CD@apple.com" , "from" : "clattner at apple.com (Chris Lattner)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 5, 2015, at 11:21 PM, Manav Gabhawala <manav1907 at gmail.com> wrote:\n> \n> One suggestion of a way to get around the problem of promotions could be implicit initializers.\n\nSwift has already had a feature to support arbitrary implicit conversion between types: it was madness and got ripped out :-)\n\nI’m not opposed to allowing user-defined implicit conversions, but IMO they need to be limited to a DAG of subtype relationships.\n\n-Chris\n\n\n> So you could have one parameter initializers that can be marked with a keyword/attribute like implicit and the compiler can automatically insert the right the initializer in place (kind of like C++ does it except the keyword implicit would be an antonym to the explicit keyword in C++). This could potentially solve the type checker speed and also allow you to move this implementation to the stdlib. It could also potentially have some interesting use cases outside of the std library too. We would also have to consider whether implicit initializers could throw errors and whether they could be failable or not.\n> IMO implicit initializers should not be able to throw but should be allowed to be failable. For instance, one could have an implicit initializer from a String to NSURL but have it failable too and use a guard let/if let to bind to it (see example later)\n> \n> So something along the lines of:\n> \n> \t\n> class Double {\n> \timplicit init(_ f: Float) {\n> \t\t// initializes a double from a float.\n> \t}\n> }\n> \n> // For the String -> NSURL\n> class NSURL { \n> \timplicit init?(_ str: String) {\n> \t\t// initializes the usual way.\n> \t}\n> }\n> // And then in at the call site\n> guard let URL : NSURL = someString\n> else { return  }\n> // Do something with someString.\n> \n> \n> However, because of how Swift is structured and its emphasis on being explicit (which is a great thing), this should only be used sparingly and should be discouraged unless it absolutely makes sense.\n> \n> Regards,\n> Manav Gabhawala\n> \n> On December 6, 2015 at 2:02:51 AM, Chris Lattner via swift-evolution (swift-evolution at swift.org <mailto:swift-evolution at swift.org>) wrote:\n> \n>> On Dec 5, 2015, at 4:27 AM, Jonathan Hull <jhull at gbis.com <mailto:jhull at gbis.com>> wrote:\n>> > I understand why you can’t auto-convert from a Double to a Float or Int32 to Int8. It is good that we have to add the cast explicitly and think though the implications.\n>> > \n>> > …but I don’t think through the implications because we currently have a boy who cried wolf situation where we have to explicitly cast everything (even the safe stuff).\n>> > \n>> > \n>> > I think all of the numeric types should be able to auto-convert if the conversion is safe (without loss of precision or overflow).\n>> > \n>> > For example:\n>> > • If an Int is casting to a larger size (Int16 -> Int32)\n>> > • Float -> Double\n>> > • Float -> CGFloat\n>> > • Int -> Float, Double, or CGFloat (but not the other way)\n>> > \n>> > I don’t see why these aren’t allowed. The forced casts make my code much less readable. Are the casts above dangerous in a way I am not aware of?\n>> \n>> I agree that the current Swift numerics model is suboptimal, I personally would like to see small integers implicitly promote to large integers (when they are known lossless), have Float promote to Double, and have both Float and Double promote to CGFloat (yes, I know that the Double -> CGFloat promotion would be lossy on 32-bit apple platforms). I personally don’t think that integer -> floating point promotions are a good idea even if value preserving, since their domains are so different.\n>> \n>> The problem with doing this today is that there are a lot of dependencies we need to get resolved first.\n>> \n>> 1. The type checker is really slow, partially because of too-many and too-crazy implicit conversions. We also get very surprising behavior when they kick in. Specifically, IMO, we need to reevaluate the T! <-> T and T to T? conversions. We have thoughts on this, but should be discussed in a separate thread if you’re interested.\n>> \n>> 2. These promotions should be expressible in the library, not hard coded into the compiler. This means that we would need a language feature to (e.g.) be able to define subtype relationships between structs. Such a feature would be generally useful and could allow us to push some of our existing compiler magic out to the stdlib.\n>> \n>> 3. We want the existing work to revise the numerics protocols to be better understood and hopefully implemented.\n>> \n>> There are also a ton of unrelated specific problems that should be addressed in various ways: e.g. macros like M_PI get imported as Double instead of a typeless literal, forcing tons of casts in code that wants to use it (e.g.) with Floats. These issues are separable, and blocked on things like generic properties not being in place.\n>> \n>> It would be great for interested contributors to start pushing on any of the above issues to help unblock progress on improving the numerics model.\n>> \n>> -Chris\n>> \n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000531.html" , "inReplyTo" : "etPan.5663e1dc.2776e37.10e90@Manav-Gabhawalas-MacBook-Pro.local" , "date" : { "$date" : 1449387037000} , "subject" : "[swift-evolution] Proposal: Auto-convert for numbers when safe" , "references" : [ "7E236CA1-A390-4B64-950C-14987C1E1D87@gbis.com" , "B4EA93B4-3A45-4203-A79A-0E959B3CC634@apple.com" , "B4EA93B4-3A45-4203-A79A-0E959B3CC634@apple.com" , "etPan.5663e1dc.2776e37.10e90@Manav-Gabhawalas-MacBook-Pro.local"]} , { "_links" : { "self" : { "href" : "/charter/emails/DCEF9750-F5E0-4639-8D78-8CC37F5A60A3@me.com"}} , "_id" : "DCEF9750-F5E0-4639-8D78-8CC37F5A60A3@me.com" , "from" : "rvojta at me.com (Robert Vojta)" , "mailingList" : "swift-evolution" , "content" : "> On 05 Dec 2015, at 22:36, Jacob Bandes-Storch <jtbandes at gmail.com> wrote:\n> \n> When you use \"weak self\", self becomes Optional inside the closure, and indeed it *can* become nil partway through. This is the same as __weak in Objective-C, and there's actually a clang warning for it (search for \"repeated-use-of-weak\" or see http://devstreaming.apple.com/videos/wwdc/2013/404xbx2xvp1eaaqonr8zokm/404/404.pdf).\n\nYep, that's correct.\n\n> That's why \"guard let strongSelf = self\" is important, and I think \"guard let self = self\" would add value without adding confusion.\n\nAgree that weakStrong can be confusing and there's maybe better way to do it. But at least, \"guard let self = self\" would be enough and we can avoid ugly and long strongSel with it.\n\nRobert" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000532.html" , "inReplyTo" : "CADcs6kMKhQRV_k=Mvh5Q1Z8bULY1kaF3XQKv9nZkHdeTyNdVMw@mail.gmail.com" , "date" : { "$date" : 1449387978000} , "subject" : "[swift-evolution] Proposal: weakStrong self in completion handler closures" , "references" : [ "6B853E77-1E06-4246-A823-1D055689FE22@me.com" , "CADcs6kPtiQ47HEoW1hZ+__rb5KA8aK0Y7qBSS2sgyj9M5w=0cA@mail.gmail.com" , "CAHF2dSLBLDwWFOvQOgKWbry-ABruSVsbu208Ay3RXP_7=CLmYw@mail.gmail.com" , "CADcs6kMKhQRV_k=Mvh5Q1Z8bULY1kaF3XQKv9nZkHdeTyNdVMw@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/1449389985.2226786.459333769.2D2E43A6@webmail.messagingengine.com"}} , "_id" : "1449389985.2226786.459333769.2D2E43A6@webmail.messagingengine.com" , "from" : "kevin at sb.org (Kevin Ballard)" , "mailingList" : "swift-evolution" , "content" : "How would weakStrong work if the closure has a non-Void return type?\n\nPersonally, I just use\n\nguard let this = self else { return }\n\nin this scenario. It's not much trouble to type `this.foo` instead of\n`self.foo` (it's even the same number of letters).\n\n-Kevin Ballrd\n\nOn Sat, Dec 5, 2015, at 03:48 AM, Robert Vojta wrote:\n> Hi all,\n> \n> let’s say we have a completion handler closure for some function\n> (networking, …) and we have [weak self] there. Example …\n> \n> doSomething() { [weak self] result in\n>   …\n> }\n> \n> … then we can use self?.whatever to access self properties, methods. Or\n> we can try to check if self exists ...\n> \n> guard let strongSelf = self else { return }\n> \n> … and use strongSelf.\n> \n> Can we introduce [weakStrong self] with following behavior:\n> \n>  - self is a weak reference\n>  - when the closure is going to be executed, all weakStrong weak\n>  references are checked if they do exist\n>  - if they do exist, they’re strong referenced for the closure and the\n>  closure is executed\n>  - if they don’t exist, closure is not executed\n> \n> doSomething() { [weakStrong self] result in\n>   // Closure code is not executed if self no longer exists\n>   // self is a strong reference now\n> }\n> \n> What do you think? Does it make sense?\n> \n> My motivation is to get rid off of the repetitive code like this one:\n> \n> doSomething() { [weak self] result in\n>   guard let strongSelf = self else { return }\n>   strongSelf.doSomethingWithResult(result)\n> }\n> \n> Robert\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000533.html" , "inReplyTo" : "6B853E77-1E06-4246-A823-1D055689FE22@me.com" , "date" : { "$date" : 1449389985000} , "subject" : "[swift-evolution] Proposal: weakStrong self in completion handler closures" , "references" : [ "6B853E77-1E06-4246-A823-1D055689FE22@me.com"] , "descendants" : [ "D24B0DD2-C149-4DD7-9755-6E5B5BD7F20B@me.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CA+Y5xYcYWQ-6YrhB=r4r8cQ9hbnMTFH2FNnWrdn5GRwQFFV-QQ@mail.gmail.com"}} , "_id" : "CA+Y5xYcYWQ-6YrhB=r4r8cQ9hbnMTFH2FNnWrdn5GRwQFFV-QQ@mail.gmail.com" , "from" : "gribozavr at gmail.com (Dmitri Gribenko)" , "mailingList" : "swift-evolution" , "content" : "On Fri, Dec 4, 2015 at 2:38 PM, Donnacha Oisín Kidney <\noisin.kidney at gmail.com> wrote:\n\n> Currently, several of the methods on SequenceType in the standard library\n> have lazy variants. flatMap, though, (seems) to have a version missing:\n> while there’s a lazy version for nested sequences, there’s no lazy version\n> for sequences of Optionals. Is there maybe a reason for this that I\n> haven’t thought of? At any rate, here’s what I had in mind:\n>\n> public struct FlatMapOptionalGenerator<G: GeneratorType, Element>:\n> GeneratorType {\n>   private let f: G.Element -> Element?\n>   private var g: G\n>   public mutating func next() -> Element? {\n>     while let x = g.next() {\n>       if let y = f(x) {\n>         return y\n>       }\n>     }\n>     return nil\n>   }\n> }\n>\n> public struct FlatMapOptionalSequence<S: LazySequenceType, Element>:\n> LazySequenceType {\n>   private let f: S.Generator.Element -> Element?\n>   private let s: S\n>   public func generate() -> FlatMapOptionalGenerator<S.Generator, Element>\n> {\n>     return FlatMapOptionalGenerator(f: f, g: s.generate())\n>   }\n> }\n>\n> extension LazySequenceType {\n>   public func flatMap<T>(transform: Generator.Element -> T?) ->\n> FlatMapOptionalSequence<Self, T> {\n>     return FlatMapOptionalSequence(f: transform, s: self)\n>   }\n> }\n>\n>\nHi,\n\nThank you for the proposal.\n\nDefining only one overload would cause the collection-ness of the input to\nbe lost.  Please take a look at the current flatMap() overloads in\nstdlib/public/core/FlatMap.swift: there's one in LazySequenceType, another\none in LazyCollectionType, and one more in LazyCollectionType with\nbidirectional indices.\n\nI'm also not a fan of introducing a specialized result type for this\noperation: given that we need three overloads, this approach would add six\nmore types to the library (three sequences and three generators).  Current\nflatMap() overloads compose existing types, but they rely on intermediate\ndata structure being a sequence or a collection.  Optional is not a\nsequence, so that exact approach won't work here.  Can you think of another\nway we could combine existing types to express the result of this operation?\n\nDmitri\n\n-- \nmain(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if\n(j){printf(\"%d\\n\",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000534.html" , "inReplyTo" : "5FD8E885-1900-4498-938D-161809D13746@gmail.com" , "date" : { "$date" : 1449393079000} , "subject" : "[swift-evolution] Lazy flatMap for Optionals" , "references" : [ "5FD8E885-1900-4498-938D-161809D13746@gmail.com"] , "descendants" : [ "CA+Y5xYd2R3B5TfhRR-OX+DRohj=aUtJW3RxM2oBOsX42XK00pg@mail.gmail.com" , "C3D6E59B-95E6-4A39-86C3-7FF7F33C38B5@gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/78552B11-3A65-4239-8B33-990E34FEA48A@gmail.com"}} , "_id" : "78552B11-3A65-4239-8B33-990E34FEA48A@gmail.com" , "from" : "lingoerer at gmail.com (Roy Fu)" , "mailingList" : "swift-evolution" , "content" : "Hi all,\n\nSimilar to the syntax ‘do try catch throw’ and ’throws’ for error handling, I propose another syntax for handling CPS functions or async call backs:\n\nfunc someFutureWrappedFunc(input: Int) future-> String{\n    doSomeStaffInBackground{ (result:String) in\n        fulfil result\n    }\n}\n\ndo{\n    let resultX = perform someFutureWrappedFunc(param)\n    let resultY = perform anotherFutureWrappedFunc(resultX)\n    let final   = resultX + resultY + perform justAnotherFutureWrappedFunc(resultX)\n    self.someLabel.text = final\n} timeout let context {\n    //maybe some additional information\n}\n\nthe reason for this proposal is for the importance of async models in modern application  architectures, and avoid such pyramids:\n\ndoSomeStaffInBackground { (resultX) -> Void in\n    \n    doSomeOtherStaff { (resultY) -> Void in\n        \n        if resultY.someCondition(resultX) {\n            \n            evenMakesItMadness(resultY) { (final) -> Void in\n                \n                //finally\n            }\n        }\n    }\n}\n\n\n\n\nFor more context comparing this async syntax to the ‘do try catch’:\n\ndo try catch:\nenum Result<T> {\n    case Success(T)\n    case Failure(ErrorType)\n}\n\nfunc flatMap<T,U> (result:Result<T>, f:T->Result<U>) -> Result<U>{\n    switch result{\n    case .Success(let v): return f(v)\n    case .Failure(let e): return .Failure(e)\n    }\n}\n\nfunc wrap1<T,U>(f:T throws-> U) -> T->Result<U> {\n    return {\n        do{\n            return try .Success(f($0))\n        }catch let e{\n            return .Failure(e)\n        }\n    }\n}\n\nfunc wrap2<T,U>(f:T -> Result<U>) -> T throws-> U{\n    return{\n        switch f($0){\n        case .Success(let v): return v\n        case .Failure(let e): throw e\n        }\n    }\n}\n\nasync:\n\nfunc flatMap<T,U> (async: (T -> Void) -> Void, f:T -> (U->Void) -> Void) -> (U -> Void) -> Void {\n    return{ cont in\n        async{ f($0)(cont) }\n    }\n}\n\nfunc wrap1<T,U>(f:T future-> U) -> T->(U->Void)->Void {\n    return {input in\n        {cont in\n            do{\n                cont(perform f(input))\n            }catch _{\n\n            }\n        }\n    }\n}\n\nfunc wrap2<T,U>(f:T -> (U->Void)->Void) -> T future-> U{\n    return{\n        f(input)({\n            fulfil $0\n        })\n    }\n}" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000536.html" , "date" : { "$date" : 1449393675000} , "subject" : "[swift-evolution] Proposal: Syntax sugar for cps or async functions similar to the \"do try catch\" for error handling." , "references" : [ ""] , "inReplyTo" :  null  , "descendants" : [ "339C6733-8C92-4616-A6A8-46FBF476923B@gmail.com" , "A4969909-2AD7-41AD-A0E3-07590FBA33D4@apple.com" , "51ADA439-E20B-4C68-B736-44C41E46A6F0@web.de"]} , { "_links" : { "self" : { "href" : "/charter/emails/1449393696.2236899.459345489.6C2ED3CC@webmail.messagingengine.com"}} , "_id" : "1449393696.2236899.459345489.6C2ED3CC@webmail.messagingengine.com" , "from" : "kevin at sb.org (Kevin Ballard)" , "mailingList" : "swift-evolution" , "content" : "There's no way to create a substring of `StaticString` that's still\ntyped as `StaticString`. This is occasionally desirable, for example if\nyou want to extract the filename from `__FILE__` to pass to another API\nthat requires a `StaticString`.\n\nI believe the best solution to this is to add a type\n`StaticString.UnicodeScalarView`, similar to `String.UnicodeScalarView`.\n`StaticString` would also be extended with a property `unicodeScalars`\nand two initializers to construct a `StaticString` from a\n`String.UnicodeScalarView`. The full proposed API looks like:\n\nextension StaticString {  /// The value of `self` as a collection of\n[Unicode scalar values]\n(http://www.unicode.org/glossary/#unicode_scalar_value).  public var\nunicodeScalars: UnicodeScalarView\n\n/// Construct the `StaticString` corresponding to the given  ///\n`UnicodeScalarView`.  public init(_: UnicodeScalarView)\n\n/// Construct the `StaticString` corresponding to the given  ///\n`UnicodeScalarView` slice.  public init(_: Slice<UnicodeScalarView>)\n\n/// A collection of [Unicode scalar values]\n(http://www.unicode.org/glossary/#unicode_scalar_value) that  /// encode\na `StaticString`.  public struct UnicodeScalarView : CollectionType {\n\ninit(_: StaticString)\n\n/// A position in a `StaticString.UnicodeScalarView`.    public struct\nIndex : BidirectionalIndexType, Comparable {      /// Returns the next\nconsecutive value after `self`.      ///      /// - Requires: The next\nvalue is representable.      @warn_unused_result      public func\nsuccessor() -> Index\n\n/// Returns the previous consecutive value before `self`.      ///\n/// - Requires: The previous value is representable.\n@warn_unused_result      public func predecessor() -> Index    }\n\n/// The position of the first `UnicodeScalar` if the `StaticString` is\n/// non-empty; identical to `endIndex` otherwise.    public var\nstartIndex: Index\n\n/// The \"past the end\" position.    ///    /// `endIndex` is not a valid\nargument to `subscript`, and is always    /// reachable from\n`startIndex` by zero or more applications of    /// `successor()`.\npublic var endIndex: Index\n\n/// Returns `true` iff `self` is empty.    public var isEmpty: Bool\n\npublic subscript(position: Index) -> UnicodeScalar  } }\n\nAn alternative would be to make StaticString itself conform to\nCollectionType, but this is a bad idea for the same reasons that String\ndoesn't conform to CollectionType.\n\n-Kevin Ballard" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000535.html" , "date" : { "$date" : 1449393696000} , "subject" : "[swift-evolution] Proposal: Add StaticString.UnicodeScalarView" , "references" : [ ""] , "inReplyTo" :  null  , "descendants" : [ "1449393836.2237188.459355225.09DD7F67@webmail.messagingengine.com" , "CA+Y5xYcNsj4qOp5h_Uiz2ysjwj3zS_OwngF0dkQy-EOfPRmEAg@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/1449393836.2237188.459355225.09DD7F67@webmail.messagingengine.com"}} , "_id" : "1449393836.2237188.459355225.09DD7F67@webmail.messagingengine.com" , "from" : "kevin at sb.org (Kevin Ballard)" , "mailingList" : "swift-evolution" , "content" : "I've submitted a proposal for this as\n\nhttps://github.com/apple/swift-evolution/pull/32\n\nI also have an implementation written as\n\nhttps://github.com/apple/swift/pull/277\n\n-Kevin Ballard\n\nOn Sun, Dec 6, 2015, at 01:21 AM, Kevin Ballard wrote:\n> There's no way to create a substring of `StaticString` that's still\n> typed as `StaticString`. This is occasionally desirable, for example\n> if you want to extract the filename from `__FILE__` to pass to another\n> API that requires a `StaticString`.\n>\n> I believe the best solution to this is to add a type\n> `StaticString.UnicodeScalarView`, similar to\n> `String.UnicodeScalarView`. `StaticString` would also be extended with\n> a property `unicodeScalars` and two initializers to construct a\n> `StaticString` from a `String.UnicodeScalarView`. The full proposed\n> API looks like:\n>\n> extension StaticString {  /// The value of `self` as a collection of\n> [Unicode scalar values]\n> (http://www.unicode.org/glossary/#unicode_scalar_value).  public var\n> unicodeScalars: UnicodeScalarView\n>\n> /// Construct the `StaticString` corresponding to the given  ///\n> `UnicodeScalarView`.  public init(_: UnicodeScalarView)\n>\n> /// Construct the `StaticString` corresponding to the given  ///\n> `UnicodeScalarView` slice.  public init(_: Slice<UnicodeScalarView>)\n>\n> /// A collection of [Unicode scalar values]\n> (http://www.unicode.org/glossary/#unicode_scalar_value) that  ///\n> encode a `StaticString`.  public struct UnicodeScalarView :\n> CollectionType {\n>\n> init(_: StaticString)\n>\n> /// A position in a `StaticString.UnicodeScalarView`.    public struct\n> Index : BidirectionalIndexType, Comparable {      /// Returns the next\n> consecutive value after `self`.      ///      /// - Requires: The next\n> value is representable.      @warn_unused_result      public func\n> successor() -> Index\n>\n> /// Returns the previous consecutive value before `self`.      ///\n> /// - Requires: The previous value is representable.\n> @warn_unused_result      public func predecessor() -> Index    }\n>\n> /// The position of the first `UnicodeScalar` if the `StaticString` is\n> /// non-empty; identical to `endIndex` otherwise.    public var\n> startIndex: Index\n>\n> /// The \"past the end\" position.    ///    /// `endIndex` is not a\n> valid argument to `subscript`, and is always    /// reachable from\n> `startIndex` by zero or more applications of    /// `successor()`.\n> public var endIndex: Index\n>\n> /// Returns `true` iff `self` is empty.    public var isEmpty: Bool\n>\n> public subscript(position: Index) -> UnicodeScalar  } }\n>\n> An alternative would be to make StaticString itself conform to\n> CollectionType, but this is a bad idea for the same reasons that\n> String doesn't conform to CollectionType.\n>\n> -Kevin Ballard" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000537.html" , "inReplyTo" : "1449393696.2236899.459345489.6C2ED3CC@webmail.messagingengine.com" , "date" : { "$date" : 1449393836000} , "subject" : "[swift-evolution] Proposal: Add StaticString.UnicodeScalarView" , "references" : [ "1449393696.2236899.459345489.6C2ED3CC@webmail.messagingengine.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/D24B0DD2-C149-4DD7-9755-6E5B5BD7F20B@me.com"}} , "_id" : "D24B0DD2-C149-4DD7-9755-6E5B5BD7F20B@me.com" , "from" : "rvojta at me.com (Robert Vojta)" , "mailingList" : "swift-evolution" , "content" : "> On 06 Dec 2015, at 09:19, Kevin Ballard via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> How would weakStrong work if the closure has a non-Void return type?\n\nAllowed only for optional (closure) parameters?\n\ndoSmth(handler: (() -> Bool)?) { [weakStrong self] in\n}\n\nweakStrong makes sense for async only where self (or anything else) can disappear. It does not make sense for @noescape, ...\n\n> Personally, I just use\n> \n> guard let this = self else { return }\n> \n> in this scenario. It's not much trouble to type `this.foo` instead of\n> `self.foo` (it's even the same number of letters).\n\nWay to do. But if you decide to move code outside the closure you're forced to replace this. with self. or delete this. The code shouldn't differ (this vs self vs strongSelf) if it's in the closure or outside of it.\n\nRobert" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000538.html" , "inReplyTo" : "1449389985.2226786.459333769.2D2E43A6@webmail.messagingengine.com" , "date" : { "$date" : 1449394211000} , "subject" : "[swift-evolution] Proposal: weakStrong self in completion handler closures" , "references" : [ "6B853E77-1E06-4246-A823-1D055689FE22@me.com" , "1449389985.2226786.459333769.2D2E43A6@webmail.messagingengine.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org"}} , "_id" : "D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org" , "from" : "swift-evolution at jacopo.giola.org (Jacopo Andrea Giola)" , "mailingList" : "swift-evolution" , "content" : "+1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.\n\nIf this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don't introduce an infinite \"switch\" loop.\n\nSent from my iPad\n\n> On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> Very much thinking out loud and not really the implications, I wonder if we might just use \"continue\" instead of \"reswitch\".\n> \n> I very much like specifying what case to fall through into, no matter how we spell it.\n> \n> - Steve\n> \n>> On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution <swift-evolution at swift.org> wrote:\n>> \n>>>> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution <swift-evolution at swift.org> wrote:\n>>>> On Dec 4, 2015, at 11:37 PM, John Calsbeek <john.calsbeek+lists at gmail.com> wrote:\n>>>> `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.\n>>>> \n>>>> It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.\n>>> \n>>> Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.\n>>> \n>>> On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.\n>> \n>> Oh, I see that Joe already brought this up, spelled “reswitch”.\n>> \n>> John.\n>> \n>>> \n>>> John.\n>>> \n>>>> \n>>>> One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).\n>>>> \n>>>> switch op {\n>>>> case LOAD_INDIRECT:\n>>>>    in0 = memory[in1]\n>>>>    fallthrough\n>>>> case LOAD:\n>>>>    out0 = memory[in0]\n>>>> //...\n>>>> }\n>>>> \n>>>> I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.\n>>>> \n>>>> Cheers,\n>>>> John\n>>>> \n>>>>>> On Dec 4, 2015, at 2:42 PM, John McCall <rjmccall at apple.com> wrote:\n>>>>>> \n>>>>>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard <kevin at sb.org> wrote:\n>>>>>> It's not actually Duff's Device. Duff's Device relies on the fact that C switch statements don't actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it's a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.\n>>>>> \n>>>>> To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.\n>>>>> \n>>>>> But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.\n>>>>> \n>>>>> John.\n>>>>> \n>>>>>>  \n>>>>>> Steve's code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It's a good example of one of the uses of `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's Device in Swift.\n>>>>>>  \n>>>>>> -Kevin Ballard\n>>>>>>  \n>>>>>>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:\n>>>>>>> Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.\n>>>>>>>  \n>>>>>>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun <erica at ericasadun.com> wrote:\n>>>>>>>>  \n>>>>>>>> Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it. \n>>>>>>>>  \n>>>>>>>> True fact: On all of gist.github.com, there are only 22 gist results for \"fallthrough language:swift\".\n>>>>>>>> Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:\n>>>>>>>> case .Enum1, .Enum2:\n>>>>>>>> expressed as \n>>>>>>>> case .Enum1: fallthrough\n>>>>>>>> case .Enum2:\n>>>>>>>>  \n>>>>>>>> And then there's streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea   I'm pretty sure that ponies were harmed in the production of whatever that last bit is.\n>>>>>>>>  \n>>>>>>>>  \n>>>>>>>>  \n>>>>>>>>  \n>>>>>>>>> On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com wrote:\n>>>>>>>>>  \n>>>>>>>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the \"fallthrough\" keyword from the language?\n>>>>>>>>>  \n>>>>>>>>> My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.\n>>>>>>>>>  \n>>>>>>>>> The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:\n>>>>>>>>>  \n>>>>>>>>> \"The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.\"\n>>>>>>>>>  \n>>>>>>>>> To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.\n>>>>>>>>>  \n>>>>>>>>> I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.\n>>>>>>>>>  \n>>>>>>>>> In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.\n>>>>>>>>>  \n>>>>>>>>> Thoughts?\n>>>>>>>>>  \n>>>>>>>>> Daniel\n>>>>>>>>>  \n>>>>>>>>> _______________________________________________\n>>>>>>>>> swift-evolution mailing list\n>>>>>>>>> swift-evolution at swift.org\n>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>>>>>> \n>>>>>>>>  \n>>>>>>>> \n>>>>>>>> _______________________________________________\n>>>>>>>> swift-evolution mailing list\n>>>>>>>> swift-evolution at swift.org\n>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>>>>> \n>>>>>>>  \n>>>>>>> \n>>>>>>> _______________________________________________\n>>>>>>> swift-evolution mailing list\n>>>>>>> swift-evolution at swift.org\n>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>>>>  \n>>>>>> \n>>>>>> _______________________________________________\n>>>>>> swift-evolution mailing list\n>>>>>> swift-evolution at swift.org\n>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>>> \n>>>>>  _______________________________________________\n>>>>> swift-evolution mailing list\n>>>>> swift-evolution at swift.org\n>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>> \n>>>> \n>>>> _______________________________________________\n>>>> swift-evolution mailing list\n>>>> swift-evolution at swift.org\n>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>> \n>>> \n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>> \n>> \n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000539.html" , "inReplyTo" : "CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com" , "date" : { "$date" : 1449395529000} , "subject" : "[swift-evolution] Proposal: Remove the \"fallthrough\" keyword" , "references" : [ "3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com" , "AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com" , "8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com" , "1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com" , "02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com" , "E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com" , "444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com" , "EF1675F6-7918-4262-B535-696104BFC405@apple.com" , "CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com"] , "descendants" : [ "6CACDDEC-7FB7-433D-AFA1-15DD4208BE16@jacopo.giola.org" , "0FCA62AB-3FBE-472E-AD11-95E18DC650A9@apple.com" , "ECE284CE-EDE3-4071-ABB6-821820F1FC44@jacopo.giola.org" , "EF9FEF97-C7B8-4D54-B406-2B62FDD15B59@springsandstruts.com" , "98973CF0-B5A8-491F-A8D0-DA73456FF01B@jacopo.giola.org" , "CAKCGC8B0UPGUHeJ_1n8XsGoo+E6Anyj_+_R7WsT76rV1Q-qu2w@mail.gmail.com" , "E7877054-1CF7-4596-800A-0D3C578A0CF1@portableinnovations.de" , "CAKCGC8Cp52O7DX6wWSc3J6FR8Xmoo_WLBgjGBa6fSXzNHhdHEg@mail.gmail.com" , "D7B06EA6-A46C-4920-9E09-CB99B96242AA@jacopo.giola.org" , "1449442122.2380087.459714713.0AC4A201@webmail.messagingengine.com" , "D9340CB2-A696-478A-BAE7-F93ED39CB2DC@red-sweater.com" , "CEA837D7-E2B1-48DC-A53B-D216F96DD8DF@apple.com" , "2423784D-3B84-41CE-9BE2-0850BFE5A3C0@apple.com" , "2A8EA416-B4FF-45B3-9C6D-F94059151129@apple.com" , "82BBEAF7-A512-460A-998C-054AE6D70BEB@springsandstruts.com" , "9C8A3DCA-B80C-4D1F-9528-DD65C0020680@apple.com" , "CAKCGC8BL6SHkO0T_Rg6Ren-NfCLs+eGBb6Zm9aFuZ5rMkWJXtQ@mail.gmail.com" , "AC2407AD-ABFF-4657-A04C-F37E52466316@springsandstruts.com" , "1449524366.1229815.460824345.0E2309C2@webmail.messagingengine.com" , "1449524552.1230499.460828169.5289846B@webmail.messagingengine.com" , "6BABB1A5-55CD-43AF-8D5D-9758F55AD611@apple.com" , "266A61BA-1890-46D7-8969-4A0225EA60B4@springsandstruts.com" , "37FA3360-5F23-462D-BE9B-3743253D2693@apple.com" , "071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com" , "CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org" , "C19956A6-C9B2-45CC-8C91-DA2215EBEA5C@alkaline-solutions.com" , "6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com" , "6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org" , "A56C416E-E246-44FC-A681-3DD66171DF30@springsandstruts.com" , "CADQN+5atyJ78vi0xssjOxh2ka_-jZTaO3ZabxFdY80YqJHFmxg@mail.gmail.com" , "CAKCGC8DHCxwtiU82CjxChc6PaiB495WOCJBP0iq04uw7iWcQmA@mail.gmail.com" , "DEBE0A49-3E5A-431F-8559-63EBA7214068@jacopo.giola.org" , "CAKCGC8DbhMOX6bHtzXQcAhjHQSw1wSSoX-TBUtew0arWA=4pSw@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/99C3AE06-9BA8-4F46-B67A-88AB0D8A3748@hartbit.com"}} , "_id" : "99C3AE06-9BA8-4F46-B67A-88AB0D8A3748@hartbit.com" , "from" : "david at hartbit.com (David Hart)" , "mailingList" : "swift-evolution" , "content" : "This property delegates feature from Kotlin sounds fantastic! As the examples in Kotlin show, it could bring a very powerful solution to many problems in Swift right now: lazy being narrow, cache missing, native KVO :D\n\nThis has just become my #1 feature proposal!\n\nSuper excited David!\n\n> On 06 Dec 2015, at 08:27, Chris Lattner <clattner at apple.com> wrote:\n> \n> \n>> On Dec 4, 2015, at 5:40 AM, David Hart <david at hartbit.com> wrote:\n>> \n>> In Objective-C, I often used the lazy initialization pattern to implement a cache for expensive operations. For exemple, here is an often used scenario in a project where objects behind foreign keys in a database ORM are only fetched when necessary:\n>> \n>> When thinking about it, I came to the conclusion that the use cases of lazy seem very narrow compared to how useful the lazy initialization pattern was in Objective-C.\n>> I want your opinion on three alternatives:\n>> \n>> 1- Do nothing, and use the slightly uglier Swift example when using a cache.\n>> 2- Modify lazy semantics to re-calculates when nil (I think this is the worst solution).\n>> 3- Add a cache modifier that re-calcualtes when nil.\n> \n> Hi David,\n> \n> My preference is:\n> 4) Kick lazy out of the compiler and make it a standard library feature instead, allowing it to be extended in lots of ways.\n> \n> The existing lazy behavior was added as a very narrow solution to a common scenario that would otherwise required optional machinations everywhere.  It succeeded in that goal, but it is super narrow, and the implementation has a number of bugs (e.g. you can’t have a lazy local variable).\n> \n> In terms of its narrowness, it has the limitations you describe, but it also doesn’t solve other common problems.  For example, many people complain about properties that are initialized only in a second phase of initialization (e.g. awakeFromNib) and right now, most folks resort to using typing their properties as ImplicitlyUnwrappedOptional to avoid using ! at every use site.  A natural solution to that is to introduce a concept of a “delayed var x : T” which does not need initialization in init(), and runtime traps if it is read before initialized.  This provides similar semantics to T!, but without infecting the type system.  Better than T!, a “delayed let x : T” would allow exactly one runtime initialization of the property.\n> \n> The problem with this line of thinking is that - if we kept going down this path - we’d end up adding a ton of very narrow solutions for specific problems, adding language complexity all the way.  This is pretty dissatisfying for a number of reasons. :-)\n> \n> A different approach is to introduce a single language feature that would allow you to define customization behavior for properties in a library, which would be a general solution to these sorts of issues.  Joe Groff is working on a proposal to do just this, similar to the idea of Kotlin property delegates (https://kotlinlang.org/docs/reference/delegated-properties.html).\n> \n> We’ve been a bit busy lately :-) but I’m hoping that he’ll send this proposal out in the next few weeks.  Assuming that proposal works out, I expect lazy to get ripped out of the language, and *that* discussion can reopen detailed debate about what the replacement should look like.\n> \n> -Chris\n> \n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000540.html" , "inReplyTo" : "C7B2EEB8-0B36-4930-B011-034548511656@apple.com" , "date" : { "$date" : 1449396045000} , "subject" : "[swift-evolution] lazy keyword vs lazy initialization pattern" , "references" : [ "C9BBB9E4-F2E9-4514-926F-8669DC731128@hartbit.com" , "C7B2EEB8-0B36-4930-B011-034548511656@apple.com"] , "descendants" : [ "546CDC6C-6D6E-41F6-B506-77C617575DAF@apple.com" , "57598505-6076-4C78-8D09-7F7C01B0D18B@web.de" , "543A1A03-A23B-42D1-96DA-DC7C3F81E49A@anandabits.com" , "87303129-BC13-487E-908D-7D2CC498CDF0@web.de"]} , { "_links" : { "self" : { "href" : "/charter/emails/BLU436-SMTP178F245BC064926665ED9B9AA0A0@phx.gbl"}} , "_id" : "BLU436-SMTP178F245BC064926665ED9B9AA0A0@phx.gbl" , "from" : "defrenz98 at hotmail.com (Davide De Franceschi)" , "mailingList" : "swift-evolution" , "content" : "I agree that \"weak-strong\" is a commonly used (and correct) pattern, and I also wish that there were an easier way to do that. I also did file a radar myself about that.\n\nBut I don't have any idea of the correct way of implementing it because the actually desired behaviour in the \"failing\" case can change depending on your use-case.\n\nMost of the times you just want to `guard let strongSelf = self else { return }`, but that works when you return `Void` and you don't want to manage this \"failure\" in any other way...\nShould `weak-strong` be allowed only for closures that `-> Void`?\nWhat if you want to fire a \"completionBlock\" anyway?\n\nWhile the need to remove this common boilerplate feels strong, I'm not certain this would be the right way. Can't really suggest a better alternative though.\n\n\n> On 5 Dec 2015, at 19:21, Jacob Bandes-Storch via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> Another approach would be to simply allow\n> \n> guard let self = self else { return }\n> On Sat, Dec 5, 2015 at 3:48 AM Robert Vojta <rvojta at me.com <mailto:rvojta at me.com>> wrote:\n> Hi all,\n> \n> let’s say we have a completion handler closure for some function (networking, …) and we have [weak self] there. Example …\n> \n> doSomething() { [weak self] result in\n>   …\n> }\n> \n> … then we can use self?.whatever to access self properties, methods. Or we can try to check if self exists ...\n> \n> guard let strongSelf = self else { return }\n> \n> … and use strongSelf.\n> \n> Can we introduce [weakStrong self] with following behavior:\n> \n>  - self is a weak reference\n>  - when the closure is going to be executed, all weakStrong weak references are checked if they do exist\n>  - if they do exist, they’re strong referenced for the closure and the closure is executed\n>  - if they don’t exist, closure is not executed\n> \n> doSomething() { [weakStrong self] result in\n>   // Closure code is not executed if self no longer exists\n>   // self is a strong reference now\n> }\n> \n> What do you think? Does it make sense?\n> \n> My motivation is to get rid off of the repetitive code like this one:\n> \n> doSomething() { [weak self] result in\n>   guard let strongSelf = self else { return }\n>   strongSelf.doSomethingWithResult(result)\n> }\n> \n> Robert\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>  _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000541.html" , "inReplyTo" : "CADcs6kPtiQ47HEoW1hZ+__rb5KA8aK0Y7qBSS2sgyj9M5w=0cA@mail.gmail.com" , "date" : { "$date" : 1449396113000} , "subject" : "[swift-evolution] Proposal: weakStrong self in completion handler closures" , "references" : [ "6B853E77-1E06-4246-A823-1D055689FE22@me.com" , "CADcs6kPtiQ47HEoW1hZ+__rb5KA8aK0Y7qBSS2sgyj9M5w=0cA@mail.gmail.com"] , "descendants" : [ "242D65BB-3319-468D-A259-DA1AC28FB5C7@me.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/55E6FBE9-E818-4240-8D74-37B7C98FDE9A@gmx.de"}} , "_id" : "55E6FBE9-E818-4240-8D74-37B7C98FDE9A@gmx.de" , "from" : "clemens.wagner.2 at gmx.de (Clemens Wagner)" , "mailingList" : "swift-evolution" , "content" : "> We’ve developed a number of Swift apps for various clients over the past year and have not needed C style for loops either.\n\nBut I think this is a very weak reason for *removing* any portion like C-loops and increment or decrement operators of a programming language. How about the developers and the productive code which used C-style loops already?\n\nI understand the reasons why you, Erica and the others don’t like C-style loops. But changing the philosophy of a productive programming language is a very bad idea.\n\nCheers\nClemens" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000639.html" , "date" : { "$date" : 1449396143000} , "subject" : "[swift-evolution] C-style For Loops" , "references" : [ ""] , "inReplyTo" :  null } , { "_links" : { "self" : { "href" : "/charter/emails/CA+Y5xYcNsj4qOp5h_Uiz2ysjwj3zS_OwngF0dkQy-EOfPRmEAg@mail.gmail.com"}} , "_id" : "CA+Y5xYcNsj4qOp5h_Uiz2ysjwj3zS_OwngF0dkQy-EOfPRmEAg@mail.gmail.com" , "from" : "gribozavr at gmail.com (Dmitri Gribenko)" , "mailingList" : "swift-evolution" , "content" : "Hi Kevin,\n\nThank you for the proposal.  This is in line with the current design of\nString.  One of the Swift 3 goals is a redesign of String, to make the API\neasier to use.  I don't think that should block this improvement, since\nwhatever the new design is, it should provide the UnicodeScalar view\nfunctionality for String, and the same API should be exposed on\nStaticString.\n\nOn Sun, Dec 6, 2015 at 1:21 AM, Kevin Ballard via swift-evolution <\nswift-evolution at swift.org> wrote:\n\n> There's no way to create a substring of `StaticString` that's still typed\n> as `StaticString`. This is occasionally desirable, for example if you want\n> to extract the filename from `__FILE__` to pass to another API that\n> requires a `StaticString`.\n>\n> I believe the best solution to this is to add a type\n> `StaticString.UnicodeScalarView`, similar to `String.UnicodeScalarView`.\n> `StaticString` would also be extended with a property `unicodeScalars` and\n> two initializers to construct a `StaticString` from a\n> `String.UnicodeScalarView`. The full proposed API looks like:\n>\n> extension StaticString {\n>   /// The value of `self` as a collection of [Unicode scalar values](\n> http://www.unicode.org/glossary/#unicode_scalar_value).\n>   public var unicodeScalars: UnicodeScalarView\n>\n>   /// Construct the `StaticString` corresponding to the given\n>   /// `UnicodeScalarView`.\n>   public init(_: UnicodeScalarView)\n>\n>   /// Construct the `StaticString` corresponding to the given\n>   /// `UnicodeScalarView` slice.\n>   public init(_: Slice<UnicodeScalarView>)\n>\n>   /// A collection of [Unicode scalar values](\n> http://www.unicode.org/glossary/#unicode_scalar_value) that\n>   /// encode a `StaticString`.\n>   public struct UnicodeScalarView : CollectionType {\n>\n\nUnicodeScalarView should be a slice type, that is,\nUnicodeScalarView.SubSequence == UnicodeScalarView.\n\nThen, you will be able to remove the\nStaticString.init(Slice<UnicodeScalarView>) initializer.\n\nIt should also be CustomStringConvertible, CustomDebugStringConvertible,\nwith the same behavior as String.\n\nPlease also add a CustomReflectable conformance, that extracts the string\nvalue and reflects that.\n\n    init(_: StaticString)\n>\n>     /// A position in a `StaticString.UnicodeScalarView`.\n>     public struct Index : BidirectionalIndexType, Comparable {\n>       /// Returns the next consecutive value after `self`.\n>       ///\n>       /// - Requires: The next value is representable.\n>       @warn_unused_result\n>       public func successor() -> Index\n>\n>       /// Returns the previous consecutive value before `self`.\n>       ///\n>       /// - Requires: The previous value is representable.\n>       @warn_unused_result\n>       public func predecessor() -> Index\n>     }\n>\n>     /// The position of the first `UnicodeScalar` if the `StaticString` is\n>     /// non-empty; identical to `endIndex` otherwise.\n>     public var startIndex: Index\n>\n>     /// The \"past the end\" position.\n>     ///\n>     /// `endIndex` is not a valid argument to `subscript`, and is always\n>     /// reachable from `startIndex` by zero or more applications of\n>     /// `successor()`.\n>     public var endIndex: Index\n>\n>     /// Returns `true` iff `self` is empty.\n>     public var isEmpty: Bool\n>\n>     public subscript(position: Index) -> UnicodeScalar\n>   }\n> }\n>\n\nYou omitted == and < APIs for indices.\n\n\n> An alternative would be to make StaticString itself conform to\n> CollectionType, but this is a bad idea for the same reasons that String\n> doesn't conform to CollectionType.\n>\n\nAgreed.\n\nDmitri\n\n-- \nmain(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if\n(j){printf(\"%d\\n\",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000542.html" , "inReplyTo" : "1449393696.2236899.459345489.6C2ED3CC@webmail.messagingengine.com" , "date" : { "$date" : 1449396171000} , "subject" : "[swift-evolution] Proposal: Add StaticString.UnicodeScalarView" , "references" : [ "1449393696.2236899.459345489.6C2ED3CC@webmail.messagingengine.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de"}} , "_id" : "AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de" , "from" : "macmoonshine at gmx.de (Clemens Wagner)" , "mailingList" : "swift-evolution" , "content" : "> We’ve developed a number of Swift apps for various clients over the past year and have not needed C style for loops either.\n\nBut I think this is a very weak reason for *removing* any portion like C-loops and increment or decrement operators of a programming language. How about the developers and the productive code which used C-style loops already?\n\nI understand the reasons why you, Erica and the others don’t like C-style loops. But changing the philosophy of a productive programming language is a very bad idea.\n\nCheers\nClemens" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000543.html" , "date" : { "$date" : 1449396221000} , "subject" : "[swift-evolution] C-style For Loops" , "references" : [ ""] , "inReplyTo" :  null  , "descendants" : [ "CAAcV4sZVC8M4yo+XEdWoGzKyG7rDYuy7ox=Rk3cdbXjFuSD4Sg@mail.gmail.com" , "B655E20A-3F9D-4B07-B6F1-80A0D81C93F2@gmx.de" , "CAOjGmwn6O2uvJBq03GZyJ+yngfAB4=rqb60dCCfpP2x7rmnEyg@mail.gmail.com" , "9C647949-D1C6-4EB3-A964-04312A957B2F@gmx.de" , "CADS5KKU3JRZo0eCvF4XgA6ZT0=Eb9wtGg-rwn45BZXC2MiXvdA@mail.gmail.com" , "8808357C-0780-423E-B028-1299CBCD2382@pobox.com" , "3743E515-225F-43C4-BB62-DC8C848BEE89@ericasadun.com" , "AA5B9DF1-AA96-4650-926F-039911A4C995@ericasadun.com" , "CC1BC37C-FBA3-4D17-9ADA-379FA69A8078@me.com" , "E35181B4-9142-4677-809C-84E9F8EA4301@anandabits.com" , "CAPh90aFdMXExnTgdaOiO_9xtYvHREW3mwC_VJQHOEbZ+qns8rQ@mail.gmail.com" , "9FCB65CF-491B-4F21-B664-AE6623E7C669@michelf.ca" , "2CF98787-3994-47AA-8B84-13C9AC7A4154@fifthace.com" , "CAPh90aFQs-RA4W++PCgG7n58p0F5NOp9jmJsz7hZxfkOZktVcA@mail.gmail.com" , "75C3B397-E687-4D6A-A5E2-D918502E8484@ericasadun.com" , "AD0908AC-1F8F-44A4-B059-8E811CE3D661@aol.com" , "CAB8TY2OSDRXUcxtMj7-isuaRmkMXafwsxiquqzedxZ+A+0kyPw@mail.gmail.com" , "E332A59C-7036-42AB-A54A-BE0FE97766EA@aol.com" , "A3B09B02-2438-4658-8073-BEBA8F1A5441@aol.com" , "3F9880E8-7BEA-4275-A939-940041861EC5@michelf.ca" , "5664F2B9.5080808@klundberg.com" , "5567A331-3420-448B-9A1F-484D44F7A792@michelf.ca" , "2F9C0A4A-4005-462F-83DD-795C6E838C3B@pobox.com" , "F3CA2962-24DB-438C-B5B8-13B33A3ACDD6@architechies.com" , "A1CD1E1C-07C2-40AA-AB39-EECDB0C09323@springsandstruts.com" , "B9F4EA1D-98F9-4A2B-8D16-9073FBDD54A5@portablesoftware.com" , "112B3CB9-7E8E-4DA6-8A20-6C2E8848E58B@alkaline-solutions.com" , "40642775-F58D-49B0-9BF3-38913FD6924C@ericasadun.com" , "B0FB69E4-C275-4E6E-9B18-6A3354164938@springsandstruts.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/B35331BD-313C-4B83-ADA1-9A8DBA287715@gmail.com"}} , "_id" : "B35331BD-313C-4B83-ADA1-9A8DBA287715@gmail.com" , "from" : "possen at gmail.com (possen p)" , "mailingList" : "swift-evolution" , "content" : "(I originally posted as possen p and since hopefully fixed that) \n\nSo, As Kevin Ballard and Ole Bergman pointed out, making a regular “if” an expression has some major complications. Having the potential to return different object types in a strictly typed language will not be easy. Also what to do if the if does not have an else. The ternary operator does not allow the if/else results of different types. In Python doing an expression with if/else is not a problem because it will let you return different types, this is legal, (which makes sense for Python):\n\nval = 10 if p == 5 else “abc\"\n\nit will not however let you omit the else part:\n\nval = 10 if False  // produces an error. \n\nso it appears if you assign to an expression in Python it will require the else part. So it is different than a regular if. \n\nSo I ask, is making the regular “if\" an expression truly desired for Swift? I do see other languages doing it, but it does seem a bit odd to assign from any “if”. In my original proposal I was suggesting that assignment is done like this:\n\nlet val = 10 else 40 if p == 5 \n\nIn this it is very similar to the ternary expression in that else part is required and both types must match, and has improved readability. This is overloading the if/else keywords to provide essentially the same thing as ternary operators.. \n\nThe following from Kevin Ballard's email:\n\n> let foo = if condition {\n>     funcWithSideEffectsThatReturnsInt()\n> } else {\n>     funcWithSideEffectsThatReturnsString() \n> }\n\n\nI find it is hard to tell that the two results are returning a value. To me it looks like it is either ignoring the return value or is returning void. \n\nMaybe emphasizing the assignment would help as below does not have return values in the method names: \n\nlet foo if condition {\n    = dosomething()\n} else {\n    = dosomethingelse() \n}\n\nputting the = after the else shows that it is returning a value for the let clause. It also helps emphasize that the return types must match and I think looks better. \n\nGoing back to my proposal with the = suggestion: \n\nlet foo = dosomething() else = dosomethingelse() if condition\n\nthis really shows that the let variable is being assigned. \n\nNote that these are still chainable expressions: \n\nvar foo = ((10 else = 40 if p == 5) else = (15 else = 14 if p == 10) if p == 4)\n\nIt may be good to make the space optional after the else:\n\nvar foo = ((10 else= 40 if p == 5) else= (15 else= 14 if p == 10) if p == 4)\n\n- Paul" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000544.html" , "inReplyTo" : "4998B6F2-B53E-451A-8DDA-353C631562D1@apple.com" , "date" : { "$date" : 1449396850000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com" , "CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com" , "C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com" , "18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com" , "2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io" , "BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com" , "CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com" , "CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com" , "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com" , "BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com" , "4998B6F2-B53E-451A-8DDA-353C631562D1@apple.com"] , "descendants" : [ "A8D2920B-554C-4495-A6E1-B797802C42A3@gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/D1CFC4EF-BA8D-424A-AD42-83E252C40206@jacopo.giola.org"}} , "_id" : "D1CFC4EF-BA8D-424A-AD42-83E252C40206@jacopo.giola.org" , "from" : "swift-evolution at jacopo.giola.org (Jacopo Andrea Giola)" , "mailingList" : "swift-evolution" , "content" : "+1 to this, but I'm not sure that this mailing list is the right place to discuss evolution of the package manager.\nI think you can directly send a pull request to the repository to be evaluated.\n\nSent from my iPad\n\n> On 05 Dec 2015, at 21:25, Lander Brandt via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> On the Swift package manager page on swift.org (https://swift.org/package-manager/#example-usage) the requirements for creating a package/application are clearly outlined, but why not include a command in the swift tool for autogenerating the require? I did a quick look and didn’t see any existing discussion, so I apologize if this has already been discussed.\n> \n> Example of the tool command: `swift init foo --type=(lib|app)`\n> \n> Would create a new directory called “foo” with the following tree structure for a project of type app:\n> \n> foo\n> ├── Package.swift\n> ├── Packages\n> ├── README.md\n> └── main.swift\n> \n> And for project of type lib:\n> \n> foo\n> ├── Package.swift\n> ├── README.md\n> └── Sources\n>     └── Foo.swift\n> \n> In both cases Package.swift would contain something basic like:\n> \n> import PackageDescription\n> \n> let package = Package(\n>     name: “Foo\",\n>     dependencies: [\n>     ]\n> )\n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000545.html" , "inReplyTo" : "193BF74F-CC27-4C1B-B0BD-9F845BB02FEC@gmail.com" , "date" : { "$date" : 1449397104000} , "subject" : "[swift-evolution] swift tool project init command" , "references" : [ "193BF74F-CC27-4C1B-B0BD-9F845BB02FEC@gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/A8D2920B-554C-4495-A6E1-B797802C42A3@gmail.com"}} , "_id" : "A8D2920B-554C-4495-A6E1-B797802C42A3@gmail.com" , "from" : "possen at gmail.com (possen p)" , "mailingList" : "swift-evolution" , "content" : "Another idea is put the conditional at the beginning:\n\nlet foo if conditional then = 10 else = 20\n\nBut that requires an additional keyword to separate out the conditional but might read better. \n\n\n\n> On Dec 6, 2015, at 2:14 AM, possen p <possen at gmail.com> wrote:\n> \n> (I originally posted as possen p and since hopefully fixed that) \n> \n> So, As Kevin Ballard and Ole Bergman pointed out, making a regular “if” an expression has some major complications. Having the potential to return different object types in a strictly typed language will not be easy. Also what to do if the if does not have an else. The ternary operator does not allow the if/else results of different types. In Python doing an expression with if/else is not a problem because it will let you return different types, this is legal, (which makes sense for Python):\n> \n> val = 10 if p == 5 else “abc\"\n> \n> it will not however let you omit the else part:\n> \n> val = 10 if False  // produces an error. \n> \n> so it appears if you assign to an expression in Python it will require the else part. So it is different than a regular if. \n> \n> So I ask, is making the regular “if\" an expression truly desired for Swift? I do see other languages doing it, but it does seem a bit odd to assign from any “if”. In my original proposal I was suggesting that assignment is done like this:\n> \n> let val = 10 else 40 if p == 5 \n> \n> In this it is very similar to the ternary expression in that else part is required and both types must match, and has improved readability. This is overloading the if/else keywords to provide essentially the same thing as ternary operators.. \n> \n> The following from Kevin Ballard's email:\n> \n>> let foo = if condition {\n>>     funcWithSideEffectsThatReturnsInt()\n>> } else {\n>>     funcWithSideEffectsThatReturnsString() \n>> }\n> \n> \n> I find it is hard to tell that the two results are returning a value. To me it looks like it is either ignoring the return value or is returning void. \n> \n> Maybe emphasizing the assignment would help as below does not have return values in the method names: \n> \n> let foo if condition {\n>     = dosomething()\n> } else {\n>     = dosomethingelse() \n> }\n> \n> putting the = after the else shows that it is returning a value for the let clause. It also helps emphasize that the return types must match and I think looks better. \n> \n> Going back to my proposal with the = suggestion: \n> \n> let foo = dosomething() else = dosomethingelse() if condition\n> \n> this really shows that the let variable is being assigned. \n> \n> Note that these are still chainable expressions: \n> \n> var foo = ((10 else = 40 if p == 5) else = (15 else = 14 if p == 10) if p == 4)\n> \n> It may be good to make the space optional after the else:\n> \n> var foo = ((10 else= 40 if p == 5) else= (15 else= 14 if p == 10) if p == 4)\n> \n> - Paul \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000546.html" , "inReplyTo" : "B35331BD-313C-4B83-ADA1-9A8DBA287715@gmail.com" , "date" : { "$date" : 1449397586000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com" , "CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com" , "C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com" , "18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com" , "2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io" , "BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com" , "CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com" , "CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com" , "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com" , "BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com" , "4998B6F2-B53E-451A-8DDA-353C631562D1@apple.com" , "B35331BD-313C-4B83-ADA1-9A8DBA287715@gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/F54D886C-4283-4DE3-BDA3-6E1947A20233@me.com"}} , "_id" : "F54D886C-4283-4DE3-BDA3-6E1947A20233@me.com" , "from" : "adrian.kashivskyy at me.com (Adrian Kashivskyy)" , "mailingList" : "swift-evolution" , "content" : "I believe this could be achieved using generic typealiases, proposed here: https://lists.swift.org/pipermail/swift-evolution/2015-December/000132.html\n\nPozdrawiam – Regards,\nAdrian Kashivskyy\n\n> Wiadomość napisana przez QQ Mail via swift-evolution <swift-evolution at swift.org> w dniu 06.12.2015, o godz. 08:17:\n> \n> If typealias support protocol constraint, I think we can reuse a lot of code, also more readable\n> \n> For Example: \n> \n> typealias PointCollection = protocol<T:CollectionType where T.Generator.Element == CGPoint>\n> \n> public extension PointCollection {\n>     \n>     \n>     \n> }\n> \n> \n> \n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000547.html" , "inReplyTo" : "78E72933-1ABE-4930-9213-C18CF258DA2D@qq.com" , "date" : { "$date" : 1449397731000} , "subject" : "[swift-evolution] Proposal: typealias support protocol constraint" , "references" : [ "78E72933-1ABE-4930-9213-C18CF258DA2D@qq.com"] , "descendants" : [ "DF17297E-E77E-4CAF-851E-2F5E5CACCDCB@qq.com" , "C03532DB-388E-46DE-A34B-7C3572DED0C8@anandabits.com" , "FE41B04C-014E-43E7-9F5E-4826380542F9@anandabits.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/242D65BB-3319-468D-A259-DA1AC28FB5C7@me.com"}} , "_id" : "242D65BB-3319-468D-A259-DA1AC28FB5C7@me.com" , "from" : "rvojta at me.com (Robert Vojta)" , "mailingList" : "swift-evolution" , "content" : "> On 6. 12. 2015, at 11:01, Davide De Franceschi via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> Most of the times you just want to `guard let strongSelf = self else { return }`, but that works when you return `Void` and you don't want to manage this \"failure\" in any other way...\n> Should `weak-strong` be allowed only for closures that `-> Void`?\n\nCan be and result will be optional. But it complicates things and makes it unclear. Which is not good.\n\n> What if you want to fire a \"completionBlock\" anyway?\n\nThen don't use weakStrong and use weak strong dance.\n\n> While the need to remove this common boilerplate feels strong, I'm not certain this would be the right way. Can't really suggest a better alternative though.\n\nAgree with you. I just wanted to start discussion about it, but not convinced about weakStrong as well.\n\nProbably what Jacob proposed would be enough. Just allow \"guard let self = self ...\" at least to remove strongSelf, this, ...\n\nRobert" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000548.html" , "inReplyTo" : "BLU436-SMTP178F245BC064926665ED9B9AA0A0@phx.gbl" , "date" : { "$date" : 1449400851000} , "subject" : "[swift-evolution] Proposal: weakStrong self in completion handler closures" , "references" : [ "6B853E77-1E06-4246-A823-1D055689FE22@me.com" , "CADcs6kPtiQ47HEoW1hZ+__rb5KA8aK0Y7qBSS2sgyj9M5w=0cA@mail.gmail.com" , "BLU436-SMTP178F245BC064926665ED9B9AA0A0@phx.gbl"]} , { "_links" : { "self" : { "href" : "/charter/emails/014D53AE-029B-40BE-8C7B-A7ED7FBDA81C@hartbit.com"}} , "_id" : "014D53AE-029B-40BE-8C7B-A7ED7FBDA81C@hartbit.com" , "from" : "david at hartbit.com (David Hart)" , "mailingList" : "swift-evolution" , "content" : "Chris, wouldn't that be better designed/implemented with the property delegate functionality Joe Groff is working on?\n\n> On 06 Dec 2015, at 07:52, Chris Lattner via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> \n>> On Dec 5, 2015, at 10:42 PM, Mosab Elagha <elagha2 at illinois.edu> wrote:\n>> \n>> +1. This feature would allow for a more clean approach in checking the existing state of a value. \n>> \n>> > Also, can a property have these observers as well as the existing ones?\n>> \n>> I'm not really familiar with the implementation of the observers, but why wouldn't it be able to? Maybe didSet can precede didChange in order of execution if both are implemented, so you can have default behavior when accessing a value but certain other behavior if it has changed. Or maybe have willChange/didChange be a property that can be accessed within willSet/didSet (like oldValue).\n> \n> I believe it is possible to implement, I’m just trying to give guidance on the sorts of things a formal proposal should address.\n> \n> -Chris\n> \n>> \n>> \n>> \n>> -Mosab Elagha\n>> \n>>> On Sun, Dec 6, 2015 at 12:11 AM, Chris Lattner via swift-evolution <swift-evolution at swift.org> wrote:\n>>> \n>>>> On Dec 5, 2015, at 4:00 PM, Nathan de Vries via swift-evolution <swift-evolution at swift.org> wrote:\n>>>> \n>>>> It's currently possible to define either or both of the following observers on a property:\n>>>> willSet, called just before the value is stored\n>>>> didSet, called immediately after the new value is stored\n>>> \n>>> ...\n>>> \n>>>> This would mean the following observers could be defined on a property:\n>>>> willSet, called just before the value is stored\n>>>> willChange, called just before the value is stored if the value is different to the previous value\n>>>> didSet, called immediately after the new value is stored\n>>>> didChange, called immediately after the new value is stored if the new value is different to the previous value\n>>> \n>>> I’m open to consider a change along these lines, but the proposal would have to be fleshed out more.  Presumably it would only work for equatable types, right?  Also, can a property have these observers as well as the existing ones?  Would it be possible to add *one of* didChange or willChange - since less is better?\n>>> \n>>> -Chris\n>>> \n>>> \n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> \n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000549.html" , "inReplyTo" : "9D162271-E4B5-45D9-AEC5-60405A70C1EF@apple.com" , "date" : { "$date" : 1449401226000} , "subject" : "[swift-evolution] Proposal: Allow willChange and didChange observers on a property" , "references" : [ "A289D8DB-F4F0-43B6-9F05-C57B04478A4A@apple.com" , "9AC32EEA-ED5F-421E-9B75-E2BB0516667C@apple.com" , "CAA60hjLpFH3u_eQVQvOjZ+gvOa++VdALYUbSGiNCwKQcyO+QFA@mail.gmail.com" , "9D162271-E4B5-45D9-AEC5-60405A70C1EF@apple.com"] , "descendants" : [ "6B38C1F5-9623-4706-BC2A-F9A5F9665AB6@apple.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/A1E5FCF7-C4EF-4126-BB2A-C39028773A18@alexkolov.com"}} , "_id" : "A1E5FCF7-C4EF-4126-BB2A-C39028773A18@alexkolov.com" , "from" : "me at alexkolov.com (Alexander Kolov)" , "mailingList" : "swift-evolution" , "content" : "Thank you for the input, Chris!\n\nI'll do my best to kickstart this project with the spirit of the core library standards and distributive it with package manager. Then maybe we could revisit closer dependency at some later date.\n\nPS. If anyone is interested in participating, please feel free to contact me directly.\n\nAlex\n\nSent from my iPhone\n\n> On Dec 6, 2015, at 7:20 AM, Chris Lattner <clattner at apple.com> wrote:\n> \n> \n>> On Dec 5, 2015, at 11:24 AM, Alexander Kolov via swift-evolution <swift-evolution at swift.org> wrote:\n>> \n>> Hi everyone,\n>> \n>> Coming from a short discussion in swift-corelibs-dev, I’m investigating the need of a standard logging API as a part of core libraries.\n>> \n>> The motivation behind this would be having a unified and configurable set of APIs between all first-party modules and third party applications and libraries.\n>> I think this will help each of us since right now we’re inventing our own solutions as well many bigger third-party library providers have formats and facilities of their own.\n>> \n>> As I currently see it would be somewhat similar to python logging and possibly even structlog (http://www.structlog.org/en/stable/), with configurable formatters and handlers, including and not limited to remote loggers and syslog support.\n>> \n>> I’d love to hear your opinions and feedback on this and possibly start with some more formalized proposal and implementation if there’s enough support and need.\n> \n> Hi Alex,\n> \n> At this point, we’d prefer that major new features like these be explored and developed as independent projects outside the official Swift repos.  There are a *ton* of really interesting library features that we could add, but for now at least, we’re keeping the Swift standard library laser focused on its “language features + core data structures & algorithms” focus, and keeping the CoreLibs work focused on achieving parity with the Apple implementations of these libraries.\n> \n> We simply don’t have bandwidth to review and design higher level features at this time.  One of the goals of the Swift package manager is to make it super easy to reuse people’s code, even if it isn’t part of the swift distro.\n> \n> -Chris\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000550.html" , "inReplyTo" : "B13A0695-75A2-445C-858F-7D854C19C326@apple.com" , "date" : { "$date" : 1449402965000} , "subject" : "[swift-evolution] Proposal: standard logging facility" , "references" : [ "BD305678-84D8-49BF-AC25-8F3492044536@alexkolov.com" , "B13A0695-75A2-445C-858F-7D854C19C326@apple.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/etPan.56642314.20830c9b.1f6@mscience.fritz.box"}} , "_id" : "etPan.56642314.20830c9b.1f6@mscience.fritz.box" , "from" : "adrian.zubarev at devandartist.com (Adrian Zubarev)" , "mailingList" : "swift-evolution" , "content" : "I come across this topic and I instantly was overwhelmed by this idea of the Setup Closures. I build a little extension just to test it with UIKit. I thought adding this keyword for Setup Closures was a good idea. If we also could remove this in from the closure it would look good on my opinion.\n\nprotocol SettableType {\n     \n    init() // designated initializer\n}\n\nextension SettableType {\n     \n    init(@noescape setup: (this: Self) -> Void) {\n         \n        self.init()\n        setup(this: self)\n    }\n}\n\nextension UIView: SettableType {}\n\nlet view = UIView()\n\nlet questionLabel = UILabel() { this in /// <- REMOVE  \n     \n    this.textAlignment = .Center\n    this.font = UIFont(name:\"SomeFontName\", size: 72)\n    this.text = \"Hello World\"\n    this.numberOfLines = 0\n    view.addSubview(this)\n}\n\n— \nRegards Adrian\n\nAm 6. Dezember 2015 bei 01:16:31, ilya via swift-evolution (swift-evolution at swift.org) schrieb:\n\n> PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.  Here's one example: ...\n\nFWIW, I created a configuration operator more then a year ago, and use it in all of my Swift projects:\n\nlet task = NSTask() +=+ {\n    $0.launchPath = \"/usr/bin/mdfind\"\n    $0.arguments = [\"kMDItemDisplayName == *.playground\"]\n    $0.standardOutput = pipe\n}\n\nNote you can also use the configured object in the rhs:\n\nlet questionLabel = UILabel() +=+ {\n    $0.textAlignment = .Center\n    $0.font =  UIFont(name:\"DnealianManuscript\", size: 72)\n    $0.text = currentQuestion.questionText\n    $0.numberOfLines = 0\n    view.addSubview($0)\n}\n\nThis $0. certainly looks ugly and it would be great to be able to simplify this. I don't llike the following much though (dot-syntax can be ambiguos here, and using simply a method name is even worse):\n\nlet questionLabel = UILabel() +=+ {\n    .textAlignment = .Center\n    .font =  UIFont(name:\"DnealianManuscript\", size: 72)\n    .text = currentQuestion.questionText\n    .numberOfLines = 0\n    view.addSubview($0)\n}\n\nActually I would be happy with something like\n\nlet questionLabel = UILabel() .{\n    ..textAlignment = .Center\n    ..font = UIFont(name:\"DnealianManuscript\", size: 72)\n    ..text = currentQuestion.questionText\n    ..numberOfLines = 0\n    view.addSubview($0)\n}\n\nOther thoughts?\n\n  \n _______________________________________________\nswift-evolution mailing list\nswift-evolution at swift.org\nhttps://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000551.html" , "inReplyTo" : "CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com" , "date" : { "$date" : 1449403156000} , "subject" : "[swift-evolution]  Request for Discussion: Setup closures" , "references" : [ "CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com"] , "descendants" : [ "F77586E8-94BF-48F3-A379-0088A02C135D@gbis.com" , "CDAFBA7E-E9E9-443F-BB82-B76ACEBF54E6@web.de"]} , { "_links" : { "self" : { "href" : "/charter/emails/6BCA9015-28F4-4B1B-8AF5-84DFA9256949@icloud.com"}} , "_id" : "6BCA9015-28F4-4B1B-8AF5-84DFA9256949@icloud.com" , "from" : "loiclecrenier at icloud.com (=?utf-8?Q?Lo=C3=AFc_Lecrenier?=)" , "mailingList" : "swift-evolution" , "content" : "I have drafted a formal proposal here: https://gist.github.com/loiclec/22459d230a21dbcb81fc\nWould love to receive feedback from the community on it, I am particularly worried about the correctness of the terms I used.\nShould I make a pull request to swift-evolution now, or should we continue the conversation here?\n\nThanks, \n\nLoïc\n\n(and sorry about emailing you on Sunday 😇 ) \n\n> On Dec 6, 2015, at 1:48 AM, John McCall <rjmccall at apple.com> wrote:\n> \n>> On Dec 5, 2015, at 4:35 PM, Loïc Lecrenier via swift-evolution <swift-evolution at swift.org> wrote:\n>> Hi everyone :)\n>> \n>> I propose introducing a new \"associated_type\" keyword that will replace \"typealias\" for declaring associated types in protocols.\n>> I remember being confused by associated types when I started using Swift, and I think one reason why was the use of the typealias keyword to define them.\n>> One reason was that I thought I knew what typealias did, and so I didn't stop to learn what it did inside a protocol. An other reason was the difficulty of finding help when searching for \"typealias\" instead of \"associated types\".\n>> Then, when I thought I understood it, I started building an excessively protocol-oriented program as an exercise. And I still lost a lot of time fighting Swift by trying to use \"real\" typealias-es inside of protocols.\n>> \n>> Conceptually, I had something like this:\n>> \n>> protocol ProtA {\n>>  typealias Container : SequenceType\n>> }\n>> protocol ProtB {\n>>  typealias AnOtherAssocType : ProtA\n>>  func foo(x: AnOtherAssocType.Container.Generator.Element, y: AnOtherAssocType.Container.Generator.Element) -> AnOtherAssocType.Container.Generator.Element\n>> }\n>> \n>> The function foo is very difficult to read, so I wanted to use a shortcut to Element by doing this:\n>> \n>> protocol ProtB {\n>>  typealias A : ProtA\n>>  typealias Element = A.Container.Generator.Element\n>>  func foo(x: Element, y: Element) -> Element\n>> }\n>> \n>> But by doing so, I didn't create a shortcut to Element, but an associated type with a default value of Element. (right?)\n>> Then I tried to write extensions to ProtB where Element conforms to, say, Equatable, and couldn't make it work because A.Container.Generator.Element didn't conform to Equatable.\n>> \n>> So, that was a rather long explanation of the reasons I think we should replace the typealias keyword by associated_type, and allow \"real\" typealias-es inside protocols.\n> \n> I think this is a great idea; re-using typealias for associated types was a mistake.\n> \n> John.\n> \n>> \n>> Ideally, I would write\n>> \n>> protocol ProtB {\n>>  associated_type AnOtherAssocType : ProtA\n>>  typealias Element = AnOtherAssocType.Container.Generator.Element\n>>  func foo(x: Element, y: Element) -> Element\n>> }\n>> \n>> and it would be exactly the same as\n>> \n>> protocol ProtB {\n>>  associated_type AnOtherAssocType : ProtA\n>>  func foo(x: A.Container.Generator.Element, y: A.Container.Generator.Element) -> A.Container.Generator.Element\n>> }\n>> \n>> There are probably some problems created by this proposal, but right now I can't see any :/\n>> \n>> Thanks,\n>> \n>> Loïc\n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000552.html" , "inReplyTo" : "80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com" , "date" : { "$date" : 1449403964000} , "subject" : "[swift-evolution] Introduce \"associated_type\" keyword" , "references" : [ "C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com" , "80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com"] , "descendants" : [ "3A2C2956-0C24-4838-84C0-B171C8F39F6F@icloud.com" , "CAKCGC8Dr29Reis3NnK-MLE3MpswCC9fEU7=Eh3VTCOmj3TfAJw@mail.gmail.com" , "2FC53481-EF6F-4B06-92FB-283A65F000E3@icloud.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/F77586E8-94BF-48F3-A379-0088A02C135D@gbis.com"}} , "_id" : "F77586E8-94BF-48F3-A379-0088A02C135D@gbis.com" , "from" : "jhull at gbis.com (Jonathan Hull)" , "mailingList" : "swift-evolution" , "content" : "I often do the following:\n\nlet questionLabel:UILabel = {\n    let label = UILabel()\n    label.textAlignment = .Center\n    label.font = UIFont(name:\"DnealianManuscript\", size: 72)\n    label.text = currentQuestion.questionText\n    label.numberOfLines = 0\n    view.addSubview(label)\n    return label\n}()\n\n\n> On Dec 6, 2015, at 3:59 AM, Adrian Zubarev via swift-evolution <swift-evolution at swift.org> wrote:\n> \n>> let questionLabel = UILabel() .{\n>>     ..textAlignment = .Center\n>>     ..font = UIFont(name:\"DnealianManuscript\", size: 72)\n>>     ..text = currentQuestion.questionText\n>>     ..numberOfLines = 0\n>>     view.addSubview($0)\n>> }\n>> \n>> Other thoughts?" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000553.html" , "inReplyTo" : "etPan.56642314.20830c9b.1f6@mscience.fritz.box" , "date" : { "$date" : 1449404022000} , "subject" : "[swift-evolution] Request for Discussion: Setup closures" , "references" : [ "CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com" , "etPan.56642314.20830c9b.1f6@mscience.fritz.box"]} , { "_links" : { "self" : { "href" : "/charter/emails/57598505-6076-4C78-8D09-7F7C01B0D18B@web.de"}} , "_id" : "57598505-6076-4C78-8D09-7F7C01B0D18B@web.de" , "from" : "thorsten.seitz at web.de (Thorsten Seitz)" , "mailingList" : "swift-evolution" , "content" : "Hi all,\n\nI like the property delegates feature from Kotlin, too, but I don’t see how it can replace the „delayed let x : T“ idea with initialization taking place in e.g. awakeFromNib, because a let-property cannot be set. With a var it would probably look roughly like follows, but with „let x : T by Delayed()“ the setValue method would not be allowed (at least in Kotlin):\n\nvar x : T by Delayed()\n\nwith\n\nclass Delayed<T> {\n\tvar value : T!\n\tfunc getValue(this: Any?, property: Property<T>) -> T { return value }\n\tfunc setValue(this: Any?, property: Property<T>, value: T) {\n\t\tguard x == nil else { abort(„Property \\(property) of \\(this) has already been initialized when trying to initialize with value \\(value)“) }\n\t\tself.value = value\n\t}\n}\n\nSome remarks\n* I chose abort() in this particular case instead of throwing because repeated initialization should be a logical error\n* Are there uses cases where throwing would be the right thing in getValue or setValue? I guess not, just like throwing is not possible in a computed property.\n* Is the compiler able to optimize away the overhead of going through getValue on each access?\n* I was a bit surprised that Kotlin does not require an interface for the delegates to implement. I would expect delegates to be required to implement appropriate interfaces (or protocols) like PropertyReader/PropertyAccessor, probably with a type parameter for the property owner as well (instead of Any?). The latter would allow \n\n-Thorsten\n\n> Am 06.12.2015 um 11:00 schrieb David Hart via swift-evolution <swift-evolution at swift.org>:\n> \n> This property delegates feature from Kotlin sounds fantastic! As the examples in Kotlin show, it could bring a very powerful solution to many problems in Swift right now: lazy being narrow, cache missing, native KVO :D\n> \n> This has just become my #1 feature proposal!\n> \n> Super excited David!\n> \n>> On 06 Dec 2015, at 08:27, Chris Lattner <clattner at apple.com> wrote:\n>> \n>> \n>>> On Dec 4, 2015, at 5:40 AM, David Hart <david at hartbit.com> wrote:\n>>> \n>>> In Objective-C, I often used the lazy initialization pattern to implement a cache for expensive operations. For exemple, here is an often used scenario in a project where objects behind foreign keys in a database ORM are only fetched when necessary:\n>>> \n>>> When thinking about it, I came to the conclusion that the use cases of lazy seem very narrow compared to how useful the lazy initialization pattern was in Objective-C.\n>>> I want your opinion on three alternatives:\n>>> \n>>> 1- Do nothing, and use the slightly uglier Swift example when using a cache.\n>>> 2- Modify lazy semantics to re-calculates when nil (I think this is the worst solution).\n>>> 3- Add a cache modifier that re-calcualtes when nil.\n>> \n>> Hi David,\n>> \n>> My preference is:\n>> 4) Kick lazy out of the compiler and make it a standard library feature instead, allowing it to be extended in lots of ways.\n>> \n>> The existing lazy behavior was added as a very narrow solution to a common scenario that would otherwise required optional machinations everywhere.  It succeeded in that goal, but it is super narrow, and the implementation has a number of bugs (e.g. you can’t have a lazy local variable).\n>> \n>> In terms of its narrowness, it has the limitations you describe, but it also doesn’t solve other common problems.  For example, many people complain about properties that are initialized only in a second phase of initialization (e.g. awakeFromNib) and right now, most folks resort to using typing their properties as ImplicitlyUnwrappedOptional to avoid using ! at every use site.  A natural solution to that is to introduce a concept of a “delayed var x : T” which does not need initialization in init(), and runtime traps if it is read before initialized.  This provides similar semantics to T!, but without infecting the type system.  Better than T!, a “delayed let x : T” would allow exactly one runtime initialization of the property.\n>> \n>> The problem with this line of thinking is that - if we kept going down this path - we’d end up adding a ton of very narrow solutions for specific problems, adding language complexity all the way.  This is pretty dissatisfying for a number of reasons. :-)\n>> \n>> A different approach is to introduce a single language feature that would allow you to define customization behavior for properties in a library, which would be a general solution to these sorts of issues.  Joe Groff is working on a proposal to do just this, similar to the idea of Kotlin property delegates (https://kotlinlang.org/docs/reference/delegated-properties.html).\n>> \n>> We’ve been a bit busy lately :-) but I’m hoping that he’ll send this proposal out in the next few weeks.  Assuming that proposal works out, I expect lazy to get ripped out of the language, and *that* discussion can reopen detailed debate about what the replacement should look like.\n>> \n>> -Chris\n>> \n>> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000554.html" , "inReplyTo" : "99C3AE06-9BA8-4F46-B67A-88AB0D8A3748@hartbit.com" , "date" : { "$date" : 1449405154000} , "subject" : "[swift-evolution] lazy keyword vs lazy initialization pattern" , "references" : [ "C9BBB9E4-F2E9-4514-926F-8669DC731128@hartbit.com" , "C7B2EEB8-0B36-4930-B011-034548511656@apple.com" , "99C3AE06-9BA8-4F46-B67A-88AB0D8A3748@hartbit.com"] , "descendants" : [ "546CDC6C-6D6E-41F6-B506-77C617575DAF@apple.com" , "543A1A03-A23B-42D1-96DA-DC7C3F81E49A@anandabits.com" , "87303129-BC13-487E-908D-7D2CC498CDF0@web.de"]} , { "_links" : { "self" : { "href" : "/charter/emails/E3A71685-F75F-46A5-8A35-3ACF38B1C791@anandabits.com"}} , "_id" : "E3A71685-F75F-46A5-8A35-3ACF38B1C791@anandabits.com" , "from" : "matthew at anandabits.com (Matthew Johnson)" , "mailingList" : "swift-evolution" , "content" : "Great to hear Chris and thanks for mentioning generic subscripts as well.  I have a use case for a generic throwing subscript so I hope patches will be forthcoming.\n\nSent from my iPad\n\n> On Dec 6, 2015, at 12:07 AM, Chris Lattner <clattner at apple.com> wrote:\n> \n> \n>>> On Dec 5, 2015, at 9:08 PM, Nikolai Vazquez via swift-evolution <swift-evolution at swift.org> wrote:\n>>> \n>>> One of the aspects of Swift that I like is computed properties for structures and classes. It allows for adding logic when obtaining values or for having the returned value be \n>> On Dec 5, 2015, at 7:17 PM, Matthew Johnson via swift-evolution <swift-evolution at swift.org> wrote:\n>> \n>> +1 to this.  Subscripts should also be able to throw and currently cannot.\n> \n> +1 from me as well.  Subscripts also currently cannot be generic.\n> \n> I consider all of these implementation limitations, not intentional parts of the design of Swift.  Patches would be very very welcome to help improve these areas.\n> \n> -Chris\n> \n> \n>> \n>> dependent on another.\n>>> \n>>> As of the `ErrorType` protocol introduction in Swift 2, we can throw errors when it comes to functions and initializers. However, this does not apply to getters and setters.\n>>> \n>>> ```swift\n>>> struct File<Data> {\n>>>     var contents: Data {\n>>>         get throws { ... }\n>>>         set throws { ... }\n>>>     }\n>>> }\n>>> ```\n>>> \n>>> A better example would be getting and setting the current working directory of the process:\n>>> \n>>> ```swift\n>>> import Foundation\n>>> \n>>> extension Process {\n>>>     static var workingDirectory: String {\n>>>         get {\n>>>             let fileManager = NSFileManager.defaultManager()\n>>>             return fileManager.currentDirectoryPath\n>>>         }\n>>>         set throws {\n>>>             let fileManager = NSFileManager.defaultManager()\n>>>             guard fileManager.changeCurrentDirectoryPath(newValue) else {\n>>>                 throw Error(\"...\")\n>>>             }\n>>>         }\n>>>     }\n>>> }\n>>> \n>>> \n>>> \n>>> ```\n>>> \n>>> \n>>>  _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>> \n>>  _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000555.html" , "inReplyTo" : "E205F705-1A64-4F4E-B838-EF81DEC56554@apple.com" , "date" : { "$date" : 1449407712000} , "subject" : "[swift-evolution] Proposal: Allow Getters and Setters to Throw" , "references" : [ "CANhuES0ZoHNV5YXzS2UyUcqE=quzBXz7bHBrpNA=do-_LVNLOg@mail.gmail.com" , "DB6756E4-1448-4517-88B2-06FF1578D440@anandabits.com" , "E205F705-1A64-4F4E-B838-EF81DEC56554@apple.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/19FBB566-3CF3-4CB3-9658-751071B88288@portablesoftware.com"}} , "_id" : "19FBB566-3CF3-4CB3-9658-751071B88288@portablesoftware.com" , "from" : "don.wills at portablesoftware.com (Don Wills)" , "mailingList" : "swift-evolution" , "content" : "The ability to overload operators is very useful.  However, that utility is diminished without the ability to overload the simple assignment operator ( = ).  I vaguely recall reading somewhere that there is a reason for this having to do with syntax ambiguity.  Can this problem be solved so that = can be overloaded?\n\nDon Wills" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000556.html" , "date" : { "$date" : 1449409479000} , "subject" : "[swift-evolution] Overloading assignment operator" , "references" : [ ""] , "inReplyTo" :  null  , "descendants" : [ "CAPh90aGVow3HRQD2zs7mZuFoZ3fxd2t4469nKrwXSS5FGzwiOw@mail.gmail.com" , "D7E083F4-C1EB-4A38-B9D1-B1FD0C0D4ABA@portablesoftware.com" , "9DA4B94C-40DB-4251-91B7-0812FEB6448E@apple.com" , "D91A1DC9-2BC7-4862-B6BD-69AF1E702D97@apple.com" , "C6EBE20F-AE01-4593-96B0-33F539F931FA@anandabits.com" , "D37A244A-8E82-42F4-A780-A28713E3D990@portablesoftware.com" , "CAN9tzpCDdNmmn8kG89FhxnnDsFiMp-M7FAEUoqdO8pHs7smLJA@mail.gmail.com" , "93AC01C7-172B-41F8-B27E-803887706B87@portablesoftware.com" , "CAKCGC8DSRhWKkJ8qD_zWzxO=vj-OiZibG-XPSnte8OJhNR37kQ@mail.gmail.com" , "DB00FFEF-B61E-4294-9891-8A64B2584289@gmail.com" , "26787AE6-26C4-47D7-8529-043233D4A383@portablesoftware.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CDAFBA7E-E9E9-443F-BB82-B76ACEBF54E6@web.de"}} , "_id" : "CDAFBA7E-E9E9-443F-BB82-B76ACEBF54E6@web.de" , "from" : "thorsten.seitz at web.de (Thorsten Seitz)" , "mailingList" : "swift-evolution" , "content" : "Nice!\nActually I don’t mind the argument of the closure at all and would probably just name it after the class, i.e. „label“ in the example:\n\nlet questionLabel = UILabel() { label in\n     \n    label.textAlignment = .Center\n    label.font = UIFont(name:\"SomeFontName\", size: 72)\n    label.text = \"Hello World\"\n    label.numberOfLines = 0\n    view.addSubview(label)\n}\n\n-Thorsten\n\n\n\n> Am 06.12.2015 um 12:59 schrieb Adrian Zubarev via swift-evolution <swift-evolution at swift.org>:\n> \n> let questionLabel = UILabel() { this in /// <- REMOVE  \n>      \n>     this.textAlignment = .Center\n>     this.font = UIFont(name:\"SomeFontName\", size: 72)\n>     this.text = \"Hello World\"\n>     this.numberOfLines = 0\n>     view.addSubview(this)\n> }" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000557.html" , "inReplyTo" : "etPan.56642314.20830c9b.1f6@mscience.fritz.box" , "date" : { "$date" : 1449409643000} , "subject" : "[swift-evolution] Request for Discussion: Setup closures" , "references" : [ "CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com" , "etPan.56642314.20830c9b.1f6@mscience.fritz.box"]} , { "_links" : { "self" : { "href" : "/charter/emails/FE7A4F85-6EAD-42D4-8781-19F38941A70D@web.de"}} , "_id" : "FE7A4F85-6EAD-42D4-8781-19F38941A70D@web.de" , "from" : "thorsten.seitz at web.de (Thorsten Seitz)" , "mailingList" : "swift-evolution" , "content" : "Why not just „type“?\n\nprotocol Foo {\n    type T\n}\n\n-Thorsten\n\n\n\n> Am 06.12.2015 um 02:46 schrieb Austin Zheng via swift-evolution <swift-evolution at swift.org>:\n> \n> I like \"associated\". Or maybe \"withtype\". Anything clear and without underscore.\n> \n> protocol Foo {\n>   associated T\n> }\n> \n> protocol Foo {\n>  withtype T\n> }\n> \n>> On Dec 5, 2015, at 5:43 PM, Stephen Celis via swift-evolution <swift-evolution at swift.org> wrote:\n>> \n>>> On Dec 5, 2015, at 8:11 PM, Kevin Lundberg via swift-evolution <swift-evolution at swift.org> wrote:\n>>> \n>>> If we must keep this concept, I would prefer something without an underscore for the keyword, like \"associatedtype\" or perhaps \"typeassociation\"\n>> \n>> Or merely \"associated\".\n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000558.html" , "inReplyTo" : "554F869D-D9A3-4672-B0BA-3153B644C65B@gmail.com" , "date" : { "$date" : 1449409896000} , "subject" : "[swift-evolution] Introduce \"associated_type\" keyword" , "references" : [ "C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com" , "80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com" , "BD192734-066B-4907-887C-0286D799CBE1@klundberg.com" , "6407A281-C936-40E3-B882-1E63279F4755@gmail.com" , "554F869D-D9A3-4672-B0BA-3153B644C65B@gmail.com"] , "descendants" : [ "9D8DFC81-ECB0-490A-82B0-3E3D01BF35A1@gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/58D3CFFF-EB66-4F96-88CE-1B2FC30F1DAF@me.com"}} , "_id" : "58D3CFFF-EB66-4F96-88CE-1B2FC30F1DAF@me.com" , "from" : "a.michail at me.com (Amir Michail)" , "mailingList" : "swift-evolution" , "content" : "With Swift, the programming language is no longer a difficult part of iOS programming. That difficulty now shifts to the iOS frameworks. Although very powerful, these frameworks take time to learn.\n\nSo why not allow iOS developers to easily and automatically share small code fragments with each other and have the compiler automatically use them to provide warnings as to how to code various tasks better?\n\nRecommended rewrites by the compiler would only involve small code fragments seen from multiple independent sources and so are unlikely to contain any sensitive code." , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000559.html" , "date" : { "$date" : 1449411360000} , "subject" : "[swift-evolution] Swift support for automatically sharing small code fragments with other iOS developers." , "references" : [ ""] , "inReplyTo" :  null  , "descendants" : [ "E0E41589-90D2-494D-84D0-D94CCE5A43A3@maven.de" , "FE19364D-CD51-4B20-BF08-681BB7C529FB@me.com" , "CAGUyf_EZrnon5Q6AnZyJRqzw=sG2NvM9vhUyymvtMBqHsMOfsw@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/D14076A5-FF22-4708-BFB2-516699EC4520@web.de"}} , "_id" : "D14076A5-FF22-4708-BFB2-516699EC4520@web.de" , "from" : "thorsten.seitz at web.de (Thorsten Seitz)" , "mailingList" : "swift-evolution" , "content" : "Wouldn’t it be possible to still have if-statements?\n\nWhen used as expression an if-expression would of course require an else-part, but when used as statement we would still have an if-statement (not an if-expression) and the else-part would be optional just like now.\n\n-Thorsten\n\n> Am 06.12.2015 um 00:12 schrieb Ole Begemann via swift-evolution <swift-evolution at swift.org>:\n> \n>>> This is subtle and requires thought\n>> \n>> What do you envision as the pitfalls of the design thinking behind if/switch expressions? I’m not a compiler programmer, but a prog-lang enthusiast. I wouldn’t mind a little nudge in the right direction.\n> \n> One thing that comes to mind is that if \"if\" is an expression, every if needs an else branch. This makes it harder to use if to conditionally perform side effects. For example, this is currently valid:\n> \n> func doSomething() { ... }\n> \n> if condition {\n>    doSomething()\n> }\n> \n> Should this be allowed? You could argue that this should work because (a) the expression result is unused and (b) the return type of doSomething is Void, so the compiler could conceivably implicitly construct an else branch that returns (). But it would be inconsistent with other expressions. Disallowing this style could make writing typical \"imperative\" code harder.\n> \n> – Ole\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000560.html" , "inReplyTo" : "909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net" , "date" : { "$date" : 1449411726000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com" , "CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com" , "C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com" , "18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com" , "2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io" , "BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com" , "CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com" , "CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com" , "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com" , "BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com" , "909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net"]} , { "_links" : { "self" : { "href" : "/charter/emails/7BDB9D9E-C327-4904-AC6F-D430D98A9EAC@icloud.com"}} , "_id" : "7BDB9D9E-C327-4904-AC6F-D430D98A9EAC@icloud.com" , "from" : "zarzycki at icloud.com (David Zarzycki)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 6, 2015, at 00:04, Chris Lattner <clattner at apple.com> wrote:\n> \n> \n>> On Dec 5, 2015, at 11:26 AM, David Zarzycki <zarzycki at icloud.com> wrote:\n>> \n>> Hi Chris,\n>> \n>> An observation about SE-0004: Remove the ++ and — operators:\n>> \n>> Given that the above is accepted, the only remaining postfix operator in the language is ‘!’ — and that is implemented by the compiler. Please consider just removing user-defined postfix operators entirely.\n> \n> Hi Dave!\n> \n> That is definitely an interesting idea.  In practice, we won’t be able to remove ++/— from the compiler until the ~Spring 2017 release, since Swift 3 will want to parse the old code and reject it with a fixit hint. \n> \n>> Doing so would define away a type checking ambiguity where “let f = T -> T = someOperatorIdentifier” is ambiguous when both prefix and postfix operators exist.\n> \n> Besides the general simplification potential for the language, is this a theoretical concern or an actual one?  You can currently do something like “let f = T->T = {$0^}” or “{^$0}” to disambiguate the prefix/postfix forms.\n\nIt is just simplification that opens the door to further simplicity and self-consistency within the language. In addition to not needing the above workaround, one could remove the fixity keywords/attributes altogether, because they’d be inferable from context.\n\nIf one wants to go deep down the rabbit hole, one could let developers avoid nested parenthesis and the “spiral call syntax problem” by allowing the language to use the same unary operator in either prefix or postfix positions. For example, instead of “(^(-(~x).a).b).c”, one could write “x~.a-.b^.c” to accomplish the same goal.\n\nDave" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000561.html" , "inReplyTo" : "F9C56B7C-34E8-40A8-B232-1FA9CC0C1FB6@apple.com" , "date" : { "$date" : 1449411769000} , "subject" : "[swift-evolution] Feedback for SE-0004: Remove the ++ and -- operators" , "references" : [ "A7E9633F-7227-47A7-BE95-68F839D76549@icloud.com" , "F9C56B7C-34E8-40A8-B232-1FA9CC0C1FB6@apple.com"] , "descendants" : [ "7C63AD72-C9A4-4794-9F1F-7D978357F5C5@apple.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/E0E41589-90D2-494D-84D0-D94CCE5A43A3@maven.de"}} , "_id" : "E0E41589-90D2-494D-84D0-D94CCE5A43A3@maven.de" , "from" : "lists at maven.de (Daniel Vollmer)" , "mailingList" : "swift-evolution" , "content" : "Hi Amir,\n\n> So why not allow iOS developers to easily and automatically share small code fragments with each other and have the compiler automatically use them to provide warnings as to how to code various tasks better?\n\nAs I understand it, this is very much out of scope for *this* project. Swift aims to (eventually) be a general purpose programming language.\n\nWhat you’re talking about is more relevant to an IDE or development aid for a specific narrowed purpose. You might be better off filing a radar against Xcode for example.\n\n\tDaniel." , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000562.html" , "inReplyTo" : "58D3CFFF-EB66-4F96-88CE-1B2FC30F1DAF@me.com" , "date" : { "$date" : 1449411819000} , "subject" : "[swift-evolution] Swift support for automatically sharing small code fragments with other iOS developers." , "references" : [ "58D3CFFF-EB66-4F96-88CE-1B2FC30F1DAF@me.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/1FDCAD5A-9937-4464-BD6A-ABECAE2BB853@web.de"}} , "_id" : "1FDCAD5A-9937-4464-BD6A-ABECAE2BB853@web.de" , "from" : "thorsten.seitz at web.de (Thorsten Seitz)" , "mailingList" : "swift-evolution" , "content" : "I’d prefer if-expressions to have the same form as if-statements, i.e.\n\nlet greeting = if let name = optionalName { \"Hello, \\(name),“ } else { “To Whom It May Concern:” }\n\n-Thorsten\n\n\nPS: As an aside this could also be written without an if-expression as follows:\n\nlet greeting = name.map(„Hello, \\($0),“) ?? “To Whom It May Concern:”\n\n\nWith regards to the question about the required else part: \n> Am 06.12.2015 um 01:12 schrieb Alex Lew via swift-evolution <swift-evolution at swift.org>:\n> \n> let greeting = “Hello, \\(name),” if let name = optionalName else “To Whom It May Concern:”\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000563.html" , "inReplyTo" : "CAKCGC8ACsCsX1VvEpStXFOD10gw308+RqVe01VxkUh0q5j_9tA@mail.gmail.com" , "date" : { "$date" : 1449411922000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com" , "CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com" , "C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com" , "18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com" , "2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io" , "BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com" , "CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com" , "CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com" , "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com" , "852EF944-A503-4021-8A7F-AE6876438981@gbis.com" , "CAKCGC8ACsCsX1VvEpStXFOD10gw308+RqVe01VxkUh0q5j_9tA@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/93AC01C7-172B-41F8-B27E-803887706B87@portablesoftware.com"}} , "_id" : "93AC01C7-172B-41F8-B27E-803887706B87@portablesoftware.com" , "from" : "don.wills at portablesoftware.com (Don Wills)" , "mailingList" : "swift-evolution" , "content" : "Silvan,\n\nYes, I understand the concern you raise.  I too have held that general opinion of overloading operators in other languages for many years.  That said, overloading arithmetic and other operators causes the same opportunity for abuse.  For example, overloading + for integers to do something different (like rounding instead of truncation) would make maintenance of existing programs into a giant guessing game.\n\nThat said, once the cat is out of the bag to overload operators, I don't see how adding support for = makes things any worse.\n\nFYI, the reason for my suggestion is to add support for fixed decimal arithmetic just like that available in COBOL.  Yeh I can hear the groans now.  However, for business applications, fixed decimal arithmetic is a basic feature that has been tossed away in new languages by language designers who don't actually labor in the trenches.  I've built a simple class to do just that - here is some sample code that uses my Number class that gives an idea of what the code does:\n\nvar amount = Number(left: 6, right: 2);\nvar result = Number(left: 9, right: 2);\namount <- 3.9;\namount += 1;\nresult <- amount * 4;\nprint(result)\n\nNote that <- is the assignment operator.  I am sure all would agree that = is superior in this situation.  Such code would be far more readable and the Number values would act just like and interoperate with Float and Int in all regards *except* that currently the = operator is not available for assignment.\n\nDon Wills\n\nPS.  FWIW, the  IEEE 754-2008 d128 alternative that Chris Lattner mentioned to me is inferior to the kind of support for fixed decimal arithmetic that I believe would help make Swift superior to C# for business applications.\n\n\n> On Dec 6, 2015, at 6:58 AM, Silvan Mosberger <kametrixom at icloud.com> wrote:\n> \n> Hi Don\n> \n> I think this is a terrible idea! Imagine what you’d be able to do with that:\n> \n> let x : String = 3\n> \n> This would lead to the same problems already discussed with implicit initialisers: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000531.html <https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000531.html>, just worse. Also assignment is something more fundamental than other operators, I doubt it’s even possible to do that.\n> \n>> On 06 Dec 2015, at 14:44, Don Wills via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>> \n>> The ability to overload operators is very useful.  However, that utility is diminished without the ability to overload the simple assignment operator ( = ).  I vaguely recall reading somewhere that there is a reason for this having to do with syntax ambiguity.  Can this problem be solved so that = can be overloaded?\n>> \n>> Don Wills\n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000564.html" , "inReplyTo" : "D022E424-6A10-4F16-A11C-41B3DF9485A8@icloud.com" , "date" : { "$date" : 1449412015000} , "subject" : "[swift-evolution] Overloading assignment operator" , "references" : [ "19FBB566-3CF3-4CB3-9658-751071B88288@portablesoftware.com" , "D022E424-6A10-4F16-A11C-41B3DF9485A8@icloud.com"] , "descendants" : [ "CAPh90aGVow3HRQD2zs7mZuFoZ3fxd2t4469nKrwXSS5FGzwiOw@mail.gmail.com" , "D37A244A-8E82-42F4-A780-A28713E3D990@portablesoftware.com" , "CAN9tzpCDdNmmn8kG89FhxnnDsFiMp-M7FAEUoqdO8pHs7smLJA@mail.gmail.com" , "CAKCGC8DSRhWKkJ8qD_zWzxO=vj-OiZibG-XPSnte8OJhNR37kQ@mail.gmail.com" , "DB00FFEF-B61E-4294-9891-8A64B2584289@gmail.com" , "26787AE6-26C4-47D7-8529-043233D4A383@portablesoftware.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAGUyf_EZrnon5Q6AnZyJRqzw=sG2NvM9vhUyymvtMBqHsMOfsw@mail.gmail.com"}} , "_id" : "CAGUyf_EZrnon5Q6AnZyJRqzw=sG2NvM9vhUyymvtMBqHsMOfsw@mail.gmail.com" , "from" : "thisisroshansmail at gmail.com (Roshan)" , "mailingList" : "swift-evolution" , "content" : "Correct me if I am wrong, but what you want is to share code fragments from\na given codebase which wouldn't compile on their own(say, because they\ndepend on parts of the codebase you don't want to share) but do contain\ncompiler annotations as if they were compiled as part of the original\ncodebase.\n\nTo me this looks like more of a development tool thing than a language\nthing.\n\nOn Sun, Dec 6, 2015 at 7:56 PM, Roshan <thisisroshansmail at gmail.com> wrote:\n\n> Correct me if I am wrong, but what you want is to share code fragments\n> from a given codebase which wouldn't compile on their own(say, because they\n> depend on parts of the codebase you don't want to share) but do contain\n> compiler annotations as if they were compiled as part of the original\n> codebase.\n>\n> To me this looks like more of a development tool thing than a language\n> thing.\n>\n> On Sun, Dec 6, 2015 at 7:46 PM, Amir Michail via swift-evolution <\n> swift-evolution at swift.org> wrote:\n>\n>> With Swift, the programming language is no longer a difficult part of iOS\n>> programming. That difficulty now shifts to the iOS frameworks. Although\n>> very powerful, these frameworks take time to learn.\n>>\n>> So why not allow iOS developers to easily and automatically share small\n>> code fragments with each other and have the compiler automatically use them\n>> to provide warnings as to how to code various tasks better?\n>>\n>> Recommended rewrites by the compiler would only involve small code\n>> fragments seen from multiple independent sources and so are unlikely to\n>> contain any sensitive code.\n>>\n>>\n>>\n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>\n>\n>\n>\n> --\n> Warm regards\n> Roshan\n>\n\n\n\n-- \nWarm regards\nRoshan" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000565.html" , "inReplyTo" : "CAGUyf_Huv+ZFwgOUEJ0xMGY_J66NGyWLJW_TvJyqm43dY3fnWQ@mail.gmail.com" , "date" : { "$date" : 1449412155000} , "subject" : "[swift-evolution] Swift support for automatically sharing small code fragments with other iOS developers." , "references" : [ "58D3CFFF-EB66-4F96-88CE-1B2FC30F1DAF@me.com" , "CAGUyf_Huv+ZFwgOUEJ0xMGY_J66NGyWLJW_TvJyqm43dY3fnWQ@mail.gmail.com"] , "descendants" : [ "FE19364D-CD51-4B20-BF08-681BB7C529FB@me.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/FE19364D-CD51-4B20-BF08-681BB7C529FB@me.com"}} , "_id" : "FE19364D-CD51-4B20-BF08-681BB7C529FB@me.com" , "from" : "a.michail at me.com (Amir Michail)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 6, 2015, at 9:29 AM, Roshan <thisisroshansmail at gmail.com> wrote:\n> \n> Correct me if I am wrong, but what you want is to share code fragments from a given codebase which wouldn't compile on their own(say, because they depend on parts of the codebase you don't want to share) but do contain compiler annotations as if they were compiled as part of the original codebase.\n> \n> To me this looks like more of a development tool thing than a language thing.\n\nI think the lines between languages, their frameworks, and their tools can be arbitrary sometimes.\n\nIn any case, making automatic code fragment sharing part of the language would result in a lot more sharing.\n\n> \n> On Sun, Dec 6, 2015 at 7:56 PM, Roshan <thisisroshansmail at gmail.com <mailto:thisisroshansmail at gmail.com>> wrote:\n> Correct me if I am wrong, but what you want is to share code fragments from a given codebase which wouldn't compile on their own(say, because they depend on parts of the codebase you don't want to share) but do contain compiler annotations as if they were compiled as part of the original codebase.\n> \n> To me this looks like more of a development tool thing than a language thing.\n> \n> On Sun, Dec 6, 2015 at 7:46 PM, Amir Michail via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n> With Swift, the programming language is no longer a difficult part of iOS programming. That difficulty now shifts to the iOS frameworks. Although very powerful, these frameworks take time to learn.\n> \n> So why not allow iOS developers to easily and automatically share small code fragments with each other and have the compiler automatically use them to provide warnings as to how to code various tasks better?\n> \n> Recommended rewrites by the compiler would only involve small code fragments seen from multiple independent sources and so are unlikely to contain any sensitive code.\n> \n> \n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n> \n> \n> \n> -- \n> Warm regards\n> Roshan\n> \n> \n> \n> -- \n> Warm regards\n> Roshan" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000566.html" , "inReplyTo" : "CAGUyf_EZrnon5Q6AnZyJRqzw=sG2NvM9vhUyymvtMBqHsMOfsw@mail.gmail.com" , "date" : { "$date" : 1449412360000} , "subject" : "[swift-evolution] Swift support for automatically sharing small code fragments with other iOS developers." , "references" : [ "58D3CFFF-EB66-4F96-88CE-1B2FC30F1DAF@me.com" , "CAGUyf_Huv+ZFwgOUEJ0xMGY_J66NGyWLJW_TvJyqm43dY3fnWQ@mail.gmail.com" , "CAGUyf_EZrnon5Q6AnZyJRqzw=sG2NvM9vhUyymvtMBqHsMOfsw@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/543A1A03-A23B-42D1-96DA-DC7C3F81E49A@anandabits.com"}} , "_id" : "543A1A03-A23B-42D1-96DA-DC7C3F81E49A@anandabits.com" , "from" : "matthew at anandabits.com (Matthew Johnson)" , "mailingList" : "swift-evolution" , "content" : "Property delegates do look very nice, but I also wonder whether they would cover the `delayed let x : T` case.  They also don’t know *when* the property is getting set.\n\nI would really like to see something like `delayed let x : T` to handle the second phase of initialization problem, although I would add the requirement that it *must* be initialized in the second phase and it *cannot* be read until it is set (as far as the compiler can detect this through control flow analysis).  This would behave quite similarly to a simple `let x : T` member but with the caveat that it is possible to blow up if you attempt to read before setting it in the second phase and the compiler cannot detect the read attempt when performing control flow analysis.  \n\nIf Swift’s property delegates were able to both support let members and require initialization during the second phase (so the instance is guaranteed to be fully initialized and work correctly after initialization completes) then they would be a great solution.  I just can’t imagine how they could enforce this semantic.  I’m looking forward to reading Joe’s proposal and will be delighted if his design is able to support the desired semantics.\n\nChris, do you agree that this semantic is desirable to support one way or another?  \n\nThorsten’s attempt to implement something like this using a property delegate looks really dangerous to me.  A var member that blows up when somebody attempts to set it a second time seems extremely fragile.  It’s like an IUO but rather than blowing up when read it also blows up when set more than once.\n\nMatthew\n\n\n> On Dec 6, 2015, at 6:32 AM, Thorsten Seitz via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> Hi all,\n> \n> I like the property delegates feature from Kotlin, too, but I don’t see how it can replace the „delayed let x : T“ idea with initialization taking place in e.g. awakeFromNib, because a let-property cannot be set. With a var it would probably look roughly like follows, but with „let x : T by Delayed()“ the setValue method would not be allowed (at least in Kotlin):\n> \n> var x : T by Delayed()\n> \n> with\n> \n> class Delayed<T> {\n> \tvar value : T!\n> \tfunc getValue(this: Any?, property: Property<T>) -> T { return value }\n> \tfunc setValue(this: Any?, property: Property<T>, value: T) {\n> \t\tguard x == nil else { abort(„Property \\(property) of \\(this) has already been initialized when trying to initialize with value \\(value)“) }\n> \t\tself.value = value\n> \t}\n> }\n> \n> Some remarks\n> * I chose abort() in this particular case instead of throwing because repeated initialization should be a logical error\n> * Are there uses cases where throwing would be the right thing in getValue or setValue? I guess not, just like throwing is not possible in a computed property.\n> * Is the compiler able to optimize away the overhead of going through getValue on each access?\n> * I was a bit surprised that Kotlin does not require an interface for the delegates to implement. I would expect delegates to be required to implement appropriate interfaces (or protocols) like PropertyReader/PropertyAccessor, probably with a type parameter for the property owner as well (instead of Any?). The latter would allow \n> \n> -Thorsten\n> \n>> Am 06.12.2015 um 11:00 schrieb David Hart via swift-evolution <swift-evolution at swift.org>:\n>> \n>> This property delegates feature from Kotlin sounds fantastic! As the examples in Kotlin show, it could bring a very powerful solution to many problems in Swift right now: lazy being narrow, cache missing, native KVO :D\n>> \n>> This has just become my #1 feature proposal!\n>> \n>> Super excited David!\n>> \n>>> On 06 Dec 2015, at 08:27, Chris Lattner <clattner at apple.com> wrote:\n>>> \n>>> \n>>>> On Dec 4, 2015, at 5:40 AM, David Hart <david at hartbit.com> wrote:\n>>>> \n>>>> In Objective-C, I often used the lazy initialization pattern to implement a cache for expensive operations. For exemple, here is an often used scenario in a project where objects behind foreign keys in a database ORM are only fetched when necessary:\n>>>> \n>>>> When thinking about it, I came to the conclusion that the use cases of lazy seem very narrow compared to how useful the lazy initialization pattern was in Objective-C.\n>>>> I want your opinion on three alternatives:\n>>>> \n>>>> 1- Do nothing, and use the slightly uglier Swift example when using a cache.\n>>>> 2- Modify lazy semantics to re-calculates when nil (I think this is the worst solution).\n>>>> 3- Add a cache modifier that re-calcualtes when nil.\n>>> \n>>> Hi David,\n>>> \n>>> My preference is:\n>>> 4) Kick lazy out of the compiler and make it a standard library feature instead, allowing it to be extended in lots of ways.\n>>> \n>>> The existing lazy behavior was added as a very narrow solution to a common scenario that would otherwise required optional machinations everywhere.  It succeeded in that goal, but it is super narrow, and the implementation has a number of bugs (e.g. you can’t have a lazy local variable).\n>>> \n>>> In terms of its narrowness, it has the limitations you describe, but it also doesn’t solve other common problems.  For example, many people complain about properties that are initialized only in a second phase of initialization (e.g. awakeFromNib) and right now, most folks resort to using typing their properties as ImplicitlyUnwrappedOptional to avoid using ! at every use site.  A natural solution to that is to introduce a concept of a “delayed var x : T” which does not need initialization in init(), and runtime traps if it is read before initialized.  This provides similar semantics to T!, but without infecting the type system.  Better than T!, a “delayed let x : T” would allow exactly one runtime initialization of the property.\n>>> \n>>> The problem with this line of thinking is that - if we kept going down this path - we’d end up adding a ton of very narrow solutions for specific problems, adding language complexity all the way.  This is pretty dissatisfying for a number of reasons. :-)\n>>> \n>>> A different approach is to introduce a single language feature that would allow you to define customization behavior for properties in a library, which would be a general solution to these sorts of issues.  Joe Groff is working on a proposal to do just this, similar to the idea of Kotlin property delegates (https://kotlinlang.org/docs/reference/delegated-properties.html).\n>>> \n>>> We’ve been a bit busy lately :-) but I’m hoping that he’ll send this proposal out in the next few weeks.  Assuming that proposal works out, I expect lazy to get ripped out of the language, and *that* discussion can reopen detailed debate about what the replacement should look like.\n>>> \n>>> -Chris\n>>> \n>>> \n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000567.html" , "inReplyTo" : "57598505-6076-4C78-8D09-7F7C01B0D18B@web.de" , "date" : { "$date" : 1449412582000} , "subject" : "[swift-evolution] lazy keyword vs lazy initialization pattern" , "references" : [ "C9BBB9E4-F2E9-4514-926F-8669DC731128@hartbit.com" , "C7B2EEB8-0B36-4930-B011-034548511656@apple.com" , "99C3AE06-9BA8-4F46-B67A-88AB0D8A3748@hartbit.com" , "57598505-6076-4C78-8D09-7F7C01B0D18B@web.de"] , "descendants" : [ "546CDC6C-6D6E-41F6-B506-77C617575DAF@apple.com" , "87303129-BC13-487E-908D-7D2CC498CDF0@web.de"]} , { "_links" : { "self" : { "href" : "/charter/emails/2BD23417-1AD2-4F2C-BC8D-BA60B4C059E1@dimsumthinking.com"}} , "_id" : "2BD23417-1AD2-4F2C-BC8D-BA60B4C059E1@dimsumthinking.com" , "from" : "daniel at dimsumthinking.com (Daniel Steinberg)" , "mailingList" : "swift-evolution" , "content" : "I love that the team has released API Design Guidelines and find them very helpful. One piece of advice, however, seems to be at odds with current Standard Library practice.\n\nCurrently the methods sort() and sortInPlace() are the non-mutating and mutating versions of sorting a collection. Similarly, there are pairs of methods in Set named union() and unionInPlace(), intersect() and intersectInPlace() and so on.\n\nI think the x(), xInPlace() pairs are easier to use than the previous pairs. the inPlace variant is clearly the mutating implementation as the name tells me that the operation is going to be performed in place on the reciever.\n\nPreviously the sort methods were named sort() and sorted(). I never could remember which is which. The API Guidelines currently recommend this sort/sorted practice as opposed to  sort/sortInPlace. \n\nI know this is a small issue - given the many important tasks you have before you, but I’d love to see the section “Be Grammatical” revised to update the following advice to match current practice. The following two are not consistent with library practices.\n\nUses of mutating methods should read as imperative verb phrases, e.g., x.reverse(), x.sort(), x.append(y).\n\n and\n\nWhen a mutating method is described by a verb, name its non-mutating counterpart according to the “ed/ing” rule, e.g. the non-mutating versions of x.sort() and x.append(y) are x.sorted() and x.appending(y).\n\nThe Swift Programming Language Guide 2.1 reflects the actual use of sort()\n\nFor example, the Swift standard library provides both the mutating method sortInPlace() and the nonmutating method sort() to collections whose generator element conforms to the Comparableprotocol. \n\nNote that in the API Guidelines sort() should be mutating and in actuality (and in the Language Guide) sort() is non-mutating.\n\n\n\n\nThank you,\n\nDaniel" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000568.html" , "date" : { "$date" : 1449412837000} , "subject" : "[swift-evolution] Proposal: Update the API Design Guidelines to reflect current Standard Library method naming conventions" , "references" : [ ""] , "inReplyTo" :  null  , "descendants" : [ "271820A9-BB4A-44F7-B227-E105D15B2327@apple.com" , "CA+Y5xYefFnpgb_5ruKkaDQHLxrrRj=Jit3PErq7uVbXZ1QV6Ow@mail.gmail.com" , "B9EC68C8-F4F2-4929-A76D-2F30ABF39F62@dimsumthinking.com" , "7C2CA2AE-E4BE-45BF-AD09-617F38B6736D@dimsumthinking.com" , "29F7EE3C-7967-4651-9C38-6D071AE543B0@apple.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/9D8DFC81-ECB0-490A-82B0-3E3D01BF35A1@gmail.com"}} , "_id" : "9D8DFC81-ECB0-490A-82B0-3E3D01BF35A1@gmail.com" , "from" : "stephen.celis at gmail.com (Stephen Celis)" , "mailingList" : "swift-evolution" , "content" : "“type” feels more ambiguous to me with the existence of Foo.Type.\n\nStephen\n\n> On Dec 6, 2015, at 8:51 AM, Thorsten Seitz <thorsten.seitz at web.de> wrote:\n> \n> Why not just „type“?\n> \n> protocol Foo {\n>    type T\n> }\n> \n> -Thorsten\n> \n> \n> \n>> Am 06.12.2015 um 02:46 schrieb Austin Zheng via swift-evolution <swift-evolution at swift.org>:\n>> \n>> I like \"associated\". Or maybe \"withtype\". Anything clear and without underscore.\n>> \n>> protocol Foo {\n>>  associated T\n>> }\n>> \n>> protocol Foo {\n>> withtype T\n>> }\n>> \n>>> On Dec 5, 2015, at 5:43 PM, Stephen Celis via swift-evolution <swift-evolution at swift.org> wrote:\n>>> \n>>>> On Dec 5, 2015, at 8:11 PM, Kevin Lundberg via swift-evolution <swift-evolution at swift.org> wrote:\n>>>> \n>>>> If we must keep this concept, I would prefer something without an underscore for the keyword, like \"associatedtype\" or perhaps \"typeassociation\"\n>>> \n>>> Or merely \"associated\".\n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>> \n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000569.html" , "inReplyTo" : "FE7A4F85-6EAD-42D4-8781-19F38941A70D@web.de" , "date" : { "$date" : 1449413045000} , "subject" : "[swift-evolution] Introduce \"associated_type\" keyword" , "references" : [ "C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com" , "80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com" , "BD192734-066B-4907-887C-0286D799CBE1@klundberg.com" , "6407A281-C936-40E3-B882-1E63279F4755@gmail.com" , "554F869D-D9A3-4672-B0BA-3153B644C65B@gmail.com" , "FE7A4F85-6EAD-42D4-8781-19F38941A70D@web.de"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAAcV4sZVC8M4yo+XEdWoGzKyG7rDYuy7ox=Rk3cdbXjFuSD4Sg@mail.gmail.com"}} , "_id" : "CAAcV4sZVC8M4yo+XEdWoGzKyG7rDYuy7ox=Rk3cdbXjFuSD4Sg@mail.gmail.com" , "from" : "cheyo at masters3d.com (J. Cheyo Jimenez)" , "mailingList" : "swift-evolution" , "content" : "https://github.com/apple/swift/commit/0d001480a94f975355cd458973d5c51cef55bff1\n\nOn Sunday, December 6, 2015, Clemens Wagner via swift-evolution <\nswift-evolution at swift.org> wrote:\n\n> > We’ve developed a number of Swift apps for various clients over the past\n> year and have not needed C style for loops either.\n>\n> But I think this is a very weak reason for *removing* any portion like\n> C-loops and increment or decrement operators of a programming language. How\n> about the developers and the productive code which used C-style loops\n> already?\n>\n> I understand the reasons why you, Erica and the others don’t like C-style\n> loops. But changing the philosophy of a productive programming language is\n> a very bad idea.\n>\n> Cheers\n> Clemens\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org <javascript:;>\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000570.html" , "inReplyTo" : "AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de" , "date" : { "$date" : 1449413247000} , "subject" : "[swift-evolution] C-style For Loops" , "references" : [ "AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de"] , "descendants" : [ "B655E20A-3F9D-4B07-B6F1-80A0D81C93F2@gmx.de" , "CADS5KKU3JRZo0eCvF4XgA6ZT0=Eb9wtGg-rwn45BZXC2MiXvdA@mail.gmail.com" , "3743E515-225F-43C4-BB62-DC8C848BEE89@ericasadun.com" , "9FCB65CF-491B-4F21-B664-AE6623E7C669@michelf.ca" , "2CF98787-3994-47AA-8B84-13C9AC7A4154@fifthace.com" , "CAPh90aFQs-RA4W++PCgG7n58p0F5NOp9jmJsz7hZxfkOZktVcA@mail.gmail.com" , "75C3B397-E687-4D6A-A5E2-D918502E8484@ericasadun.com" , "AD0908AC-1F8F-44A4-B059-8E811CE3D661@aol.com" , "CAB8TY2OSDRXUcxtMj7-isuaRmkMXafwsxiquqzedxZ+A+0kyPw@mail.gmail.com" , "E332A59C-7036-42AB-A54A-BE0FE97766EA@aol.com" , "A3B09B02-2438-4658-8073-BEBA8F1A5441@aol.com" , "3F9880E8-7BEA-4275-A939-940041861EC5@michelf.ca" , "5664F2B9.5080808@klundberg.com" , "5567A331-3420-448B-9A1F-484D44F7A792@michelf.ca" , "2F9C0A4A-4005-462F-83DD-795C6E838C3B@pobox.com" , "40642775-F58D-49B0-9BF3-38913FD6924C@ericasadun.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/B655E20A-3F9D-4B07-B6F1-80A0D81C93F2@gmx.de"}} , "_id" : "B655E20A-3F9D-4B07-B6F1-80A0D81C93F2@gmx.de" , "from" : "macmoonshine at gmx.de (Clemens Wagner)" , "mailingList" : "swift-evolution" , "content" : "Hi,\n\na little bit more explanation would be very helpful and welcome.\n\nCheers\nClemens\n\n> Am 06.12.2015 um 15:47 schrieb J. Cheyo Jimenez <cheyo at masters3d.com>:\n> \n> \n> https://github.com/apple/swift/commit/0d001480a94f975355cd458973d5c51cef55bff1\n> \n> On Sunday, December 6, 2015, Clemens Wagner via swift-evolution <swift-evolution at swift.org> wrote:\n> > We’ve developed a number of Swift apps for various clients over the past year and have not needed C style for loops either.\n> \n> But I think this is a very weak reason for *removing* any portion like C-loops and increment or decrement operators of a programming language. How about the developers and the productive code which used C-style loops already?\n> \n> I understand the reasons why you, Erica and the others don’t like C-style loops. But changing the philosophy of a productive programming language is a very bad idea.\n> \n> Cheers\n> Clemens\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000571.html" , "inReplyTo" : "CAAcV4sZVC8M4yo+XEdWoGzKyG7rDYuy7ox=Rk3cdbXjFuSD4Sg@mail.gmail.com" , "date" : { "$date" : 1449413764000} , "subject" : "[swift-evolution] C-style For Loops" , "references" : [ "AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de" , "CAAcV4sZVC8M4yo+XEdWoGzKyG7rDYuy7ox=Rk3cdbXjFuSD4Sg@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/C03532DB-388E-46DE-A34B-7C3572DED0C8@anandabits.com"}} , "_id" : "C03532DB-388E-46DE-A34B-7C3572DED0C8@anandabits.com" , "from" : "matthew at anandabits.com (Matthew Johnson)" , "mailingList" : "swift-evolution" , "content" : "This request isn’t really about typealias at all.  It has two elements.\n\nFirst, it’s about the ability to bind Self and / or associated types in a protocol and use the result as a type.  This is highly desirable and is similar to features in the ML module system.\n\nFirst is the ability to use a protocol with self or associated types as a type, not just a generic constraint:\n\nprotocol<CollectionType where CollectionType.Generator.Element == CGPoint>\n\nI don’t think the `T:` label is necessary here as the protocol name serves as a good identifier in this context.  Although the protocol name could probably be omitted when there is only one protocol here as it is implicit:\n\nprotocol<CollectionType where Generator.Element == CGPoint>\n\nThe general form of this would look like:\n\nprotocol<P1, P2, P3 where *list of constraints*>\n\nIn this case the protocol name would be required, at least when more than one protocol in the list have an associated type with the same name (and possibly in all cases).  The list of constraints could identify associated types, bind them to concrete types, constrain Self to a specific superclass, etc.  The Self constraint might look like this:\n\nprotocol<P1, P2, P3 where Self: UIViewController>\n\nIdeally we would not need to bind all associated types in the protocol in order to use it at a type, but would only be allowed to use members that do not mention the unbound associated type in their signature.\n\nOnce we have the ability to bind associated types and use the result as a type, the typealias use falls out automatically.\n\nSecond, it’s about the ability to extend a typealias where some generic constraints are specified in the typealias.  This would allow us to re-use the binding of generic constraints, but could be confusing if the extension is far removed in source from the typealias.  I’m not sure how I feel about this part of the proposal.\n\nMatthew\n\n> On Dec 6, 2015, at 4:28 AM, Adrian Kashivskyy via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> I believe this could be achieved using generic typealiases, proposed here: https://lists.swift.org/pipermail/swift-evolution/2015-December/000132.html <https://lists.swift.org/pipermail/swift-evolution/2015-December/000132.html>\n> \n> Pozdrawiam – Regards,\n> Adrian Kashivskyy\n> \n>> Wiadomość napisana przez QQ Mail via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> w dniu 06.12.2015, o godz. 08:17:\n>> \n>> If typealias support protocol constraint, I think we can reuse a lot of code, also more readable\n>> \n>> For Example: \n>> \n>> typealias PointCollection = protocol<T:CollectionType where T.Generator.Element == CGPoint>\n>> \n>> public extension PointCollection {\n>>     \n>>     \n>>     \n>> }\n>> \n>> \n>> \n>> \n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> \n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000572.html" , "inReplyTo" : "F54D886C-4283-4DE3-BDA3-6E1947A20233@me.com" , "date" : { "$date" : 1449414439000} , "subject" : "[swift-evolution] Proposal: typealias support protocol constraint" , "references" : [ "78E72933-1ABE-4930-9213-C18CF258DA2D@qq.com" , "F54D886C-4283-4DE3-BDA3-6E1947A20233@me.com"] , "descendants" : [ "DF17297E-E77E-4CAF-851E-2F5E5CACCDCB@qq.com" , "FE41B04C-014E-43E7-9F5E-4826380542F9@anandabits.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/1A62EBA8-4AC4-4F05-B486-F90194FE5740@michelf.ca"}} , "_id" : "1A62EBA8-4AC4-4F05-B486-F90194FE5740@michelf.ca" , "from" : "michel.fortin at michelf.ca (Michel Fortin)" , "mailingList" : "swift-evolution" , "content" : "Le 5 déc. 2015 à 22:35, Kevin Ballard <kevin at sb.org> a écrit :\n\n> Which is in the context of the fact that @convention(selector) MyObject\n> -> Args -> Ret encodes the receiver type, but the problem is the\n> selector is sent to AnyObject, so having the receiver type in there is\n> basically false type-safety (it looks like it's strongly-typed but it's\n> actually not as that type information will be thrown away before the\n> selector is used). I'm not really sure why Michel claimed that your\n> closure suggestion was a solution to this problem, because the only\n> reasonable behavior one can use in such a category emitted on\n> AnyObject/swift base class is to fatalError, which is no better than\n> what happens if the selector simply isn't implemented.\n\nSomehow in the thinking process I forgot that the category could have been put on MyObject instead of NSObject. I agree it's better to set the category on MyObject.\n\nAs for why a category at all? The risk is that another class implements \"doSomething:\" with a different argument type or return type than the \"doSomething:\" referring to, and that somehow an object of this other class becomes the target. In that case you want to halt the program to avoid the other \"doSomething:\" method from being called. That's why I suggested using a unique selector. And that idea came from Joe's suggestion of creating unique selectors from context-free closures.\n\n\n>> There's plenty of useful space between \"no type safety\" and \"perfect type safety\", IMO.\n> \n> In principle I agree. My basic argument here is that\n> @convention(selector) provides so little actual type safety that it's\n> not worth the language complexity. And I also worry that providing\n> functionality that appears to be strongly-typed but doesn't actually\n> provide any typing guarantees in practice will end up as a safety hazard\n> for unwary programmers.\n\nThis is a reasonable concern. My opinion is that for @convention(selector) to be worthwhile, it needs to be safe.. If it can't be made safe, then maybe the idea probably should be abandoned. I think we are on the same page here, except that I'm more optimistic about type-safety.\n\n\n> It's also worth pointing out that my alternative suggestion of simply\n> providing some syntax to explicitly get a Selector from a method could\n> still use your closure-generating idea to work for non- at objc methods.\n> Heck, we don't even really need syntax for this, we could just say that\n> unbound method references can resolve to Selectors in addition to\n> function types (just as the primary suggestion here allows method\n> references to resolve to @convention(selector) functions in addition to\n> @convention(swift) functions).\n\nMost ideas floating in this thread are actually not mutually exclusive. I wouldn't qualify them as \"alternatives\" really since they can easily combine. We should look at the tradeoff of each and keep the good ones.\n\n\n-- \nMichel Fortin\nmichel.fortin at michelf.ca\nhttps://michelf.ca" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000573.html" , "inReplyTo" : "1449372912.2146477.459241273.0F8138F3@webmail.messagingengine.com" , "date" : { "$date" : 1449415593000} , "subject" : "[swift-evolution] Type-safe selectors" , "references" : [ "B4E7896A-ACC6-49C0-8E15-47418D012C0B@michelf.ca" , "2CA0197A-B5E5-466B-AF27-C552A998764E@apple.com" , "1449271642.2877123.458487961.609100F1@webmail.messagingengine.com" , "B70B24CB-485C-4A9B-8575-E391FBC8C263@apple.com" , "1449296613.1919415.458667425.16848C1F@webmail.messagingengine.com" , "8508E135-791E-4B88-A758-9208388DA878@michelf.ca" , "1449347746.2071795.459083425.1FD398E4@webmail.messagingengine.com" , "92C8AF30-9249-4152-A24E-86496425BD4D@apple.com" , "1449372912.2146477.459241273.0F8138F3@webmail.messagingengine.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/3A2C2956-0C24-4838-84C0-B171C8F39F6F@icloud.com"}} , "_id" : "3A2C2956-0C24-4838-84C0-B171C8F39F6F@icloud.com" , "from" : "loiclecrenier at icloud.com (=?utf-8?Q?Lo=C3=AFc_Lecrenier?=)" , "mailingList" : "swift-evolution" , "content" : "Well, I went ahead and created a pull request :)\n\nI also included a “proposed approach” section, where I propose to deprecate \nthe `typealias` keyword for Swift 2.2, and replace it entirely for Swift 3.0.\n\nDoes anyone have any thought on that? This is a bit aggressive, but I think it’s worth it.\nIt is actually the same approach Erica proposed for removing C for-loops.\n\nLoïc\n\n> On Dec 6, 2015, at 1:12 PM, Loïc Lecrenier <loiclecrenier at icloud.com> wrote:\n> \n> I have drafted a formal proposal here: https://gist.github.com/loiclec/22459d230a21dbcb81fc\n> Would love to receive feedback from the community on it, I am particularly worried about the correctness of the terms I used.\n> Should I make a pull request to swift-evolution now, or should we continue the conversation here?\n> \n> Thanks, \n> \n> Loïc\n> \n> (and sorry about emailing you on Sunday 😇 ) \n> \n>> On Dec 6, 2015, at 1:48 AM, John McCall <rjmccall at apple.com> wrote:\n>> \n>>> On Dec 5, 2015, at 4:35 PM, Loïc Lecrenier via swift-evolution <swift-evolution at swift.org> wrote:\n>>> Hi everyone :)\n>>> \n>>> I propose introducing a new \"associated_type\" keyword that will replace \"typealias\" for declaring associated types in protocols.\n>>> I remember being confused by associated types when I started using Swift, and I think one reason why was the use of the typealias keyword to define them.\n>>> One reason was that I thought I knew what typealias did, and so I didn't stop to learn what it did inside a protocol. An other reason was the difficulty of finding help when searching for \"typealias\" instead of \"associated types\".\n>>> Then, when I thought I understood it, I started building an excessively protocol-oriented program as an exercise. And I still lost a lot of time fighting Swift by trying to use \"real\" typealias-es inside of protocols.\n>>> \n>>> Conceptually, I had something like this:\n>>> \n>>> protocol ProtA {\n>>> typealias Container : SequenceType\n>>> }\n>>> protocol ProtB {\n>>> typealias AnOtherAssocType : ProtA\n>>> func foo(x: AnOtherAssocType.Container.Generator.Element, y: AnOtherAssocType.Container.Generator.Element) -> AnOtherAssocType.Container.Generator.Element\n>>> }\n>>> \n>>> The function foo is very difficult to read, so I wanted to use a shortcut to Element by doing this:\n>>> \n>>> protocol ProtB {\n>>> typealias A : ProtA\n>>> typealias Element = A.Container.Generator.Element\n>>> func foo(x: Element, y: Element) -> Element\n>>> }\n>>> \n>>> But by doing so, I didn't create a shortcut to Element, but an associated type with a default value of Element. (right?)\n>>> Then I tried to write extensions to ProtB where Element conforms to, say, Equatable, and couldn't make it work because A.Container.Generator.Element didn't conform to Equatable.\n>>> \n>>> So, that was a rather long explanation of the reasons I think we should replace the typealias keyword by associated_type, and allow \"real\" typealias-es inside protocols.\n>> \n>> I think this is a great idea; re-using typealias for associated types was a mistake.\n>> \n>> John.\n>> \n>>> \n>>> Ideally, I would write\n>>> \n>>> protocol ProtB {\n>>> associated_type AnOtherAssocType : ProtA\n>>> typealias Element = AnOtherAssocType.Container.Generator.Element\n>>> func foo(x: Element, y: Element) -> Element\n>>> }\n>>> \n>>> and it would be exactly the same as\n>>> \n>>> protocol ProtB {\n>>> associated_type AnOtherAssocType : ProtA\n>>> func foo(x: A.Container.Generator.Element, y: A.Container.Generator.Element) -> A.Container.Generator.Element\n>>> }\n>>> \n>>> There are probably some problems created by this proposal, but right now I can't see any :/\n>>> \n>>> Thanks,\n>>> \n>>> Loïc\n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000574.html" , "inReplyTo" : "6BCA9015-28F4-4B1B-8AF5-84DFA9256949@icloud.com" , "date" : { "$date" : 1449415925000} , "subject" : "[swift-evolution] Introduce \"associated_type\" keyword" , "references" : [ "C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com" , "80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com" , "6BCA9015-28F4-4B1B-8AF5-84DFA9256949@icloud.com"] , "descendants" : [ "CAKCGC8Dr29Reis3NnK-MLE3MpswCC9fEU7=Eh3VTCOmj3TfAJw@mail.gmail.com" , "2FC53481-EF6F-4B06-92FB-283A65F000E3@icloud.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAOjGmwn6O2uvJBq03GZyJ+yngfAB4=rqb60dCCfpP2x7rmnEyg@mail.gmail.com"}} , "_id" : "CAOjGmwn6O2uvJBq03GZyJ+yngfAB4=rqb60dCCfpP2x7rmnEyg@mail.gmail.com" , "from" : "inboxonly4 at gmail.com (inbox only)" , "mailingList" : "swift-evolution" , "content" : "True,even that a feature isn't used doesn't mean that you need to remove\nthat feature.\nI hope that the proposal will be rejected.\n\n2015-12-06 12:03 GMT+02:00 Clemens Wagner via swift-evolution <\nswift-evolution at swift.org>:\n\n> > We’ve developed a number of Swift apps for various clients over the past\n> year and have not needed C style for loops either.\n>\n> But I think this is a very weak reason for *removing* any portion like\n> C-loops and increment or decrement operators of a programming language. How\n> about the developers and the productive code which used C-style loops\n> already?\n>\n> I understand the reasons why you, Erica and the others don’t like C-style\n> loops. But changing the philosophy of a productive programming language is\n> a very bad idea.\n>\n> Cheers\n> Clemens\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000575.html" , "inReplyTo" : "AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de" , "date" : { "$date" : 1449415994000} , "subject" : "[swift-evolution] C-style For Loops" , "references" : [ "AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de"] , "descendants" : [ "9C647949-D1C6-4EB3-A964-04312A957B2F@gmx.de" , "CC1BC37C-FBA3-4D17-9ADA-379FA69A8078@me.com" , "F3CA2962-24DB-438C-B5B8-13B33A3ACDD6@architechies.com" , "A1CD1E1C-07C2-40AA-AB39-EECDB0C09323@springsandstruts.com" , "B9F4EA1D-98F9-4A2B-8D16-9073FBDD54A5@portablesoftware.com" , "112B3CB9-7E8E-4DA6-8A20-6C2E8848E58B@alkaline-solutions.com" , "B0FB69E4-C275-4E6E-9B18-6A3354164938@springsandstruts.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/475AB355-591C-42D9-A43B-1ED8D02BA1C3@anandabits.com"}} , "_id" : "475AB355-591C-42D9-A43B-1ED8D02BA1C3@anandabits.com" , "from" : "matthew at anandabits.com (Matthew Johnson)" , "mailingList" : "swift-evolution" , "content" : "Thanks for chiming in on this thread.  I definitely understand the desire to wait on features like this until post-Swfit 3 and possibly post-hygienic macros as well.\n\nI would add to your list of memberwise initializer deficiencies the fact that it is “all or nothing”.  I’m wondering what you think of generalizing our “utterance” of the memberwise initializer in a way that allows the flexibility for the initializer itself to handle initialization of some of the members while allowing the compiler to generate the implementation for other members.  I described one idea for doing this in a post last night where I described an @initializable member attribute.  I’m not tied to that specific solution, but I do think it is highly desirable to have complier-generated memberwise initialization that is more flexible than an “all or nothing” solution.  What are your thoughts?\n\nMatthew\n\n> On Dec 6, 2015, at 12:34 AM, Chris Lattner via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> On Dec 5, 2015, at 1:03 PM, Brent Royal-Gordon via swift-evolution <swift-evolution at swift.org> wrote:\n>>> There’s lots of boilerplate of initializing structs with stored properties and initializer parameters. I’d like to create a syntax for alleviating that in the 90% case.\n> \n> As a general comment, at this point, I’d personally prefer to stay away from purely syntactic sugar syntax optimizations, unless they are very broadly applicable across the language.  There are a ton of core things still missing from the swift language and type system, and I’d prefer that we stay focused on that.  Post-Swift 3 we can consider adding a hygienic macro system, and the baking out of other language features may lead to the eliminate for some of the sugar that would otherwise be added.\n> \n>> I’d like to propose an alternative approach.\n>> \n>> Swift already generates a default initializer for structs that don’t have any initializers explicitly defined. However, the moment you write init(, that initializer disappears. It’s also never available on classes, because they have to dispatch to another initializer.\n> \n> Yes, this is really unfortunate.  The default memberwise initializer behavior of Swift has at least these deficiencies (IMO):\n> \n> 1) Defining a custom init in a struct disables the memberwise initializer, and there is no easy way to get it back.\n> 2) Access control + the memberwise init often requires you to implement it yourself.\n> 3) We don’t get memberwise inits for classes.\n> 4) var properties with default initializers should have their parameter to the synthesized initializer defaulted.\n> 5) lazy properties with memberwise initializers have problems (the memberwise init eagerly touches it).\n> \n> One of the things missing is the ability to “utter” the memberwise initializer, I’d suggest syntax along the lines of:\n> \n>  memberwise init()    // memberwise is a \"decl modifier\"\n> \n> So you could say:\n> \n>  public memberwise init()\n> \n> to specifically say you want the default one given public access control (for example).\n> \n> \n> It would be really great for someone to tackle these problems holistically! \n> \n> -Chris\n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000576.html" , "inReplyTo" : "819785E7-2803-4A65-882F-DB1A9EC0483B@apple.com" , "date" : { "$date" : 1449416511000} , "subject" : "[swift-evolution] Proposal: helpers for initializing properties of same name as parameters" , "references" : [ "CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com" , "4F8C6141-CEFA-43DA-8FD9-5C787789ED68@architechies.com" , "819785E7-2803-4A65-882F-DB1A9EC0483B@apple.com"] , "descendants" : [ "6F2EF9CF-2E73-4470-9AA7-93DFE00FEA6D@apple.com" , "CA+ddMk2uvrEwLZf4fcsYxDbFnagOcywttsdC7HRB9jkeVdZ=zA@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/87303129-BC13-487E-908D-7D2CC498CDF0@web.de"}} , "_id" : "87303129-BC13-487E-908D-7D2CC498CDF0@web.de" , "from" : "thorsten.seitz at web.de (Thorsten Seitz)" , "mailingList" : "swift-evolution" , "content" : "Absolutely correct. I’d prefer a statically checked solution, too :-)\n\n-Thorsten\n\n\n> Am 06.12.2015 um 15:36 schrieb Matthew Johnson via swift-evolution <swift-evolution at swift.org>:\n> \n> Property delegates do look very nice, but I also wonder whether they would cover the `delayed let x : T` case.  They also don’t know *when* the property is getting set.\n> \n> I would really like to see something like `delayed let x : T` to handle the second phase of initialization problem, although I would add the requirement that it *must* be initialized in the second phase and it *cannot* be read until it is set (as far as the compiler can detect this through control flow analysis).  This would behave quite similarly to a simple `let x : T` member but with the caveat that it is possible to blow up if you attempt to read before setting it in the second phase and the compiler cannot detect the read attempt when performing control flow analysis.  \n> \n> If Swift’s property delegates were able to both support let members and require initialization during the second phase (so the instance is guaranteed to be fully initialized and work correctly after initialization completes) then they would be a great solution.  I just can’t imagine how they could enforce this semantic.  I’m looking forward to reading Joe’s proposal and will be delighted if his design is able to support the desired semantics.\n> \n> Chris, do you agree that this semantic is desirable to support one way or another?  \n> \n> Thorsten’s attempt to implement something like this using a property delegate looks really dangerous to me.  A var member that blows up when somebody attempts to set it a second time seems extremely fragile.  It’s like an IUO but rather than blowing up when read it also blows up when set more than once.\n> \n> Matthew\n> \n> \n>> On Dec 6, 2015, at 6:32 AM, Thorsten Seitz via swift-evolution <swift-evolution at swift.org> wrote:\n>> \n>> Hi all,\n>> \n>> I like the property delegates feature from Kotlin, too, but I don’t see how it can replace the „delayed let x : T“ idea with initialization taking place in e.g. awakeFromNib, because a let-property cannot be set. With a var it would probably look roughly like follows, but with „let x : T by Delayed()“ the setValue method would not be allowed (at least in Kotlin):\n>> \n>> var x : T by Delayed()\n>> \n>> with\n>> \n>> class Delayed<T> {\n>> \tvar value : T!\n>> \tfunc getValue(this: Any?, property: Property<T>) -> T { return value }\n>> \tfunc setValue(this: Any?, property: Property<T>, value: T) {\n>> \t\tguard x == nil else { abort(„Property \\(property) of \\(this) has already been initialized when trying to initialize with value \\(value)“) }\n>> \t\tself.value = value\n>> \t}\n>> }\n>> \n>> Some remarks\n>> * I chose abort() in this particular case instead of throwing because repeated initialization should be a logical error\n>> * Are there uses cases where throwing would be the right thing in getValue or setValue? I guess not, just like throwing is not possible in a computed property.\n>> * Is the compiler able to optimize away the overhead of going through getValue on each access?\n>> * I was a bit surprised that Kotlin does not require an interface for the delegates to implement. I would expect delegates to be required to implement appropriate interfaces (or protocols) like PropertyReader/PropertyAccessor, probably with a type parameter for the property owner as well (instead of Any?). The latter would allow \n>> \n>> -Thorsten\n>> \n>>> Am 06.12.2015 um 11:00 schrieb David Hart via swift-evolution <swift-evolution at swift.org>:\n>>> \n>>> This property delegates feature from Kotlin sounds fantastic! As the examples in Kotlin show, it could bring a very powerful solution to many problems in Swift right now: lazy being narrow, cache missing, native KVO :D\n>>> \n>>> This has just become my #1 feature proposal!\n>>> \n>>> Super excited David!\n>>> \n>>>> On 06 Dec 2015, at 08:27, Chris Lattner <clattner at apple.com> wrote:\n>>>> \n>>>> \n>>>>> On Dec 4, 2015, at 5:40 AM, David Hart <david at hartbit.com> wrote:\n>>>>> \n>>>>> In Objective-C, I often used the lazy initialization pattern to implement a cache for expensive operations. For exemple, here is an often used scenario in a project where objects behind foreign keys in a database ORM are only fetched when necessary:\n>>>>> \n>>>>> When thinking about it, I came to the conclusion that the use cases of lazy seem very narrow compared to how useful the lazy initialization pattern was in Objective-C.\n>>>>> I want your opinion on three alternatives:\n>>>>> \n>>>>> 1- Do nothing, and use the slightly uglier Swift example when using a cache.\n>>>>> 2- Modify lazy semantics to re-calculates when nil (I think this is the worst solution).\n>>>>> 3- Add a cache modifier that re-calcualtes when nil.\n>>>> \n>>>> Hi David,\n>>>> \n>>>> My preference is:\n>>>> 4) Kick lazy out of the compiler and make it a standard library feature instead, allowing it to be extended in lots of ways.\n>>>> \n>>>> The existing lazy behavior was added as a very narrow solution to a common scenario that would otherwise required optional machinations everywhere.  It succeeded in that goal, but it is super narrow, and the implementation has a number of bugs (e.g. you can’t have a lazy local variable).\n>>>> \n>>>> In terms of its narrowness, it has the limitations you describe, but it also doesn’t solve other common problems.  For example, many people complain about properties that are initialized only in a second phase of initialization (e.g. awakeFromNib) and right now, most folks resort to using typing their properties as ImplicitlyUnwrappedOptional to avoid using ! at every use site.  A natural solution to that is to introduce a concept of a “delayed var x : T” which does not need initialization in init(), and runtime traps if it is read before initialized.  This provides similar semantics to T!, but without infecting the type system.  Better than T!, a “delayed let x : T” would allow exactly one runtime initialization of the property.\n>>>> \n>>>> The problem with this line of thinking is that - if we kept going down this path - we’d end up adding a ton of very narrow solutions for specific problems, adding language complexity all the way.  This is pretty dissatisfying for a number of reasons. :-)\n>>>> \n>>>> A different approach is to introduce a single language feature that would allow you to define customization behavior for properties in a library, which would be a general solution to these sorts of issues.  Joe Groff is working on a proposal to do just this, similar to the idea of Kotlin property delegates (https://kotlinlang.org/docs/reference/delegated-properties.html).\n>>>> \n>>>> We’ve been a bit busy lately :-) but I’m hoping that he’ll send this proposal out in the next few weeks.  Assuming that proposal works out, I expect lazy to get ripped out of the language, and *that* discussion can reopen detailed debate about what the replacement should look like.\n>>>> \n>>>> -Chris\n>>>> \n>>>> \n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>> \n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000577.html" , "inReplyTo" : "543A1A03-A23B-42D1-96DA-DC7C3F81E49A@anandabits.com" , "date" : { "$date" : 1449417477000} , "subject" : "[swift-evolution] lazy keyword vs lazy initialization pattern" , "references" : [ "C9BBB9E4-F2E9-4514-926F-8669DC731128@hartbit.com" , "C7B2EEB8-0B36-4930-B011-034548511656@apple.com" , "99C3AE06-9BA8-4F46-B67A-88AB0D8A3748@hartbit.com" , "57598505-6076-4C78-8D09-7F7C01B0D18B@web.de" , "543A1A03-A23B-42D1-96DA-DC7C3F81E49A@anandabits.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/5B57FA0A-C205-4937-8005-94DD2F69806A@dimsumthinking.com"}} , "_id" : "5B57FA0A-C205-4937-8005-94DD2F69806A@dimsumthinking.com" , "from" : "daniel at dimsumthinking.com (Daniel Steinberg)" , "mailingList" : "swift-evolution" , "content" : "Yes! It feels silly to have to re-implement the default initializer just to make it public. I would love to see this.\n\nDaniel\n> On Dec 6, 2015, at 1:34 AM, Chris Lattner via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> So you could say:\n> \n>  public memberwise init()\n> \n> to specifically say you want the default one given public access control (for example)." , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000578.html" , "inReplyTo" : "819785E7-2803-4A65-882F-DB1A9EC0483B@apple.com" , "date" : { "$date" : 1449417713000} , "subject" : "[swift-evolution] Proposal: helpers for initializing properties of same name as parameters" , "references" : [ "CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com" , "4F8C6141-CEFA-43DA-8FD9-5C787789ED68@architechies.com" , "819785E7-2803-4A65-882F-DB1A9EC0483B@apple.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/B9F4EA1D-98F9-4A2B-8D16-9073FBDD54A5@portablesoftware.com"}} , "_id" : "B9F4EA1D-98F9-4A2B-8D16-9073FBDD54A5@portablesoftware.com" , "from" : "don.wills at portablesoftware.com (Don Wills)" , "mailingList" : "swift-evolution" , "content" : "I too hope that the proposal to remove C-style loops is rejected.  Yes, they aren't that necessary any more, but if we want Swift to compete with Java, C#, C++ and C, there is no reason to remove basic features like C-style loops just because they are politically incorrect.  If there was a functional reason, I might get on board with removing it, but there isn't.\n\nI also hope that the decision to remove increment and decrement operators is reversed using the same logic.  Just because *you* don't like something that has been a feature of dozens of programming languages for 40 years doesn't mean removing that feature is a good idea.  One man's goto statement is another man's Leatherman multi-tool.  And FWIW, if C-style loops stay in the language, they become much more ugly without increment and decrement.\n\nDon Wills\n\n> On Dec 6, 2015, at 8:33 AM, inbox only via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> True,even that a feature isn't used doesn't mean that you need to remove that feature.\n> I hope that the proposal will be rejected.\n> \n> 2015-12-06 12:03 GMT+02:00 Clemens Wagner via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>>:\n> > We’ve developed a number of Swift apps for various clients over the past year and have not needed C style for loops either.\n> \n> But I think this is a very weak reason for *removing* any portion like C-loops and increment or decrement operators of a programming language. How about the developers and the productive code which used C-style loops already?\n> \n> I understand the reasons why you, Erica and the others don’t like C-style loops. But changing the philosophy of a productive programming language is a very bad idea.\n> \n> Cheers\n> Clemens\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n> \n>  _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000579.html" , "inReplyTo" : "CAOjGmwn6O2uvJBq03GZyJ+yngfAB4=rqb60dCCfpP2x7rmnEyg@mail.gmail.com" , "date" : { "$date" : 1449417803000} , "subject" : "[swift-evolution] C-style For Loops" , "references" : [ "AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de" , "CAOjGmwn6O2uvJBq03GZyJ+yngfAB4=rqb60dCCfpP2x7rmnEyg@mail.gmail.com"] , "descendants" : [ "9C647949-D1C6-4EB3-A964-04312A957B2F@gmx.de" , "F3CA2962-24DB-438C-B5B8-13B33A3ACDD6@architechies.com" , "A1CD1E1C-07C2-40AA-AB39-EECDB0C09323@springsandstruts.com" , "112B3CB9-7E8E-4DA6-8A20-6C2E8848E58B@alkaline-solutions.com" , "B0FB69E4-C275-4E6E-9B18-6A3354164938@springsandstruts.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/C3D6E59B-95E6-4A39-86C3-7FF7F33C38B5@gmail.com"}} , "_id" : "C3D6E59B-95E6-4A39-86C3-7FF7F33C38B5@gmail.com" , "from" : "oisin.kidney at gmail.com (=?utf-8?Q?Donnacha_Ois=C3=ADn_Kidney?=)" , "mailingList" : "swift-evolution" , "content" : "(forgot to cc the mailing list)\n\nYou can define it in terms of a map-filter-map chain, like this:\n\nextension LazySequenceType {\n  \n  @warn_unused_result\n  public func flatMap<T>(transform: Elements.Generator.Element -> T?)\n    -> LazyMapSequence<LazyFilterSequence<LazyMapSequence<Elements, T?>>, T> {\n      return self\n        .map(transform)\n        .filter { opt in opt != nil }\n        .map { notNil in notNil! }\n  }\n}\n\nThe version for LazyCollectionType can be done similarly:\n\nextension LazyCollectionType {\n  \n  @warn_unused_result\n  public func flatMap<T>(transform: Elements.Generator.Element -> T?)\n    -> LazyMapCollection<LazyFilterCollection<LazyMapCollection<Elements, T?>>, T> {\n      return self\n        .map(transform)\n        .filter { opt in opt != nil }\n        .map { notNil in notNil! }\n  }\n}\n\nThere seems to be no performance overhead vs the custom struct version in my (very preliminary) testing.\n\nThe version for a LazyCollectionType with a BidirectionalIndexType would rely on a similar LazyFilterCollection, but a BidirectionalFilterCollection doesn’t exist (I think). Is that something that might be included in this proposal?\n\nOisin.\n\n> On 6 Dec 2015, at 09:11, Dmitri Gribenko <gribozavr at gmail.com> wrote:\n> \n> On Fri, Dec 4, 2015 at 2:38 PM, Donnacha Oisín Kidney <oisin.kidney at gmail.com <mailto:oisin.kidney at gmail.com>> wrote:\n> Currently, several of the methods on SequenceType in the standard library have lazy variants. flatMap, though, (seems) to have a version missing: while there’s a lazy version for nested sequences, there’s no lazy version for sequences of Optionals. Is there maybe a reason for this that I haven’t thought of? At any rate, here’s what I had in mind:\n> \n> public struct FlatMapOptionalGenerator<G: GeneratorType, Element>: GeneratorType {\n>   private let f: G.Element -> Element?\n>   private var g: G\n>   public mutating func next() -> Element? {\n>     while let x = g.next() {\n>       if let y = f(x) {\n>         return y\n>       }\n>     }\n>     return nil\n>   }\n> }\n> \n> public struct FlatMapOptionalSequence<S: LazySequenceType, Element>: LazySequenceType {\n>   private let f: S.Generator.Element -> Element?\n>   private let s: S\n>   public func generate() -> FlatMapOptionalGenerator<S.Generator, Element> {\n>     return FlatMapOptionalGenerator(f: f, g: s.generate())\n>   }\n> }\n> \n> extension LazySequenceType {\n>   public func flatMap<T>(transform: Generator.Element -> T?) -> FlatMapOptionalSequence<Self, T> {\n>     return FlatMapOptionalSequence(f: transform, s: self)\n>   }\n> }\n> \n> \n> Hi,\n> \n> Thank you for the proposal.\n> \n> Defining only one overload would cause the collection-ness of the input to be lost.  Please take a look at the current flatMap() overloads in stdlib/public/core/FlatMap.swift: there's one in LazySequenceType, another one in LazyCollectionType, and one more in LazyCollectionType with bidirectional indices.\n> \n> I'm also not a fan of introducing a specialized result type for this operation: given that we need three overloads, this approach would add six more types to the library (three sequences and three generators).  Current flatMap() overloads compose existing types, but they rely on intermediate data structure being a sequence or a collection.  Optional is not a sequence, so that exact approach won't work here.  Can you think of another way we could combine existing types to express the result of this operation?\n> \n> Dmitri\n> \n> -- \n> main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if\n> (j){printf(\"%d\\n\",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com <mailto:gribozavr at gmail.com>>*/" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000580.html" , "inReplyTo" : "CA+Y5xYcYWQ-6YrhB=r4r8cQ9hbnMTFH2FNnWrdn5GRwQFFV-QQ@mail.gmail.com" , "date" : { "$date" : 1449417987000} , "subject" : "[swift-evolution] Lazy flatMap for Optionals" , "references" : [ "5FD8E885-1900-4498-938D-161809D13746@gmail.com" , "CA+Y5xYcYWQ-6YrhB=r4r8cQ9hbnMTFH2FNnWrdn5GRwQFFV-QQ@mail.gmail.com"] , "descendants" : [ "CA+Y5xYd2R3B5TfhRR-OX+DRohj=aUtJW3RxM2oBOsX42XK00pg@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/A3773EB7-8ED6-4576-97BE-329A3BFB5CF4@icloud.com"}} , "_id" : "A3773EB7-8ED6-4576-97BE-329A3BFB5CF4@icloud.com" , "from" : "plxswift at icloud.com (plx)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 5, 2015, at 8:10 PM, Joe Groff <jgroff at apple.com> wrote:\n> \n> \n>> On Dec 5, 2015, at 11:34 AM, plx via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>> \n>> Swift’s standard library's core collections' value-like, copy-on-write behavior is handy in the small, but they compose rather poorly with each other: if you have e.g. [K:Set<V>], and plan to mutate the “inner\" sets, it seems at present as if there is no way to avoid an unnecessary transient copy of each set for each mutation you perform upon it.\n>> \n>> Various workarounds/solutions exist but all are full of unfortunate tradeoffs and/or limited further composability; in concrete cases you can do alright, but it’s hard to craft a generic solution that doesn’t inadvertently reintroduce the problem you started-out trying to solve.\n>> \n>> Is anything currently on the roadmap to address this specifically — whether optimizer improvements, extended APIs, implementation adjustments, a `borrow` construct, or some other approach?\n>> \n> \n> Do you have specific examples of problems you're trying to solve?\n\nI'm not entirely sure if you're asking:\n\n1. what are some specific problems with the standard library collections' composability?\n2. what are some specific problems with available solutions to the problems in (1)?\n3. what are some specific problems for which *performant* nested collections would be useful?\n\n...so I'll answer (1) and (2) quickly, then provide some context for (3).\n\nBefore I'll begin, I'll preface this by re-stating what I wanted to know:\n\n- whether or not the problems I see for (1) and (2) are seen as such\n- whether or not anything is already on the roadmap to address (1) and (2)\n\n...and in case, thanks for your time and consideration.\n\nFor (1), the problem is simply that when you nest Swift's collections -- at least within a `Dictionary`, e.g. `[K:Set<V>]` -- there's currently no direct way to do efficient, in-place mutations of the inner `Set<V>` values; performance here is essentially quadratic (see Appendix A).\n  \nThat you get ~quadratic performance in this context isn't surprising, given the collections' design; the aspect I see as problematic is the lack of any straightforward way to do any better.\n\nFor (2), if you want e.g. all of the following:\n\n- a collection `DictionaryOfSets` behaving ~ [K:Set<V>]\n- re-using the basic collection types\n- with value-like semantics (e.g. to fit in with the rest of the language)\n- with better-than-quadratic performance on updates\n\n...then the following outline seems to be the minimal amount of work to achieve all of the above:\n\n- a class like `class Box<T> { var storage: T }` (etc.)\n- a struct like `struct _DictionaryOfSets<K,V> { var storage: [K:Box<Set<V>>] }`\n  - best if this implements all-or-most of the public API on `DictionaryOfSets`\n  - knows how to perform a deep copy of `storage`\n- a struct like `struct DictionaryOfSets<K,V> { var buffer: ManagedBuffer<_DictionaryOfSets<K,V>,Void> }`  \n  - takes care of checking `isUniquelyReferenced` and making deep-copies when needed\n  - with ownership now assured, forwards all calls to the buffer's `_DictionaryOfSets` \n  \n...which is certainly tractable, but also feels rather disproportionate: to make it work we've now added 2 additional levels of indirection -- one due to the outer `ManagedBuffer`, and one more due to `Box` -- which we only need because we have no other way to manipulate the essentially-equivalent ownership-and-copying-(...etc.) behavior of `Dictionary` and `Set`.\n\nThis all feels like it could -- and should! -- be unnecessary, with e.g. some way of indicating an intent to do an in-place update if possible.\n\nAs for (3), a surprising amount of application-infrastructure code amounts to babysitting a nested collection of some kind.\n\nAs one example, if you want a generic solution to the \"pool-and-reuse a bunch of expensive-to-create elements\" (consider e.g. `UITableView` or `UICollectionView`), a `[Key:Set<V>]`-like collection is extremely handy:\n\n    protocol ReusableComponentType: Equatable, Hashable {\n      func prepareForPooling()\n      func prepareForReuse()\n      var reuseIdentifier: String { get }\n    }\n    \n    protocol ComponentFactoryType {\n      typealias Component: ReusableComponentType\n      func instantiateComponent(reuseIdentifier: String) -> Component\n    }\n    \n    class ReusableComponentPool<Component:ReusableComponentType> {\n      private var factories: [String:AnyComponentFactory<Component>]\n      private var poolSizeLimits: [String:Int]\n      private var reusePool: DictionaryOfSets<String,Component>\n      // ^ NESTED COLLECTION HERE, ~ [String:Set<Component>]\n      \n      func dequeueComponentForReuseIdentifier(identifier: String) -> Component {\n        if let existing = self.reusePool.popFirstElementForKey(identifier) {\n          existing.prepareForReuse()\n        } else if let created = self.factories[identifier]?.instantiateComponent(reuseIdentifier: identifier) {\n          return created\n        } else {\n          fatalError(\"No registered factory for identifier '\\(identifier)'!\")\n        }\n      }\n      \n      func poolComponentForPotentialReuse(component: Component) {\n        self.reusePool.insertElement(\n          component,\n          forKey: component.identifier\n        )\n      }\n      \n      func drainOverfullPoolsIfNecessary() {\n        for (identifier,sizeLimit) in self.poolSizeLimits {\n          self.reusePool.shrinkSetForKey(\n            identifier,\n            ifAboveCount: sizeLimit\n          )\n        }\n      }\n      \n    }\n\n...but it's also a handy thing in other places (tracking active-transfers-by-host as ~`[String:Set<NSURL>]`, tracking discovered characteristics-of-services in `CoreBluetooth` as ~`[CBUUID:Set<CBUUID>]`, tracking invalidated layout attributes by supplementary-element-kind as ~`[String:Set<NSIndexPath>]`, organizing equivalence-classes for certain types of unit tests, and so on).\n\nNote that it's not just `[K:Set<V>]`, either; sometimes `[K:[V]]` is handy, sometimes `[K:[Q:V]]` is handy (and ~ `[(K,Q):V]` isn't right); if Swift's stdlib gets an `OrderedSet` or `OrderedDictionary` there would be uses for those, as well.\n\nNote that although in any specific use-case, you are arguably better off with a specific solution, e.g.:\n\n    private class SingleComponentPool<Component:ReusableComponentType> {\n      let factory: AnyComponentFactory<Component>\n      let sizeLimit: Int?\n      var pool: Set<Component>\n    }\n    \n    class ReusableComponentPool<Component:ReusableComponentType> {\n      private var pools: [String:SingleComponentPool<Component>]\n    }\n\n...instead of the earlier above, there's still arguably a utility to having a fancy collection that can be used in various contexts, with a rich supporting API.\n\nIn closing, thanks again for taking the time to read and thanks in advance for any consideration or response.\n\n## Appendix: Concrete Benchmarks\n\nTo make the sure the performance implications are clear:\n\n    func test10BareInserts() {\n      self.measureBlock() {\n        var target = Set<Int>()\n        for index in 0..<10 {\n          target.insert(index)\n        }\n      }\n    }\n    \n    func test10NestedInserts() {\n      self.measureBlock() {\n        var target = [Int:Set<Int>]()\n        var target[0] = Set<Int>()\n        for index in 0..<10 {\n          target[0]?.insert(index)\n        }\n      }\n    }\n\n...and so on, for e.g. `test100*`, `test1000*`, ...etc. Here's how this performs:\n\n- 10 inserts: \n  - bare:   *0.000003\n  - nested: *0.000008\n- 100 inserts:\n  - bare:   *0.000012\n  - nested: *0.000073\n- 1000 inserts:\n  - bare:  *0.000081\n  - nested: 0.003\n- 10000 inserts:\n  - bare:   0.001\n  - nested: 0.431\n- 100000 inserts:\n  - bare:   0.009\n  - nested: 41.937\n- 1000000 inserts:\n  - bare:   0.112\n  - nested: ????? (didn't run, but > 1 hr if trend continues...)\n  \n...(where the un-marked values are average times, and those marked `*` are eyeballed modes over the runs, since XCTest seemingly rounds averages < 0.001 to 0.000). Tested under a Release build, FWIW.\n\nAs always whether this matters depends on problem-size and context.\n\n> -Joe\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000581.html" , "inReplyTo" : "90FCCED1-02A8-4842-8467-20B31D23AF63@apple.com" , "date" : { "$date" : 1449418058000} , "subject" : "[swift-evolution] Inquiry: Improved Composability of stdlib Collections?" , "references" : [ "C6420D4E-B7FF-4A40-B9CE-2FC92EEC6EFF@icloud.com" , "90FCCED1-02A8-4842-8467-20B31D23AF63@apple.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/B6FE292E-AD5C-417D-8F79-96EF7AECCF35@icloud.com"}} , "_id" : "B6FE292E-AD5C-417D-8F79-96EF7AECCF35@icloud.com" , "from" : "zarzycki at icloud.com (David Zarzycki)" , "mailingList" : "swift-evolution" , "content" : "Hi Jonathan,\n\nThis is really cool. Thanks for sharing! As I responded to Chris later in the thread (and to use different words), I do agree that postfix syntax is really useful, and arguably better than prefix syntax. What I was ultimately suggesting was that if Swift only had “unary” operators, then one can freely use them in either postfix or prefix positions. Just use whatever is natural for your code. The only downside of what I was suggesting is that one cannot have *different* behavior for a given operator just based on its prefix or postfix position.\n\nCheers,\nDave\n\n> On Dec 6, 2015, at 10:40, Jonathan Hull <jhull at gbis.com> wrote:\n> \n> TL;DR: Please don’t remove custom postfix operators.\n> \n> I actually rely on the custom postfix operators a great deal.\n> \n> My first real swift project was to write a PEG parser where you define the grammar rules in swift itself (which allows the rules and code to be intermixed freely… which is super useful). I can call functions or execute a block upon a match.\n> \n> The grammar uses a bunch of custom operators including several postfix ones.  Here is a snippet of rules for a grammar which allows complex math equations (This is swift code in a rules() method)\n> \n> rule(\"mathFunc\")        <- word & ( %\"mathFuncParams\" | %\"mathEmptyParams\")\n> rule(\"mathFuncParams\")  <~ \"(\"¡ ~ %\"mathExpr\" ~ (\",\"¡ ~ %\"mathExpr\")* ~ \")\"¡\n> rule(\"mathEmptyParams\") <~ \"(\"¡ ~ \")\"¡\n> \n> The only reason this works at all is that there are several overloaded operators\n> <-\t\tDefine rule\n> <~\t\tDefine rule ignoring whitespace\n> &   \t\tSequence\n> ~ \t\tSame as &, but ignore whitespace\n> |\t\tOrdered Choice\n> postfix *\tRepeat 0 or more times\n> postfix ¡\tDiscard token\n> prefix %\tReference to rule\n> \n> As mentioned above, this is useful because I can intermix swift code and PEG rules:\n> \n> rule(\"boolCompare\") <~ %\"mathExpr\" ~ %\"boolCompareType\" ~ %\"mathExpr\"=^{s in\n>     let rhs = s.stack.popMath()!\n>     let comp = s.stack.popStr()!\n>     let lhs = s.stack.popMath()!\n>     s.stack.push(Token.boolExpr(ComparisonExpr(lhs:lhs,rhs:rhs,comparison:comp)))\n> }\n>         \n> (Above: Whenever the rhs mathExpr matches, it runs code which pops the tokens off the stack and replaces them with a token representing the comparison)\n> \n> I have several projects which depend on this code, which I wouldn’t be able to do without custom operators (and postfix operators make it a lot closer to the standard PEG notation)\n> \n> Please don’t remove custom postfix operators.\n> \n> Thanks,\n> Jon\n> \n> \n> \n>> On Dec 5, 2015, at 11:26 AM, David Zarzycki via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>> \n>> Hi Chris,\n>> \n>> An observation about SE-0004: Remove the ++ and — operators:\n>> \n>> Given that the above is accepted, the only remaining postfix operator in the language is ‘!’ — and that is implemented by the compiler. Please consider just removing user-defined postfix operators entirely. Doing so would define away a type checking ambiguity where “let f : T -> T = someOperatorIdentifier” is ambiguous when both prefix and postfix operators exist.\n>> \n>> Cheers, Dave _____________________________________________ swift-evolution mailing list swift-evolution at swift.org <mailto:swift-evolution at swift.org> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000582.html" , "inReplyTo" : "2A7A8B2A-97F2-4364-9817-B28B0FA687C4@gbis.com" , "date" : { "$date" : 1449418804000} , "subject" : "[swift-evolution] Feedback for SE-0004: Remove the ++ and -- operators" , "references" : [ "A7E9633F-7227-47A7-BE95-68F839D76549@icloud.com" , "2A7A8B2A-97F2-4364-9817-B28B0FA687C4@gbis.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/49EEA2E6-55F2-49DE-A59F-A13017626370@web.de"}} , "_id" : "49EEA2E6-55F2-49DE-A59F-A13017626370@web.de" , "from" : "thorsten.seitz at web.de (Thorsten Seitz)" , "mailingList" : "swift-evolution" , "content" : "> Am 06.12.2015 um 01:28 schrieb Alex Lew via swift-evolution <swift-evolution at swift.org>:\n> \n> I don't think you can just get rid of the if statement in favor of an expression. You still want to be able to do this:\n> \n> if (condition) {\n>     funcWithSideEffectsThatReturnsInt()\n> } else {\n>     funcWithSideEffectsThatReturnsString()\n> }\n> \n> but that's not a valid expression (what is its type?).\n\nThat would actually be no problem if Swift’s type system would have union types (Ceylon has union and intersection types which are quite awesome and enable lots of nice things quite naturally, see http://ceylon-lang.org/documentation/1.2/tour/types/).\n\nIn that case the type of such an expression would just be the union of both types, which is written Int | String in Ceylon.\n\n-Thorsten" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000583.html" , "inReplyTo" : "CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com" , "date" : { "$date" : 1449419107000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com" , "CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com" , "C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com" , "18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com" , "2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io" , "BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com" , "CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com" , "CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com" , "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com" , "BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com" , "909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net" , "0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com" , "49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net" , "CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com"] , "descendants" : [ "D381E334-74B7-41EC-90BF-544A925D2204@icloud.com" , "D9043847-2CF1-40A8-9BDD-2C0DCCAB5A38@supmenow.com" , "EAEE8B4A-12A2-4FD6-BA7B-B26071F08489@gmail.com" , "CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com" , "4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com" , "CAAcV4sbQxUywKAHE=3SCACEFH4YvUqjwEr_0=fjf59ndZtoedg@mail.gmail.com" , "07270E34-E284-4FF0-B2EA-6DBB54FF78B5@portableinnovations.de" , "67057217-F4BC-4584-8B52-8EBA2CFA8CC7@portableinnovations.de" , "45B71AF5-DD4F-4E9C-A128-5B8041917564@me.com" , "CAKCGC8BmmCk55=6UC_qk_C+ZNq2JfGpOPO5cJ=SK2784kmvbGg@mail.gmail.com" , "B6DDD94B-0755-4D40-94F0-D2469A644818@portableinnovations.de" , "CAKCGC8AerqpPTrwdmPAvhmp-fLt-v=LXw4z0t+2o93g9GmAaxw@mail.gmail.com" , "54E5D8F5-616D-41EB-A550-E639FE861575@gmail.com" , "CAKCGC8CsJ7g_Fu8fnQ5Mv=yAzbSvb0Z+iNmdXKnJaAcWR2UKuw@mail.gmail.com" , "6830F74D-78FC-4B20-A6D5-683185B30164@gmail.com" , "691A92C4-1A5F-4CAE-AF50-F6AAA3A3F32C@portableinnovations.de" , "D35074A6-1C34-4BA3-AAF1-8CFE1992A522@me.com" , "1EE735A6-FF0F-4E49-BE7D-AC7E6C8A87EC@tarantsov.com" , "3D250DE5-09BC-4A6B-AF59-E1D714DF709A@tarantsov.com" , "BB6A4434-E2B1-4192-8450-90D636E6A7F5@fastmail.fm" , "0ED79E6D-A89A-4F3E-9269-6216BD10EB22@sealedabstract.com" , "CAAcV4sb9eMhuLGL3QsBw4bFxj1FQrokCAanKjEFRNNReE8zWOQ@mail.gmail.com" , "7253CF12-DBD4-483D-941F-04851E5AD394@tarantsov.com" , "CAAcV4sbo4=Hdzp+yx-km-CnhNDm2uQ-gDJsvdug_Pg-MjTPC=Q@mail.gmail.com" , "CAAcV4sbAk_eSdjz7bQ6ggdZNE+thmj7-wT_pG2+eRMKDVba+wA@mail.gmail.com" , "B619CC7E-59A8-4B3C-8E46-FC7FD4C4C6E6@apple.com" , "2372BF92-E97D-40C3-8FEC-0CA9B00ACACE@icloud.com" , "BB1D04A8-2E17-497F-AE74-8FDE4AEC4D77@fastmail.fm" , "2F722DE2-D3AE-44D5-83BB-CBCD371801AD@icloud.com" , "7B70F158-5B8A-425B-980C-CD08210342D4@me.com" , "FDB72AC4-0B0A-4D0F-A9D2-FFE43A55362E@gmail.com" , "9E0141FF-8B3B-4736-88EE-11F05930D149@fastmail.fm" , "CAAcV4sba2j1hOrBJO1kmLpLcjwSQoE0LUejbdNxa05zFzUmi3g@mail.gmail.com" , "DE316C42-6FA7-4A60-80C2-AFF74844EF09@fastmail.fm" , "33B028BA-EB5F-4986-9F16-3057390C3F16@gmail.com" , "BB8653D1-400D-49BC-AA77-6ECC096747B3@icloud.com" , "54B5FAEC-8636-44C5-96A2-0401999DD5D2@gmail.com" , "D679F068-B7C8-4DF2-A7E6-4D78B74F6B17@tarantsov.com" , "DDCE4FC9-2DED-45E5-8D9B-CAB2AA8CF9E6@gmail.com" , "C1C319DB-3934-40B6-ABEE-51B07463E6EF@upzzle.com" , "1C3ADBD7-D4CD-417A-AC45-029D7A889812@fastmail.fm" , "39024D06-E664-42EB-9E68-4D3E5BDC577D@anandabits.com" , "CAE+=ROVg0cJVKnSdwB=KPrEtr=GYd+PMMaOvbCj=N0RtUT=Q6A@mail.gmail.com" , "CAE+=ROVUD1ECe9yHG8kMW0skCFV0=BK70rw+5V7rNHEfmGhNjQ@mail.gmail.com" , "C04621E1-91D2-4A7D-9F9C-58F862B38355@icloud.com" , "581FE433-8169-4D61-9C3F-D90DAD600B9B@icloud.com" , "DB890044-1DAF-4832-8380-F78F61FBC96D@uzh.ch" , "CAE+=ROXg+tM0VYn1bscairmM9sQQ0nh1tYb4SexyWnM7TbeyaA@mail.gmail.com" , "CAE+=ROX9M8XSU8reKMf=RNCwu4Xu95V0G9W9T=Xr0nc8KerHjw@mail.gmail.com" , "CAAcV4sZKJg+x0v4rc1h=ydKE+EFEjanyBnqm8BWO=za-fF+jXA@mail.gmail.com" , "B017EE8F-7732-448E-80AB-7694904D28B4@icloud.com" , "D6AA07FC-261F-4D09-BC32-9FF7792659EC@eggerapps.at" , "CAE+=ROWf2XT2mxM5uWJCjz1Q3wZB71w=svWmGgX5v2=Y2rLzNw@mail.gmail.com" , "EB862217-2E54-4503-9C0C-DD943D428880@gmail.com" , "E0FCC493-27B9-499C-9884-4E00DB831131@gmail.com" , "934A39F6-ECB6-405B-8EF6-97E3C55604AD@uzh.ch" , "5824A613-F216-400B-AD16-9D368FA3A397@gmail.com" , "29A77367-05BF-4667-B25F-C06F520D0CB5@fastmail.fm" , "5525CD3F-062A-4ECB-809F-1964AE645CFC@gmail.com" , "CALkjWZsKQUQc0oDMkru8YGRv5rqOeqXF=4HnU2V0wo_5Q8SjnQ@mail.gmail.com" , "047B4955-1E5A-4A77-BAE3-63E8633A3AE1@gmail.com" , "CAE+=ROWxmKEic9DxN+CXyf=O7AtxgoHox5tSM1SCy_6E0ODphQ@mail.gmail.com" , "A7043ACA-9CE9-4739-919F-93F65FE7273B@gmail.com" , "6137630B-E3E8-45C6-AB48-FABFE9586EA9@me.com" , "CBB03FEA-50E2-4D7B-92B5-FB8A74B6719A@icloud.com" , "28E69DC8-4663-4FB6-8F99-F645E5D3F960@gmail.com" , "CAAcV4sZRQkVeBSqHv8UE_SJh-oEzZ74W6zd+sYxwEKhYZYsfxA@mail.gmail.com" , "CAAcV4sbakzYnefbui=hYKRDTMkrN_s1hFTn3CLwZUzWWa0M3LA@mail.gmail.com" , "63683E0A-B1FE-42A1-9878-FFEA34D1B993@gmail.com" , "CAAcV4sY8O=z5TL41vMoW3rKCHEWH3ikD8ZVJu-AEgVBYx-JXsA@mail.gmail.com" , "CAAcV4sbgPfRGZcU2U3fHcN2nky_ZqhCspWkz9DXYCjXyZFhvOQ@mail.gmail.com" , "A97ACA91-183C-41D9-ACEF-61B74D51E5BA@icloud.com" , "A9768B92-225F-49C8-B2D1-D572E1BD93DB@gmail.com" , "3BBED4DB-4944-4D4D-8603-A9E122B108B9@fastmail.fm" , "4C94F89B-CEDF-4480-8043-ED80AE0EB76A@eggerapps.at" , "B834ABFE-0DB7-426F-B932-74CD7884E46F@icloud.com" , "D58261F7-759A-4B10-84BE-A7882D50C7A5@owensd.io" , "0FEC8813-07C3-48E2-8D76-D0EF7709DA8E@tarantsov.com" , "6C13EC21-3BF0-4633-ABAB-C91322598ABC@apple.com" , "50765AC5-1CFE-406D-9CB5-B28ABBEB84ED@fastmail.fm" , "C64EC68B-1BBE-498A-937A-257E01314DEB@apple.com" , "CALkjWZu1S0ykcnenz_Z0AEuaiyeyTpxSYRMwknqeRxJAxnJT7w@mail.gmail.com" , "CAPrQK3CZy45bfx7qTgJoCH6pkocd_9sPTc0CNrAvsrRM6Vixkg@mail.gmail.com" , "CAB056B2-A975-45B3-93BD-14DE06903042@gmail.com" , "6FDA08B7-192F-42F2-BD2F-F7980463C833@novafore.com" , "40273CEA-F386-47C3-9314-C355B2E320CB@gmail.com" , "CANGnqV1WfTHxgfk4PNTQozU31EAa7z4MZF7d0gc058F4_=EtcQ@mail.gmail.com" , "C9FD779C-AF2C-466C-B741-34D40FB47413@icloud.com" , "48DEE2AB-7D93-47AC-9296-42AD9DD987E2@gmail.com" , "A4DFD8C0-135E-4B40-A264-B7FBCD07D322@fastmail.fm" , "CALkjWZvopih52vGsUfsqzrsEPP-G02eDg=8+EKLrpCMNciW+gA@mail.gmail.com" , "CALkjWZsMC7daCZHg_SDw=EiySCZtN7knDqVhXiF6+3dKTZZTGA@mail.gmail.com" , "CAEEOKET4Ud0bbSW_-Ss6V08tLy2YhF3n1TvQ06Xk5Jjak5-GHg@mail.gmail.com" , "CAAcV4sYaK4=N=ePDkHKbiodYp3HfiHW2yFxWs0A9Rt7LJ8DYvg@mail.gmail.com" , "CAAcV4sbOpH=sbPePnKhcHNXFy-YbPubUvF5PDaoLN_Rs8yL_rw@mail.gmail.com" , "C0B48136-1470-48EB-89D8-CD1B6F8553B1@apple.com" , "7227A933-1AFF-4470-90CB-2880776CEF03@fastmail.fm" , "3017B038-022E-4E46-8ABD-74873DC4C14C@icloud.com" , "CAAcV4sZ=8N3FDgo5aJT50dPwBh=SjM5NTSFgiT6OgSGcbsdcKg@mail.gmail.com" , "A2116BA7-633C-40BA-B7EF-B6A69582C2A3@icloud.com" , "9B4EA1B7-9D30-4B60-9AD0-34119EB9837D@apple.com" , "4BBB2771-4817-4BF3-919D-D7E14826C38D@apple.com" , "D17C306A-4934-4D72-B4FA-E7897B8E82B1@gmail.com" , "99FBC506-E086-4609-8585-42CA7E7E9852@apple.com" , "CAB5C60u6fSAaFgWDw2MY-PP1sJDEDqGRObqF+WwiHoXYvTwwZg@mail.gmail.com" , "3F9131C9-B757-4211-AED4-8E71E3CE9810@anandabits.com" , "EC7C2819-0125-437D-8940-1E3F610B500D@icloud.com" , "38E32460-C46B-428A-91A1-37A74D863127@gmail.com" , "CAAcV4sZZt8mwh9_rixfQ3dAdrPV77=uuqsAvdBM5f90K8sb6hw@mail.gmail.com" , "473B2AAA-7AE4-4B09-B013-6EE9CA6AB2AA@gmail.com" , "32A23B96-9CCC-4114-8939-07EE62E7B6AC@apple.com" , "A5DF87B9-47F1-4A2D-A51B-27CB3221912D@apple.com" , "028924F8-3DD9-40F9-A907-C4DB2344043B@gmail.com" , "CAB5C60tv0=-aBnPzwDCAp8oE8Km+tB6huYPxTrZNi=ObBKXAww@mail.gmail.com" , "CAB5C60sGJPaYPFtEoKB0DC-6A11LogCQAOCeZ-C6dvkmMd2oyg@mail.gmail.com" , "277EE0B5-01B3-48CE-992F-AE838034C0F1@apple.com" , "897A3F1D-1BCB-41B3-9096-0E46DEFA844A@apple.com" , "CAB5C60vD=QyN6LqyKU431jUSQQbuBEJcGiHkwq=+nRmTFhbU9A@mail.gmail.com" , "F4ED804A-2DC1-48DE-AD7C-DBE2A0BEF047@apple.com" , "81AA5235-A524-4F1A-AAA0-EB44BFFB0FEC@architechies.com" , "34A6EE6D-AECF-4887-BEB8-0D841C7CB1F2@icloud.com" , "CAAcV4sYZ6JoLy+=XKStCyh-XTJVmttrBZvqTuNq=Decsv2NEzg@mail.gmail.com" , "F5E748B4-BD58-408D-9330-DE255B9531E9@icloud.com" , "CACOvyQXZ1-qfbz7=0R1iXudZQdFMHPPQ2GVv_5DKwFEvZEF2pA@mail.gmail.com" , "27C9213F-B866-4A98-B0DC-E1492700B28B@apple.com" , "AE17F2D6-0107-4F61-AE13-01E5236ED770@apple.com" , "C320EC78-2D4E-46A8-90ED-4175F5B80072@gmail.com" , "CAB5C60szP8_2p8qqX13ph3wDQU6iRM0P09hVmXu7ar9SvRN+vw@mail.gmail.com" , "15A5CF07-DAED-4B92-A983-D88C2FA6BC8E@gmail.com" , "2822BF6F-172E-4003-B1A4-FB1C518CB701@googlemail.com" , "414E3C0D-EEC1-4005-8D68-5CA91EBADD0F@gmail.com" , "72FA697D-D1C9-4E73-B554-7313DC940D4B@apple.com" , "63C561FE-B75F-4A9B-8DF6-B2335D4C03CB@apple.com" , "CAEEOKEQyUwgvkEvPu2Xv_xAEJWiMTgGtv=KdY-2gkzhJXR7D4A@mail.gmail.com" , "A5DE0BD4-E526-4682-82B0-9B541CEF1C15@gmail.com" , "CAB5C60tn=nNstD2ke_RACYJsmAVvWQx-vJV=PfhqsOgaKx9pfw@mail.gmail.com" , "30B4EAF6-C852-4691-B397-24086AE1F9D9@icloud.com" , "1E2BDCE0-2132-40E8-96BC-BA51233281C7@novafore.com" , "C5F7CACF-736F-4794-B38E-0BE409F96835@novafore.com" , "FAEB0D09-1CB7-4706-B4CC-43DF40A2D243@apple.com" , "03C1FF36-43C3-46D1-88A1-3ECDCBB56567@gmail.com" , "CAB5C60sXr46WbfmaUctNKfWk01G_4pHgktykf4dJQZDbQ1QPWA@mail.gmail.com" , "4FB8F138-A0EF-4DDF-9AAD-A7172195F469@novafore.com" , "0C330020-F7D9-45D0-9B2D-E4DAD3AE105C@anandabits.com" , "CAB5C60vXzip01M6r62uQdkrXCxfBaQPgU7tdHsz+0Tu0i4Zksw@mail.gmail.com" , "BED20179-20C3-4F3A-B5D5-5E09286333F5@anandabits.com" , "CAKCGC8CWGc1L0fsc7TtzDeCqu5bxPX3q3MMZCw+2HPGuPHHC1A@mail.gmail.com" , "7D68F57E-C847-4E0D-AF3A-FD1F2DC928A9@icloud.com" , "1449429569.1342623.459603529.32C935BC@webmail.messagingengine.com" , "11462DA4-ACDD-4CF3-BD57-47886B655970@anandabits.com" , "CAKCGC8AVDe6W9X=XvFEnbkae8xom2Us8xczKFShqKu2+kPnRJA@mail.gmail.com" , "0DF0732F-0958-47C1-A6C3-62A8AB2F4386@icloud.com" , "CAKCGC8BEzyEPAFWCPKPiH+UL3KmZm7aM6KUPu-F9DKV-YvUbCA@mail.gmail.com" , "4A5C6452-0A1B-42A3-AFD4-3DEA04E310C6@icloud.com" , "6DA2FDFF-F978-4ECA-9E2B-F757F6D8BBF3@icloud.com" , "2116BFD1-25BC-4B9F-A3A6-08758782BB88@anandabits.com" , "C919D677-30C0-4F1E-B221-9B28365D67A9@gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/112B3CB9-7E8E-4DA6-8A20-6C2E8848E58B@alkaline-solutions.com"}} , "_id" : "112B3CB9-7E8E-4DA6-8A20-6C2E8848E58B@alkaline-solutions.com" , "from" : "david at alkaline-solutions.com (David Waite)" , "mailingList" : "swift-evolution" , "content" : "Nearly every for loop I’ve written in other languages has used pre or post increment (depending on the language), which is being removed in Swift 3.0. It makes sense for 'for loops' to go if pre/post increment goes away.\n\n-DW\n\n> On Dec 6, 2015, at 9:03 AM, Don Wills via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> I too hope that the proposal to remove C-style loops is rejected.  Yes, they aren't that necessary any more, but if we want Swift to compete with Java, C#, C++ and C, there is no reason to remove basic features like C-style loops just because they are politically incorrect.  If there was a functional reason, I might get on board with removing it, but there isn't.\n> \n> I also hope that the decision to remove increment and decrement operators is reversed using the same logic.  Just because *you* don't like something that has been a feature of dozens of programming languages for 40 years doesn't mean removing that feature is a good idea.  One man's goto statement is another man's Leatherman multi-tool.  And FWIW, if C-style loops stay in the language, they become much more ugly without increment and decrement.\n> \n> Don Wills\n> \n>> On Dec 6, 2015, at 8:33 AM, inbox only via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>> \n>> True,even that a feature isn't used doesn't mean that you need to remove that feature.\n>> I hope that the proposal will be rejected.\n>> \n>> 2015-12-06 12:03 GMT+02:00 Clemens Wagner via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>>:\n>> > We’ve developed a number of Swift apps for various clients over the past year and have not needed C style for loops either.\n>> \n>> But I think this is a very weak reason for *removing* any portion like C-loops and increment or decrement operators of a programming language. How about the developers and the productive code which used C-style loops already?\n>> \n>> I understand the reasons why you, Erica and the others don’t like C-style loops. But changing the philosophy of a productive programming language is a very bad idea.\n>> \n>> Cheers\n>> Clemens\n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>> \n>>  _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n> \n>  _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000584.html" , "inReplyTo" : "B9F4EA1D-98F9-4A2B-8D16-9073FBDD54A5@portablesoftware.com" , "date" : { "$date" : 1449419490000} , "subject" : "[swift-evolution] C-style For Loops" , "references" : [ "AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de" , "CAOjGmwn6O2uvJBq03GZyJ+yngfAB4=rqb60dCCfpP2x7rmnEyg@mail.gmail.com" , "B9F4EA1D-98F9-4A2B-8D16-9073FBDD54A5@portablesoftware.com"] , "descendants" : [ "9C647949-D1C6-4EB3-A964-04312A957B2F@gmx.de" , "F3CA2962-24DB-438C-B5B8-13B33A3ACDD6@architechies.com" , "A1CD1E1C-07C2-40AA-AB39-EECDB0C09323@springsandstruts.com" , "B0FB69E4-C275-4E6E-9B18-6A3354164938@springsandstruts.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/51ADA439-E20B-4C68-B736-44C41E46A6F0@web.de"}} , "_id" : "51ADA439-E20B-4C68-B736-44C41E46A6F0@web.de" , "from" : "thorsten.seitz at web.de (Thorsten Seitz)" , "mailingList" : "swift-evolution" , "content" : "Hi Roy,\n\nI’d prefer if such special syntax would not be reserved for just async computations but used for monadic computations in general (with the async case just being a monad implementation).\n\n-Thorsten\n\n> Am 06.12.2015 um 10:21 schrieb Roy Fu via swift-evolution <swift-evolution at swift.org>:\n> \n> Hi all,\n> \n> Similar to the syntax ‘do try catch throw’ and ’throws’ for error handling, I propose another syntax for handling CPS functions or async call backs:\n> \n> func someFutureWrappedFunc(input: Int) future-> String{\n>     doSomeStaffInBackground{ (result:String) in\n>         fulfil result\n>     }\n> }\n> \n> do{\n>     let resultX = perform someFutureWrappedFunc(param)\n>     let resultY = perform anotherFutureWrappedFunc(resultX)\n>     let final   = resultX + resultY + perform justAnotherFutureWrappedFunc(resultX)\n>     self.someLabel.text = final\n> } timeout let context {\n>     //maybe some additional information\n> }\n> \n> the reason for this proposal is for the importance of async models in modern application  architectures, and avoid such pyramids:\n> \n> doSomeStaffInBackground { (resultX) -> Void in\n>     \n>     doSomeOtherStaff { (resultY) -> Void in\n>         \n>         if resultY.someCondition(resultX) {\n>             \n>             evenMakesItMadness(resultY) { (final) -> Void in\n>                 \n>                 //finally\n>             }\n>         }\n>     }\n> }\n> \n> \n> \n> \n> For more context comparing this async syntax to the ‘do try catch’:\n> \n> do try catch:\n> enum Result<T> {\n>     case Success(T)\n>     case Failure(ErrorType)\n> }\n> \n> func flatMap<T,U> (result:Result<T>, f:T->Result<U>) -> Result<U>{\n>     switch result{\n>     case .Success(let v): return f(v)\n>     case .Failure(let e): return .Failure(e)\n>     }\n> }\n> \n> func wrap1<T,U>(f:T throws-> U) -> T->Result<U> {\n>     return {\n>         do{\n>             return try .Success(f($0))\n>         }catch let e{\n>             return .Failure(e)\n>         }\n>     }\n> }\n> \n> func wrap2<T,U>(f:T -> Result<U>) -> T throws-> U{\n>     return{\n>         switch f($0){\n>         case .Success(let v): return v\n>         case .Failure(let e): throw e\n>         }\n>     }\n> }\n> \n> async:\n> \n> func flatMap<T,U> (async: (T -> Void) -> Void, f:T -> (U->Void) -> Void) -> (U -> Void) -> Void {\n>     return{ cont in\n>         async{ f($0)(cont) }\n>     }\n> }\n> \n> func wrap1<T,U>(f:T future-> U) -> T->(U->Void)->Void {\n>     return {input in\n>         {cont in\n>             do{\n>                 cont(perform f(input))\n>             }catch _{\n> \n>             }\n>         }\n>     }\n> }\n> \n> func wrap2<T,U>(f:T -> (U->Void)->Void) -> T future-> U{\n>     return{\n>         f(input)({\n>             fulfil $0\n>         })\n>     }\n> }\n> \n> \n> \n> \n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000585.html" , "inReplyTo" : "78552B11-3A65-4239-8B33-990E34FEA48A@gmail.com" , "date" : { "$date" : 1449419760000} , "subject" : "[swift-evolution] Proposal: Syntax sugar for cps or async functions similar to the \"do try catch\" for error handling." , "references" : [ "78552B11-3A65-4239-8B33-990E34FEA48A@gmail.com"] , "descendants" : [ "339C6733-8C92-4616-A6A8-46FBF476923B@gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/0413C70D-A999-46F1-8D46-FEEC93F2C2FC@gmail.com"}} , "_id" : "0413C70D-A999-46F1-8D46-FEEC93F2C2FC@gmail.com" , "from" : "vinivendra at gmail.com (Vinicius Vendramini)" , "mailingList" : "swift-evolution" , "content" : "While I understand the motivation behind this change, I think it’s pretty far from paying the addition of a new language feature. Is this\n\nlet questionLabel = UILabel() {\n    $0.textAlignment = .Center\n    $0.font =  UIFont(name:\"DnealianManuscript\", size: 72)\n    $0.text = currentQuestion.questionText\n    $0.numberOfLines = 0\n    view.addSubview($0)\n}\n\nreally that much better than this?\n\nlet label = UILabel()\n\nlabel.textAlignment = .Center\nlabel.font =  UIFont(name:\"DnealianManuscript\", size: 72)\nlabel.text = currentQuestion.questionText\nlabel.numberOfLines = 0\nview.addSubview(label)\n\nTo be honest, the second looks much more readable to me. I like the indentation of the first one, but that doesn’t sound like enough of a reason: one could easily re-indent the lines to one’s liking (which actually looks kinda good with 4-spaces indentation, since `var` or `let` plus a space equals 4 characters:)\n\nlet label = UILabel()\n    label.textAlignment = .Center\n    label.font =  UIFont(name:\"DnealianManuscript\", size: 72)\n    label.text = currentQuestion.questionText\n    label.numberOfLines = 0\n    view.addSubview(label)\n\nAs far as I understand the proposals so far, this approach only changes the way we’d write the initialization, but doesn’t actually allow us to do something that couldn’t be done earlier (e.g. access internal members, change immutable variables…) right? \n\n\n> On Dec 5, 2015, at 11:31 PM, Matthew Johnson via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> As stated previously, I think a more specific solution is the best way to address the initialization / setup / configuration problem. While that is the case I did think some more about the ideas in this thread.\n> \n> I believe two things are being proposed here:\n> \n> 1. The ability to append a trailing closure to any initializer (that doesn’t already declare one itself) that accepts a single argument of the initialized type.  If the caller supplies such a closure, the compiler performs a code transformation as follows:\n> \n> let questionLabel = UILabel() {\n> \t$0.textAlignment = .Center\n> \t$0.font =  UIFont(name:\"DnealianManuscript\", size: 72)\n> \t$0.numberOfLines = 0\n> }\n> \n> becomes something like this (which is valid Swift today:\n> \n> let questionLabel = UILabel(); {\n> \t$0.textAlignment = .Center\n> \t$0.font =  UIFont(name:\"DnealianManuscript\", size: 72)\n> \t$0.numberOfLines = 0\n> }(questionLabel)\n> \n> The code transformation doesn’t actually buy us much.  I’m a big believer in removing the need for clutter and boilerplate as much as possible, but even I must admit that the difference is really small and can be reduced a bit further using currently valid Swift code as demonstrated by the “configuration operator” mentioned in the previous post.\n> \n> 2. A new abbreviation of the $0 shorthand that would be valid only as the first characters on a line of code.  For consistency this shorthand should work in any closure, not just in “setup closures”.  I agree that $0 is uglier than necessary in this use case which would be relatively common in Cocoa code if this pattern becomes common.\n> \n> The biggest drawback I can think of to a feature like this is that it is a feature specifically designed to make the use of var members more convenient.  It might be a good thing that “setup closures\" are a little bit ugly given that they are only able to “setup\" mutable members and require those members to be initialized to potentially meaningless default values (or worse, IUO members defaulted to nil!).  \n> \n> Ideally an instance would be configured correctly when the initializer completes and we should work to find language solutions to make this safe and convenient.  Once we have the right language solutions ideally we can use them in new types and retrofit existing types to use them over time, thus eliminating the need for “setup closures” alltogether.\n> \n> \n>> On Dec 5, 2015, at 6:16 PM, ilya via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>> \n>> > PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.  Here's one example: ...\n>> \n>> FWIW, I created a configuration operator more then a year ago, and use it in all of my Swift projects:\n>> \n>> let task = NSTask() +=+ {\n>>     $0.launchPath = \"/usr/bin/mdfind\"\n>>     $0.arguments = [\"kMDItemDisplayName == *.playground\"]\n>>     $0.standardOutput = pipe\n>> }\n>> \n>> Note you can also use the configured object in the rhs:\n>> \n>> let questionLabel = UILabel() +=+ {\n>>     $0.textAlignment = .Center\n>>     $0.font =  UIFont(name:\"DnealianManuscript\", size: 72)\n>>     $0.text = currentQuestion.questionText\n>>     $0.numberOfLines = 0\n>>     view.addSubview($0)\n>> }\n>> \n>> This $0. certainly looks ugly and it would be great to be able to simplify this. I don't llike the following much though (dot-syntax can be ambiguos here, and using simply a method name is even worse):\n>> \n>> let questionLabel = UILabel() +=+ {\n>>     .textAlignment = .Center\n>>     .font =  UIFont(name:\"DnealianManuscript\", size: 72)\n>>     .text = currentQuestion.questionText\n>>     .numberOfLines = 0\n>>     view.addSubview($0)\n>> }\n>> \n>> Actually I would be happy with something like\n>> \n>> let questionLabel = UILabel() .{\n>>     ..textAlignment = .Center\n>>     ..font = UIFont(name:\"DnealianManuscript\", size: 72)\n>>     ..text = currentQuestion.questionText\n>>     ..numberOfLines = 0\n>>     view.addSubview($0)\n>> }\n>> \n>> Other thoughts?\n>> \n>>   \n>>  _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n> \n>  _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000586.html" , "inReplyTo" : "849CDDCE-CC11-4DA1-A8D4-F0440049231C@anandabits.com" , "date" : { "$date" : 1449419795000} , "subject" : "[swift-evolution] Request for Discussion: Setup closures" , "references" : [ "CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com" , "849CDDCE-CC11-4DA1-A8D4-F0440049231C@anandabits.com"] , "descendants" : [ "AA0220E6-BD02-4B04-98DF-C73C00F8FB0C@anandabits.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/6B38C1F5-9623-4706-BC2A-F9A5F9665AB6@apple.com"}} , "_id" : "6B38C1F5-9623-4706-BC2A-F9A5F9665AB6@apple.com" , "from" : "clattner at apple.com (Chris Lattner)" , "mailingList" : "swift-evolution" , "content" : "Yes, it that proposal is capable of expressing this, then that is how I would prefer property observers in general to work.\n\n-Chris\n\n> On Dec 6, 2015, at 3:27 AM, David Hart <david at hartbit.com> wrote:\n> \n> Chris, wouldn't that be better designed/implemented with the property delegate functionality Joe Groff is working on?\n> \n>> On 06 Dec 2015, at 07:52, Chris Lattner via swift-evolution <swift-evolution at swift.org> wrote:\n>> \n>> \n>>> On Dec 5, 2015, at 10:42 PM, Mosab Elagha <elagha2 at illinois.edu> wrote:\n>>> \n>>> +1. This feature would allow for a more clean approach in checking the existing state of a value. \n>>> \n>>> > Also, can a property have these observers as well as the existing ones?\n>>> \n>>> I'm not really familiar with the implementation of the observers, but why wouldn't it be able to? Maybe didSet can precede didChange in order of execution if both are implemented, so you can have default behavior when accessing a value but certain other behavior if it has changed. Or maybe have willChange/didChange be a property that can be accessed within willSet/didSet (like oldValue).\n>> \n>> I believe it is possible to implement, I’m just trying to give guidance on the sorts of things a formal proposal should address.\n>> \n>> -Chris\n>> \n>>> \n>>> \n>>> \n>>> -Mosab Elagha\n>>> \n>>>> On Sun, Dec 6, 2015 at 12:11 AM, Chris Lattner via swift-evolution <swift-evolution at swift.org> wrote:\n>>>> \n>>>>> On Dec 5, 2015, at 4:00 PM, Nathan de Vries via swift-evolution <swift-evolution at swift.org> wrote:\n>>>>> \n>>>>> It's currently possible to define either or both of the following observers on a property:\n>>>>> willSet, called just before the value is stored\n>>>>> didSet, called immediately after the new value is stored\n>>>> \n>>>> ...\n>>>> \n>>>>> This would mean the following observers could be defined on a property:\n>>>>> willSet, called just before the value is stored\n>>>>> willChange, called just before the value is stored if the value is different to the previous value\n>>>>> didSet, called immediately after the new value is stored\n>>>>> didChange, called immediately after the new value is stored if the new value is different to the previous value\n>>>> \n>>>> I’m open to consider a change along these lines, but the proposal would have to be fleshed out more.  Presumably it would only work for equatable types, right?  Also, can a property have these observers as well as the existing ones?  Would it be possible to add *one of* didChange or willChange - since less is better?\n>>>> \n>>>> -Chris\n>>>> \n>>>> \n>>>> _______________________________________________\n>>>> swift-evolution mailing list\n>>>> swift-evolution at swift.org\n>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>> \n>> \n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000587.html" , "inReplyTo" : "014D53AE-029B-40BE-8C7B-A7ED7FBDA81C@hartbit.com" , "date" : { "$date" : 1449420165000} , "subject" : "[swift-evolution] Proposal: Allow willChange and didChange observers on a property" , "references" : [ "A289D8DB-F4F0-43B6-9F05-C57B04478A4A@apple.com" , "9AC32EEA-ED5F-421E-9B75-E2BB0516667C@apple.com" , "CAA60hjLpFH3u_eQVQvOjZ+gvOa++VdALYUbSGiNCwKQcyO+QFA@mail.gmail.com" , "9D162271-E4B5-45D9-AEC5-60405A70C1EF@apple.com" , "014D53AE-029B-40BE-8C7B-A7ED7FBDA81C@hartbit.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CE57813E-C13D-47C6-9CEA-32B26789A0BE@apple.com"}} , "_id" : "CE57813E-C13D-47C6-9CEA-32B26789A0BE@apple.com" , "from" : "anthony.parker at apple.com (Tony Parker)" , "mailingList" : "swift-evolution" , "content" : "Hi Chris,\n\nThanks for bringing this idea to the list.\n\nIs NSDate really the only thing that we want to conform to comparable, or is there a set of classes which should do so? I’d like to think about the larger set of consequences here (and if possible, deal with one coherent answer for all of Foundation rather than do these classes one at a time).\n\n- Tony\n\n> On Dec 5, 2015, at 3:36 PM, Chris Amanse via swift-corelibs-dev <swift-corelibs-dev at swift.org> wrote:\n> \n> Hello Swift Developers,\n> \n> I think it's a good idea to conform NSDate to the Comparable protocol, so instead of using:\n> \n> if someDate.compare(today) == .OrderedAscending { }\n> \n> Developers can easily compare using compare dates using comparison operators:\n> \n> if someDate < today { }\n> \n> In my opinion, the code is still readable if developers use comparison operators on NSDates.\n> \n> Here's a quick implementation from my swift-corelibs-foundation fork: https://github.com/chrisamanse/swift-corelibs-foundation/commit/3c4eff643c5271de5bec2461798051347be13916 <https://github.com/chrisamanse/swift-corelibs-foundation/commit/3c4eff643c5271de5bec2461798051347be13916>\n> \n> Thank you.\n>  _______________________________________________\n> swift-corelibs-dev mailing list\n> swift-corelibs-dev at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-corelibs-dev" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000588.html" , "inReplyTo" : "CAEryqghYNO4JKWRGkF_qFTew7cGPtG7iNP32DndN1dOHLkjATQ@mail.gmail.com" , "date" : { "$date" : 1449420457000} , "subject" : "[swift-evolution] [swift-corelibs-dev] Proposal: Conforming NSDate to Comparable" , "references" : [ "CAEryqghYNO4JKWRGkF_qFTew7cGPtG7iNP32DndN1dOHLkjATQ@mail.gmail.com"] , "descendants" : [ "90204A78-4C14-4A1E-9F99-4FFF1FDDFCC2@gmail.com" , "CAEryqghXu8EGTjWcsPjk5tUbYDfC0E1xTD_rBT=hY7uR1aO7pg@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/9354DB3D-8EFE-4AA9-B372-1FBB575381D7@web.de"}} , "_id" : "9354DB3D-8EFE-4AA9-B372-1FBB575381D7@web.de" , "from" : "thorsten.seitz at web.de (Thorsten Seitz)" , "mailingList" : "swift-evolution" , "content" : "+1\n\n-Thorsten\n\n> Am 06.12.2015 um 01:13 schrieb Austin Zheng via swift-evolution <swift-evolution at swift.org>:\n> \n> No, I don't. I think Python's biggest appeal to new programmers is the fact that it has such a great standard library, making it really easy to do whatever you want to do without figuring out how to find or add in external dependencies.\n> \n> Anyways, mistyped Python code still breaks, it just breaks at runtime instead of compile time. In fact, I'd argue that this is even less beginner friendly, since you might write a function that works with some inputs and then inexplicably breaks with others.\n> \n> Austin\n> \n>> On Dec 5, 2015, at 4:09 PM, Amir Michail <a.michail at me.com <mailto:a.michail at me.com>> wrote:\n>> \n>> \n>>> On Dec 5, 2015, at 7:05 PM, Austin Zheng via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>> \n>>> ml>\n>>> I disagree with the idea that a type system is too much of a hurdle for beginner programmers to overcome.\n>> \n>> Don’t you think that Python currently provides a better introduction to programming due to its simplicity?\n>> \n>>> \n>>> Austin\n>>> \n>>>> On Dec 5, 2015, at 4:01 PM, Kevin Lundberg via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>>> \n>>>> This is somewhat possible today on Apple platforms with AnyObject. You can call any objc-visible method on AnyObject and it will compile, and the return type will also be AnyObject (I don't recall if the return type is optional as well or not). This doesn't work with value types, but neither does id in objc.\n>>>> \n>>>> Having a more complete lax typed mode similar to Python or php I think is of limited usefulness, would add too much complexity to the language, and yield too much uncertainty about any given piece of swift code. \n>>>> \n>>>> --\n>>>> Kevin Lundberg\n>>>> \n>>>> On Dec 5, 2015, at 6:50 PM, Adrian Kashivskyy via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>>> \n>>>>> I can't believe I'm seeing a proposal to remove type safety, one of the fundamental features of Swift...\n>>>>> \n>>>>> Regards,\n>>>>> Adrian Kashivskyy\n>>>>> iOS Developer at Netguru\n>>>>> \n>>>>>> Wiadomość napisana przez Amir Michail via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> w dniu 05.12.2015, o godz. 20:51:\n>>>>>> \n>>>>>> Python is still easier than Swift for beginning programmers. But maybe such a mode can allow Swift to be used by beginners also? _____________________________________________ swift-evolution mailing list swift-evolution at swift.org <mailto:swift-evolution at swift.org> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>> _______________________________________________\n>>>>> swift-evolution mailing list\n>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>> _______________________________________________\n>>>> swift-evolution mailing list\n>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>> \n>>> --rbÚḟîẁ\n>>> íz{CÊhĠ+bḃx§)Ŷ_______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>> https://lists.swift.org/ma <https://lists.swift.org/ma>\n> \n>  _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000589.html" , "inReplyTo" : "B3DEBE77-A879-4A1E-BC4D-1F028E6D326A@gmail.com" , "date" : { "$date" : 1449420723000} , "subject" : "[swift-evolution] A mode with no type checking to compete with Python." , "references" : [ "5E968E10-2DBD-4999-978C-B398BC446A21@me.com" , "7240610C-B5DA-41B8-909A-D138404C6799@me.com" , "0CFEA686-79B9-4B51-A984-7C706879BB5D@klundberg.com" , "E2C52ABB-8CD4-4D5C-BFA3-F3EA995AC6FC@gmail.com" , "7F08A62B-6FD7-4AF2-A939-EF1D3CD71BD7@me.com" , "B3DEBE77-A879-4A1E-BC4D-1F028E6D326A@gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/AA0220E6-BD02-4B04-98DF-C73C00F8FB0C@anandabits.com"}} , "_id" : "AA0220E6-BD02-4B04-98DF-C73C00F8FB0C@anandabits.com" , "from" : "matthew at anandabits.com (Matthew Johnson)" , "mailingList" : "swift-evolution" , "content" : "I agree that this is pretty far from paying for a language feature.  I much prefer the ideas we are discussing in the \"helpers for initializing properties of same name as parameters\" thread for reasons already stated.\n\nSent from my iPad\n\n> On Dec 6, 2015, at 10:36 AM, Vinicius Vendramini <vinivendra at gmail.com> wrote:\n> \n> While I understand the motivation behind this change, I think it’s pretty far from paying the addition of a new language feature. Is this\n> \n> let questionLabel = UILabel() {\n>     $0.textAlignment = .Center\n>     $0.font =  UIFont(name:\"DnealianManuscript\", size: 72)\n>     $0.text = currentQuestion.questionText\n>     $0.numberOfLines = 0\n>     view.addSubview($0)\n> }\n> \n> really that much better than this?\n> \n> let label = UILabel()\n> \n> label.textAlignment = .Center\n> label.font =  UIFont(name:\"DnealianManuscript\", size: 72)\n> label.text = currentQuestion.questionText\n> label.numberOfLines = 0\n> view.addSubview(label)\n> \n> To be honest, the second looks much more readable to me. I like the indentation of the first one, but that doesn’t sound like enough of a reason: one could easily re-indent the lines to one’s liking (which actually looks kinda good with 4-spaces indentation, since `var` or `let` plus a space equals 4 characters:)\n> \n> let label = UILabel()\n>     label.textAlignment = .Center\n>     label.font =  UIFont(name:\"DnealianManuscript\", size: 72)\n>     label.text = currentQuestion.questionText\n>     label.numberOfLines = 0\n>     view.addSubview(label)\n> \n> As far as I understand the proposals so far, this approach only changes the way we’d write the initialization, but doesn’t actually allow us to do something that couldn’t be done earlier (e.g. access internal members, change immutable variables…) right? \n> \n> \n>> On Dec 5, 2015, at 11:31 PM, Matthew Johnson via swift-evolution <swift-evolution at swift.org> wrote:\n>> \n>> As stated previously, I think a more specific solution is the best way to address the initialization / setup / configuration problem. While that is the case I did think some more about the ideas in this thread.\n>> \n>> I believe two things are being proposed here:\n>> \n>> 1. The ability to append a trailing closure to any initializer (that doesn’t already declare one itself) that accepts a single argument of the initialized type.  If the caller supplies such a closure, the compiler performs a code transformation as follows:\n>> \n>> let questionLabel = UILabel() {\n>> \t$0.textAlignment = .Center\n>> \t$0.font =  UIFont(name:\"DnealianManuscript\", size: 72)\n>> \t$0.numberOfLines = 0\n>> }\n>> \n>> becomes something like this (which is valid Swift today:\n>> \n>> let questionLabel = UILabel(); {\n>> \t$0.textAlignment = .Center\n>> \t$0.font =  UIFont(name:\"DnealianManuscript\", size: 72)\n>> \t$0.numberOfLines = 0\n>> }(questionLabel)\n>> \n>> The code transformation doesn’t actually buy us much.  I’m a big believer in removing the need for clutter and boilerplate as much as possible, but even I must admit that the difference is really small and can be reduced a bit further using currently valid Swift code as demonstrated by the “configuration operator” mentioned in the previous post.\n>> \n>> 2. A new abbreviation of the $0 shorthand that would be valid only as the first characters on a line of code.  For consistency this shorthand should work in any closure, not just in “setup closures”.  I agree that $0 is uglier than necessary in this use case which would be relatively common in Cocoa code if this pattern becomes common.\n>> \n>> The biggest drawback I can think of to a feature like this is that it is a feature specifically designed to make the use of var members more convenient.  It might be a good thing that “setup closures\" are a little bit ugly given that they are only able to “setup\" mutable members and require those members to be initialized to potentially meaningless default values (or worse, IUO members defaulted to nil!).  \n>> \n>> Ideally an instance would be configured correctly when the initializer completes and we should work to find language solutions to make this safe and convenient.  Once we have the right language solutions ideally we can use them in new types and retrofit existing types to use them over time, thus eliminating the need for “setup closures” alltogether.\n>> \n>> \n>>> On Dec 5, 2015, at 6:16 PM, ilya via swift-evolution <swift-evolution at swift.org> wrote:\n>>> \n>>> > PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.  Here's one example: ...\n>>> \n>>> FWIW, I created a configuration operator more then a year ago, and use it in all of my Swift projects:\n>>> \n>>> let task = NSTask() +=+ {\n>>>     $0.launchPath = \"/usr/bin/mdfind\"\n>>>     $0.arguments = [\"kMDItemDisplayName == *.playground\"]\n>>>     $0.standardOutput = pipe\n>>> }\n>>> \n>>> Note you can also use the configured object in the rhs:\n>>> \n>>> let questionLabel = UILabel() +=+ {\n>>>     $0.textAlignment = .Center\n>>>     $0.font =  UIFont(name:\"DnealianManuscript\", size: 72)\n>>>     $0.text = currentQuestion.questionText\n>>>     $0.numberOfLines = 0\n>>>     view.addSubview($0)\n>>> }\n>>> \n>>> This $0. certainly looks ugly and it would be great to be able to simplify this. I don't llike the following much though (dot-syntax can be ambiguos here, and using simply a method name is even worse):\n>>> \n>>> let questionLabel = UILabel() +=+ {\n>>>     .textAlignment = .Center\n>>>     .font =  UIFont(name:\"DnealianManuscript\", size: 72)\n>>>     .text = currentQuestion.questionText\n>>>     .numberOfLines = 0\n>>>     view.addSubview($0)\n>>> }\n>>> \n>>> Actually I would be happy with something like\n>>> \n>>> let questionLabel = UILabel() .{\n>>>     ..textAlignment = .Center\n>>>     ..font = UIFont(name:\"DnealianManuscript\", size: 72)\n>>>     ..text = currentQuestion.questionText\n>>>     ..numberOfLines = 0\n>>>     view.addSubview($0)\n>>> }\n>>> \n>>> Other thoughts?\n>>> \n>>>   \n>>>  _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>> \n>>  _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000590.html" , "inReplyTo" : "0413C70D-A999-46F1-8D46-FEEC93F2C2FC@gmail.com" , "date" : { "$date" : 1449421145000} , "subject" : "[swift-evolution] Request for Discussion: Setup closures" , "references" : [ "CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com" , "849CDDCE-CC11-4DA1-A8D4-F0440049231C@anandabits.com" , "0413C70D-A999-46F1-8D46-FEEC93F2C2FC@gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/40642775-F58D-49B0-9BF3-38913FD6924C@ericasadun.com"}} , "_id" : "40642775-F58D-49B0-9BF3-38913FD6924C@ericasadun.com" , "from" : "erica at ericasadun.com (Erica Sadun)" , "mailingList" : "swift-evolution" , "content" : "Last week, I made the following proposal for Swift:\n\nThe C-style for-loop appears to be a mechanical carry-over from C rather than a genuinely Swift-specific construct. It is rarely used and not very Swift-like.\n\nMore Swift-typical construction is already available with for-in statements and stride. Removing for loops would simplify the language and starve the most common use-points for -- and ++, which are already due to be eliminated from the language.\n\nThe value of this construct is limited and I believe its removal should be seriously considered.\n\nYesterday, I was on family time. Today, I am grabbing a little Swift-break to respond to the discussion I otherwise missed on-list. Please forgive the lateness of this response.\n\nLack of Language Necessity\n\nClemens writes:\n> We’ve developed a number of Swift apps for various clients over the past year and have not needed C style for loops either.\n\n\nBut I think this is a very weak reason for *removing* any portion like C-loops and increment or decrement operators of a programming language. How about the developers and the productive code which used C-style loops already?\n\nI understand the reasons why you, Erica and the others don’t like C-style loops. But changing the philosophy of a productive programming language is a very bad idea.\n\nI don't think the C-style loop was ever really part of the language philosophy. It feels like a vestigial feature that no one ever got around to cleaning up. Its entire functionality is easily replaced by other, existing Swift constructs. While Swift design deliberately held onto C-like features for familiarity, I see no special benefit to retaining the for-loop.\n\nIn contrast, consider fallthrough. There was a discussion on Friday about fallthrough, and it quickly became apparent that losing this language feature would have a significant impact on a few key algorithms. Several list participant were able to pop forward and say \"without this feature, I would not be able to do X, Y or Z\". I see no parallel case to be made for for-loops.\n\nLowered Readability and Maintainability\n\nI have aesthetic reasons for disliking the for-loop. The C-style loop is harder to read especially for those not coming from C-style languages, easier to mess up at edge conditions, and is commonly used for side-effects which, in a language focused on safety, is not a feature to be encouraged. \n\nFor example, one side effect that was mentioned on-list yesterday was the incrementor, which is guaranteed in C-style to execute late:\nRoland King writes:\n\nfor var floatingThing = start ; floatingThing <= end ; floatingThing += delta\n{\n\t// more than a few lines of code with early escape continues\n}\n\nshows intent of the loop very clearly, start, condition and increment all together at the top, and however you loop you always execute the increment part of the statement. Convert that to a while(), if you have a continue in the body, you have a good chance of not incrementing at all, or duplicating the increment code before every continue. So you can’t always nicely turn for into while. I second the point below about the loop variable being local to the for as well, I also like that. \n\nLate incrementor management is a feature that can be mimicked with defer, as pointed out by several other list members.\n\nAnother complaint regarded a loss of succinctness. Per Melin wrote: \n\nAnother example from the same LinkedList class. It finds the right place to insert a new node:\n\n  for next = head; next != nil && index > 0; prev = next, next = next!.next, --index { }\n\nExtreme? Probably, but I like it better than the same thing done in five lines of while loop.\n\nI'd argue that readability and maintainability are core API goals. Clarity is always to be preferred to brevity. Let me point you to Justin Etheredge's essay \"Don't be clever\" (http://www.codethinked.com/dont-be-clever). \n\nSo next time you go to write a super clever line of code, think to yourself \"Will the benefits of this super cleverness be outweighed by the future issues in maintaining and understanding the code?\" And if there is anyhesitation at all, then you better not be clever, because 3 months from now you will come across that code and say \"What the hell was I thinking?\" Then you’ll end up rewriting it anyway.\n\nIncrementor Challenges\n\nAnother complaint involved forgetting or misplacing the incrementor when transforming items to while loops. There are two cases being glommed together here, and I'd like to separate them.\n\nFirst, there's a collection case, in which the collection provides its own indices. In such implementations, there's simply no need to manually declare and manage an index. You can use for-in.\n\nSecond, there's what I'm going to call the bitmap case, where an index may refer to geometrically-related indices, which happens often in image processing. (I'm going to repress any \"Just use Accelerate\" rant. This is a significant area of programming).  Here's some pseudocode that demonstrates how this might look in a for-loop-less Swift implementation:\n\n    for row in 0..<height {\n        for column in 0..<width {\n            var sum: UInt = 0\n            for rowOffset in -1...1 {\n                for columnOffset in -1...1 {\n                    let index = pixelOffsetAt(row + rowOffset, column + columnOffset) + redChannelOffset\n                    sum += pixels[index]\n                }\n            }\n            let currentRedPixelBlurredAverage = sum / 9\n            // blah blah other stuff\n        }\n    }\n\nAgain, I don't see anything that would limit relative indexing  with this proposal.\n\nThe Skip Case\n\nMatthijs Hollemans writes, \n\nAnother benefit of a C-style for loop is that it simply ignores the loop when n <= i, as in the following example,\n\n  for var i = 100; i < n; ++i { ...\n\nwhile the Swifty version gives an error because it cannot create a range where the end is smaller than the start: \n\n  for i in 100..<n { ...\n\nOf course, you can add an if-statement to catch this but in the C-style loop this is implicit. Hence, it is more expressive.\n\nI may be in the minority but I rather like that this becomes an error. The \"skip\" behavior reads to me as an unintended side-effect rather than a purposeful design goal. I prefer a philosophy that minimizes such possibilities in a safe modern language.\n\nIssues of Type \n\nRoland King writes,\n\nI must be the only person who still likes C-style for loops on occasion. eg a loop with something floating point \n\nI counter that stride addresses this for all conforming strideable types, not just floating point values. \n\nTraining Costs and Migration Benefits\n\nThe main argument against losing the feature seems to be the higher training costs for C-style coders and the higher porting costs for existing C-code.  I'd argue that the training costs to a new language are significant and whether there's a C-style for loop will not materially change those overall costs, especially for those moving from Objective-C where the for-in loop is common. Second, porting to Swift should be motivated by an enhancement of safety and maintainability. Swift already supports external calls to C routines. If you want to keep your code in C, there's nothing stopping you from doing so. (Or to put it in American Politician-speak, \"If you like your C-code, you can keep your C-code\")\n\nMore Direct Swift Replacements\n\nAfter all this discussion, let me end with a suggestion proposed by Joe Groff for anyone who would still miss the for-loop by approximating the same control flow in native Swift:\n\n\nfunc cStyleFor(@autoclosure init initializer: () -> (), @autoclosure test: () -> Bool, @autoclosure inc: () -> (), body: () throws -> ()) rethrows {\n  // left as an exercise\n}\n\nvar i = 0\ncStyleFor(init: i = 0, test: i < 10, inc: ++i) {\n  print(i)\n}\n\n-Joe\n\nThe only feature this does not include, as pointed out by list members, is a co-declared variable binding. In a C-style for-loop, the \"i\" is bound as part of the declaration. In this implementation, it requires a separate declaration line and remains in the scope for its lifetime.\n\nWrap-up\n\nI hope I have addressed the concerns brought up on-list. If I missed one of yours please feel free to reply. The voting and review period will be between 7 Dec and 10 Dec. Here is the master schedule: https://github.com/apple/swift-evolution/blob/master/schedule.md\n\nBest regards,\n\n-- Erica\n\n\n\n> On Dec 6, 2015, at 7:47 AM, J. Cheyo Jimenez via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> \n> https://github.com/apple/swift/commit/0d001480a94f975355cd458973d5c51cef55bff1 <https://github.com/apple/swift/commit/0d001480a94f975355cd458973d5c51cef55bff1>\n> \n> On Sunday, December 6, 2015, Clemens Wagner via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n> > We’ve developed a number of Swift apps for various clients over the past year and have not needed C style for loops either.\n> \n> But I think this is a very weak reason for *removing* any portion like C-loops and increment or decrement operators of a programming language. How about the developers and the productive code which used C-style loops already?\n> \n> I understand the reasons why you, Erica and the others don’t like C-style loops. But changing the philosophy of a productive programming language is a very bad idea.\n> \n> Cheers\n> Clemens\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org <javascript:;>\n> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>  _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000591.html" , "inReplyTo" : "CAAcV4sZVC8M4yo+XEdWoGzKyG7rDYuy7ox=Rk3cdbXjFuSD4Sg@mail.gmail.com" , "date" : { "$date" : 1449421154000} , "subject" : "[swift-evolution] C-style For Loops" , "references" : [ "AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de" , "CAAcV4sZVC8M4yo+XEdWoGzKyG7rDYuy7ox=Rk3cdbXjFuSD4Sg@mail.gmail.com"] , "descendants" : [ "CADS5KKU3JRZo0eCvF4XgA6ZT0=Eb9wtGg-rwn45BZXC2MiXvdA@mail.gmail.com" , "3743E515-225F-43C4-BB62-DC8C848BEE89@ericasadun.com" , "9FCB65CF-491B-4F21-B664-AE6623E7C669@michelf.ca" , "2CF98787-3994-47AA-8B84-13C9AC7A4154@fifthace.com" , "CAPh90aFQs-RA4W++PCgG7n58p0F5NOp9jmJsz7hZxfkOZktVcA@mail.gmail.com" , "75C3B397-E687-4D6A-A5E2-D918502E8484@ericasadun.com" , "AD0908AC-1F8F-44A4-B059-8E811CE3D661@aol.com" , "CAB8TY2OSDRXUcxtMj7-isuaRmkMXafwsxiquqzedxZ+A+0kyPw@mail.gmail.com" , "E332A59C-7036-42AB-A54A-BE0FE97766EA@aol.com" , "A3B09B02-2438-4658-8073-BEBA8F1A5441@aol.com" , "3F9880E8-7BEA-4275-A939-940041861EC5@michelf.ca" , "5664F2B9.5080808@klundberg.com" , "5567A331-3420-448B-9A1F-484D44F7A792@michelf.ca" , "2F9C0A4A-4005-462F-83DD-795C6E838C3B@pobox.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com"}} , "_id" : "CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com" , "from" : "alexl.mail+swift at gmail.com (Alex Lew)" , "mailingList" : "swift-evolution" , "content" : "What if we left the if { ...} else { ... } syntax alone (as a statement),\nand updated the ternary expression to be a more general pattern matching\nexpression (closer to \"switch\")? Something like\n\nlet x = condition ?\n   true: \"Hello\"\n   false: \"Goodbye\"\n\nlet x = optionalValue ?\n   .Some(let unwrapped): \"Hello, \\(unwrapped)\"\n   .None: \"To Whom It May Concern\"\n\nlet myFavoriteColor = yourFavoriteColor ?\n    .Blue: .Red\n    .Green: .Blue\n    .Red: .Green\n\nlet quadrant = (x, y) ?\n    let (x, y) where x < 50 && y < 50: \"top left\"\n    let (x, y) where x < 50 && y > 50: \"bottom left\"\n    let (x, y) where x > 50 && y < 50: \"top right\"\n    default: \"bottom right\"\n\nThe colon comes from the fact that this is sort of a light-weight\nexpression-based \"switch\" statement, where each branch can only contain an\nexpression, not a series of statements.\n\nThis is very similar to pattern matching expressions in languages like\nHaskell, ML, and Coq.\n\nOn Sun, Dec 6, 2015 at 11:25 AM, Thorsten Seitz <thorsten.seitz at web.de>\nwrote:\n\n> Am 06.12.2015 um 01:28 schrieb Alex Lew via swift-evolution <\n> swift-evolution at swift.org>:\n>\n> I don't think you can just get rid of the if statement in favor of an\n> expression. You still want to be able to do this:\n>\n> if (condition) {\n>     funcWithSideEffectsThatReturnsInt()\n> } else {\n>     funcWithSideEffectsThatReturnsString()\n> }\n>\n> but that's not a valid expression (what is its type?).\n>\n>\n> That would actually be no problem if Swift’s type system would have union\n> types (Ceylon has union and intersection types which are quite awesome and\n> enable lots of nice things quite naturally, see\n> http://ceylon-lang.org/documentation/1.2/tour/types/).\n>\n> In that case the type of such an expression would just be the union of\n> both types, which is written Int | String in Ceylon.\n>\n> -Thorsten\n>\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000592.html" , "inReplyTo" : "49EEA2E6-55F2-49DE-A59F-A13017626370@web.de" , "date" : { "$date" : 1449421353000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com" , "CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com" , "C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com" , "18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com" , "2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io" , "BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com" , "CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com" , "CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com" , "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com" , "BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com" , "909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net" , "0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com" , "49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net" , "CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com" , "49EEA2E6-55F2-49DE-A59F-A13017626370@web.de"] , "descendants" : [ "D381E334-74B7-41EC-90BF-544A925D2204@icloud.com" , "D9043847-2CF1-40A8-9BDD-2C0DCCAB5A38@supmenow.com" , "EAEE8B4A-12A2-4FD6-BA7B-B26071F08489@gmail.com" , "4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com" , "CAAcV4sbQxUywKAHE=3SCACEFH4YvUqjwEr_0=fjf59ndZtoedg@mail.gmail.com" , "07270E34-E284-4FF0-B2EA-6DBB54FF78B5@portableinnovations.de" , "67057217-F4BC-4584-8B52-8EBA2CFA8CC7@portableinnovations.de" , "45B71AF5-DD4F-4E9C-A128-5B8041917564@me.com" , "CAKCGC8BmmCk55=6UC_qk_C+ZNq2JfGpOPO5cJ=SK2784kmvbGg@mail.gmail.com" , "B6DDD94B-0755-4D40-94F0-D2469A644818@portableinnovations.de" , "CAKCGC8AerqpPTrwdmPAvhmp-fLt-v=LXw4z0t+2o93g9GmAaxw@mail.gmail.com" , "54E5D8F5-616D-41EB-A550-E639FE861575@gmail.com" , "CAKCGC8CsJ7g_Fu8fnQ5Mv=yAzbSvb0Z+iNmdXKnJaAcWR2UKuw@mail.gmail.com" , "6830F74D-78FC-4B20-A6D5-683185B30164@gmail.com" , "691A92C4-1A5F-4CAE-AF50-F6AAA3A3F32C@portableinnovations.de" , "D35074A6-1C34-4BA3-AAF1-8CFE1992A522@me.com" , "1EE735A6-FF0F-4E49-BE7D-AC7E6C8A87EC@tarantsov.com" , "3D250DE5-09BC-4A6B-AF59-E1D714DF709A@tarantsov.com" , "BB6A4434-E2B1-4192-8450-90D636E6A7F5@fastmail.fm" , "0ED79E6D-A89A-4F3E-9269-6216BD10EB22@sealedabstract.com" , "CAAcV4sb9eMhuLGL3QsBw4bFxj1FQrokCAanKjEFRNNReE8zWOQ@mail.gmail.com" , "7253CF12-DBD4-483D-941F-04851E5AD394@tarantsov.com" , "CAAcV4sbo4=Hdzp+yx-km-CnhNDm2uQ-gDJsvdug_Pg-MjTPC=Q@mail.gmail.com" , "CAAcV4sbAk_eSdjz7bQ6ggdZNE+thmj7-wT_pG2+eRMKDVba+wA@mail.gmail.com" , "B619CC7E-59A8-4B3C-8E46-FC7FD4C4C6E6@apple.com" , "2372BF92-E97D-40C3-8FEC-0CA9B00ACACE@icloud.com" , "BB1D04A8-2E17-497F-AE74-8FDE4AEC4D77@fastmail.fm" , "2F722DE2-D3AE-44D5-83BB-CBCD371801AD@icloud.com" , "7B70F158-5B8A-425B-980C-CD08210342D4@me.com" , "FDB72AC4-0B0A-4D0F-A9D2-FFE43A55362E@gmail.com" , "9E0141FF-8B3B-4736-88EE-11F05930D149@fastmail.fm" , "CAAcV4sba2j1hOrBJO1kmLpLcjwSQoE0LUejbdNxa05zFzUmi3g@mail.gmail.com" , "DE316C42-6FA7-4A60-80C2-AFF74844EF09@fastmail.fm" , "33B028BA-EB5F-4986-9F16-3057390C3F16@gmail.com" , "BB8653D1-400D-49BC-AA77-6ECC096747B3@icloud.com" , "54B5FAEC-8636-44C5-96A2-0401999DD5D2@gmail.com" , "D679F068-B7C8-4DF2-A7E6-4D78B74F6B17@tarantsov.com" , "DDCE4FC9-2DED-45E5-8D9B-CAB2AA8CF9E6@gmail.com" , "C1C319DB-3934-40B6-ABEE-51B07463E6EF@upzzle.com" , "1C3ADBD7-D4CD-417A-AC45-029D7A889812@fastmail.fm" , "39024D06-E664-42EB-9E68-4D3E5BDC577D@anandabits.com" , "CAE+=ROVg0cJVKnSdwB=KPrEtr=GYd+PMMaOvbCj=N0RtUT=Q6A@mail.gmail.com" , "CAE+=ROVUD1ECe9yHG8kMW0skCFV0=BK70rw+5V7rNHEfmGhNjQ@mail.gmail.com" , "C04621E1-91D2-4A7D-9F9C-58F862B38355@icloud.com" , "581FE433-8169-4D61-9C3F-D90DAD600B9B@icloud.com" , "DB890044-1DAF-4832-8380-F78F61FBC96D@uzh.ch" , "CAE+=ROXg+tM0VYn1bscairmM9sQQ0nh1tYb4SexyWnM7TbeyaA@mail.gmail.com" , "CAE+=ROX9M8XSU8reKMf=RNCwu4Xu95V0G9W9T=Xr0nc8KerHjw@mail.gmail.com" , "CAAcV4sZKJg+x0v4rc1h=ydKE+EFEjanyBnqm8BWO=za-fF+jXA@mail.gmail.com" , "B017EE8F-7732-448E-80AB-7694904D28B4@icloud.com" , "D6AA07FC-261F-4D09-BC32-9FF7792659EC@eggerapps.at" , "CAE+=ROWf2XT2mxM5uWJCjz1Q3wZB71w=svWmGgX5v2=Y2rLzNw@mail.gmail.com" , "EB862217-2E54-4503-9C0C-DD943D428880@gmail.com" , "E0FCC493-27B9-499C-9884-4E00DB831131@gmail.com" , "934A39F6-ECB6-405B-8EF6-97E3C55604AD@uzh.ch" , "5824A613-F216-400B-AD16-9D368FA3A397@gmail.com" , "29A77367-05BF-4667-B25F-C06F520D0CB5@fastmail.fm" , "5525CD3F-062A-4ECB-809F-1964AE645CFC@gmail.com" , "CALkjWZsKQUQc0oDMkru8YGRv5rqOeqXF=4HnU2V0wo_5Q8SjnQ@mail.gmail.com" , "047B4955-1E5A-4A77-BAE3-63E8633A3AE1@gmail.com" , "CAE+=ROWxmKEic9DxN+CXyf=O7AtxgoHox5tSM1SCy_6E0ODphQ@mail.gmail.com" , "A7043ACA-9CE9-4739-919F-93F65FE7273B@gmail.com" , "6137630B-E3E8-45C6-AB48-FABFE9586EA9@me.com" , "CBB03FEA-50E2-4D7B-92B5-FB8A74B6719A@icloud.com" , "28E69DC8-4663-4FB6-8F99-F645E5D3F960@gmail.com" , "CAAcV4sZRQkVeBSqHv8UE_SJh-oEzZ74W6zd+sYxwEKhYZYsfxA@mail.gmail.com" , "CAAcV4sbakzYnefbui=hYKRDTMkrN_s1hFTn3CLwZUzWWa0M3LA@mail.gmail.com" , "63683E0A-B1FE-42A1-9878-FFEA34D1B993@gmail.com" , "CAAcV4sY8O=z5TL41vMoW3rKCHEWH3ikD8ZVJu-AEgVBYx-JXsA@mail.gmail.com" , "CAAcV4sbgPfRGZcU2U3fHcN2nky_ZqhCspWkz9DXYCjXyZFhvOQ@mail.gmail.com" , "A97ACA91-183C-41D9-ACEF-61B74D51E5BA@icloud.com" , "A9768B92-225F-49C8-B2D1-D572E1BD93DB@gmail.com" , "3BBED4DB-4944-4D4D-8603-A9E122B108B9@fastmail.fm" , "4C94F89B-CEDF-4480-8043-ED80AE0EB76A@eggerapps.at" , "B834ABFE-0DB7-426F-B932-74CD7884E46F@icloud.com" , "D58261F7-759A-4B10-84BE-A7882D50C7A5@owensd.io" , "0FEC8813-07C3-48E2-8D76-D0EF7709DA8E@tarantsov.com" , "6C13EC21-3BF0-4633-ABAB-C91322598ABC@apple.com" , "50765AC5-1CFE-406D-9CB5-B28ABBEB84ED@fastmail.fm" , "C64EC68B-1BBE-498A-937A-257E01314DEB@apple.com" , "CALkjWZu1S0ykcnenz_Z0AEuaiyeyTpxSYRMwknqeRxJAxnJT7w@mail.gmail.com" , "CAPrQK3CZy45bfx7qTgJoCH6pkocd_9sPTc0CNrAvsrRM6Vixkg@mail.gmail.com" , "CAB056B2-A975-45B3-93BD-14DE06903042@gmail.com" , "6FDA08B7-192F-42F2-BD2F-F7980463C833@novafore.com" , "40273CEA-F386-47C3-9314-C355B2E320CB@gmail.com" , "CANGnqV1WfTHxgfk4PNTQozU31EAa7z4MZF7d0gc058F4_=EtcQ@mail.gmail.com" , "C9FD779C-AF2C-466C-B741-34D40FB47413@icloud.com" , "48DEE2AB-7D93-47AC-9296-42AD9DD987E2@gmail.com" , "A4DFD8C0-135E-4B40-A264-B7FBCD07D322@fastmail.fm" , "CALkjWZvopih52vGsUfsqzrsEPP-G02eDg=8+EKLrpCMNciW+gA@mail.gmail.com" , "CALkjWZsMC7daCZHg_SDw=EiySCZtN7knDqVhXiF6+3dKTZZTGA@mail.gmail.com" , "CAEEOKET4Ud0bbSW_-Ss6V08tLy2YhF3n1TvQ06Xk5Jjak5-GHg@mail.gmail.com" , "CAAcV4sYaK4=N=ePDkHKbiodYp3HfiHW2yFxWs0A9Rt7LJ8DYvg@mail.gmail.com" , "CAAcV4sbOpH=sbPePnKhcHNXFy-YbPubUvF5PDaoLN_Rs8yL_rw@mail.gmail.com" , "C0B48136-1470-48EB-89D8-CD1B6F8553B1@apple.com" , "7227A933-1AFF-4470-90CB-2880776CEF03@fastmail.fm" , "3017B038-022E-4E46-8ABD-74873DC4C14C@icloud.com" , "CAAcV4sZ=8N3FDgo5aJT50dPwBh=SjM5NTSFgiT6OgSGcbsdcKg@mail.gmail.com" , "A2116BA7-633C-40BA-B7EF-B6A69582C2A3@icloud.com" , "9B4EA1B7-9D30-4B60-9AD0-34119EB9837D@apple.com" , "4BBB2771-4817-4BF3-919D-D7E14826C38D@apple.com" , "D17C306A-4934-4D72-B4FA-E7897B8E82B1@gmail.com" , "99FBC506-E086-4609-8585-42CA7E7E9852@apple.com" , "CAB5C60u6fSAaFgWDw2MY-PP1sJDEDqGRObqF+WwiHoXYvTwwZg@mail.gmail.com" , "3F9131C9-B757-4211-AED4-8E71E3CE9810@anandabits.com" , "EC7C2819-0125-437D-8940-1E3F610B500D@icloud.com" , "38E32460-C46B-428A-91A1-37A74D863127@gmail.com" , "CAAcV4sZZt8mwh9_rixfQ3dAdrPV77=uuqsAvdBM5f90K8sb6hw@mail.gmail.com" , "473B2AAA-7AE4-4B09-B013-6EE9CA6AB2AA@gmail.com" , "32A23B96-9CCC-4114-8939-07EE62E7B6AC@apple.com" , "A5DF87B9-47F1-4A2D-A51B-27CB3221912D@apple.com" , "028924F8-3DD9-40F9-A907-C4DB2344043B@gmail.com" , "CAB5C60tv0=-aBnPzwDCAp8oE8Km+tB6huYPxTrZNi=ObBKXAww@mail.gmail.com" , "CAB5C60sGJPaYPFtEoKB0DC-6A11LogCQAOCeZ-C6dvkmMd2oyg@mail.gmail.com" , "277EE0B5-01B3-48CE-992F-AE838034C0F1@apple.com" , "897A3F1D-1BCB-41B3-9096-0E46DEFA844A@apple.com" , "CAB5C60vD=QyN6LqyKU431jUSQQbuBEJcGiHkwq=+nRmTFhbU9A@mail.gmail.com" , "F4ED804A-2DC1-48DE-AD7C-DBE2A0BEF047@apple.com" , "81AA5235-A524-4F1A-AAA0-EB44BFFB0FEC@architechies.com" , "34A6EE6D-AECF-4887-BEB8-0D841C7CB1F2@icloud.com" , "CAAcV4sYZ6JoLy+=XKStCyh-XTJVmttrBZvqTuNq=Decsv2NEzg@mail.gmail.com" , "F5E748B4-BD58-408D-9330-DE255B9531E9@icloud.com" , "CACOvyQXZ1-qfbz7=0R1iXudZQdFMHPPQ2GVv_5DKwFEvZEF2pA@mail.gmail.com" , "27C9213F-B866-4A98-B0DC-E1492700B28B@apple.com" , "AE17F2D6-0107-4F61-AE13-01E5236ED770@apple.com" , "C320EC78-2D4E-46A8-90ED-4175F5B80072@gmail.com" , "CAB5C60szP8_2p8qqX13ph3wDQU6iRM0P09hVmXu7ar9SvRN+vw@mail.gmail.com" , "15A5CF07-DAED-4B92-A983-D88C2FA6BC8E@gmail.com" , "2822BF6F-172E-4003-B1A4-FB1C518CB701@googlemail.com" , "414E3C0D-EEC1-4005-8D68-5CA91EBADD0F@gmail.com" , "72FA697D-D1C9-4E73-B554-7313DC940D4B@apple.com" , "63C561FE-B75F-4A9B-8DF6-B2335D4C03CB@apple.com" , "CAEEOKEQyUwgvkEvPu2Xv_xAEJWiMTgGtv=KdY-2gkzhJXR7D4A@mail.gmail.com" , "A5DE0BD4-E526-4682-82B0-9B541CEF1C15@gmail.com" , "CAB5C60tn=nNstD2ke_RACYJsmAVvWQx-vJV=PfhqsOgaKx9pfw@mail.gmail.com" , "30B4EAF6-C852-4691-B397-24086AE1F9D9@icloud.com" , "1E2BDCE0-2132-40E8-96BC-BA51233281C7@novafore.com" , "C5F7CACF-736F-4794-B38E-0BE409F96835@novafore.com" , "FAEB0D09-1CB7-4706-B4CC-43DF40A2D243@apple.com" , "03C1FF36-43C3-46D1-88A1-3ECDCBB56567@gmail.com" , "CAB5C60sXr46WbfmaUctNKfWk01G_4pHgktykf4dJQZDbQ1QPWA@mail.gmail.com" , "4FB8F138-A0EF-4DDF-9AAD-A7172195F469@novafore.com" , "0C330020-F7D9-45D0-9B2D-E4DAD3AE105C@anandabits.com" , "CAB5C60vXzip01M6r62uQdkrXCxfBaQPgU7tdHsz+0Tu0i4Zksw@mail.gmail.com" , "BED20179-20C3-4F3A-B5D5-5E09286333F5@anandabits.com" , "CAKCGC8CWGc1L0fsc7TtzDeCqu5bxPX3q3MMZCw+2HPGuPHHC1A@mail.gmail.com" , "7D68F57E-C847-4E0D-AF3A-FD1F2DC928A9@icloud.com" , "1449429569.1342623.459603529.32C935BC@webmail.messagingengine.com" , "11462DA4-ACDD-4CF3-BD57-47886B655970@anandabits.com" , "CAKCGC8AVDe6W9X=XvFEnbkae8xom2Us8xczKFShqKu2+kPnRJA@mail.gmail.com" , "0DF0732F-0958-47C1-A6C3-62A8AB2F4386@icloud.com" , "CAKCGC8BEzyEPAFWCPKPiH+UL3KmZm7aM6KUPu-F9DKV-YvUbCA@mail.gmail.com" , "4A5C6452-0A1B-42A3-AFD4-3DEA04E310C6@icloud.com" , "6DA2FDFF-F978-4ECA-9E2B-F757F6D8BBF3@icloud.com" , "2116BFD1-25BC-4B9F-A3A6-08758782BB88@anandabits.com" , "C919D677-30C0-4F1E-B221-9B28365D67A9@gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAKCGC8CWGc1L0fsc7TtzDeCqu5bxPX3q3MMZCw+2HPGuPHHC1A@mail.gmail.com"}} , "_id" : "CAKCGC8CWGc1L0fsc7TtzDeCqu5bxPX3q3MMZCw+2HPGuPHHC1A@mail.gmail.com" , "from" : "alexl.mail+swift at gmail.com (Alex Lew)" , "mailingList" : "swift-evolution" , "content" : "To elaborate, the reason I like this is that I think it fits with Swift's\ngeneral pattern (no pun intended) of extending familiar C syntactic forms\nto work with functional features. C's enums become Algebraic Datatypes; C's\nswitch statements become pattern-matching statements; C's if and for and\nwhile statements are also updated with pattern-matching abilities.\n\nThe ternary operator is C's answer to the \"if-as-an-expression\" question.\nSo why can't a modified version be our answer to the\n\"pattern-matching-as-an-expression\" question?\n\nIt also has the advantage of being more explicit than the original ternary\noperator -- having to label the true: and false: cases makes it clearer\nwhat you're trying to achieve.\n\nOn Sun, Dec 6, 2015 at 12:02 PM, Alex Lew <alexl.mail+swift at gmail.com>\nwrote:\n\n> What if we left the if { ...} else { ... } syntax alone (as a statement),\n> and updated the ternary expression to be a more general pattern matching\n> expression (closer to \"switch\")? Something like\n>\n> let x = condition ?\n>    true: \"Hello\"\n>    false: \"Goodbye\"\n>\n> let x = optionalValue ?\n>    .Some(let unwrapped): \"Hello, \\(unwrapped)\"\n>    .None: \"To Whom It May Concern\"\n>\n> let myFavoriteColor = yourFavoriteColor ?\n>     .Blue: .Red\n>     .Green: .Blue\n>     .Red: .Green\n>\n> let quadrant = (x, y) ?\n>     let (x, y) where x < 50 && y < 50: \"top left\"\n>     let (x, y) where x < 50 && y > 50: \"bottom left\"\n>     let (x, y) where x > 50 && y < 50: \"top right\"\n>     default: \"bottom right\"\n>\n> The colon comes from the fact that this is sort of a light-weight\n> expression-based \"switch\" statement, where each branch can only contain an\n> expression, not a series of statements.\n>\n> This is very similar to pattern matching expressions in languages like\n> Haskell, ML, and Coq.\n>\n> On Sun, Dec 6, 2015 at 11:25 AM, Thorsten Seitz <thorsten.seitz at web.de>\n> wrote:\n>\n>> Am 06.12.2015 um 01:28 schrieb Alex Lew via swift-evolution <\n>> swift-evolution at swift.org>:\n>>\n>> I don't think you can just get rid of the if statement in favor of an\n>> expression. You still want to be able to do this:\n>>\n>> if (condition) {\n>>     funcWithSideEffectsThatReturnsInt()\n>> } else {\n>>     funcWithSideEffectsThatReturnsString()\n>> }\n>>\n>> but that's not a valid expression (what is its type?).\n>>\n>>\n>> That would actually be no problem if Swift’s type system would have union\n>> types (Ceylon has union and intersection types which are quite awesome and\n>> enable lots of nice things quite naturally, see\n>> http://ceylon-lang.org/documentation/1.2/tour/types/).\n>>\n>> In that case the type of such an expression would just be the union of\n>> both types, which is written Int | String in Ceylon.\n>>\n>> -Thorsten\n>>\n>>\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000593.html" , "inReplyTo" : "CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com" , "date" : { "$date" : 1449421600000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com" , "CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com" , "C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com" , "18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com" , "2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io" , "BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com" , "CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com" , "CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com" , "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com" , "BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com" , "909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net" , "0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com" , "49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net" , "CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com" , "49EEA2E6-55F2-49DE-A59F-A13017626370@web.de" , "CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/9D5E0564-E4A2-4F64-8741-526CF79959F4@ericasadun.com"}} , "_id" : "9D5E0564-E4A2-4F64-8741-526CF79959F4@ericasadun.com" , "from" : "erica at ericasadun.com (Erica Sadun)" , "mailingList" : "swift-evolution" , "content" : "On Dec 5, 2015, at 11:15 PM, Chris Lattner via swift-evolution <swift-evolution at swift.org> wrote:\n> Separate from compiler-enforced policies, I’d *love* to see someone tackle implementing a \"go fmt” analog that reformats Swift code into a standard style, as well as a “clang format”  tool that could be used by IDEs for on-the-fly editing of code, as well as a “linter” / static analysis tool which can flag potential issues while having a higher tolerance for false positives.  These should be separate from the “always on” compiler diagnostics though.\n> \n> -Chris\n\nI have a fairly minimal held-together-by-bandaids linter I put together: \n\nhttps://github.com/erica/testlint\n\nI have hesitated to develop it much further because I didn't want to be committed to inter-process SourceKit hacking and did not yet have access to a reliable parse tree. In its current state, it's a regex-based line-by-line scan.\n\nThe rules it follows are here: https://github.com/erica/testlint/blob/master/testlint/sources/Linter.m\nwith fairly copious commenting\n\n\n-- Erica" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000594.html" , "inReplyTo" : "4F75A42F-4721-4932-85B7-912DFCA57C2D@apple.com" , "date" : { "$date" : 1449421655000} , "subject" : "[swift-evolution] \"bad smells\" should be compiler errors with suggestions on how to fix them" , "references" : [ "557CCA5F-E52F-439C-B224-AC4990140373@gmail.com" , "1449324589110.9d79fd62@Nodemailer" , "CF5C0804-061E-487B-9030-005E76177BD1@harlanhaskins.com" , "E4BE1F82-1BCB-4E27-B2E5-CDBE673EF7B8@me.com" , "49EF0786-90E4-4748-B532-E4C68D33458D@gmail.com" , "4F75A42F-4721-4932-85B7-912DFCA57C2D@apple.com"] , "descendants" : [ "CACyzo1jKFZZ2TLTxXYyd_o1j9d5HBAKmg3Doz7QN9O=JGViOtA@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/9C647949-D1C6-4EB3-A964-04312A957B2F@gmx.de"}} , "_id" : "9C647949-D1C6-4EB3-A964-04312A957B2F@gmx.de" , "from" : "macmoonshine at gmx.de (Clemens Wagner)" , "mailingList" : "swift-evolution" , "content" : "I think removing the increment and decrement operators is just another bad idea. They are well known and frequently used by many developers. But discussing an approved proposal would be pointless. :( In my opinion Swift will be unusable if fundamental features will change every year. Some kind of stability in the language would be highly appreciated by Swift users.\n\nClemens\n\n> Am 06.12.2015 um 17:31 schrieb David Waite via swift-evolution <swift-evolution at swift.org>:\n> \n> Nearly every for loop I’ve written in other languages has used pre or post increment (depending on the language), which is being removed in Swift 3.0. It makes sense for 'for loops' to go if pre/post increment goes away.\n> \n> -DW\n> \n>> On Dec 6, 2015, at 9:03 AM, Don Wills via swift-evolution <swift-evolution at swift.org> wrote:\n>> \n>> I too hope that the proposal to remove C-style loops is rejected.  Yes, they aren't that necessary any more, but if we want Swift to compete with Java, C#, C++ and C, there is no reason to remove basic features like C-style loops just because they are politically incorrect.  If there was a functional reason, I might get on board with removing it, but there isn't.\n>> \n>> I also hope that the decision to remove increment and decrement operators is reversed using the same logic.  Just because *you* don't like something that has been a feature of dozens of programming languages for 40 years doesn't mean removing that feature is a good idea.  One man's goto statement is another man's Leatherman multi-tool.  And FWIW, if C-style loops stay in the language, they become much more ugly without increment and decrement.\n>> \n>> Don Wills\n>> \n>>> On Dec 6, 2015, at 8:33 AM, inbox only via swift-evolution <swift-evolution at swift.org> wrote:\n>>> \n>>> True,even that a feature isn't used doesn't mean that you need to remove that feature.\n>>> I hope that the proposal will be rejected.\n>>> \n>>> 2015-12-06 12:03 GMT+02:00 Clemens Wagner via swift-evolution <swift-evolution at swift.org>:\n>>> > We’ve developed a number of Swift apps for various clients over the past year and have not needed C style for loops either.\n>>> \n>>> But I think this is a very weak reason for *removing* any portion like C-loops and increment or decrement operators of a programming language. How about the developers and the productive code which used C-style loops already?\n>>> \n>>> I understand the reasons why you, Erica and the others don’t like C-style loops. But changing the philosophy of a productive programming language is a very bad idea.\n>>> \n>>> Cheers\n>>> Clemens\n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>> \n>>>  _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>> \n>>  _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> \n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000595.html" , "inReplyTo" : "112B3CB9-7E8E-4DA6-8A20-6C2E8848E58B@alkaline-solutions.com" , "date" : { "$date" : 1449421701000} , "subject" : "[swift-evolution] C-style For Loops" , "references" : [ "AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de" , "CAOjGmwn6O2uvJBq03GZyJ+yngfAB4=rqb60dCCfpP2x7rmnEyg@mail.gmail.com" , "B9F4EA1D-98F9-4A2B-8D16-9073FBDD54A5@portablesoftware.com" , "112B3CB9-7E8E-4DA6-8A20-6C2E8848E58B@alkaline-solutions.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/8837F311-F6F8-462E-90E0-88981C537EFD@ericasadun.com"}} , "_id" : "8837F311-F6F8-462E-90E0-88981C537EFD@ericasadun.com" , "from" : "erica at ericasadun.com (Erica Sadun)" , "mailingList" : "swift-evolution" , "content" : "I have developed something similar as well (http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/).\n\nIs yours capable of handling enums and structs that would otherwise be let after declaration because mine is not.\n\n-- E\n\n\n> On Dec 5, 2015, at 5:16 PM, ilya via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> > PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.  Here's one example: ...\n> \n> FWIW, I created a configuration operator more then a year ago, and use it in all of my Swift projects:\n> \n> let task = NSTask() +=+ {\n>     $0.launchPath = \"/usr/bin/mdfind\"\n>     $0.arguments = [\"kMDItemDisplayName == *.playground\"]\n>     $0.standardOutput = pipe\n> }\n> \n> Note you can also use the configured object in the rhs:\n> \n> let questionLabel = UILabel() +=+ {\n>     $0.textAlignment = .Center\n>     $0.font =  UIFont(name:\"DnealianManuscript\", size: 72)\n>     $0.text = currentQuestion.questionText\n>     $0.numberOfLines = 0\n>     view.addSubview($0)\n> }\n> \n> This $0. certainly looks ugly and it would be great to be able to simplify this. I don't llike the following much though (dot-syntax can be ambiguos here, and using simply a method name is even worse):\n> \n> let questionLabel = UILabel() +=+ {\n>     .textAlignment = .Center\n>     .font =  UIFont(name:\"DnealianManuscript\", size: 72)\n>     .text = currentQuestion.questionText\n>     .numberOfLines = 0\n>     view.addSubview($0)\n> }\n> \n> Actually I would be happy with something like\n> \n> let questionLabel = UILabel() .{\n>     ..textAlignment = .Center\n>     ..font = UIFont(name:\"DnealianManuscript\", size: 72)\n>     ..text = currentQuestion.questionText\n>     ..numberOfLines = 0\n>     view.addSubview($0)\n> }\n> \n> Other thoughts?\n> \n>   \n>  _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000596.html" , "inReplyTo" : "CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com" , "date" : { "$date" : 1449421846000} , "subject" : "[swift-evolution] Request for Discussion: Setup closures" , "references" : [ "CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com"] , "descendants" : [ "F757A1B0-69AA-40E0-BB72-9A043CE6D93D@ericasadun.com" , "F833B947-4FFD-485E-912A-31B50140660F@anandabits.com" , "F6635EA0-2342-451E-8675-FF1819BD715C@anandabits.com" , "2F1E045F-3242-4943-9471-B40D6B476C97@anandabits.com" , "35BE2387-2F9C-491F-B71F-1635243ABADA@ericasadun.com" , "38E11489-CE79-4690-8567-98FD7793B4FF@gmail.com" , "159233D0-A835-4435-840E-A9594DDCA37D@ericasadun.com" , "CAKCGC8AOx_ffGe1AjpQJt9ULr3zwTBsnphJCht92se7-Hfi_+g@mail.gmail.com" , "DC82287B-4583-47F3-9389-B756C91436F5@alkaline-solutions.com" , "CC9D9491-212A-4D20-8CC2-34FD984F6463@portableinnovations.de" , "EF05B911-5728-47F4-AB13-F960FF2B21A4@portableinnovations.de" , "F379B44A-9B6F-47BD-95B0-9FC795BC035B@architechies.com" , "BB9D9FE2-F252-41F4-A3EA-2D8053A7579C@gmx.de" , "1F3D7F58-0EC6-4541-9734-A95CE62BAF6E@anandabits.com" , "2139FFE7-79C5-4981-A036-250F2D5EF0A4@ericasadun.com" , "24FE9022-00E3-459C-8A71-540BCF436286@apple.com" , "E904EA6A-6422-49F6-9C5E-07BCDC7D3543@gmx.de" , "98A80B8C-AC32-408D-AD8F-CDE0EB782B4C@apple.com" , "03F8648F-236A-46A5-8D21-CA066DBA1932@anandabits.com" , "D49345E8-5E22-46C8-9EF2-EF0DB4D32D87@apple.com" , "77AE5195-4E57-4814-A228-AF23723C853B@ericasadun.com" , "B818E6F9-1526-4725-BCDA-AB8C36F3CED7@maven.de" , "6A18AB5F-3794-42A6-8142-AAA7B2B61000@apple.com" , "9520AAC7-B49D-4CB7-96EE-E9891BAC9268@ericasadun.com" , "5981B70E-98D3-4A99-AF49-106254DFEB54@apple.com" , "86e837d7-cac3-438b-8297-4f6f401b641f@Spark" , "315B39D9-AE33-438B-8EFF-CC4796EECAAF@pobox.com" , "731CB499-F42F-45D4-8A3B-8D7B963D3709@monod-broca.fr" , "CADcs6kNOmo32YcBHOjmsV3eKiJ4yo0nDxz+5mjWNtp3JG0FsOA@mail.gmail.com" , "616C48D0-D626-487E-861C-CF125879BABB@ericasadun.com" , "3A77268A-D52E-4821-9488-671491506835@monod-broca.fr" , "B5AE3C08-FB9F-4024-B6BF-ECAADC1196E8@pobox.com" , "52D7FF3E-4E16-447D-AFCF-6915ABF999C1@gmx.de" , "98E5A56D-2912-4725-8E5E-14F25153B184@gmx.de" , "3C9B366C-D4A8-4777-8CF9-E46B52F806E2@pobox.com" , "4CCD3C85-FC9C-4509-B2A9-2D761A6A9921@ericasadun.com" , "F3860C6E-19F2-4E01-AF30-1CC813893B1C@anandabits.com" , "DD7C743B-5E22-4603-AA6A-AF3F75B4DE62@ericasadun.com" , "CAPh90aE1m68_kDFqOGuO-u6qP3WKtqSJS9XMU-KKrO0N3yV0kg@mail.gmail.com" , "0674FFD1-76FB-4376-9F34-0FF8B7560798@anandabits.com" , "5B0D18B8-0255-4F2E-86E3-253058585BDB@fifthace.com" , "512C0649-506C-41B3-BBB9-BBF6B80437FE@ericasadun.com" , "CADcs6kOfPJ73WdN-UHTZAPs7Zx_MmSUjrKy6r=EMphLdGfti8w@mail.gmail.com" , "ED9A9872-62B4-4957-B708-94F3015365C5@alkaline-solutions.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com"}} , "_id" : "4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com" , "from" : "sean at fifthace.com (Sean Heber)" , "mailingList" : "swift-evolution" , "content" : "I really like this train of thought. +1\n\nl8r\nSean\n\n\n> On Dec 6, 2015, at 11:02 AM, Alex Lew via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> What if we left the if { ...} else { ... } syntax alone (as a statement), and updated the ternary expression to be a more general pattern matching expression (closer to \"switch\")? Something like\n> \n> let x = condition ?\n>    true: \"Hello\"\n>    false: \"Goodbye\"\n> \n> let x = optionalValue ?\n>    .Some(let unwrapped): \"Hello, \\(unwrapped)\"\n>    .None: \"To Whom It May Concern\"\n> \n> let myFavoriteColor = yourFavoriteColor ?\n>     .Blue: .Red\n>     .Green: .Blue\n>     .Red: .Green\n> \n> let quadrant = (x, y) ?\n>     let (x, y) where x < 50 && y < 50: \"top left\"\n>     let (x, y) where x < 50 && y > 50: \"bottom left\"\n>     let (x, y) where x > 50 && y < 50: \"top right\"\n>     default: \"bottom right\"\n> \n> The colon comes from the fact that this is sort of a light-weight expression-based \"switch\" statement, where each branch can only contain an expression, not a series of statements.\n> \n> This is very similar to pattern matching expressions in languages like Haskell, ML, and Coq.\n> \n> On Sun, Dec 6, 2015 at 11:25 AM, Thorsten Seitz <thorsten.seitz at web.de> wrote:\n>>> Am 06.12.2015 um 01:28 schrieb Alex Lew via swift-evolution <swift-evolution at swift.org>:\n>>> \n>>> I don't think you can just get rid of the if statement in favor of an expression. You still want to be able to do this:\n>>> \n>>> if (condition) {\n>>>     funcWithSideEffectsThatReturnsInt()\n>>> } else {\n>>>     funcWithSideEffectsThatReturnsString()\n>>> }\n>>> \n>>> but that's not a valid expression (what is its type?).\n>> \n>> That would actually be no problem if Swift’s type system would have union types (Ceylon has union and intersection types which are quite awesome and enable lots of nice things quite naturally, see http://ceylon-lang.org/documentation/1.2/tour/types/).\n>> \n>> In that case the type of such an expression would just be the union of both types, which is written Int | String in Ceylon.\n>> \n>> -Thorsten\n> \n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000597.html" , "inReplyTo" : "CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com" , "date" : { "$date" : 1449421903000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com" , "CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com" , "C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com" , "18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com" , "2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io" , "BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com" , "CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com" , "CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com" , "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com" , "BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com" , "909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net" , "0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com" , "49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net" , "CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com" , "49EEA2E6-55F2-49DE-A59F-A13017626370@web.de" , "CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com"] , "descendants" : [ "D381E334-74B7-41EC-90BF-544A925D2204@icloud.com" , "D9043847-2CF1-40A8-9BDD-2C0DCCAB5A38@supmenow.com" , "EAEE8B4A-12A2-4FD6-BA7B-B26071F08489@gmail.com" , "07270E34-E284-4FF0-B2EA-6DBB54FF78B5@portableinnovations.de" , "67057217-F4BC-4584-8B52-8EBA2CFA8CC7@portableinnovations.de" , "45B71AF5-DD4F-4E9C-A128-5B8041917564@me.com" , "CAKCGC8BmmCk55=6UC_qk_C+ZNq2JfGpOPO5cJ=SK2784kmvbGg@mail.gmail.com" , "B6DDD94B-0755-4D40-94F0-D2469A644818@portableinnovations.de" , "CAKCGC8AerqpPTrwdmPAvhmp-fLt-v=LXw4z0t+2o93g9GmAaxw@mail.gmail.com" , "54E5D8F5-616D-41EB-A550-E639FE861575@gmail.com" , "CAKCGC8CsJ7g_Fu8fnQ5Mv=yAzbSvb0Z+iNmdXKnJaAcWR2UKuw@mail.gmail.com" , "6830F74D-78FC-4B20-A6D5-683185B30164@gmail.com" , "691A92C4-1A5F-4CAE-AF50-F6AAA3A3F32C@portableinnovations.de" , "D35074A6-1C34-4BA3-AAF1-8CFE1992A522@me.com" , "1EE735A6-FF0F-4E49-BE7D-AC7E6C8A87EC@tarantsov.com" , "3D250DE5-09BC-4A6B-AF59-E1D714DF709A@tarantsov.com" , "BB6A4434-E2B1-4192-8450-90D636E6A7F5@fastmail.fm" , "0ED79E6D-A89A-4F3E-9269-6216BD10EB22@sealedabstract.com" , "CAAcV4sb9eMhuLGL3QsBw4bFxj1FQrokCAanKjEFRNNReE8zWOQ@mail.gmail.com" , "7253CF12-DBD4-483D-941F-04851E5AD394@tarantsov.com" , "CAAcV4sbo4=Hdzp+yx-km-CnhNDm2uQ-gDJsvdug_Pg-MjTPC=Q@mail.gmail.com" , "CAAcV4sbAk_eSdjz7bQ6ggdZNE+thmj7-wT_pG2+eRMKDVba+wA@mail.gmail.com" , "B619CC7E-59A8-4B3C-8E46-FC7FD4C4C6E6@apple.com" , "2372BF92-E97D-40C3-8FEC-0CA9B00ACACE@icloud.com" , "BB1D04A8-2E17-497F-AE74-8FDE4AEC4D77@fastmail.fm" , "2F722DE2-D3AE-44D5-83BB-CBCD371801AD@icloud.com" , "7B70F158-5B8A-425B-980C-CD08210342D4@me.com" , "FDB72AC4-0B0A-4D0F-A9D2-FFE43A55362E@gmail.com" , "9E0141FF-8B3B-4736-88EE-11F05930D149@fastmail.fm" , "CAAcV4sba2j1hOrBJO1kmLpLcjwSQoE0LUejbdNxa05zFzUmi3g@mail.gmail.com" , "DE316C42-6FA7-4A60-80C2-AFF74844EF09@fastmail.fm" , "33B028BA-EB5F-4986-9F16-3057390C3F16@gmail.com" , "BB8653D1-400D-49BC-AA77-6ECC096747B3@icloud.com" , "54B5FAEC-8636-44C5-96A2-0401999DD5D2@gmail.com" , "D679F068-B7C8-4DF2-A7E6-4D78B74F6B17@tarantsov.com" , "DDCE4FC9-2DED-45E5-8D9B-CAB2AA8CF9E6@gmail.com" , "C1C319DB-3934-40B6-ABEE-51B07463E6EF@upzzle.com" , "1C3ADBD7-D4CD-417A-AC45-029D7A889812@fastmail.fm" , "39024D06-E664-42EB-9E68-4D3E5BDC577D@anandabits.com" , "CAE+=ROVg0cJVKnSdwB=KPrEtr=GYd+PMMaOvbCj=N0RtUT=Q6A@mail.gmail.com" , "CAE+=ROVUD1ECe9yHG8kMW0skCFV0=BK70rw+5V7rNHEfmGhNjQ@mail.gmail.com" , "C04621E1-91D2-4A7D-9F9C-58F862B38355@icloud.com" , "581FE433-8169-4D61-9C3F-D90DAD600B9B@icloud.com" , "DB890044-1DAF-4832-8380-F78F61FBC96D@uzh.ch" , "CAE+=ROXg+tM0VYn1bscairmM9sQQ0nh1tYb4SexyWnM7TbeyaA@mail.gmail.com" , "CAE+=ROX9M8XSU8reKMf=RNCwu4Xu95V0G9W9T=Xr0nc8KerHjw@mail.gmail.com" , "CAAcV4sZKJg+x0v4rc1h=ydKE+EFEjanyBnqm8BWO=za-fF+jXA@mail.gmail.com" , "B017EE8F-7732-448E-80AB-7694904D28B4@icloud.com" , "D6AA07FC-261F-4D09-BC32-9FF7792659EC@eggerapps.at" , "CAE+=ROWf2XT2mxM5uWJCjz1Q3wZB71w=svWmGgX5v2=Y2rLzNw@mail.gmail.com" , "EB862217-2E54-4503-9C0C-DD943D428880@gmail.com" , "E0FCC493-27B9-499C-9884-4E00DB831131@gmail.com" , "934A39F6-ECB6-405B-8EF6-97E3C55604AD@uzh.ch" , "5824A613-F216-400B-AD16-9D368FA3A397@gmail.com" , "29A77367-05BF-4667-B25F-C06F520D0CB5@fastmail.fm" , "5525CD3F-062A-4ECB-809F-1964AE645CFC@gmail.com" , "CALkjWZsKQUQc0oDMkru8YGRv5rqOeqXF=4HnU2V0wo_5Q8SjnQ@mail.gmail.com" , "047B4955-1E5A-4A77-BAE3-63E8633A3AE1@gmail.com" , "CAE+=ROWxmKEic9DxN+CXyf=O7AtxgoHox5tSM1SCy_6E0ODphQ@mail.gmail.com" , "A7043ACA-9CE9-4739-919F-93F65FE7273B@gmail.com" , "6137630B-E3E8-45C6-AB48-FABFE9586EA9@me.com" , "CBB03FEA-50E2-4D7B-92B5-FB8A74B6719A@icloud.com" , "28E69DC8-4663-4FB6-8F99-F645E5D3F960@gmail.com" , "CAAcV4sZRQkVeBSqHv8UE_SJh-oEzZ74W6zd+sYxwEKhYZYsfxA@mail.gmail.com" , "CAAcV4sbakzYnefbui=hYKRDTMkrN_s1hFTn3CLwZUzWWa0M3LA@mail.gmail.com" , "63683E0A-B1FE-42A1-9878-FFEA34D1B993@gmail.com" , "CAAcV4sY8O=z5TL41vMoW3rKCHEWH3ikD8ZVJu-AEgVBYx-JXsA@mail.gmail.com" , "CAAcV4sbgPfRGZcU2U3fHcN2nky_ZqhCspWkz9DXYCjXyZFhvOQ@mail.gmail.com" , "A97ACA91-183C-41D9-ACEF-61B74D51E5BA@icloud.com" , "A9768B92-225F-49C8-B2D1-D572E1BD93DB@gmail.com" , "3BBED4DB-4944-4D4D-8603-A9E122B108B9@fastmail.fm" , "4C94F89B-CEDF-4480-8043-ED80AE0EB76A@eggerapps.at" , "B834ABFE-0DB7-426F-B932-74CD7884E46F@icloud.com" , "D58261F7-759A-4B10-84BE-A7882D50C7A5@owensd.io" , "0FEC8813-07C3-48E2-8D76-D0EF7709DA8E@tarantsov.com" , "6C13EC21-3BF0-4633-ABAB-C91322598ABC@apple.com" , "50765AC5-1CFE-406D-9CB5-B28ABBEB84ED@fastmail.fm" , "C64EC68B-1BBE-498A-937A-257E01314DEB@apple.com" , "CALkjWZu1S0ykcnenz_Z0AEuaiyeyTpxSYRMwknqeRxJAxnJT7w@mail.gmail.com" , "CAPrQK3CZy45bfx7qTgJoCH6pkocd_9sPTc0CNrAvsrRM6Vixkg@mail.gmail.com" , "CAB056B2-A975-45B3-93BD-14DE06903042@gmail.com" , "6FDA08B7-192F-42F2-BD2F-F7980463C833@novafore.com" , "40273CEA-F386-47C3-9314-C355B2E320CB@gmail.com" , "CANGnqV1WfTHxgfk4PNTQozU31EAa7z4MZF7d0gc058F4_=EtcQ@mail.gmail.com" , "C9FD779C-AF2C-466C-B741-34D40FB47413@icloud.com" , "48DEE2AB-7D93-47AC-9296-42AD9DD987E2@gmail.com" , "A4DFD8C0-135E-4B40-A264-B7FBCD07D322@fastmail.fm" , "CALkjWZvopih52vGsUfsqzrsEPP-G02eDg=8+EKLrpCMNciW+gA@mail.gmail.com" , "CALkjWZsMC7daCZHg_SDw=EiySCZtN7knDqVhXiF6+3dKTZZTGA@mail.gmail.com" , "CAEEOKET4Ud0bbSW_-Ss6V08tLy2YhF3n1TvQ06Xk5Jjak5-GHg@mail.gmail.com" , "CAAcV4sYaK4=N=ePDkHKbiodYp3HfiHW2yFxWs0A9Rt7LJ8DYvg@mail.gmail.com" , "CAAcV4sbOpH=sbPePnKhcHNXFy-YbPubUvF5PDaoLN_Rs8yL_rw@mail.gmail.com" , "C0B48136-1470-48EB-89D8-CD1B6F8553B1@apple.com" , "7227A933-1AFF-4470-90CB-2880776CEF03@fastmail.fm" , "3017B038-022E-4E46-8ABD-74873DC4C14C@icloud.com" , "CAAcV4sZ=8N3FDgo5aJT50dPwBh=SjM5NTSFgiT6OgSGcbsdcKg@mail.gmail.com" , "A2116BA7-633C-40BA-B7EF-B6A69582C2A3@icloud.com" , "9B4EA1B7-9D30-4B60-9AD0-34119EB9837D@apple.com" , "4BBB2771-4817-4BF3-919D-D7E14826C38D@apple.com" , "D17C306A-4934-4D72-B4FA-E7897B8E82B1@gmail.com" , "99FBC506-E086-4609-8585-42CA7E7E9852@apple.com" , "CAB5C60u6fSAaFgWDw2MY-PP1sJDEDqGRObqF+WwiHoXYvTwwZg@mail.gmail.com" , "3F9131C9-B757-4211-AED4-8E71E3CE9810@anandabits.com" , "EC7C2819-0125-437D-8940-1E3F610B500D@icloud.com" , "38E32460-C46B-428A-91A1-37A74D863127@gmail.com" , "CAAcV4sZZt8mwh9_rixfQ3dAdrPV77=uuqsAvdBM5f90K8sb6hw@mail.gmail.com" , "473B2AAA-7AE4-4B09-B013-6EE9CA6AB2AA@gmail.com" , "32A23B96-9CCC-4114-8939-07EE62E7B6AC@apple.com" , "A5DF87B9-47F1-4A2D-A51B-27CB3221912D@apple.com" , "028924F8-3DD9-40F9-A907-C4DB2344043B@gmail.com" , "CAB5C60tv0=-aBnPzwDCAp8oE8Km+tB6huYPxTrZNi=ObBKXAww@mail.gmail.com" , "CAB5C60sGJPaYPFtEoKB0DC-6A11LogCQAOCeZ-C6dvkmMd2oyg@mail.gmail.com" , "277EE0B5-01B3-48CE-992F-AE838034C0F1@apple.com" , "897A3F1D-1BCB-41B3-9096-0E46DEFA844A@apple.com" , "CAB5C60vD=QyN6LqyKU431jUSQQbuBEJcGiHkwq=+nRmTFhbU9A@mail.gmail.com" , "F4ED804A-2DC1-48DE-AD7C-DBE2A0BEF047@apple.com" , "81AA5235-A524-4F1A-AAA0-EB44BFFB0FEC@architechies.com" , "34A6EE6D-AECF-4887-BEB8-0D841C7CB1F2@icloud.com" , "CAAcV4sYZ6JoLy+=XKStCyh-XTJVmttrBZvqTuNq=Decsv2NEzg@mail.gmail.com" , "F5E748B4-BD58-408D-9330-DE255B9531E9@icloud.com" , "CACOvyQXZ1-qfbz7=0R1iXudZQdFMHPPQ2GVv_5DKwFEvZEF2pA@mail.gmail.com" , "27C9213F-B866-4A98-B0DC-E1492700B28B@apple.com" , "AE17F2D6-0107-4F61-AE13-01E5236ED770@apple.com" , "C320EC78-2D4E-46A8-90ED-4175F5B80072@gmail.com" , "CAB5C60szP8_2p8qqX13ph3wDQU6iRM0P09hVmXu7ar9SvRN+vw@mail.gmail.com" , "15A5CF07-DAED-4B92-A983-D88C2FA6BC8E@gmail.com" , "2822BF6F-172E-4003-B1A4-FB1C518CB701@googlemail.com" , "414E3C0D-EEC1-4005-8D68-5CA91EBADD0F@gmail.com" , "72FA697D-D1C9-4E73-B554-7313DC940D4B@apple.com" , "63C561FE-B75F-4A9B-8DF6-B2335D4C03CB@apple.com" , "CAEEOKEQyUwgvkEvPu2Xv_xAEJWiMTgGtv=KdY-2gkzhJXR7D4A@mail.gmail.com" , "A5DE0BD4-E526-4682-82B0-9B541CEF1C15@gmail.com" , "CAB5C60tn=nNstD2ke_RACYJsmAVvWQx-vJV=PfhqsOgaKx9pfw@mail.gmail.com" , "30B4EAF6-C852-4691-B397-24086AE1F9D9@icloud.com" , "1E2BDCE0-2132-40E8-96BC-BA51233281C7@novafore.com" , "C5F7CACF-736F-4794-B38E-0BE409F96835@novafore.com" , "FAEB0D09-1CB7-4706-B4CC-43DF40A2D243@apple.com" , "03C1FF36-43C3-46D1-88A1-3ECDCBB56567@gmail.com" , "CAB5C60sXr46WbfmaUctNKfWk01G_4pHgktykf4dJQZDbQ1QPWA@mail.gmail.com" , "4FB8F138-A0EF-4DDF-9AAD-A7172195F469@novafore.com" , "0C330020-F7D9-45D0-9B2D-E4DAD3AE105C@anandabits.com" , "CAB5C60vXzip01M6r62uQdkrXCxfBaQPgU7tdHsz+0Tu0i4Zksw@mail.gmail.com" , "BED20179-20C3-4F3A-B5D5-5E09286333F5@anandabits.com" , "7D68F57E-C847-4E0D-AF3A-FD1F2DC928A9@icloud.com" , "1449429569.1342623.459603529.32C935BC@webmail.messagingengine.com" , "11462DA4-ACDD-4CF3-BD57-47886B655970@anandabits.com" , "CAKCGC8AVDe6W9X=XvFEnbkae8xom2Us8xczKFShqKu2+kPnRJA@mail.gmail.com" , "0DF0732F-0958-47C1-A6C3-62A8AB2F4386@icloud.com" , "CAKCGC8BEzyEPAFWCPKPiH+UL3KmZm7aM6KUPu-F9DKV-YvUbCA@mail.gmail.com" , "4A5C6452-0A1B-42A3-AFD4-3DEA04E310C6@icloud.com" , "6DA2FDFF-F978-4ECA-9E2B-F757F6D8BBF3@icloud.com" , "2116BFD1-25BC-4B9F-A3A6-08758782BB88@anandabits.com" , "C919D677-30C0-4F1E-B221-9B28365D67A9@gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/0FCA62AB-3FBE-472E-AD11-95E18DC650A9@apple.com"}} , "_id" : "0FCA62AB-3FBE-472E-AD11-95E18DC650A9@apple.com" , "from" : "scanon at apple.com (Steve Canon)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola <swift-evolution at jacopo.giola.org>\n> \n> If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don't introduce an infinite \"switch\" loop.\n\nDetecting this in general is solving the halting problem, so such a check isn't actually feasible.  One could warn when termination can't be proved, but making it a hard error would remove much of the usefulness for implementing interpreters.\n\n- Steve" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000598.html" , "inReplyTo" : "D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org" , "date" : { "$date" : 1449422187000} , "subject" : "[swift-evolution] Proposal: Remove the \"fallthrough\" keyword" , "references" : [ "3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com" , "AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com" , "8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com" , "1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com" , "02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com" , "E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com" , "444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com" , "EF1675F6-7918-4262-B535-696104BFC405@apple.com" , "CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com" , "D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org"] , "descendants" : [ "6CACDDEC-7FB7-433D-AFA1-15DD4208BE16@jacopo.giola.org"]} , { "_links" : { "self" : { "href" : "/charter/emails/4CCD3C85-FC9C-4509-B2A9-2D761A6A9921@ericasadun.com"}} , "_id" : "4CCD3C85-FC9C-4509-B2A9-2D761A6A9921@ericasadun.com" , "from" : "erica at ericasadun.com (Erica Sadun)" , "mailingList" : "swift-evolution" , "content" : "Matthew, I'll look for it and see what's there. More and more I'm thinking there are in fact two distinct problems to be solved: one that maintains self in a cascade of operations, and another that extends initializers, even for constants.\n\nI'm hesitant to coalesce and summarize all this discussion yet because I'm already committed to championing the for-loop proposal but it seems that it would be really valuable right now to lay out the two side-by-side and discuss that plus your helpers-for-initializing-peroperties-of-same-name-as-parameters.\n\n-- E\np.s. In my head, I'm thinking that the compiler must check in setup closures or self-specific-closures for potential overlaps between properties and existing symbols\n\n\n> On Dec 6, 2015, at 10:22 AM, Matthew Johnson <matthew at anandabits.com> wrote:\n> \n> Hi Erica,\n> \n> You might be interested in a possible language feature I described in the \"helpers for initializing properties of same name as parameters\" thread last night.  It is intended to address the desire for concise, safe and flexible initialization without needing to sacrifice immutability.   I would love to hear your thoughts on the list if you have a chance to read through it.\n> \n> Thanks,\n> Matthew\n> \n> Sent from my iPad\n> \n> On Dec 6, 2015, at 11:10 AM, Erica Sadun via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n> \n>> I have developed something similar as well (http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/ <http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/>).\n>> \n>> Is yours capable of handling enums and structs that would otherwise be let after declaration because mine is not.\n>> \n>> -- E\n>> \n>> \n>>> On Dec 5, 2015, at 5:16 PM, ilya via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>> \n>>> > PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.  Here's one example: ...\n>>> \n>>> FWIW, I created a configuration operator more then a year ago, and use it in all of my Swift projects:\n>>> \n>>> let task = NSTask() +=+ {\n>>>     $0.launchPath = \"/usr/bin/mdfind\"\n>>>     $0.arguments = [\"kMDItemDisplayName == *.playground\"]\n>>>     $0.standardOutput = pipe\n>>> }\n>>> \n>>> Note you can also use the configured object in the rhs:\n>>> \n>>> let questionLabel = UILabel() +=+ {\n>>>     $0.textAlignment = .Center\n>>>     $0.font =  UIFont(name:\"DnealianManuscript\", size: 72)\n>>>     $0.text = currentQuestion.questionText\n>>>     $0.numberOfLines = 0\n>>>     view.addSubview($0)\n>>> }\n>>> \n>>> This $0. certainly looks ugly and it would be great to be able to simplify this. I don't llike the following much though (dot-syntax can be ambiguos here, and using simply a method name is even worse):\n>>> \n>>> let questionLabel = UILabel() +=+ {\n>>>     .textAlignment = .Center\n>>>     .font =  UIFont(name:\"DnealianManuscript\", size: 72)\n>>>     .text = currentQuestion.questionText\n>>>     .numberOfLines = 0\n>>>     view.addSubview($0)\n>>> }\n>>> \n>>> Actually I would be happy with something like\n>>> \n>>> let questionLabel = UILabel() .{\n>>>     ..textAlignment = .Center\n>>>     ..font = UIFont(name:\"DnealianManuscript\", size: 72)\n>>>     ..text = currentQuestion.questionText\n>>>     ..numberOfLines = 0\n>>>     view.addSubview($0)\n>>> }\n>>> \n>>> Other thoughts?\n>>> \n>>>   \n>>>  _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>> \n>> \n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000599.html" , "inReplyTo" : "94756ED2-71C9-4FF3-B3BA-2CB35975B5C4@anandabits.com" , "date" : { "$date" : 1449422768000} , "subject" : "[swift-evolution] Request for Discussion: Setup closures" , "references" : [ "CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com" , "8837F311-F6F8-462E-90E0-88981C537EFD@ericasadun.com" , "94756ED2-71C9-4FF3-B3BA-2CB35975B5C4@anandabits.com"] , "descendants" : [ "F3860C6E-19F2-4E01-AF30-1CC813893B1C@anandabits.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/5664713E.1050702@brockerhoff.net"}} , "_id" : "5664713E.1050702@brockerhoff.net" , "from" : "rainer at brockerhoff.net (Rainer Brockerhoff)" , "mailingList" : "swift-evolution" , "content" : "On 12/5/15 22:02, swift-evolution-request at swift.org wrote:\n> Date: Sat, 05 Dec 2015 18:23:28 -0500\n> From: Steve Canon <scanon at apple.com>\n> To: John McCall <rjmccall at apple.com>\n> Message-ID: <CA6BFF82-A212-41B6-8104-A0527E84D31C at apple.com>\n> \n> Very much thinking out loud and not really the implications, I wonder if we might just use \"continue\" instead of \"reswitch\".\n> \n> I very much like specifying what case to fall through into, no matter how we spell it.\n\nIt's somewhat funny seeing you guys all avoiding the word \"goto\"... :-)\nHey, it's just a unconditional branch!\n\nNow seriously, in a past incarnation I used C in very resource-limited\ncontexts (both in execution time and code size) and goto-ing around\ninside a switch statement was often the only solution.\n\nNot that porting Swift to a Raspberry Zero should be a short-term goal,\nbut if the current \"fallthrough\" stays in whatever incarnation, I'd be\nhappy.\n\nTyping this in reminded me of a possible way to allow common code to be\nexecuted at the end of some cases, but not others: before the switch,\nset up a closure (or an array or dict of closures, whatever) and call\nthat as the case's last statement; no doubt you-all would have\nsuggestions about properly scoping such a thing.\n\n-- \nRainer Brockerhoff  <rainer at brockerhoff.net>\nBelo Horizonte, Brazil\n\"In the affairs of others even fools are wise\nIn their own business even sages err.\"\nhttp://brockerhoff.net/blog/" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000600.html" , "inReplyTo" : "mailman.517.1449360158.15739.swift-evolution@swift.org" , "date" : { "$date" : 1449423166000} , "subject" : "[swift-evolution] Proposal: Remove the \"fallthrough\" keyword" , "references" : [ "mailman.517.1449360158.15739.swift-evolution@swift.org"]} , { "_links" : { "self" : { "href" : "/charter/emails/6CACDDEC-7FB7-433D-AFA1-15DD4208BE16@jacopo.giola.org"}} , "_id" : "6CACDDEC-7FB7-433D-AFA1-15DD4208BE16@jacopo.giola.org" , "from" : "swift-evolution at jacopo.giola.org (Jacopo Andrea Giola)" , "mailingList" : "swift-evolution" , "content" : "Well, you caught me, I was thinking of a static analyzer check but for whatever reason my hands typed compiler check. Go figure.\n\nIn the static analyzer this check can be feasible? I know is not a memory leak, but at least he can see if the code flow inside a switch with reswitch statements will continue to go around on the same cases.\nBut this is only my wild guess, without a clue on what a static analyzer can do :)\n\n- Jacopo\n\n> On 06 Dec 2015, at 18:16, Steve Canon <scanon at apple.com> wrote:\n> \n> \n>> On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola <swift-evolution at jacopo.giola.org>\n>> \n>> If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don't introduce an infinite \"switch\" loop.\n> \n> Detecting this in general is solving the halting problem, so such a check isn't actually feasible.  One could warn when termination can't be proved, but making it a hard error would remove much of the usefulness for implementing interpreters.\n> \n> - Steve" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000601.html" , "inReplyTo" : "0FCA62AB-3FBE-472E-AD11-95E18DC650A9@apple.com" , "date" : { "$date" : 1449423976000} , "subject" : "[swift-evolution] Proposal: Remove the \"fallthrough\" keyword" , "references" : [ "3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com" , "AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com" , "8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com" , "1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com" , "02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com" , "E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com" , "444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com" , "EF1675F6-7918-4262-B535-696104BFC405@apple.com" , "CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com" , "D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org" , "0FCA62AB-3FBE-472E-AD11-95E18DC650A9@apple.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/90204A78-4C14-4A1E-9F99-4FFF1FDDFCC2@gmail.com"}} , "_id" : "90204A78-4C14-4A1E-9F99-4FFF1FDDFCC2@gmail.com" , "from" : "stephen.celis at gmail.com (Stephen Celis)" , "mailingList" : "swift-evolution" , "content" : "Seems to me that anything with `-compare:` could conform to Comparable. The list, however, is surprisingly short, and half bridge over to native Swift types that are already Comparable:\n\n- [NSDate compare:]\n- [NSIndexPath compare:]\n- [NSNumber compare:]\n- [NSString compare:]\n\nLooks like NSIndexPath may be the only other contender.\n\nStephen\n\n> On Dec 6, 2015, at 11:47 AM, Tony Parker via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> Hi Chris,\n> \n> Thanks for bringing this idea to the list.\n> \n> Is NSDate really the only thing that we want to conform to comparable, or is there a set of classes which should do so? I’d like to think about the larger set of consequences here (and if possible, deal with one coherent answer for all of Foundation rather than do these classes one at a time).\n> \n> - Tony\n> \n>> On Dec 5, 2015, at 3:36 PM, Chris Amanse via swift-corelibs-dev <swift-corelibs-dev at swift.org <mailto:swift-corelibs-dev at swift.org>> wrote:\n>> \n>> Hello Swift Developers,\n>> \n>> I think it's a good idea to conform NSDate to the Comparable protocol, so instead of using:\n>> \n>> if someDate.compare(today) == .OrderedAscending { }\n>> \n>> Developers can easily compare using compare dates using comparison operators:\n>> \n>> if someDate < today { }\n>> \n>> In my opinion, the code is still readable if developers use comparison operators on NSDates.\n>> \n>> Here's a quick implementation from my swift-corelibs-foundation fork: https://github.com/chrisamanse/swift-corelibs-foundation/commit/3c4eff643c5271de5bec2461798051347be13916 <https://github.com/chrisamanse/swift-corelibs-foundation/commit/3c4eff643c5271de5bec2461798051347be13916>\n>> \n>> Thank you.\n>>  _______________________________________________\n>> swift-corelibs-dev mailing list\n>> swift-corelibs-dev at swift.org <mailto:swift-corelibs-dev at swift.org>\n>> https://lists.swift.org/mailman/listinfo/swift-corelibs-dev <https://lists.swift.org/mailman/listinfo/swift-corelibs-dev>\n> \n>  _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000602.html" , "inReplyTo" : "CE57813E-C13D-47C6-9CEA-32B26789A0BE@apple.com" , "date" : { "$date" : 1449424101000} , "subject" : "[swift-evolution] [swift-corelibs-dev] Proposal: Conforming NSDate to Comparable" , "references" : [ "CAEryqghYNO4JKWRGkF_qFTew7cGPtG7iNP32DndN1dOHLkjATQ@mail.gmail.com" , "CE57813E-C13D-47C6-9CEA-32B26789A0BE@apple.com"] , "descendants" : [ "CAEryqghXu8EGTjWcsPjk5tUbYDfC0E1xTD_rBT=hY7uR1aO7pg@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CADS5KKU3JRZo0eCvF4XgA6ZT0=Eb9wtGg-rwn45BZXC2MiXvdA@mail.gmail.com"}} , "_id" : "CADS5KKU3JRZo0eCvF4XgA6ZT0=Eb9wtGg-rwn45BZXC2MiXvdA@mail.gmail.com" , "from" : "p at greendale.se (Per Melin)" , "mailingList" : "swift-evolution" , "content" : "On Sun, Dec 6, 2015 at 5:59 PM, Erica Sadun via swift-evolution <\nswift-evolution at swift.org> wrote:\n\n> Another complaint regarded a loss of succinctness. Per Melin wrote:\n>\n> Another example from the same LinkedList class. It finds the right place\n> to insert a new node:\n>\n>   for next = head; next != nil && index > 0; prev = next, next = next!.\n> next, --index { }\n>\n> Extreme? Probably, but I like it better than the same thing done in five\n> lines of while loop.\n>\n>\n>\nNo worries, but for the record, I did absolutely not write that. I *quoted*\nthat. I think that C-style 'for' is a horrible mess that should be killed\nwith fire." , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000603.html" , "inReplyTo" : "40642775-F58D-49B0-9BF3-38913FD6924C@ericasadun.com" , "date" : { "$date" : 1449425323000} , "subject" : "[swift-evolution] C-style For Loops" , "references" : [ "AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de" , "CAAcV4sZVC8M4yo+XEdWoGzKyG7rDYuy7ox=Rk3cdbXjFuSD4Sg@mail.gmail.com" , "40642775-F58D-49B0-9BF3-38913FD6924C@ericasadun.com"] , "descendants" : [ "3743E515-225F-43C4-BB62-DC8C848BEE89@ericasadun.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/3743E515-225F-43C4-BB62-DC8C848BEE89@ericasadun.com"}} , "_id" : "3743E515-225F-43C4-BB62-DC8C848BEE89@ericasadun.com" , "from" : "erica at ericasadun.com (Erica Sadun)" , "mailingList" : "swift-evolution" , "content" : "On Dec 6, 2015, at 11:08 AM, Per Melin <p at greendale.se> wrote:\n> \n> On Sun, Dec 6, 2015 at 5:59 PM, Erica Sadun via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n> Another complaint regarded a loss of succinctness. Per Melin wrote: \n> \n> Another example from the same LinkedList class. It finds the right place to insert a new node:\n> \n>   for next = head; next != nil && index > 0; prev = next, next = next!.next, --index { }\n> \n> Extreme? Probably, but I like it better than the same thing done in five lines of while loop.\n> \n> \n> No worries, but for the record, I did absolutely not write that. I *quoted* that. I think that C-style 'for' is a horrible mess that should be killed with fire.\n> \n> \n\nMy apologies! -- E" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000604.html" , "inReplyTo" : "CADS5KKU3JRZo0eCvF4XgA6ZT0=Eb9wtGg-rwn45BZXC2MiXvdA@mail.gmail.com" , "date" : { "$date" : 1449425436000} , "subject" : "[swift-evolution] C-style For Loops" , "references" : [ "AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de" , "CAAcV4sZVC8M4yo+XEdWoGzKyG7rDYuy7ox=Rk3cdbXjFuSD4Sg@mail.gmail.com" , "40642775-F58D-49B0-9BF3-38913FD6924C@ericasadun.com" , "CADS5KKU3JRZo0eCvF4XgA6ZT0=Eb9wtGg-rwn45BZXC2MiXvdA@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/339C6733-8C92-4616-A6A8-46FBF476923B@gmail.com"}} , "_id" : "339C6733-8C92-4616-A6A8-46FBF476923B@gmail.com" , "from" : "lingoerer at gmail.com (Roy Fu)" , "mailingList" : "swift-evolution" , "content" : "I personally do prefer that too, but, it's still not that clear for the attitude of core team on introducing too much functional paradigms. More importantly we had to consider if this would add on learning curve for new programmers.\n\n> On Dec 7, 2015, at 12:36 AM, Thorsten Seitz <thorsten.seitz at web.de> wrote:\n> \n> Hi Roy,\n> \n> I’d prefer if such special syntax would not be reserved for just async computations but used for monadic computations in general (with the async case just being a monad implementation).\n> \n> -Thorsten\n> \n>> Am 06.12.2015 um 10:21 schrieb Roy Fu via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>>:\n>> \n>> Hi all,\n>> \n>> Similar to the syntax ‘do try catch throw’ and ’throws’ for error handling, I propose another syntax for handling CPS functions or async call backs:\n>> \n>> func someFutureWrappedFunc(input: Int) future-> String{\n>>     doSomeStaffInBackground{ (result:String) in\n>>         fulfil result\n>>     }\n>> }\n>> \n>> do{\n>>     let resultX = perform someFutureWrappedFunc(param)\n>>     let resultY = perform anotherFutureWrappedFunc(resultX)\n>>     let final   = resultX + resultY + perform justAnotherFutureWrappedFunc(resultX)\n>>     self.someLabel.text = final\n>> } timeout let context {\n>>     //maybe some additional information\n>> }\n>> \n>> the reason for this proposal is for the importance of async models in modern application  architectures, and avoid such pyramids:\n>> \n>> doSomeStaffInBackground { (resultX) -> Void in\n>>     \n>>     doSomeOtherStaff { (resultY) -> Void in\n>>         \n>>         if resultY.someCondition(resultX) {\n>>             \n>>             evenMakesItMadness(resultY) { (final) -> Void in\n>>                 \n>>                 //finally\n>>             }\n>>         }\n>>     }\n>> }\n>> \n>> \n>> \n>> \n>> For more context comparing this async syntax to the ‘do try catch’:\n>> \n>> do try catch:\n>> enum Result<T> {\n>>     case Success(T)\n>>     case Failure(ErrorType)\n>> }\n>> \n>> func flatMap<T,U> (result:Result<T>, f:T->Result<U>) -> Result<U>{\n>>     switch result{\n>>     case .Success(let v): return f(v)\n>>     case .Failure(let e): return .Failure(e)\n>>     }\n>> }\n>> \n>> func wrap1<T,U>(f:T throws-> U) -> T->Result<U> {\n>>     return {\n>>         do{\n>>             return try .Success(f($0))\n>>         }catch let e{\n>>             return .Failure(e)\n>>         }\n>>     }\n>> }\n>> \n>> func wrap2<T,U>(f:T -> Result<U>) -> T throws-> U{\n>>     return{\n>>         switch f($0){\n>>         case .Success(let v): return v\n>>         case .Failure(let e): throw e\n>>         }\n>>     }\n>> }\n>> \n>> async:\n>> \n>> func flatMap<T,U> (async: (T -> Void) -> Void, f:T -> (U->Void) -> Void) -> (U -> Void) -> Void {\n>>     return{ cont in\n>>         async{ f($0)(cont) }\n>>     }\n>> }\n>> \n>> func wrap1<T,U>(f:T future-> U) -> T->(U->Void)->Void {\n>>     return {input in\n>>         {cont in\n>>             do{\n>>                 cont(perform f(input))\n>>             }catch _{\n>> \n>>             }\n>>         }\n>>     }\n>> }\n>> \n>> func wrap2<T,U>(f:T -> (U->Void)->Void) -> T future-> U{\n>>     return{\n>>         f(input)({\n>>             fulfil $0\n>>         })\n>>     }\n>> }\n>> \n>> \n>> \n>> \n>> \n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000605.html" , "inReplyTo" : "51ADA439-E20B-4C68-B736-44C41E46A6F0@web.de" , "date" : { "$date" : 1449425779000} , "subject" : "[swift-evolution] Proposal: Syntax sugar for cps or async functions similar to the \"do try catch\" for error handling." , "references" : [ "78552B11-3A65-4239-8B33-990E34FEA48A@gmail.com" , "51ADA439-E20B-4C68-B736-44C41E46A6F0@web.de"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAKCGC8Dr29Reis3NnK-MLE3MpswCC9fEU7=Eh3VTCOmj3TfAJw@mail.gmail.com"}} , "_id" : "CAKCGC8Dr29Reis3NnK-MLE3MpswCC9fEU7=Eh3VTCOmj3TfAJw@mail.gmail.com" , "from" : "alexl.mail+swift at gmail.com (Alex Lew)" , "mailingList" : "swift-evolution" , "content" : "Commented on the proposal but realize that it might be better to reply\nhere.\n\nFor clarification: when you say \"deprecate typealias\" do you mean only in\nthe context of associated types or in the language as a whole?\n\nI also thought it might make sense to add to the proposal a disabling of\nthe \"default\" behavior that is currently allowed for type aliases in\nprotocols:\n\nprotocol Prot {\n    associated Container: SequenceType\n    associated Element = Container.Generator.Element // should be illegal\n}\n\nInstead, if you actually want the semantics of an additional associated\ntype with a default (but overridable) value, you should use a protocol\nextension. (Which means that associated ____ = ____ would be allowed in\nprotocol extensions, but not associated ____ : _____  or associated ____ :\n____ = _____.) Does that sound right?\n\n\nOn Sun, Dec 6, 2015 at 10:32 AM, Loïc Lecrenier <swift-evolution at swift.org>\nwrote:\n\n> Well, I went ahead and created a pull request :)\n>\n> I also included a “proposed approach” section, where I propose to deprecate\n> the `typealias` keyword for Swift 2.2, and replace it entirely for Swift\n> 3.0.\n>\n> Does anyone have any thought on that? This is a bit aggressive, but I\n> think it’s worth it.\n> It is actually the same approach Erica proposed for removing C for-loops.\n>\n> Loïc\n>\n> > On Dec 6, 2015, at 1:12 PM, Loïc Lecrenier <loiclecrenier at icloud.com>\n> wrote:\n> >\n> > I have drafted a formal proposal here:\n> https://gist.github.com/loiclec/22459d230a21dbcb81fc\n> > Would love to receive feedback from the community on it, I am\n> particularly worried about the correctness of the terms I used.\n> > Should I make a pull request to swift-evolution now, or should we\n> continue the conversation here?\n> >\n> > Thanks,\n> >\n> > Loïc\n> >\n> > (and sorry about emailing you on Sunday 😇 )\n> >\n> >> On Dec 6, 2015, at 1:48 AM, John McCall <rjmccall at apple.com> wrote:\n> >>\n> >>> On Dec 5, 2015, at 4:35 PM, Loïc Lecrenier via swift-evolution <\n> swift-evolution at swift.org> wrote:\n> >>> Hi everyone :)\n> >>>\n> >>> I propose introducing a new \"associated_type\" keyword that will\n> replace \"typealias\" for declaring associated types in protocols.\n> >>> I remember being confused by associated types when I started using\n> Swift, and I think one reason why was the use of the typealias keyword to\n> define them.\n> >>> One reason was that I thought I knew what typealias did, and so I\n> didn't stop to learn what it did inside a protocol. An other reason was the\n> difficulty of finding help when searching for \"typealias\" instead of\n> \"associated types\".\n> >>> Then, when I thought I understood it, I started building an\n> excessively protocol-oriented program as an exercise. And I still lost a\n> lot of time fighting Swift by trying to use \"real\" typealias-es inside of\n> protocols.\n> >>>\n> >>> Conceptually, I had something like this:\n> >>>\n> >>> protocol ProtA {\n> >>> typealias Container : SequenceType\n> >>> }\n> >>> protocol ProtB {\n> >>> typealias AnOtherAssocType : ProtA\n> >>> func foo(x: AnOtherAssocType.Container.Generator.Element, y:\n> AnOtherAssocType.Container.Generator.Element) ->\n> AnOtherAssocType.Container.Generator.Element\n> >>> }\n> >>>\n> >>> The function foo is very difficult to read, so I wanted to use a\n> shortcut to Element by doing this:\n> >>>\n> >>> protocol ProtB {\n> >>> typealias A : ProtA\n> >>> typealias Element = A.Container.Generator.Element\n> >>> func foo(x: Element, y: Element) -> Element\n> >>> }\n> >>>\n> >>> But by doing so, I didn't create a shortcut to Element, but an\n> associated type with a default value of Element. (right?)\n> >>> Then I tried to write extensions to ProtB where Element conforms to,\n> say, Equatable, and couldn't make it work because\n> A.Container.Generator.Element didn't conform to Equatable.\n> >>>\n> >>> So, that was a rather long explanation of the reasons I think we\n> should replace the typealias keyword by associated_type, and allow \"real\"\n> typealias-es inside protocols.\n> >>\n> >> I think this is a great idea; re-using typealias for associated types\n> was a mistake.\n> >>\n> >> John.\n> >>\n> >>>\n> >>> Ideally, I would write\n> >>>\n> >>> protocol ProtB {\n> >>> associated_type AnOtherAssocType : ProtA\n> >>> typealias Element = AnOtherAssocType.Container.Generator.Element\n> >>> func foo(x: Element, y: Element) -> Element\n> >>> }\n> >>>\n> >>> and it would be exactly the same as\n> >>>\n> >>> protocol ProtB {\n> >>> associated_type AnOtherAssocType : ProtA\n> >>> func foo(x: A.Container.Generator.Element, y:\n> A.Container.Generator.Element) -> A.Container.Generator.Element\n> >>> }\n> >>>\n> >>> There are probably some problems created by this proposal, but right\n> now I can't see any :/\n> >>>\n> >>> Thanks,\n> >>>\n> >>> Loïc\n> >>> _______________________________________________\n> >>> swift-evolution mailing list\n> >>> swift-evolution at swift.org\n> >>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> >\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000606.html" , "inReplyTo" : "3A2C2956-0C24-4838-84C0-B171C8F39F6F@icloud.com" , "date" : { "$date" : 1449426856000} , "subject" : "[swift-evolution] Introduce \"associated_type\" keyword" , "references" : [ "C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com" , "80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com" , "6BCA9015-28F4-4B1B-8AF5-84DFA9256949@icloud.com" , "3A2C2956-0C24-4838-84C0-B171C8F39F6F@icloud.com"] , "descendants" : [ "2FC53481-EF6F-4B06-92FB-283A65F000E3@icloud.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/75B91A7D-2A61-471C-BA61-D3F92EEACC89@pobox.com"}} , "_id" : "75B91A7D-2A61-471C-BA61-D3F92EEACC89@pobox.com" , "from" : "cantrell at pobox.com (Paul Cantrell)" , "mailingList" : "swift-evolution" , "content" : "> I think Python's biggest appeal to new programmers is the fact that it has such a great standard library\n\nThis is not the case, at least in my teaching experience.\n\nOne of the largest hurdles for new programmers, and the one that differentiates beginning languages more than any other, is compiler strictness. This includes both syntax and static type checking.\n\nWe easily forget how hard learning syntax is: to see every piece of punctuation as significant, to read code as a parse tree, to think inside the box of the language’s type system. Programmers in their first months easily spend 50% of the time getting their code to compile, usually more like 80%.\n\nThe problem with compile-time strictness of any kind is that the compiler won’t do _anything_ until _everything_ compiles. I’ve seen this drive beginners to burnout, even drive them away from CS altogether. (To help calibrate your thinking about just how much we’ve forgotten that we learned: eons and eons ago, when my department taught its intro courses in Pascal and C++, the main first-year hurdle was not dealing with unsafe pointers, but knowing where to put the semicolons. Semicolons!)\n\nWhen you don’t understand what a failure looks like, it’s tremendously helpful to be able to actually run the code and see the failure happen. Having the language say “this can’t possibly work so I won’t run it” is not helpful to beginners; it’s just bottled frustration. Having the language say “it worked until I got here, at which point this happened” is infinitely more helpful.\n\nThe biggest hurdle to a beginning programmer is how _stupid_ programming makes one feel. We experience programmers are all used to this. Beginners are not. Their successes are rarer, the obstacles more daunting. Every stumble feels intensely personal. Anything that makes success more incremental and more self-discoverable helps.\n\n• • •\n\nYou might think at this point that I’m arguing in favor of the “no types to compete with Python” mode, but I’d vote against it.\n\nThe ideal beginner language has a flexible, forgiving syntax that rewards guessing; the least compile-time type checking possible; and very clear error messages (both compiler and runtime). On all three counts, this sounds very far from Swift today. Better error messages would be good for all of us, but the other two just don’t sound like Swift.\n\nGood beginner languages reward exploration by empirical experimentation. Good professional development languages reward clarity of intent. Those two things are often in tension, and Swift’s core aesthetic clearly lands on the side of the second.\n\nIs making it a good language for new beginners truly a design goal of Swift? I don’t think it should be. It _does_ seem like an excellent design goal to keep the language as simple, approachable, and learnable as it can be within its aesthetic.\n\nCheers,\n\nPaul\n\nP.S. The Bret Victor article that describes the thinking behind playgrounds has some oustanding ideas on making languages more learnable: http://worrydream.com/#!/LearnableProgramming <http://worrydream.com/#!/LearnableProgramming>\n\n–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––\nhttps://innig.net • @inthehands • http://siestaframework.com/\n\n\n> On Dec 5, 2015, at 6:13 PM, Austin Zheng via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> No, I don't. I think Python's biggest appeal to new programmers is the fact that it has such a great standard library, making it really easy to do whatever you want to do without figuring out how to find or add in external dependencies.\n> \n> Anyways, mistyped Python code still breaks, it just breaks at runtime instead of compile time. In fact, I'd argue that this is even less beginner friendly, since you might write a function that works with some inputs and then inexplicably breaks with others.\n> \n> Austin\n> \n>> On Dec 5, 2015, at 4:09 PM, Amir Michail <a.michail at me.com <mailto:a.michail at me.com>> wrote:\n>> \n>> \n>>> On Dec 5, 2015, at 7:05 PM, Austin Zheng via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>> \n>>> ml>\n>>> I disagree with the idea that a type system is too much of a hurdle for beginner programmers to overcome.\n>> \n>> Don’t you think that Python currently provides a better introduction to programming due to its simplicity?\n>> \n>>> \n>>> Austin\n>>> \n>>>> On Dec 5, 2015, at 4:01 PM, Kevin Lundberg via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>>> \n>>>> This is somewhat possible today on Apple platforms with AnyObject. You can call any objc-visible method on AnyObject and it will compile, and the return type will also be AnyObject (I don't recall if the return type is optional as well or not). This doesn't work with value types, but neither does id in objc.\n>>>> \n>>>> Having a more complete lax typed mode similar to Python or php I think is of limited usefulness, would add too much complexity to the language, and yield too much uncertainty about any given piece of swift code. \n>>>> \n>>>> --\n>>>> Kevin Lundberg\n>>>> \n>>>> On Dec 5, 2015, at 6:50 PM, Adrian Kashivskyy via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>>> \n>>>>> I can't believe I'm seeing a proposal to remove type safety, one of the fundamental features of Swift...\n>>>>> \n>>>>> Regards,\n>>>>> Adrian Kashivskyy\n>>>>> iOS Developer at Netguru\n>>>>> \n>>>>>> Wiadomość napisana przez Amir Michail via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> w dniu 05.12.2015, o godz. 20:51:\n>>>>>> \n>>>>>> Python is still easier than Swift for beginning programmers. But maybe such a mode can allow Swift to be used by beginners also? _____________________________________________ swift-evolution mailing list swift-evolution at swift.org <mailto:swift-evolution at swift.org> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>> \n>>>>> \n>>>>> _______________________________________________\n>>>>> swift-evolution mailing list\n>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>> \n>>>> _______________________________________________\n>>>> swift-evolution mailing list\n>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>> \n>>> \n>>> --rbÚḟîẁ\n>>> íz{CÊhĠ+bḃx§)Ŷ_______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>> https://lists.swift.org/ma <https://lists.swift.org/ma>\n> \n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000607.html" , "inReplyTo" : "B3DEBE77-A879-4A1E-BC4D-1F028E6D326A@gmail.com" , "date" : { "$date" : 1449427359000} , "subject" : "[swift-evolution] A mode with no type checking to compete with Python." , "references" : [ "5E968E10-2DBD-4999-978C-B398BC446A21@me.com" , "7240610C-B5DA-41B8-909A-D138404C6799@me.com" , "0CFEA686-79B9-4B51-A984-7C706879BB5D@klundberg.com" , "E2C52ABB-8CD4-4D5C-BFA3-F3EA995AC6FC@gmail.com" , "7F08A62B-6FD7-4AF2-A939-EF1D3CD71BD7@me.com" , "B3DEBE77-A879-4A1E-BC4D-1F028E6D326A@gmail.com"] , "descendants" : [ "CAKCGC8Dcw0w-vzR=vmHN2ik9GTjiaZmRiGqdnF8Kq7xhX7+m7A@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAKCGC8DSRhWKkJ8qD_zWzxO=vj-OiZibG-XPSnte8OJhNR37kQ@mail.gmail.com"}} , "_id" : "CAKCGC8DSRhWKkJ8qD_zWzxO=vj-OiZibG-XPSnte8OJhNR37kQ@mail.gmail.com" , "from" : "alexl.mail+swift at gmail.com (Alex Lew)" , "mailingList" : "swift-evolution" , "content" : "Don, have you considered making your Number type FloatLiteralConvertible?\nThis would allow you not just to *let number: Number = 4.9*, but also pass\nin 4.9 to a function that expected a *Number*. It would not let you set\nNumber variables to be equal to other variables of type Float, it seems\nyour main use case here is literals anyway.\n\nhttp://swiftdoc.org/v2.0/protocol/FloatLiteralConvertible/\n\nOn Sun, Dec 6, 2015 at 9:26 AM, Don Wills via swift-evolution <\nswift-evolution at swift.org> wrote:\n\n> Silvan,\n>\n> Yes, I understand the concern you raise.  I too have held that general\n> opinion of overloading operators in other languages for many years.  That\n> said, overloading arithmetic and other operators causes the same\n> opportunity for abuse.  For example, overloading + for integers to do\n> something different (like rounding instead of truncation) would make\n> maintenance of existing programs into a giant guessing game.\n>\n> That said, once the cat is out of the bag to overload operators, I don't\n> see how adding support for = makes things any worse.\n>\n> FYI, the reason for my suggestion is to add support for fixed decimal\n> arithmetic just like that available in COBOL.  Yeh I can hear the groans\n> now.  However, for business applications, fixed decimal arithmetic is a\n> basic feature that has been tossed away in new languages by language\n> designers who don't actually labor in the trenches.  I've built a simple\n> class to do just that - here is some sample code that uses my Number class\n> that gives an idea of what the code does:\n>\n> var amount = Number(left: 6, right: 2);\n> var result = Number(left: 9, right: 2);\n> amount <- 3.9;\n> amount += 1;\n> result <- amount * 4;\n> print(result)\n>\n> Note that <- is the assignment operator.  I am sure all would agree that =\n> is superior in this situation.  Such code would be far more readable and\n> the Number values would act just like and interoperate with Float and Int\n> in all regards *except* that currently the = operator is not available for\n> assignment.\n>\n> Don Wills\n>\n> PS.  FWIW, the  IEEE 754-2008 d128 alternative that Chris Lattner\n> mentioned to me is inferior to the kind of support for fixed decimal\n> arithmetic that I believe would help make Swift superior to C# for business\n> applications.\n>\n>\n> On Dec 6, 2015, at 6:58 AM, Silvan Mosberger < kametrixom at icloud.com>\n> wrote:\n>\n> Hi Don\n>\n> I think this is a terrible idea! Imagine what you’d be able to do with\n> that:\n>\n> let x : String = 3\n>\n> This would lead to the same problems already discussed with implicit\n> initialisers:\n> https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000531.html,\n> just worse. Also assignment is something more fundamental than other\n> operators, I doubt it’s even possible to do that.\n>\n> On 06 Dec 2015, at 14:44, Don Wills via swift-evolution <\n> swift-evolution at swift.org> wrote:\n>\n> The ability to overload operators is very useful.  However, that utility\n> is diminished without the ability to overload the simple assignment\n> operator ( = ).  I vaguely recall reading somewhere that there is a reason\n> for this having to do with syntax ambiguity.  Can this problem be solved so\n> that = can be overloaded?\n>\n> Don Wills\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>\n>\n> Untracked with Trackbuster <https://trackbuster.com/?sig>\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000608.html" , "inReplyTo" : "93AC01C7-172B-41F8-B27E-803887706B87@portablesoftware.com" , "date" : { "$date" : 1449427383000} , "subject" : "[swift-evolution] Overloading assignment operator" , "references" : [ "19FBB566-3CF3-4CB3-9658-751071B88288@portablesoftware.com" , "D022E424-6A10-4F16-A11C-41B3DF9485A8@icloud.com" , "93AC01C7-172B-41F8-B27E-803887706B87@portablesoftware.com"] , "descendants" : [ "D37A244A-8E82-42F4-A780-A28713E3D990@portablesoftware.com" , "CAN9tzpCDdNmmn8kG89FhxnnDsFiMp-M7FAEUoqdO8pHs7smLJA@mail.gmail.com" , "DB00FFEF-B61E-4294-9891-8A64B2584289@gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAKCGC8Dcw0w-vzR=vmHN2ik9GTjiaZmRiGqdnF8Kq7xhX7+m7A@mail.gmail.com"}} , "_id" : "CAKCGC8Dcw0w-vzR=vmHN2ik9GTjiaZmRiGqdnF8Kq7xhX7+m7A@mail.gmail.com" , "from" : "alexl.mail+swift at gmail.com (Alex Lew)" , "mailingList" : "swift-evolution" , "content" : "Yes! As a high school CS teacher, agreed 100%. This is what makes Racket /\nScheme such a great introductory language: there is really only one type of\nsyntax mistake you can make, and it's having mismatched parens (something\nthat the IDE makes it easy for students to see). When students move on to\nJava for AP, in come the errors. I've seen students give up on CS because\nthey can never compile their code -- in one case, for example, a student\nwas putting semicolons after every if statement, for loop, while loop, and\nmethod definition, before the opening curly brace. (In my experience,\nsyntax presents a bigger hurdle than type errors.)\n\nSwift is not, primarily, a teaching language *for beginners*. (It makes a\ngreat teaching language for intermediate and advanced students, or students\nwho want to learn about fancy type systems.) Its type system is extremely\npowerful but also beyond the scope of an introductory programming course.\nThat said, playgrounds *are* very cool and help alleviate some of the\nfrustration of writing a long program and having it not compile.\n\nOn Sun, Dec 6, 2015 at 1:42 PM, Paul Cantrell via swift-evolution <\nswift-evolution at swift.org> wrote:\n\n> I think Python's biggest appeal to new programmers is the fact that it has\n> such a great standard library\n>\n>\n> This is not the case, at least in my teaching experience.\n>\n> One of the largest hurdles for new programmers, and the one that\n> differentiates beginning languages more than any other, is compiler\n> strictness. This includes both syntax and static type checking.\n>\n> We easily forget how hard learning syntax is: to see every piece of\n> punctuation as significant, to read code as a parse tree, to think inside\n> the box of the language’s type system. Programmers in their first months\n> easily spend 50% of the time getting their code to compile, usually more\n> like 80%.\n>\n> The problem with compile-time strictness of any kind is that the compiler\n> won’t do _anything_ until _everything_ compiles. I’ve seen this drive\n> beginners to burnout, even drive them away from CS altogether. (To help\n> calibrate your thinking about just how much we’ve forgotten that we\n> learned: eons and eons ago, when my department taught its intro courses in\n> Pascal and C++, the main first-year hurdle was not dealing with unsafe\n> pointers, but knowing where to put the semicolons. Semicolons!)\n>\n> When you don’t understand what a failure looks like, it’s tremendously\n> helpful to be able to actually run the code and see the failure happen.\n> Having the language say “this can’t possibly work so I won’t run it” is not\n> helpful to beginners; it’s just bottled frustration. Having the language\n> say “it worked until I got here, at which point this happened” is\n> infinitely more helpful.\n>\n> The biggest hurdle to a beginning programmer is how _stupid_ programming\n> makes one feel. We experience programmers are all used to this. Beginners\n> are not. Their successes are rarer, the obstacles more daunting. Every\n> stumble feels intensely personal. Anything that makes success more\n> incremental and more self-discoverable helps.\n>\n> • • •\n>\n> You might think at this point that I’m arguing in favor of the “no types\n> to compete with Python” mode, but I’d vote against it.\n>\n> The ideal beginner language has a flexible, forgiving syntax that rewards\n> guessing; the least compile-time type checking possible; and very clear\n> error messages (both compiler and runtime). On all three counts, this\n> sounds very far from Swift today. Better error messages would be good for\n> all of us, but the other two just don’t sound like Swift.\n>\n> Good beginner languages reward exploration by empirical experimentation.\n> Good professional development languages reward clarity of intent. Those two\n> things are often in tension, and Swift’s core aesthetic clearly lands on\n> the side of the second.\n>\n> Is making it a good language for new beginners truly a design goal of\n> Swift? I don’t think it should be. It _does_ seem like an excellent design\n> goal to keep the language as simple, approachable, and learnable as it can\n> be within its aesthetic.\n>\n> Cheers,\n>\n> Paul\n>\n> P.S. The Bret Victor article that describes the thinking behind\n> playgrounds has some oustanding ideas on making languages more learnable:\n> http://worrydream.com/#!/LearnableProgramming\n>\n> –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––\n> https://innig.net • @inthehands • http://siestaframework.com/\n>\n>\n> On Dec 5, 2015, at 6:13 PM, Austin Zheng via swift-evolution <\n> swift-evolution at swift.org> wrote:\n>\n> No, I don't. I think Python's biggest appeal to new programmers is the\n> fact that it has such a great standard library, making it really easy to do\n> whatever you want to do without figuring out how to find or add in external\n> dependencies.\n>\n> Anyways, mistyped Python code still breaks, it just breaks at runtime\n> instead of compile time. In fact, I'd argue that this is even less beginner\n> friendly, since you might write a function that works with some inputs and\n> then inexplicably breaks with others.\n>\n> Austin\n>\n> On Dec 5, 2015, at 4:09 PM, Amir Michail < a.michail at me.com> wrote:\n>\n>\n> On Dec 5, 2015, at 7:05 PM, Austin Zheng via swift-evolution <\n> swift-evolution at swift.org> wrote:\n>\n> ml>\n> I disagree with the idea that a type system is too much of a hurdle for\n> beginner programmers to overcome.\n>\n>\n> Don’t you think that Python currently provides a better introduction to\n> programming due to its simplicity?\n>\n>\n> Austin\n>\n> On Dec 5, 2015, at 4:01 PM, Kevin Lundberg via swift-evolution <\n> swift-evolution at swift.org> wrote:\n>\n> This is somewhat possible today on Apple platforms with AnyObject. You can\n> call any objc-visible method on AnyObject and it will compile, and the\n> return type will also be AnyObject (I don't recall if the return type is\n> optional as well or not). This doesn't work with value types, but neither\n> does id in objc.\n>\n> Having a more complete lax typed mode similar to Python or php I think is\n> of limited usefulness, would add too much complexity to the language, and\n> yield too much uncertainty about any given piece of swift code.\n>\n> --\n> Kevin Lundberg\n>\n> On Dec 5, 2015, at 6:50 PM, Adrian Kashivskyy via swift-evolution <\n> swift-evolution at swift.org> wrote:\n>\n> I can't believe I'm seeing a proposal to remove type safety, one of the\n> fundamental features of Swift...\n>\n> Regards,\n> Adrian Kashivskyy\n> iOS Developer at Netguru\n>\n> Wiadomość napisana przez Amir Michail via swift-evolution <\n> swift-evolution at swift.org> w dniu 05.12.2015, o godz. 20:51:\n>\n> Python is still easier than Swift for beginning programmers. But maybe\n> such a mode can allow Swift to be used by beginners also?\n> *____________________________________________*_ swift-evolution mailing\n> list swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>\n> --r‡bž Úḟîẁ\n> ‰íz{CŠÊhĠ+bḃx§–)Ŷ_______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/ma\n>\n>\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>\n> Untracked with Trackbuster <https://trackbuster.com/?sig>\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000609.html" , "inReplyTo" : "75B91A7D-2A61-471C-BA61-D3F92EEACC89@pobox.com" , "date" : { "$date" : 1449428181000} , "subject" : "[swift-evolution] A mode with no type checking to compete with Python." , "references" : [ "5E968E10-2DBD-4999-978C-B398BC446A21@me.com" , "7240610C-B5DA-41B8-909A-D138404C6799@me.com" , "0CFEA686-79B9-4B51-A984-7C706879BB5D@klundberg.com" , "E2C52ABB-8CD4-4D5C-BFA3-F3EA995AC6FC@gmail.com" , "7F08A62B-6FD7-4AF2-A939-EF1D3CD71BD7@me.com" , "B3DEBE77-A879-4A1E-BC4D-1F028E6D326A@gmail.com" , "75B91A7D-2A61-471C-BA61-D3F92EEACC89@pobox.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/7D68F57E-C847-4E0D-AF3A-FD1F2DC928A9@icloud.com"}} , "_id" : "7D68F57E-C847-4E0D-AF3A-FD1F2DC928A9@icloud.com" , "from" : "possen at gmail.com (Paul Ossenbruggen)" , "mailingList" : "swift-evolution" , "content" : "I like this too, seems more powerful.  Also, would single line expressions be allowed?  If not would case be required for example:\n\nlet myFavoriteColor = yourFavoriteColor ?\n    case .Blue: .Red\n    case .Green: .Blue\n    case .Red: .Green\n    default: .Yellow\n\n\n> On Dec 6, 2015, at 9:11 AM, Sean Heber via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> I really like this train of thought. +1\n> \n> l8r\n> Sean\n> \n> \n> On Dec 6, 2015, at 11:02 AM, Alex Lew via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n> \n>> What if we left the if { ...} else { ... } syntax alone (as a statement), and updated the ternary expression to be a more general pattern matching expression (closer to \"switch\")? Something like\n>> \n>> let x = condition ?\n>>    true: \"Hello\"\n>>    false: \"Goodbye\"\n>> \n>> let x = optionalValue ?\n>>    .Some(let unwrapped): \"Hello, \\(unwrapped)\"\n>>    .None: \"To Whom It May Concern\"\n>> \n>> let myFavoriteColor = yourFavoriteColor ?\n>>     .Blue: .Red\n>>     .Green: .Blue\n>>     .Red: .Green\n>> \n>> let quadrant = (x, y) ?\n>>     let (x, y) where x < 50 && y < 50: \"top left\"\n>>     let (x, y) where x < 50 && y > 50: \"bottom left\"\n>>     let (x, y) where x > 50 && y < 50: \"top right\"\n>>     default: \"bottom right\"\n>> \n>> The colon comes from the fact that this is sort of a light-weight expression-based \"switch\" statement, where each branch can only contain an expression, not a series of statements.\n>> \n>> This is very similar to pattern matching expressions in languages like Haskell, ML, and Coq.\n>> \n>> On Sun, Dec 6, 2015 at 11:25 AM, Thorsten Seitz <thorsten.seitz at web.de <mailto:thorsten.seitz at web.de>> wrote:\n>>> Am 06.12.2015 um 01:28 schrieb Alex Lew via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>>:\n>>> \n>>> I don't think you can just get rid of the if statement in favor of an expression. You still want to be able to do this:\n>>> \n>>> if (condition) {\n>>>     funcWithSideEffectsThatReturnsInt()\n>>> } else {\n>>>     funcWithSideEffectsThatReturnsString()\n>>> }\n>>> \n>>> but that's not a valid expression (what is its type?).\n>> \n>> That would actually be no problem if Swift’s type system would have union types (Ceylon has union and intersection types which are quite awesome and enable lots of nice things quite naturally, see http://ceylon-lang.org/documentation/1.2/tour/types/ <http://ceylon-lang.org/documentation/1.2/tour/types/>).\n>> \n>> In that case the type of such an expression would just be the union of both types, which is written Int | String in Ceylon.\n>> \n>> -Thorsten\n>> \n>> \n>> \n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>  _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000610.html" , "inReplyTo" : "4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com" , "date" : { "$date" : 1449428222000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com" , "CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com" , "C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com" , "18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com" , "2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io" , "BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com" , "CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com" , "CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com" , "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com" , "BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com" , "909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net" , "0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com" , "49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net" , "CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com" , "49EEA2E6-55F2-49DE-A59F-A13017626370@web.de" , "CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com" , "4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com"] , "descendants" : [ "1449429569.1342623.459603529.32C935BC@webmail.messagingengine.com" , "CAKCGC8BEzyEPAFWCPKPiH+UL3KmZm7aM6KUPu-F9DKV-YvUbCA@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com"}} , "_id" : "071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com" , "from" : "colin at springsandstruts.com (Colin Barrett)" , "mailingList" : "swift-evolution" , "content" : "tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.\n\nApologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.\n\nI think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)\n\nConsider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:\n\nhttps://gist.github.com/cbarrett/23b24a9fe76efdf006df <https://gist.github.com/cbarrett/23b24a9fe76efdf006df>\n\nThis technique is very extensible — for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.\n\nYes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type — low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.\n\nThanks,\n-Colin\n\n> On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.\n> \n> If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don't introduce an infinite \"switch\" loop.\n> \n> Sent from my iPad\n> \n> On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n> \n>> Very much thinking out loud and not really the implications, I wonder if we might just use \"continue\" instead of \"reswitch\".\n>> \n>> I very much like specifying what case to fall through into, no matter how we spell it.\n>> \n>> - Steve\n>> \n>> On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>> \n>>>> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>>>> On Dec 4, 2015, at 11:37 PM, John Calsbeek <john.calsbeek+lists at gmail.com <mailto:john.calsbeek+lists at gmail.com>> wrote:\n>>>>> `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.\n>>>>> \n>>>>> It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.\n>>>> \n>>>> Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.\n>>>> \n>>>> On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.\n>>> \n>>> Oh, I see that Joe already brought this up, spelled “reswitch”.\n>>> \n>>> John.\n>>> \n>>>> \n>>>> John.\n>>>> \n>>>>> \n>>>>> One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).\n>>>>> \n>>>>> switch op {\n>>>>> case LOAD_INDIRECT:\n>>>>>    in0 = memory[in1]\n>>>>>    fallthrough\n>>>>> case LOAD:\n>>>>>    out0 = memory[in0]\n>>>>> //...\n>>>>> }\n>>>>> \n>>>>> I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.\n>>>>> \n>>>>> Cheers,\n>>>>> John\n>>>>> \n>>>>>> On Dec 4, 2015, at 2:42 PM, John McCall <rjmccall at apple.com <mailto:rjmccall at apple.com>> wrote:\n>>>>>> \n>>>>>>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard <kevin at sb.org <mailto:kevin at sb.org>> wrote:\n>>>>>>> It's not actually Duff's Device. Duff's Device relies on the fact that C switch statements don't actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it's a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.\n>>>>>> \n>>>>>> To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.\n>>>>>> \n>>>>>> But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.\n>>>>>> \n>>>>>> John.\n>>>>>> \n>>>>>>>  \n>>>>>>> Steve's code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It's a good example of one of the uses of `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's Device in Swift.\n>>>>>>>  \n>>>>>>> -Kevin Ballard\n>>>>>>>  \n>>>>>>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:\n>>>>>>>> Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.\n>>>>>>>>  \n>>>>>>>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:\n>>>>>>>>>  \n>>>>>>>>> Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it. \n>>>>>>>>>  \n>>>>>>>>> True fact: On all of gist.github.com <http://gist.github.com/>, there are only 22 gist results for \"fallthrough language:swift\".\n>>>>>>>>> Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:\n>>>>>>>>> case .Enum1, .Enum2:\n>>>>>>>>> expressed as \n>>>>>>>>> case .Enum1: fallthrough\n>>>>>>>>> case .Enum2:\n>>>>>>>>>  \n>>>>>>>>> And then there's streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea <https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea>   I'm pretty sure that ponies were harmed in the production of whatever that last bit is.\n>>>>>>>>>  \n>>>>>>>>>  \n>>>>>>>>>  \n>>>>>>>>>  \n>>>>>>>>>> On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com <mailto:jalkut at red-sweater.com> wrote:\n>>>>>>>>>>  \n>>>>>>>>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the \"fallthrough\" keyword from the language?\n>>>>>>>>>>  \n>>>>>>>>>> My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.\n>>>>>>>>>>  \n>>>>>>>>>> The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:\n>>>>>>>>>>  \n>>>>>>>>>> \"The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.\"\n>>>>>>>>>>  \n>>>>>>>>>> To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.\n>>>>>>>>>>  \n>>>>>>>>>> I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.\n>>>>>>>>>>  \n>>>>>>>>>> In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.\n>>>>>>>>>>  \n>>>>>>>>>> Thoughts?\n>>>>>>>>>>  \n>>>>>>>>>> Daniel\n>>>>>>>>>>  \n>>>>>>>>>> _______________________________________________\n>>>>>>>>>> swift-evolution mailing list\n>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>>>>>> \n>>>>>>>>>  \n>>>>>>>>> \n>>>>>>>>> _______________________________________________\n>>>>>>>>> swift-evolution mailing list\n>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>>>>> \n>>>>>>>>  \n>>>>>>>> \n>>>>>>>> _______________________________________________\n>>>>>>>> swift-evolution mailing list\n>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>>>>  \n>>>>>>> \n>>>>>>> _______________________________________________\n>>>>>>> swift-evolution mailing list\n>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>>> \n>>>>>>  _______________________________________________\n>>>>>> swift-evolution mailing list\n>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>> \n>>>>> _______________________________________________\n>>>>> swift-evolution mailing list\n>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>> \n>>>> \n>>>> _______________________________________________\n>>>> swift-evolution mailing list\n>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>> \n>>> \n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>> \n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000611.html" , "inReplyTo" : "D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org" , "date" : { "$date" : 1449428276000} , "subject" : "[swift-evolution] Proposal: Remove the \"fallthrough\" keyword" , "references" : [ "3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com" , "AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com" , "8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com" , "1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com" , "02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com" , "E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com" , "444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com" , "EF1675F6-7918-4262-B535-696104BFC405@apple.com" , "CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com" , "D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org"] , "descendants" : [ "ECE284CE-EDE3-4071-ABB6-821820F1FC44@jacopo.giola.org" , "EF9FEF97-C7B8-4D54-B406-2B62FDD15B59@springsandstruts.com" , "98973CF0-B5A8-491F-A8D0-DA73456FF01B@jacopo.giola.org" , "CAKCGC8B0UPGUHeJ_1n8XsGoo+E6Anyj_+_R7WsT76rV1Q-qu2w@mail.gmail.com" , "E7877054-1CF7-4596-800A-0D3C578A0CF1@portableinnovations.de" , "CAKCGC8Cp52O7DX6wWSc3J6FR8Xmoo_WLBgjGBa6fSXzNHhdHEg@mail.gmail.com" , "D7B06EA6-A46C-4920-9E09-CB99B96242AA@jacopo.giola.org" , "1449442122.2380087.459714713.0AC4A201@webmail.messagingengine.com" , "D9340CB2-A696-478A-BAE7-F93ED39CB2DC@red-sweater.com" , "CEA837D7-E2B1-48DC-A53B-D216F96DD8DF@apple.com" , "2423784D-3B84-41CE-9BE2-0850BFE5A3C0@apple.com" , "2A8EA416-B4FF-45B3-9C6D-F94059151129@apple.com" , "82BBEAF7-A512-460A-998C-054AE6D70BEB@springsandstruts.com" , "9C8A3DCA-B80C-4D1F-9528-DD65C0020680@apple.com" , "CAKCGC8BL6SHkO0T_Rg6Ren-NfCLs+eGBb6Zm9aFuZ5rMkWJXtQ@mail.gmail.com" , "AC2407AD-ABFF-4657-A04C-F37E52466316@springsandstruts.com" , "1449524366.1229815.460824345.0E2309C2@webmail.messagingengine.com" , "1449524552.1230499.460828169.5289846B@webmail.messagingengine.com" , "6BABB1A5-55CD-43AF-8D5D-9758F55AD611@apple.com" , "266A61BA-1890-46D7-8969-4A0225EA60B4@springsandstruts.com" , "37FA3360-5F23-462D-BE9B-3743253D2693@apple.com" , "CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org" , "C19956A6-C9B2-45CC-8C91-DA2215EBEA5C@alkaline-solutions.com" , "6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com" , "6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org" , "A56C416E-E246-44FC-A681-3DD66171DF30@springsandstruts.com" , "CADQN+5atyJ78vi0xssjOxh2ka_-jZTaO3ZabxFdY80YqJHFmxg@mail.gmail.com" , "CAKCGC8DHCxwtiU82CjxChc6PaiB495WOCJBP0iq04uw7iWcQmA@mail.gmail.com" , "DEBE0A49-3E5A-431F-8559-63EBA7214068@jacopo.giola.org" , "CAKCGC8DbhMOX6bHtzXQcAhjHQSw1wSSoX-TBUtew0arWA=4pSw@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/DB00FFEF-B61E-4294-9891-8A64B2584289@gmail.com"}} , "_id" : "DB00FFEF-B61E-4294-9891-8A64B2584289@gmail.com" , "from" : "stephen.celis at gmail.com (Stephen Celis)" , "mailingList" : "swift-evolution" , "content" : "I think that his number assignment (via `<~`) depends on the current state of `amount`, and that using FloatLiteralConvertible does not provide enough information at the call site (since the current value is not available in the initializer).\n\nStephen\n\n> On Dec 6, 2015, at 1:43 PM, Alex Lew via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> Don, have you considered making your Number type FloatLiteralConvertible? This would allow you not just to let number: Number = 4.9, but also pass in 4.9 to a function that expected a Number. It would not let you set Number variables to be equal to other variables of type Float, it seems your main use case here is literals anyway.\n> \n> http://swiftdoc.org/v2.0/protocol/FloatLiteralConvertible/ <http://swiftdoc.org/v2.0/protocol/FloatLiteralConvertible/>\n> \n> On Sun, Dec 6, 2015 at 9:26 AM, Don Wills via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n> Silvan,\n> \n> Yes, I understand the concern you raise.  I too have held that general opinion of overloading operators in other languages for many years.  That said, overloading arithmetic and other operators causes the same opportunity for abuse.  For example, overloading + for integers to do something different (like rounding instead of truncation) would make maintenance of existing programs into a giant guessing game.\n> \n> That said, once the cat is out of the bag to overload operators, I don't see how adding support for = makes things any worse.\n> \n> FYI, the reason for my suggestion is to add support for fixed decimal arithmetic just like that available in COBOL.  Yeh I can hear the groans now.  However, for business applications, fixed decimal arithmetic is a basic feature that has been tossed away in new languages by language designers who don't actually labor in the trenches.  I've built a simple class to do just that - here is some sample code that uses my Number class that gives an idea of what the code does:\n> \n> var amount = Number(left: 6, right: 2);\n> var result = Number(left: 9, right: 2);\n> amount <- 3.9;\n> amount += 1;\n> result <- amount * 4;\n> print(result)\n> \n> Note that <- is the assignment operator.  I am sure all would agree that = is superior in this situation.  Such code would be far more readable and the Number values would act just like and interoperate with Float and Int in all regards *except* that currently the = operator is not available for assignment.\n> \n> Don Wills\n> \n> PS.  FWIW, the  IEEE 754-2008 d128 alternative that Chris Lattner mentioned to me is inferior to the kind of support for fixed decimal arithmetic that I believe would help make Swift superior to C# for business applications.\n> \n> \n>> On Dec 6, 2015, at 6:58 AM, Silvan Mosberger < kametrixom at icloud.com <mailto:kametrixom at icloud.com>> wrote:\n>> \n>> Hi Don\n>> \n>> I think this is a terrible idea! Imagine what you’d be able to do with that:\n>> \n>> let x : String = 3\n>> \n>> This would lead to the same problems already discussed with implicit initialisers: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000531.html <https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000531.html>, just worse. Also assignment is something more fundamental than other operators, I doubt it’s even possible to do that.\n>> \n>>> On 06 Dec 2015, at 14:44, Don Wills via swift-evolution < swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>> \n>>> The ability to overload operators is very useful.  However, that utility is diminished without the ability to overload the simple assignment operator ( = ).  I vaguely recall reading somewhere that there is a reason for this having to do with syntax ambiguity.  Can this problem be solved so that = can be overloaded? \n>>> \n>>> Don Wills \n>>> _______________________________________________ \n>>> swift-evolution mailing list \n>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org> \n>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution> \n>> \n> \n> Untracked with Trackbuster <https://trackbuster.com/?sig>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n> \n> \n>  _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000612.html" , "inReplyTo" : "CAKCGC8DSRhWKkJ8qD_zWzxO=vj-OiZibG-XPSnte8OJhNR37kQ@mail.gmail.com" , "date" : { "$date" : 1449428371000} , "subject" : "[swift-evolution] Overloading assignment operator" , "references" : [ "19FBB566-3CF3-4CB3-9658-751071B88288@portablesoftware.com" , "D022E424-6A10-4F16-A11C-41B3DF9485A8@icloud.com" , "93AC01C7-172B-41F8-B27E-803887706B87@portablesoftware.com" , "CAKCGC8DSRhWKkJ8qD_zWzxO=vj-OiZibG-XPSnte8OJhNR37kQ@mail.gmail.com"] , "descendants" : [ "D37A244A-8E82-42F4-A780-A28713E3D990@portablesoftware.com" , "CAN9tzpCDdNmmn8kG89FhxnnDsFiMp-M7FAEUoqdO8pHs7smLJA@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/9896FC65-F28A-4BF4-AA7A-95C18904C56B@yahoo.com"}} , "_id" : "9896FC65-F28A-4BF4-AA7A-95C18904C56B@yahoo.com" , "from" : "kellygerber22 at yahoo.com (Kelly Gerber)" , "mailingList" : "swift-evolution" , "content" : "I think that the C-style for loop should be removed from Swift. The scope rules for this for loop are wrong. Every loop sees the same scope. This is a source of bugs if you export the loop variable name outside the scope of the for statement, for example in a closure. The following code illustrates the problem:\n\nvar handlers: [() -> ()] = []\n\nfor i in 0..<5 {\n    handlers.append { print(i) }\n}\n\nfor handler in handlers {\n    handler()  // \"0 1 2 3 4\"\n}\n\nhandlers = []\n\nfor var i = 0; i < 5; i += 1 {\n    handlers.append { print(i) }\n}\n\nfor handler in handlers {\n    handler()  // \"5 5 5 5 5\"\n}\n\nThe Swift for-in loop does the right thing naturally. The C-style for loop does the wrong thing naturally. Removing the C-style for loop from Swift will eliminate one more class of possible errors from the language." , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000613.html" , "date" : { "$date" : 1449428613000} , "subject" : "[swift-evolution] [Draft] [Idea] [Loops] C-style For Loops" , "references" : [ ""] , "inReplyTo" :  null  , "descendants" : [ "CA+Y5xYdpHCoCSwGi8MB3cWLd79XHNGo8BB2G=LJaPSPVtsq8Qg@mail.gmail.com" , "289929F8-E37F-40CA-9C1F-E71537027F5F@architechies.com" , "8E65F943-2F5B-4D60-B294-E66A418B2C17@gmail.com" , "7CBA0795-377E-4B17-ACEC-5714B273E18C@alkaline-solutions.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAAcV4sbQxUywKAHE=3SCACEFH4YvUqjwEr_0=fjf59ndZtoedg@mail.gmail.com"}} , "_id" : "CAAcV4sbQxUywKAHE=3SCACEFH4YvUqjwEr_0=fjf59ndZtoedg@mail.gmail.com" , "from" : "cheyo at masters3d.com (J. Cheyo Jimenez)" , "mailingList" : "swift-evolution" , "content" : "I do like the idea of leaving the if else as an statement because it\nmay simplify things. Ideally the new ternary syntax would exclude the\nquestion mark and colon. Without introducing new keywords, it could work\nsomething like the following.\n\nlet result = where condition switch x else y\n\nlet result2 = where x < y switch 1 else where y == x switch 2 else 3\n\n\n\n\n\n\nOn Sunday, December 6, 2015, Alex Lew via swift-evolution <\nswift-evolution at swift.org> wrote:\n\n> What if we left the if { ...} else { ... } syntax alone (as a statement),\n> and updated the ternary expression to be a more general pattern matching\n> expression (closer to \"switch\")? Something like\n>\n> let x = condition ?\n>    true: \"Hello\"\n>    false: \"Goodbye\"\n>\n> let x = optionalValue ?\n>    .Some(let unwrapped): \"Hello, \\(unwrapped)\"\n>    .None: \"To Whom It May Concern\"\n>\n> let myFavoriteColor = yourFavoriteColor ?\n>     .Blue: .Red\n>     .Green: .Blue\n>     .Red: .Green\n>\n> let quadrant = (x, y) ?\n>     let (x, y) where x < 50 && y < 50: \"top left\"\n>     let (x, y) where x < 50 && y > 50: \"bottom left\"\n>     let (x, y) where x > 50 && y < 50: \"top right\"\n>     default: \"bottom right\"\n>\n> The colon comes from the fact that this is sort of a light-weight\n> expression-based \"switch\" statement, where each branch can only contain an\n> expression, not a series of statements.\n>\n> This is very similar to pattern matching expressions in languages like\n> Haskell, ML, and Coq.\n>\n> On Sun, Dec 6, 2015 at 11:25 AM, Thorsten Seitz <thorsten.seitz at web.de\n> <javascript:_e(%7B%7D,'cvml','thorsten.seitz at web.de');>> wrote:\n>\n>> Am 06.12.2015 um 01:28 schrieb Alex Lew via swift-evolution <\n>> swift-evolution at swift.org\n>> <javascript:_e(%7B%7D,'cvml','swift-evolution at swift.org');>>:\n>>\n>> I don't think you can just get rid of the if statement in favor of an\n>> expression. You still want to be able to do this:\n>>\n>> if (condition) {\n>>     funcWithSideEffectsThatReturnsInt()\n>> } else {\n>>     funcWithSideEffectsThatReturnsString()\n>> }\n>>\n>> but that's not a valid expression (what is its type?).\n>>\n>>\n>> That would actually be no problem if Swift’s type system would have union\n>> types (Ceylon has union and intersection types which are quite awesome and\n>> enable lots of nice things quite naturally, see\n>> http://ceylon-lang.org/documentation/1.2/tour/types/).\n>>\n>> In that case the type of such an expression would just be the union of\n>> both types, which is written Int | String in Ceylon.\n>>\n>> -Thorsten\n>>\n>>\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000614.html" , "inReplyTo" : "CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com" , "date" : { "$date" : 1449428615000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com" , "CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com" , "C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com" , "18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com" , "2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io" , "BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com" , "CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com" , "CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com" , "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com" , "BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com" , "909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net" , "0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com" , "49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net" , "CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com" , "49EEA2E6-55F2-49DE-A59F-A13017626370@web.de" , "CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/F3860C6E-19F2-4E01-AF30-1CC813893B1C@anandabits.com"}} , "_id" : "F3860C6E-19F2-4E01-AF30-1CC813893B1C@anandabits.com" , "from" : "matthew at anandabits.com (Matthew Johnson)" , "mailingList" : "swift-evolution" , "content" : "Thanks Erica. I agree that there are two distinct, but related problems being discussed here as well as several ideas for solutions.  \n\nI will try to provide a side-by-side summary of the problems and proposed solutions in the next day or so when I have a chance to pull it together.\n\n\n> On Dec 6, 2015, at 11:26 AM, Erica Sadun <erica at ericasadun.com> wrote:\n> \n> Matthew, I'll look for it and see what's there. More and more I'm thinking there are in fact two distinct problems to be solved: one that maintains self in a cascade of operations, and another that extends initializers, even for constants.\n> \n> I'm hesitant to coalesce and summarize all this discussion yet because I'm already committed to championing the for-loop proposal but it seems that it would be really valuable right now to lay out the two side-by-side and discuss that plus your helpers-for-initializing-peroperties-of-same-name-as-parameters.\n> \n> -- E\n> p.s. In my head, I'm thinking that the compiler must check in setup closures or self-specific-closures for potential overlaps between properties and existing symbols\n> \n> \n>> On Dec 6, 2015, at 10:22 AM, Matthew Johnson <matthew at anandabits.com <mailto:matthew at anandabits.com>> wrote:\n>> \n>> Hi Erica,\n>> \n>> You might be interested in a possible language feature I described in the \"helpers for initializing properties of same name as parameters\" thread last night.  It is intended to address the desire for concise, safe and flexible initialization without needing to sacrifice immutability.   I would love to hear your thoughts on the list if you have a chance to read through it.\n>> \n>> Thanks,\n>> Matthew\n>> \n>> Sent from my iPad\n>> \n>> On Dec 6, 2015, at 11:10 AM, Erica Sadun via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>> \n>>> I have developed something similar as well (http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/ <http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/>).\n>>> \n>>> Is yours capable of handling enums and structs that would otherwise be let after declaration because mine is not.\n>>> \n>>> -- E\n>>> \n>>> \n>>>> On Dec 5, 2015, at 5:16 PM, ilya via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>>> \n>>>> > PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.  Here's one example: ...\n>>>> \n>>>> FWIW, I created a configuration operator more then a year ago, and use it in all of my Swift projects:\n>>>> \n>>>> let task = NSTask() +=+ {\n>>>>     $0.launchPath = \"/usr/bin/mdfind\"\n>>>>     $0.arguments = [\"kMDItemDisplayName == *.playground\"]\n>>>>     $0.standardOutput = pipe\n>>>> }\n>>>> \n>>>> Note you can also use the configured object in the rhs:\n>>>> \n>>>> let questionLabel = UILabel() +=+ {\n>>>>     $0.textAlignment = .Center\n>>>>     $0.font =  UIFont(name:\"DnealianManuscript\", size: 72)\n>>>>     $0.text = currentQuestion.questionText\n>>>>     $0.numberOfLines = 0\n>>>>     view.addSubview($0)\n>>>> }\n>>>> \n>>>> This $0. certainly looks ugly and it would be great to be able to simplify this. I don't llike the following much though (dot-syntax can be ambiguos here, and using simply a method name is even worse):\n>>>> \n>>>> let questionLabel = UILabel() +=+ {\n>>>>     .textAlignment = .Center\n>>>>     .font =  UIFont(name:\"DnealianManuscript\", size: 72)\n>>>>     .text = currentQuestion.questionText\n>>>>     .numberOfLines = 0\n>>>>     view.addSubview($0)\n>>>> }\n>>>> \n>>>> Actually I would be happy with something like\n>>>> \n>>>> let questionLabel = UILabel() .{\n>>>>     ..textAlignment = .Center\n>>>>     ..font = UIFont(name:\"DnealianManuscript\", size: 72)\n>>>>     ..text = currentQuestion.questionText\n>>>>     ..numberOfLines = 0\n>>>>     view.addSubview($0)\n>>>> }\n>>>> \n>>>> Other thoughts?\n>>>> \n>>>>   \n>>>>  _______________________________________________\n>>>> swift-evolution mailing list\n>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>> \n>>> \n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000615.html" , "inReplyTo" : "4CCD3C85-FC9C-4509-B2A9-2D761A6A9921@ericasadun.com" , "date" : { "$date" : 1449428656000} , "subject" : "[swift-evolution] Request for Discussion: Setup closures" , "references" : [ "CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com" , "8837F311-F6F8-462E-90E0-88981C537EFD@ericasadun.com" , "94756ED2-71C9-4FF3-B3BA-2CB35975B5C4@anandabits.com" , "4CCD3C85-FC9C-4509-B2A9-2D761A6A9921@ericasadun.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/8808357C-0780-423E-B028-1299CBCD2382@pobox.com"}} , "_id" : "8808357C-0780-423E-B028-1299CBCD2382@pobox.com" , "from" : "cantrell at pobox.com (Paul Cantrell)" , "mailingList" : "swift-evolution" , "content" : "I’d like to express my pure joy at a proposal to _remove_ a feature from a popular language.\n\nMy favorite Swift feature? Its brilliant insights that optionality should be a characteristic of _types_ but mutability should be a characteristic of _variables_ are right up there. But no, my favorite feature of Swift so far is its willingness to make breaking language changes. Hallelujiah!\n\nFear of removing features and making breaking changes is what doomed Java to its current status of “most used, most sneered at.” It’s what’s turned C++ into the world’s largest ball of twine. Swift is wise to set the early precedent of carefully considered breaking language changes.\n\n>> We’ve developed a number of Swift apps for various clients over the past year and have not needed C style for loops either.\n> \n> But I think this is a very weak reason for *removing* any portion like C-loops and increment or decrement operators of a programming language.\n\nI cannot imagine a better case for removing a language feature.\n\nWe have a feature that is:\n\n1. not widely used,\n2. easily replaced with other languages features where it is used, and\n3. inconsistent with the language’s general aesthetic.\n\nTheory, observation, and taste agree. If this isn’t a feature to remove for the health of the language, then what is?\n\nCheers,\n\nPaul\n\n–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––\nhttps://innig.net • @inthehands • http://siestaframework.com/" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000616.html" , "inReplyTo" : "AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de" , "date" : { "$date" : 1449428880000} , "subject" : "[swift-evolution] C-style For Loops" , "references" : [ "AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de"] , "descendants" : [ "AA5B9DF1-AA96-4650-926F-039911A4C995@ericasadun.com" , "E35181B4-9142-4677-809C-84E9F8EA4301@anandabits.com" , "CAPh90aFdMXExnTgdaOiO_9xtYvHREW3mwC_VJQHOEbZ+qns8rQ@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/B0FB69E4-C275-4E6E-9B18-6A3354164938@springsandstruts.com"}} , "_id" : "B0FB69E4-C275-4E6E-9B18-6A3354164938@springsandstruts.com" , "from" : "colin at springsandstruts.com (Colin Barrett)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 6, 2015, at 11:31 AM, David Waite via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> Nearly every for loop I’ve written in other languages has used pre or post increment (depending on the language), which is being removed in Swift 3.0. It makes sense for 'for loops' to go if pre/post increment goes away.\n\nI’m not 100% convinced by this line of reasoning (using the += form or successor() isn’t THAT clunky) but it is awfully poetic.\n\nFun fact, you write (albiet with different syntax) C-style for-loops as library code:\n\n> for i in CStyle(0, {$0 < 20}, {$0 += 1}) {\n>  // do something 20 times\n> }\n\nWhere CStyle is just a straightforward implementation of SequenceType. (Tuples allow for simultaneous iteration, which is usually when I end up with C-style for-loops)\n\n(Apologies if this was mentioned up thread, I’ve only just recently joined the list)\n\n-Colin\n\n> -DW\n> \n>> On Dec 6, 2015, at 9:03 AM, Don Wills via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>> \n>> I too hope that the proposal to remove C-style loops is rejected.  Yes, they aren't that necessary any more, but if we want Swift to compete with Java, C#, C++ and C, there is no reason to remove basic features like C-style loops just because they are politically incorrect.  If there was a functional reason, I might get on board with removing it, but there isn't.\n>> \n>> I also hope that the decision to remove increment and decrement operators is reversed using the same logic.  Just because *you* don't like something that has been a feature of dozens of programming languages for 40 years doesn't mean removing that feature is a good idea.  One man's goto statement is another man's Leatherman multi-tool.  And FWIW, if C-style loops stay in the language, they become much more ugly without increment and decrement.\n>> \n>> Don Wills\n>> \n>>> On Dec 6, 2015, at 8:33 AM, inbox only via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>> \n>>> True,even that a feature isn't used doesn't mean that you need to remove that feature.\n>>> I hope that the proposal will be rejected.\n>>> \n>>> 2015-12-06 12:03 GMT+02:00 Clemens Wagner via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>>:\n>>> > We’ve developed a number of Swift apps for various clients over the past year and have not needed C style for loops either.\n>>> \n>>> But I think this is a very weak reason for *removing* any portion like C-loops and increment or decrement operators of a programming language. How about the developers and the productive code which used C-style loops already?\n>>> \n>>> I understand the reasons why you, Erica and the others don’t like C-style loops. But changing the philosophy of a productive programming language is a very bad idea.\n>>> \n>>> Cheers\n>>> Clemens\n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>> \n>>>  _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>> \n>>  _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>  _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000617.html" , "inReplyTo" : "112B3CB9-7E8E-4DA6-8A20-6C2E8848E58B@alkaline-solutions.com" , "date" : { "$date" : 1449429082000} , "subject" : "[swift-evolution] C-style For Loops" , "references" : [ "AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de" , "CAOjGmwn6O2uvJBq03GZyJ+yngfAB4=rqb60dCCfpP2x7rmnEyg@mail.gmail.com" , "B9F4EA1D-98F9-4A2B-8D16-9073FBDD54A5@portablesoftware.com" , "112B3CB9-7E8E-4DA6-8A20-6C2E8848E58B@alkaline-solutions.com"] , "descendants" : [ "F3CA2962-24DB-438C-B5B8-13B33A3ACDD6@architechies.com" , "A1CD1E1C-07C2-40AA-AB39-EECDB0C09323@springsandstruts.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/AA5B9DF1-AA96-4650-926F-039911A4C995@ericasadun.com"}} , "_id" : "AA5B9DF1-AA96-4650-926F-039911A4C995@ericasadun.com" , "from" : "erica at ericasadun.com (Erica Sadun)" , "mailingList" : "swift-evolution" , "content" : "That is very odd indeed.\n\nIf you add explicit capture, the issue goes away:\n\nvar handlers: [() -> Void] = []\n\nfor i in 0..<5 {\n    handlers.append {[i] in print(i, terminator:\",\") }\n}\n\nfor handler in handlers {\n    handler()  // \"0 1 2 3 4\"\n}\n\nhandlers = []\n\nfor var i = 0; i < 5; i += 1 {\n    handlers.append {[i] in print(i, terminator:\",\") }\n}\n\nprint(\"\")\nfor handler in handlers {\n    handler()  // was \"5 5 5 5 5\", now 1, 2, 3, 4, 5\n}\n\nIt really seems like a bug to me rather than a feature of the for-loop\n\n-- Erica\n\n\n> On Dec 6, 2015, at 12:03 PM, Kelly Gerber via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> I think that the C-style for loop should be removed from Swift. The scope rules for this for loop are wrong. Every loop sees the same scope. This is a source of bugs if you export the loop variable name outside the scope of the for statement, for example in a closure. The following code illustrates the problem:\n> \n> var handlers: [() -> ()] = []\n> \n> for i in 0..<5 {\n>     handlers.append { print(i) }\n> }\n> \n> for handler in handlers {\n>     handler()  // \"0 1 2 3 4\"\n> }\n> \n> handlers = []\n> \n> for var i = 0; i < 5; i += 1 {\n>     handlers.append { print(i) }\n> }\n> \n> for handler in handlers {\n>     handler()  // \"5 5 5 5 5\"\n> }\n> \n> The Swift for-in loop does the right thing naturally. The C-style for loop does the wrong thing naturally. Removing the C-style for loop from Swift will eliminate one more class of possible errors from the language.\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000618.html" , "inReplyTo" : "8808357C-0780-423E-B028-1299CBCD2382@pobox.com" , "date" : { "$date" : 1449429272000} , "subject" : "[swift-evolution] C-style For Loops" , "references" : [ "AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de" , "8808357C-0780-423E-B028-1299CBCD2382@pobox.com"] , "descendants" : [ "CAPh90aFdMXExnTgdaOiO_9xtYvHREW3mwC_VJQHOEbZ+qns8rQ@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/1449429569.1342623.459603529.32C935BC@webmail.messagingengine.com"}} , "_id" : "1449429569.1342623.459603529.32C935BC@webmail.messagingengine.com" , "from" : "kevin at klundberg.com (Kevin Lundberg)" , "mailingList" : "swift-evolution" , "content" : "Ostensibly, case may not be necessary if you could delimit each case on one line with something (perhaps a comma, or something else if that would not fit well within the grammar):\n\nlet thisColor = thatColor ? .Blue: .Red, .Green: .Blue, .Red: .Green,\ndefault: .Yellow\n\nOn Sun, Dec 6, 2015, at 01:57 PM, Paul Ossenbruggen via swift-evolution wrote:\n> I like this too, seems more powerful.  Also, would single line\n> expressions be allowed?  If not would case be required for example:\n>\n> let myFavoriteColor = yourFavoriteColor ?    case .Blue: .Red    case\n> .Green: .Blue    case .Red: .Green    default: .Yellow\n>\n>\n>> On Dec 6, 2015, at 9:11 AM, Sean Heber via swift-evolution <swift-\n>> evolution at swift.org> wrote:\n>>\n>> I really like this train of thought. +1\n>>\n>> l8r Sean\n>>\n>> On Dec 6, 2015, at 11:02 AM, Alex Lew via swift-evolution <swift-\n>> evolution at swift.org> wrote:\n>>> What if we left the if { ...} else { ... } syntax alone (as a\n>>> statement), and updated the ternary expression to be a more general\n>>> pattern matching expression (closer to \"switch\")? Something like\n>>>\n>>> let x = condition ?   true: \"Hello\"   false: \"Goodbye\"\n>>>\n>>> let x = optionalValue ?   .Some(let unwrapped): \"Hello,\n>>> \\(unwrapped)\"   .None: \"To Whom It May Concern\"\n>>>\n>>> let myFavoriteColor = yourFavoriteColor ?    .Blue: .Red    .Green:\n>>> .Blue    .Red: .Green\n>>>\n>>> let quadrant = (x, y) ?    let (x, y) where x < 50 && y < 50: \"top\n>>> left\"    let (x, y) where x < 50 && y > 50: \"bottom left\"    let (x,\n>>> y) where x > 50 && y < 50: \"top right\"    default: \"bottom right\"\n>>>\n>>> The colon comes from the fact that this is sort of a light-weight\n>>> expression-based \"switch\" statement, where each branch can only\n>>> contain an expression, not a series of statements.\n>>>\n>>> This is very similar to pattern matching expressions in languages\n>>> like Haskell, ML, and Coq.\n>>>\n>>> On Sun, Dec 6, 2015 at 11:25 AM, Thorsten\n>>> Seitz<thorsten.seitz at web.de>wrote:\n>>>>\n>>>>> Am 06.12.2015 um 01:28 schrieb Alex Lew via swift-evolution <swift-\n>>>>> evolution at swift.org>:\n>>>>>\n>>>>> I don't think you can just get rid of the if statement in favor of\n>>>>> an expression. You still want to be able to do this:\n>>>>>\n>>>>> if (condition) {    funcWithSideEffectsThatReturnsInt() } else {\n>>>>> funcWithSideEffectsThatReturnsString() }\n>>>>>\n>>>>> but that's not a valid expression (what is its type?).\n>>>>\n>>>>\n>>>> That would actually be no problem if Swift’s type system would have\n>>>> union types (Ceylon has union and intersection types which are\n>>>> quite awesome and enable lots of nice things quite naturally, see\n>>>> http://ceylon-lang.org/documentation/1.2/tour/types/).\n>>>>\n>>>> In that case the type of such an expression would just be the union\n>>>> of both types, which is writtenInt | Stringin Ceylon.\n>>>>\n>>>>\n>>>> -Thorsten\n>>>>\n>>>>\n>>>\n>>>\n>>> _______________________________________________\n>>> swift-evolution mailing list swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>  _______________________________________________\n>> swift-evolution mailing list swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n> _________________________________________________\n> swift-evolution mailing list swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000619.html" , "inReplyTo" : "7D68F57E-C847-4E0D-AF3A-FD1F2DC928A9@icloud.com" , "date" : { "$date" : 1449429569000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com" , "CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com" , "C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com" , "18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com" , "2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io" , "BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com" , "CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com" , "CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com" , "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com" , "BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com" , "909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net" , "0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com" , "49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net" , "CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com" , "49EEA2E6-55F2-49DE-A59F-A13017626370@web.de" , "CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com" , "4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com" , "7D68F57E-C847-4E0D-AF3A-FD1F2DC928A9@icloud.com"] , "descendants" : [ "67057217-F4BC-4584-8B52-8EBA2CFA8CC7@portableinnovations.de" , "11462DA4-ACDD-4CF3-BD57-47886B655970@anandabits.com" , "CAKCGC8AVDe6W9X=XvFEnbkae8xom2Us8xczKFShqKu2+kPnRJA@mail.gmail.com" , "0DF0732F-0958-47C1-A6C3-62A8AB2F4386@icloud.com" , "CAKCGC8BEzyEPAFWCPKPiH+UL3KmZm7aM6KUPu-F9DKV-YvUbCA@mail.gmail.com" , "4A5C6452-0A1B-42A3-AFD4-3DEA04E310C6@icloud.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/E35181B4-9142-4677-809C-84E9F8EA4301@anandabits.com"}} , "_id" : "E35181B4-9142-4677-809C-84E9F8EA4301@anandabits.com" , "from" : "matthew at anandabits.com (Matthew Johnson)" , "mailingList" : "swift-evolution" , "content" : "+1 on embracing breaking change as necessary for moving the language forward!\n\n> On Dec 6, 2015, at 1:08 PM, Paul Cantrell via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> I’d like to express my pure joy at a proposal to _remove_ a feature from a popular language.\n> \n> My favorite Swift feature? Its brilliant insights that optionality should be a characteristic of _types_ but mutability should be a characteristic of _variables_ are right up there. But no, my favorite feature of Swift so far is its willingness to make breaking language changes. Hallelujiah!\n> \n> Fear of removing features and making breaking changes is what doomed Java to its current status of “most used, most sneered at.” It’s what’s turned C++ into the world’s largest ball of twine. Swift is wise to set the early precedent of carefully considered breaking language changes.\n> \n>>> We’ve developed a number of Swift apps for various clients over the past year and have not needed C style for loops either.\n>> \n>> But I think this is a very weak reason for *removing* any portion like C-loops and increment or decrement operators of a programming language.\n> \n> I cannot imagine a better case for removing a language feature.\n> \n> We have a feature that is:\n> \n> 1. not widely used,\n> 2. easily replaced with other languages features where it is used, and\n> 3. inconsistent with the language’s general aesthetic.\n> \n> Theory, observation, and taste agree. If this isn’t a feature to remove for the health of the language, then what is?\n> \n> Cheers,\n> \n> Paul\n> \n> –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––\n> https://innig.net • @inthehands • http://siestaframework.com/\n> \n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000620.html" , "inReplyTo" : "8808357C-0780-423E-B028-1299CBCD2382@pobox.com" , "date" : { "$date" : 1449429780000} , "subject" : "[swift-evolution] C-style For Loops" , "references" : [ "AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de" , "8808357C-0780-423E-B028-1299CBCD2382@pobox.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/2FC53481-EF6F-4B06-92FB-283A65F000E3@icloud.com"}} , "_id" : "2FC53481-EF6F-4B06-92FB-283A65F000E3@icloud.com" , "from" : "loiclecrenier at icloud.com (=?utf-8?Q?Lo=C3=AFc_Lecrenier?=)" , "mailingList" : "swift-evolution" , "content" : "Yes, I mean “deprecate typealias” only in the context of associated types. Will clarify, thanks :)\n\nAs for forbidding the default behavior, I don’t think I’m qualified enough to answer that. \nAt first glance, it seems to make sense.\n\nHowever, I feel like this deserves to be an other proposal, after this one is (hopefully!) accepted.\nBecause currently the proposal is extremely simple: it is about replacing one keyword \nwith another one, in order to improve the clarity of the grammar. Moreover, the transition \nfrom the previous grammar to the proposed one is immediate.\n \nChanges to the places where (associated types / type aliases) are allowed will involve more \ntechnical discussions, may be more controversial, and may complicate the review of the proposal.\n\nSo, unless someone familiar with the inner workings of Swift tells me that allowing \n“associated ___ = ___” in protocol extensions is an obvious consequence of adding the \n`associated` keyword, I would rather not include it in the proposal. \n\nHappy to hear any counter-argument, though :)\n\nLoïc \n\n> On Dec 6, 2015, at 7:34 PM, Alex Lew <alexl.mail+swift at gmail.com> wrote:\n> \n> Commented on the proposal but realize that it might be better to reply here. \n> \n> For clarification: when you say \"deprecate typealias\" do you mean only in the context of associated types or in the language as a whole?\n>  \n> I also thought it might make sense to add to the proposal a disabling of the \"default\" behavior that is currently allowed for type aliases in protocols:\n> \n> protocol Prot {\n>     associated Container: SequenceType\n>     associated Element = Container.Generator.Element // should be illegal\n> }\n> \n> Instead, if you actually want the semantics of an additional associated type with a default (but overridable) value, you should use a protocol extension. (Which means that associated ____ = ____ would be allowed in protocol extensions, but not associated ____ : _____  or associated ____ : ____ = _____.) Does that sound right?\n> \n> \n> On Sun, Dec 6, 2015 at 10:32 AM, Loïc Lecrenier <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n> Well, I went ahead and created a pull request :)\n> \n> I also included a “proposed approach” section, where I propose to deprecate\n> the `typealias` keyword for Swift 2.2, and replace it entirely for Swift 3.0.\n> \n> Does anyone have any thought on that? This is a bit aggressive, but I think it’s worth it.\n> It is actually the same approach Erica proposed for removing C for-loops.\n> \n> Loïc\n> \n> > On Dec 6, 2015, at 1:12 PM, Loïc Lecrenier <loiclecrenier at icloud.com <mailto:loiclecrenier at icloud.com>> wrote:\n> >\n> > I have drafted a formal proposal here: https://gist.github.com/loiclec/22459d230a21dbcb81fc <https://gist.github.com/loiclec/22459d230a21dbcb81fc>\n> > Would love to receive feedback from the community on it, I am particularly worried about the correctness of the terms I used.\n> > Should I make a pull request to swift-evolution now, or should we continue the conversation here?\n> >\n> > Thanks,\n> >\n> > Loïc\n> >\n> > (and sorry about emailing you on Sunday 😇 )\n> >\n> >> On Dec 6, 2015, at 1:48 AM, John McCall <rjmccall at apple.com <mailto:rjmccall at apple.com>> wrote:\n> >>\n> >>> On Dec 5, 2015, at 4:35 PM, Loïc Lecrenier via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n> >>> Hi everyone :)\n> >>>\n> >>> I propose introducing a new \"associated_type\" keyword that will replace \"typealias\" for declaring associated types in protocols.\n> >>> I remember being confused by associated types when I started using Swift, and I think one reason why was the use of the typealias keyword to define them.\n> >>> One reason was that I thought I knew what typealias did, and so I didn't stop to learn what it did inside a protocol. An other reason was the difficulty of finding help when searching for \"typealias\" instead of \"associated types\".\n> >>> Then, when I thought I understood it, I started building an excessively protocol-oriented program as an exercise. And I still lost a lot of time fighting Swift by trying to use \"real\" typealias-es inside of protocols.\n> >>>\n> >>> Conceptually, I had something like this:\n> >>>\n> >>> protocol ProtA {\n> >>> typealias Container : SequenceType\n> >>> }\n> >>> protocol ProtB {\n> >>> typealias AnOtherAssocType : ProtA\n> >>> func foo(x: AnOtherAssocType.Container.Generator.Element, y: AnOtherAssocType.Container.Generator.Element) -> AnOtherAssocType.Container.Generator.Element\n> >>> }\n> >>>\n> >>> The function foo is very difficult to read, so I wanted to use a shortcut to Element by doing this:\n> >>>\n> >>> protocol ProtB {\n> >>> typealias A : ProtA\n> >>> typealias Element = A.Container.Generator.Element\n> >>> func foo(x: Element, y: Element) -> Element\n> >>> }\n> >>>\n> >>> But by doing so, I didn't create a shortcut to Element, but an associated type with a default value of Element. (right?)\n> >>> Then I tried to write extensions to ProtB where Element conforms to, say, Equatable, and couldn't make it work because A.Container.Generator.Element didn't conform to Equatable.\n> >>>\n> >>> So, that was a rather long explanation of the reasons I think we should replace the typealias keyword by associated_type, and allow \"real\" typealias-es inside protocols.\n> >>\n> >> I think this is a great idea; re-using typealias for associated types was a mistake.\n> >>\n> >> John.\n> >>\n> >>>\n> >>> Ideally, I would write\n> >>>\n> >>> protocol ProtB {\n> >>> associated_type AnOtherAssocType : ProtA\n> >>> typealias Element = AnOtherAssocType.Container.Generator.Element\n> >>> func foo(x: Element, y: Element) -> Element\n> >>> }\n> >>>\n> >>> and it would be exactly the same as\n> >>>\n> >>> protocol ProtB {\n> >>> associated_type AnOtherAssocType : ProtA\n> >>> func foo(x: A.Container.Generator.Element, y: A.Container.Generator.Element) -> A.Container.Generator.Element\n> >>> }\n> >>>\n> >>> There are probably some problems created by this proposal, but right now I can't see any :/\n> >>>\n> >>> Thanks,\n> >>>\n> >>> Loïc\n> >>> _______________________________________________\n> >>> swift-evolution mailing list\n> >>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> >>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n> >\n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000621.html" , "inReplyTo" : "CAKCGC8Dr29Reis3NnK-MLE3MpswCC9fEU7=Eh3VTCOmj3TfAJw@mail.gmail.com" , "date" : { "$date" : 1449429954000} , "subject" : "[swift-evolution] Introduce \"associated_type\" keyword" , "references" : [ "C2A147B1-A7EB-4A3C-B03C-852870CBD34E@icloud.com" , "80997F28-F342-4FE4-8EE8-5A05DDEBEB9A@apple.com" , "6BCA9015-28F4-4B1B-8AF5-84DFA9256949@icloud.com" , "3A2C2956-0C24-4838-84C0-B171C8F39F6F@icloud.com" , "CAKCGC8Dr29Reis3NnK-MLE3MpswCC9fEU7=Eh3VTCOmj3TfAJw@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/FE41B04C-014E-43E7-9F5E-4826380542F9@anandabits.com"}} , "_id" : "FE41B04C-014E-43E7-9F5E-4826380542F9@anandabits.com" , "from" : "matthew at anandabits.com (Matthew Johnson)" , "mailingList" : "swift-evolution" , "content" : "Yes, the idea is that this protocol type with partially or totally bound associated types would be valid anywhere you could use a type.\n\nI’m not a compiler developer and I’m sure there are implementation complexities and a lot of subtleties to work through.  But I believe it is possible as Swift’s protocols share many similarities with ML’s module system and ML is able to do this.  \n\nHopefully someone from the core team can chime in on feasibility, desirability, and priority of a feature like this.\n\n\n> On Dec 6, 2015, at 1:22 PM, Paul Cantrell <cantrell at pobox.com> wrote:\n> \n>> The general form of this would look like:\n>> \n>> protocol<P1, P2, P3 where *list of constraints*>\n> \n> \n> I’m very interested in this. Would this also extend to variables & parameters with generic types that are only constrained, or not specified at all? For example:\n> \n>     let heterogeneousCollections: protocol<CollectionType where Generator.Element: CollectionType> = whatever\n> \n> …or even:\n> \n>     let heterogeneousCollections: [CollectionType] = whatever\n> \n> …because we don’t need to know the element types to get the max count:\n> \n>     let maxSize = heterogenousCollections.map { $0.count }.maxElement()\n> \n> If so, I’m desperate for this. The lack of it forced some ugly compromises in Siesta’s API.\n> \n> Cheers, P\n> \n> \n>> On Dec 6, 2015, at 9:07 AM, Matthew Johnson via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>> \n>> This request isn’t really about typealias at all.  It has two elements.\n>> \n>> First, it’s about the ability to bind Self and / or associated types in a protocol and use the result as a type.  This is highly desirable and is similar to features in the ML module system.\n>> \n>> First is the ability to use a protocol with self or associated types as a type, not just a generic constraint:\n>> \n>> protocol<CollectionType where CollectionType.Generator.Element == CGPoint>\n>> \n>> I don’t think the `T:` label is necessary here as the protocol name serves as a good identifier in this context.  Although the protocol name could probably be omitted when there is only one protocol here as it is implicit:\n>> \n>> protocol<CollectionType where Generator.Element == CGPoint>\n>> \n>> The general form of this would look like:\n>> \n>> protocol<P1, P2, P3 where *list of constraints*>\n>> \n>> In this case the protocol name would be required, at least when more than one protocol in the list have an associated type with the same name (and possibly in all cases).  The list of constraints could identify associated types, bind them to concrete types, constrain Self to a specific superclass, etc.  The Self constraint might look like this:\n>> \n>> protocol<P1, P2, P3 where Self: UIViewController>\n>> \n>> Ideally we would not need to bind all associated types in the protocol in order to use it at a type, but would only be allowed to use members that do not mention the unbound associated type in their signature.\n>> \n>> Once we have the ability to bind associated types and use the result as a type, the typealias use falls out automatically.\n>> \n>> Second, it’s about the ability to extend a typealias where some generic constraints are specified in the typealias.  This would allow us to re-use the binding of generic constraints, but could be confusing if the extension is far removed in source from the typealias.  I’m not sure how I feel about this part of the proposal.\n>> \n>> Matthew\n>> \n>>> On Dec 6, 2015, at 4:28 AM, Adrian Kashivskyy via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>> \n>>> I believe this could be achieved using generic typealiases, proposed here: https://lists.swift.org/pipermail/swift-evolution/2015-December/000132.html <https://lists.swift.org/pipermail/swift-evolution/2015-December/000132.html>\n>>> \n>>> Pozdrawiam – Regards,\n>>> Adrian Kashivskyy\n>>> \n>>>> Wiadomość napisana przez QQ Mail via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> w dniu 06.12.2015, o godz. 08:17:\n>>>> \n>>>> If typealias support protocol constraint, I think we can reuse a lot of code, also more readable\n>>>> \n>>>> For Example: \n>>>> \n>>>> typealias PointCollection = protocol<T:CollectionType where T.Generator.Element == CGPoint>\n>>>> \n>>>> public extension PointCollection {\n>>>>     \n>>>>     \n>>>>     \n>>>> }\n>>>> \n>>>> \n>>>> \n>>>> \n>>>> _______________________________________________\n>>>> swift-evolution mailing list\n>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>> \n>>> \n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>> \n>> \n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000622.html" , "inReplyTo" : "CF5B84C6-7EE1-43D2-AA08-E7A3FEF91023@pobox.com" , "date" : { "$date" : 1449430066000} , "subject" : "[swift-evolution] Proposal: typealias support protocol constraint" , "references" : [ "78E72933-1ABE-4930-9213-C18CF258DA2D@qq.com" , "F54D886C-4283-4DE3-BDA3-6E1947A20233@me.com" , "C03532DB-388E-46DE-A34B-7C3572DED0C8@anandabits.com" , "CF5B84C6-7EE1-43D2-AA08-E7A3FEF91023@pobox.com"] , "descendants" : [ "DF17297E-E77E-4CAF-851E-2F5E5CACCDCB@qq.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/70E0CB06-BF3D-41D5-8902-FA64A1FA7BE2@anandabits.com"}} , "_id" : "70E0CB06-BF3D-41D5-8902-FA64A1FA7BE2@anandabits.com" , "from" : "matthew at anandabits.com (Matthew Johnson)" , "mailingList" : "swift-evolution" , "content" : "Problem:\nSwift numeric types all currently have a family of conversion initializers.  In many use cases they leave a lot to be desired.  Initializing an integer type with a floating point value will truncate any fractional portion of the number.  Initializing with an out-of-range value traps.  \n\nSolution:\n\nSometimes it would be more desirable to convert the runtime value if it can be done without losing information (or possibly with only minimal loss of precision when initializing a floating point type).  This could be easily accomplished if the standard library had a family of failable initializers for all numeric types, either returning an Optional or throwing when the initialization was not successful.  \n\nI prefer the throwing version because failure can be automatically propagated up the call stack and the error could capture value that was provided and the type that failed to initialize which may be useful when debugging.  Also, `try?` allows callers to throw away the error if the detail isn’t necessary.  However, the Optional version would provide the basic functionality that is desired and would be sufficient if the community likes it better.\n\n//  Conversions from all integer types.\ninit?(_ value: Int8)\ninit?(_ value: Int16)\ninit?(_ value: Int32)\ninit?(_ value: Int64)\ninit?(_ value: Int)\ninit?(_ value: UInt8)\ninit?(_ value: UInt16)\ninit?(_ value: UInt32)\ninit?(_ value: UInt64)\ninit?(_ value: UInt)\n\n//  Conversions from all floating-point types.\ninit?(_ value: Float)\ninit?(_ value: Double)\n#if arch(i386) || arch(x86_64)\ninit?(_ value: Float80)\n#endif\n\nOR\n\n//  Conversions from all integer types.\ninit(_ value: Int8) throws\ninit(_ value: Int16) throws\ninit(_ value: Int32) throws\ninit(_ value: Int64) throws\ninit(_ value: Int) throws\ninit(_ value: UInt8) throws\ninit(_ value: UInt16) throws\ninit(_ value: UInt32) throws\ninit(_ value: UInt64) throws\ninit(_ value: UInt) throws\n\n//  Conversions from all floating-point types.\ninit(_ value: Float) throws\ninit(_ value: Double) throws\n#if arch(i386) || arch(x86_64)\ninit(_ value: Float80) throws\n#endif" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000623.html" , "date" : { "$date" : 1449430117000} , "subject" : "[swift-evolution] Proposal: failable numeric conversion initializers" , "references" : [ ""] , "inReplyTo" :  null  , "descendants" : [ "CA+Y5xYeSeriEGiEV+zZsUfmWhX9W_K0XufPYA2UFTkiSudwNAA@mail.gmail.com" , "BE962A59-AB37-434C-8C74-88F5B8EA2FB9@portableinnovations.de" , "CA+Y5xYdoECeo59zLA8HhfR5GwSY1H2bUPqe95jBD8-W0+Yvh+Q@mail.gmail.com" , "DB874B34-A802-4988-AA06-131E278A1873@apple.com" , "F44D89E9-B4FB-4017-A3EA-C29E3B3873B2@anandabits.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAKCGC8BEzyEPAFWCPKPiH+UL3KmZm7aM6KUPu-F9DKV-YvUbCA@mail.gmail.com"}} , "_id" : "CAKCGC8BEzyEPAFWCPKPiH+UL3KmZm7aM6KUPu-F9DKV-YvUbCA@mail.gmail.com" , "from" : "alexl.mail+swift at gmail.com (Alex Lew)" , "mailingList" : "swift-evolution" , "content" : "Yes, I'm of two minds about adding *case*.\n\nOn the one hand, it is much more consistent with the rest of the\nlanguage. *case\n*is used everywhere else in Swift that pattern matching is allowed. (if\ncase..., for case..., while case...) I think this is a strong argument that\nit should be used in pattern matching expressions too.\n\nOn the other hand, what is the point of pattern matching expressions if not\nto be brief? They don't enable you to do anything you couldn't do before\nwith a switch and assignment, right? So it seems like a priority should be\ngetting them to look nice and readable, which the comma syntax does. It\nactually doesn't look too bad with both case and comma:\n\nlet thisColor = thatColor ? case .Blue: .Red, case .Green: .Blue, default:\n.Yellow\n\nAnd on the third hand, it still does save you a good amount of space even\nif you're not all on one line. Compare\n\nlet thisColor: Color\nswitch thatColor {\n    case .Blue:\n        thisColor = .Red\n    case .Green\n        thisColor = .Blue\n    default:\n        thisColor = .Yellow\n}\n\nwith\n\nlet thisColor = thatColor ?\n    case .Blue: .Red\n    case .Green: .Blue\n    default: .Yellow\n\n\n\n\n\nOn Sun, Dec 6, 2015 at 2:19 PM, Kevin Lundberg via swift-evolution <\nswift-evolution at swift.org> wrote:\n\n> Ostensibly, case may not be necessary if you could delimit each case on\n> one line with something (perhaps a comma, or something else if that would\n> not fit well within the grammar):\n>\n> let thisColor = thatColor ? .Blue: .Red, .Green: .Blue, .Red: .Green,\n> default: .Yellow\n>\n> On Sun, Dec 6, 2015, at 01:57 PM, Paul Ossenbruggen via swift-evolution\n> wrote:\n>\n> I like this too, seems more powerful.  Also, would single line expressions\n> be allowed?  If not would case be required for example:\n>\n> let myFavoriteColor = yourFavoriteColor ?\n>     case .Blue: .Red\n>     case .Green: .Blue\n>     case .Red: .Green\n>     default: .Yellow\n>\n>\n>\n> On Dec 6, 2015, at 9:11 AM, Sean Heber via swift-evolution <\n> swift-evolution at swift.org> wrote:\n>\n> I really like this train of thought. +1\n>\n> l8r\n> Sean\n>\n> On Dec 6, 2015, at 11:02 AM, Alex Lew via swift-evolution <\n> swift-evolution at swift.org> wrote:\n>\n> What if we left the if { ...} else { ... } syntax alone (as a statement),\n> and updated the ternary expression to be a more general pattern matching\n> expression (closer to \"switch\")? Something like\n>\n> let x = condition ?\n>    true: \"Hello\"\n>    false: \"Goodbye\"\n>\n> let x = optionalValue ?\n>    .Some(let unwrapped): \"Hello, \\(unwrapped)\"\n>    .None: \"To Whom It May Concern\"\n>\n> let myFavoriteColor = yourFavoriteColor ?\n>     .Blue: .Red\n>     .Green: .Blue\n>     .Red: .Green\n>\n> let quadrant = (x, y) ?\n>     let (x, y) where x < 50 && y < 50: \"top left\"\n>     let (x, y) where x < 50 && y > 50: \"bottom left\"\n>     let (x, y) where x > 50 && y < 50: \"top right\"\n>     default: \"bottom right\"\n>\n> The colon comes from the fact that this is sort of a light-weight\n> expression-based \"switch\" statement, where each branch can only contain an\n> expression, not a series of statements.\n>\n> This is very similar to pattern matching expressions in languages like\n> Haskell, ML, and Coq.\n>\n> On Sun, Dec 6, 2015 at 11:25 AM, Thorsten Seitz <thorsten.seitz at web.de> wrote:\n>\n>\n>\n>\n> Am 06.12.2015 um 01:28 schrieb Alex Lew via swift-evolution <\n> swift-evolution at swift.org>:\n>\n> I don't think you can just get rid of the if statement in favor of an\n> expression. You still want to be able to do this:\n>\n> if (condition) {\n>     funcWithSideEffectsThatReturnsInt()\n> } else {\n>     funcWithSideEffectsThatReturnsString()\n> }\n>\n> but that's not a valid expression (what is its type?).\n>\n>\n>\n> That would actually be no problem if Swift’s type system would have union\n> types (Ceylon has union and intersection types which are quite awesome and\n> enable lots of nice things quite naturally, see\n> http://ceylon-lang.org/documentation/1.2/tour/types/).\n>\n> In that case the type of such an expression would just be the union of\n> both types, which is written Int | String in Ceylon.\n>\n>\n> -Thorsten\n>\n>\n>\n>\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>\n> *_______________________________________________*\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>\n> Untracked with Trackbuster <https://trackbuster.com/?sig>\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000624.html" , "inReplyTo" : "1449429569.1342623.459603529.32C935BC@webmail.messagingengine.com" , "date" : { "$date" : 1449430828000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com" , "CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com" , "C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com" , "18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com" , "2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io" , "BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com" , "CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com" , "CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com" , "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com" , "BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com" , "909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net" , "0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com" , "49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net" , "CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com" , "49EEA2E6-55F2-49DE-A59F-A13017626370@web.de" , "CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com" , "4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com" , "7D68F57E-C847-4E0D-AF3A-FD1F2DC928A9@icloud.com" , "1449429569.1342623.459603529.32C935BC@webmail.messagingengine.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/F757A1B0-69AA-40E0-BB72-9A043CE6D93D@ericasadun.com"}} , "_id" : "F757A1B0-69AA-40E0-BB72-9A043CE6D93D@ericasadun.com" , "from" : "erica at ericasadun.com (Erica Sadun)" , "mailingList" : "swift-evolution" , "content" : "I was specifically referring to value types. I apologize for not being clearer.\n\n-- E\n\n\n> On Dec 6, 2015, at 12:42 PM, ilya <ilya.nikokoshev at gmail.com> wrote:\n> \n> Yes, it works for immutable objects with the correct definition, see the playground contents at https://github.com/ilyannn/iOS-Swift-Materials/blob/master/Playgrounds/Configure.playground/Contents.swift <https://github.com/ilyannn/iOS-Swift-Materials/blob/master/Playgrounds/Configure.playground/Contents.swift>\n> \n> On Sun, Dec 6, 2015 at 8:10 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:\n> I have developed something similar as well (http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/ <http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/>).\n> \n> Is yours capable of handling enums and structs that would otherwise be let after declaration because mine is not.\n> \n> -- E\n> \n> \n>> On Dec 5, 2015, at 5:16 PM, ilya via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>> \n>> > PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.  Here's one example: ...\n>> \n>> FWIW, I created a configuration operator more then a year ago, and use it in all of my Swift projects:\n>> \n>> let task = NSTask() +=+ {\n>>     $0.launchPath = \"/usr/bin/mdfind\"\n>>     $0.arguments = [\"kMDItemDisplayName == *.playground\"]\n>>     $0.standardOutput = pipe\n>> }\n>> \n>> Note you can also use the configured object in the rhs:\n>> \n>> let questionLabel = UILabel() +=+ {\n>>     $0.textAlignment = .Center\n>>     $0.font =  UIFont(name:\"DnealianManuscript\", size: 72)\n>>     $0.text = currentQuestion.questionText\n>>     $0.numberOfLines = 0\n>>     view.addSubview($0)\n>> }\n>> \n>> This $0. certainly looks ugly and it would be great to be able to simplify this. I don't llike the following much though (dot-syntax can be ambiguos here, and using simply a method name is even worse):\n>> \n>> let questionLabel = UILabel() +=+ {\n>>     .textAlignment = .Center\n>>     .font =  UIFont(name:\"DnealianManuscript\", size: 72)\n>>     .text = currentQuestion.questionText\n>>     .numberOfLines = 0\n>>     view.addSubview($0)\n>> }\n>> \n>> Actually I would be happy with something like\n>> \n>> let questionLabel = UILabel() .{\n>>     ..textAlignment = .Center\n>>     ..font = UIFont(name:\"DnealianManuscript\", size: 72)\n>>     ..text = currentQuestion.questionText\n>>     ..numberOfLines = 0\n>>     view.addSubview($0)\n>> }\n>> \n>> Other thoughts?\n>> \n>>   \n>>  _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n> \n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000625.html" , "inReplyTo" : "CAPh90aEHX5aWQOnpkDJxeTt3DXOH6Xdqq1BXYVr_tvB63QKx1g@mail.gmail.com" , "date" : { "$date" : 1449431014000} , "subject" : "[swift-evolution] Request for Discussion: Setup closures" , "references" : [ "CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com" , "8837F311-F6F8-462E-90E0-88981C537EFD@ericasadun.com" , "CAPh90aEHX5aWQOnpkDJxeTt3DXOH6Xdqq1BXYVr_tvB63QKx1g@mail.gmail.com"] , "descendants" : [ "F833B947-4FFD-485E-912A-31B50140660F@anandabits.com" , "F6635EA0-2342-451E-8675-FF1819BD715C@anandabits.com" , "2F1E045F-3242-4943-9471-B40D6B476C97@anandabits.com" , "35BE2387-2F9C-491F-B71F-1635243ABADA@ericasadun.com" , "38E11489-CE79-4690-8567-98FD7793B4FF@gmail.com" , "159233D0-A835-4435-840E-A9594DDCA37D@ericasadun.com" , "CAKCGC8AOx_ffGe1AjpQJt9ULr3zwTBsnphJCht92se7-Hfi_+g@mail.gmail.com" , "DC82287B-4583-47F3-9389-B756C91436F5@alkaline-solutions.com" , "CC9D9491-212A-4D20-8CC2-34FD984F6463@portableinnovations.de" , "EF05B911-5728-47F4-AB13-F960FF2B21A4@portableinnovations.de" , "F379B44A-9B6F-47BD-95B0-9FC795BC035B@architechies.com" , "BB9D9FE2-F252-41F4-A3EA-2D8053A7579C@gmx.de" , "1F3D7F58-0EC6-4541-9734-A95CE62BAF6E@anandabits.com" , "2139FFE7-79C5-4981-A036-250F2D5EF0A4@ericasadun.com" , "24FE9022-00E3-459C-8A71-540BCF436286@apple.com" , "E904EA6A-6422-49F6-9C5E-07BCDC7D3543@gmx.de" , "98A80B8C-AC32-408D-AD8F-CDE0EB782B4C@apple.com" , "03F8648F-236A-46A5-8D21-CA066DBA1932@anandabits.com" , "D49345E8-5E22-46C8-9EF2-EF0DB4D32D87@apple.com" , "77AE5195-4E57-4814-A228-AF23723C853B@ericasadun.com" , "B818E6F9-1526-4725-BCDA-AB8C36F3CED7@maven.de" , "6A18AB5F-3794-42A6-8142-AAA7B2B61000@apple.com" , "9520AAC7-B49D-4CB7-96EE-E9891BAC9268@ericasadun.com" , "5981B70E-98D3-4A99-AF49-106254DFEB54@apple.com" , "86e837d7-cac3-438b-8297-4f6f401b641f@Spark" , "315B39D9-AE33-438B-8EFF-CC4796EECAAF@pobox.com" , "731CB499-F42F-45D4-8A3B-8D7B963D3709@monod-broca.fr" , "CADcs6kNOmo32YcBHOjmsV3eKiJ4yo0nDxz+5mjWNtp3JG0FsOA@mail.gmail.com" , "616C48D0-D626-487E-861C-CF125879BABB@ericasadun.com" , "3A77268A-D52E-4821-9488-671491506835@monod-broca.fr" , "B5AE3C08-FB9F-4024-B6BF-ECAADC1196E8@pobox.com" , "52D7FF3E-4E16-447D-AFCF-6915ABF999C1@gmx.de" , "98E5A56D-2912-4725-8E5E-14F25153B184@gmx.de" , "3C9B366C-D4A8-4777-8CF9-E46B52F806E2@pobox.com" , "DD7C743B-5E22-4603-AA6A-AF3F75B4DE62@ericasadun.com" , "CAPh90aE1m68_kDFqOGuO-u6qP3WKtqSJS9XMU-KKrO0N3yV0kg@mail.gmail.com" , "0674FFD1-76FB-4376-9F34-0FF8B7560798@anandabits.com" , "5B0D18B8-0255-4F2E-86E3-253058585BDB@fifthace.com" , "512C0649-506C-41B3-BBB9-BBF6B80437FE@ericasadun.com" , "CADcs6kOfPJ73WdN-UHTZAPs7Zx_MmSUjrKy6r=EMphLdGfti8w@mail.gmail.com" , "ED9A9872-62B4-4957-B708-94F3015365C5@alkaline-solutions.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/11462DA4-ACDD-4CF3-BD57-47886B655970@anandabits.com"}} , "_id" : "11462DA4-ACDD-4CF3-BD57-47886B655970@anandabits.com" , "from" : "matthew at anandabits.com (Matthew Johnson)" , "mailingList" : "swift-evolution" , "content" : "I am not a fan of this approach based on the ternary operator.  The ternary operator is already a bit of an anomaly in that all other operators are unary or binary and do not perform any control flow (beyond possibly short circuiting an autoclosure argument).\n\nI would much rather features that perform control flow continue to use keywords, but allow them to be expressions.  \n\nOnce we have control flow expressions I would like to see the ternary operator removed from the language as it would no longer server a purpose.  Removing the ternary operator seems to fit nicely with the direction to remove some features that are carried over from C-based languages but don’t necessarily fit with the direction Swift is heading.\n\n\n> On Dec 6, 2015, at 1:19 PM, Kevin Lundberg via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> Ostensibly, case may not be necessary if you could delimit each case on one line with something (perhaps a comma, or something else if that would not fit well within the grammar):\n>  \n> let thisColor = thatColor ? .Blue: .Red, .Green: .Blue, .Red: .Green, default: .Yellow\n>  \n> On Sun, Dec 6, 2015, at 01:57 PM, Paul Ossenbruggen via swift-evolution wrote:\n>> I like this too, seems more powerful.  Also, would single line expressions be allowed?  If not would case be required for example:\n>>  \n>> let myFavoriteColor = yourFavoriteColor ?\n>>     case .Blue: .Red\n>>     case .Green: .Blue\n>>     case .Red: .Green\n>>     default: .Yellow\n>>  \n>>  \n>>> On Dec 6, 2015, at 9:11 AM, Sean Heber via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>>  \n>>> I really like this train of thought. +1\n>>>  \n>>> l8r\n>>> Sean\n>>>  \n>>> On Dec 6, 2015, at 11:02 AM, Alex Lew via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>>> What if we left the if { ...} else { ... } syntax alone (as a statement), and updated the ternary expression to be a more general pattern matching expression (closer to \"switch\")? Something like\n>>>>  \n>>>> let x = condition ?\n>>>>    true: \"Hello\"\n>>>>    false: \"Goodbye\"\n>>>>  \n>>>> let x = optionalValue ?\n>>>>    .Some(let unwrapped): \"Hello, \\(unwrapped)\"\n>>>>    .None: \"To Whom It May Concern\"\n>>>>  \n>>>> let myFavoriteColor = yourFavoriteColor ?\n>>>>     .Blue: .Red\n>>>>     .Green: .Blue\n>>>>     .Red: .Green\n>>>>  \n>>>> let quadrant = (x, y) ?\n>>>>     let (x, y) where x < 50 && y < 50: \"top left\"\n>>>>     let (x, y) where x < 50 && y > 50: \"bottom left\"\n>>>>     let (x, y) where x > 50 && y < 50: \"top right\"\n>>>>     default: \"bottom right\"\n>>>>  \n>>>> The colon comes from the fact that this is sort of a light-weight expression-based \"switch\" statement, where each branch can only contain an expression, not a series of statements.\n>>>>  \n>>>> This is very similar to pattern matching expressions in languages like Haskell, ML, and Coq.\n>>>>  \n>>>> On Sun, Dec 6, 2015 at 11:25 AM, Thorsten Seitz<thorsten.seitz at web.de <mailto:thorsten.seitz at web.de>>wrote:\n>>>>  \n>>>>> Am 06.12.2015 um 01:28 schrieb Alex Lew via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>>:\n>>>>>  \n>>>>> I don't think you can just get rid of the if statement in favor of an expression. You still want to be able to do this:\n>>>>>  \n>>>>> if (condition) {\n>>>>>     funcWithSideEffectsThatReturnsInt()\n>>>>> } else {\n>>>>>     funcWithSideEffectsThatReturnsString()\n>>>>> }\n>>>>>  \n>>>>> but that's not a valid expression (what is its type?).\n>>>>  \n>>>>  \n>>>> That would actually be no problem if Swift’s type system would have union types (Ceylon has union and intersection types which are quite awesome and enable lots of nice things quite naturally, seehttp://ceylon-lang.org/documentation/1.2/tour/types/ <http://ceylon-lang.org/documentation/1.2/tour/types/>).\n>>>>  \n>>>> In that case the type of such an expression would just be the union of both types, which is writtenInt | Stringin Ceylon.\n>>>>  \n>>>>  \n>>>> -Thorsten\n>>>>  \n>>>>  \n>>>>  \n>>>> \n>>>> _______________________________________________\n>>>> swift-evolution mailing list\n>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>> \n>> \n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>  \n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000626.html" , "inReplyTo" : "1449429569.1342623.459603529.32C935BC@webmail.messagingengine.com" , "date" : { "$date" : 1449431307000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com" , "CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com" , "C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com" , "18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com" , "2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io" , "BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com" , "CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com" , "CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com" , "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com" , "BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com" , "909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net" , "0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com" , "49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net" , "CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com" , "49EEA2E6-55F2-49DE-A59F-A13017626370@web.de" , "CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com" , "4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com" , "7D68F57E-C847-4E" , "0D-AF3A-" , "FD1F2DC928A9@icloud.com" , "1449429569.1342623.459603529.32C935BC@webmail.messagingengine.com"] , "descendants" : [ "07270E34-E284-4FF0-B2EA-6DBB54FF78B5@portableinnovations.de" , "67057217-F4BC-4584-8B52-8EBA2CFA8CC7@portableinnovations.de" , "45B71AF5-DD4F-4E9C-A128-5B8041917564@me.com" , "CAKCGC8BmmCk55=6UC_qk_C+ZNq2JfGpOPO5cJ=SK2784kmvbGg@mail.gmail.com" , "CAKCGC8AerqpPTrwdmPAvhmp-fLt-v=LXw4z0t+2o93g9GmAaxw@mail.gmail.com" , "54E5D8F5-616D-41EB-A550-E639FE861575@gmail.com" , "CAKCGC8CsJ7g_Fu8fnQ5Mv=yAzbSvb0Z+iNmdXKnJaAcWR2UKuw@mail.gmail.com" , "6830F74D-78FC-4B20-A6D5-683185B30164@gmail.com" , "CAKCGC8AVDe6W9X=XvFEnbkae8xom2Us8xczKFShqKu2+kPnRJA@mail.gmail.com" , "0DF0732F-0958-47C1-A6C3-62A8AB2F4386@icloud.com" , "4A5C6452-0A1B-42A3-AFD4-3DEA04E310C6@icloud.com" , "6DA2FDFF-F978-4ECA-9E2B-F757F6D8BBF3@icloud.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAPh90aFdMXExnTgdaOiO_9xtYvHREW3mwC_VJQHOEbZ+qns8rQ@mail.gmail.com"}} , "_id" : "CAPh90aFdMXExnTgdaOiO_9xtYvHREW3mwC_VJQHOEbZ+qns8rQ@mail.gmail.com" , "from" : "ilya.nikokoshev at gmail.com (ilya)" , "mailingList" : "swift-evolution" , "content" : "I think this is indeed an (anti-)feature of C-style loop.\n\n`for var i = 0; i < 5; i += 1` is supposed to actually create a variable i;\nin particular you can change this variable yourself or pass the reference\nto it, so the implementation must work as follows:\n\nvar i = 0;\nwhile( ...\n\nNaturally, the closures are able to capture and modify i as well.\n\nOr, in other words, by the definition of what C-style loop is, `for let i =\n0; i < 5; i += 1` is impossible.\n\nThis magic behavior is in fact the best argument for the removal of C-style\nloop, imho.\n\n\n\nOn Sun, Dec 6, 2015 at 10:14 PM, Erica Sadun via swift-evolution <\nswift-evolution at swift.org> wrote:\n\n> That is very odd indeed.\n>\n> If you add explicit capture, the issue goes away:\n>\n> var handlers: [() -> Void] = []\n>\n> for i in 0..<5 {\n>     handlers.append {[i] in print(i, terminator:\",\") }\n> }\n>\n> for handler in handlers {\n>     handler()  // \"0 1 2 3 4\"\n> }\n>\n> handlers = []\n>\n> for var i = 0; i < 5; i += 1 {\n>     handlers.append {[i] in print(i, terminator:\",\") }\n> }\n>\n> print(\"\")\n> for handler in handlers {\n>     handler()  // was \"5 5 5 5 5\", now 1, 2, 3, 4, 5\n> }\n>\n> It really seems like a bug to me rather than a feature of the for-loop\n>\n> -- Erica\n>\n>\n> On Dec 6, 2015, at 12:03 PM, Kelly Gerber via swift-evolution <\n> swift-evolution at swift.org> wrote:\n>\n> I think that the C-style *for* loop should be removed from Swift. The\n> scope rules for this *for* loop are wrong. Every loop sees the same\n> scope. This is a source of bugs if you export the loop variable name\n> outside the scope of the *for* statement, for example in a closure. The\n> following code illustrates the problem:\n>\n> var handlers: [() -> ()] = []\n>\n> for i in 0..<5 {\n>     handlers.append { print(i) }\n> }\n>\n> for handler in handlers {\n>     handler()  // \"0 1 2 3 4\"\n> }\n>\n> handlers = []\n>\n> for var i = 0; i < 5; i += 1 {\n>     handlers.append { print(i) }\n> }\n>\n> for handler in handlers {\n>     handler()  // \"5 5 5 5 5\"\n> }\n>\n> The Swift *for-in* loop does the right thing naturally. The C-style *for* loop\n> does the wrong thing naturally. Removing the C-style *for* loop from\n> Swift will eliminate one more class of possible errors from the language.\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000627.html" , "inReplyTo" : "AA5B9DF1-AA96-4650-926F-039911A4C995@ericasadun.com" , "date" : { "$date" : 1449431671000} , "subject" : "[swift-evolution] C-style For Loops" , "references" : [ "AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de" , "8808357C-0780-423E-B028-1299CBCD2382@pobox.com" , "AA5B9DF1-AA96-4650-926F-039911A4C995@ericasadun.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CC1BC37C-FBA3-4D17-9ADA-379FA69A8078@me.com"}} , "_id" : "CC1BC37C-FBA3-4D17-9ADA-379FA69A8078@me.com" , "from" : "liamdunn at me.com (Liam Butler-Lawrence)" , "mailingList" : "swift-evolution" , "content" : "I’m going to add a +1 for Erica’s proposal. Here’s why:\n\n1. For every situation in which the for loop could be used, a for…in (either with ranges or strides) or while loop could achieve the same goals.\n\n2. For the vast majority of these cases, the for…in or while version is much cleaner and easier to read than for(init;test;inc). More extensive refactoring might be necessary in some cases, but in my opinion that effort would be worthwhile to improve readability and consistency.\n\n3. For new programmers learning the language, the for…in is much easier to learn. To my understanding, this is a major goal of Swift. For those coming to Swift that have some experience with other languages, we should be guiding them towards the optimal Swift way of doing things. Letting those programmers use an inelegant, legacy feature “just because” does not seem to me to fit the goals of Swift. In addition, the for…in loop is not even a new Swift concept; many languages (including C++, and Objective-C, and Python) already have for..in style loops available.\n\n4. To the comment that said \"even that a feature isn't used doesn't mean that you need to remove that feature\": I don’t agree. If a given feature is inferior to its alternatives and is not actually in common use, why not simplify the language and just remove it? I think many of us would agree that for(init;test;inc) loops fail the smell test we should be using: would we add this in Swift 3 if it didn’t already exist?\n\nLastly, I’d like to point out that I, too, had a knee-jerk negative reaction when I saw the already accepted proposal for removing ++ and --. After reading the rationale and discussion regarding that change, I completely changed my mind. I believe this proposal should accepted for similar reasons.\n\nThanks,\nLiam\n\n> On Dec 6, 2015, at 10:33 AM, inbox only via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> True,even that a feature isn't used doesn't mean that you need to remove that feature.\n> I hope that the proposal will be rejected.\n> \n> 2015-12-06 12:03 GMT+02:00 Clemens Wagner via swift-evolution <swift-evolution at swift.org>:\n>> > We’ve developed a number of Swift apps for various clients over the past year and have not needed C style for loops either.\n>> \n>> But I think this is a very weak reason for *removing* any portion like C-loops and increment or decrement operators of a programming language. How about the developers and the productive code which used C-style loops already?\n>> \n>> I understand the reasons why you, Erica and the others don’t like C-style loops. But changing the philosophy of a productive programming language is a very bad idea.\n>> \n>> Cheers\n>> Clemens\n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> \n>  _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000628.html" , "inReplyTo" : "CAOjGmwn6O2uvJBq03GZyJ+yngfAB4=rqb60dCCfpP2x7rmnEyg@mail.gmail.com" , "date" : { "$date" : 1449431815000} , "subject" : "[swift-evolution] C-style For Loops" , "references" : [ "AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de" , "CAOjGmwn6O2uvJBq03GZyJ+yngfAB4=rqb60dCCfpP2x7rmnEyg@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org"}} , "_id" : "CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org" , "from" : "swift-evolution at jacopo.giola.org (Jacopo Andrea Giola)" , "mailingList" : "swift-evolution" , "content" : " Hi Colin,\n\nthe initial proposal was indeed to remove entirely the `fallthrough` keyword but many people expressed your similar concern and from that point the discussion was steered through an \"enhancement\" and better refinement of the keyword.\n\nThe new idea is to substitute the old keyword with \"reswitch\" passing the desired new value on which the switch is applied.\nSo something like this:\n\nswitch (enum) {\n\tcase .One:\n\t\t// do something\n\t\treswitch .Two\n\tcase .Two:\n\t\t// do something else\n\tdefault:\n\t\t// and so one\n}\n\nThis new behaviour, IMO, is better suited for Swift because is more declarative of the developer intent and doesn't carry over unintentional misbehaviour.\nIs more declarative because you are forced to state in which case you want to go, and even if the order of the switch’ cases will change in the future, you don't fall in the wrong case by mistake.\n\nswitch (enum) {\n\tcase .One:\n\t\t// do something\n\t\treswitch .Two\n\tcase .OneAndAHalf\n\t\t// maybe this change is not made by you but by a messed up merge\n\tcase .Two:\n\t\t// do something else\n\tdefault:\n\t\t// and so one\n}\n\nIn this case if you are using the fallthrough keyboard your code is now broken by accident, and depending on what are you trying to do inside the cases you can have a hidden bug that your tests are not seeing right away. \n\nAnother advantage is that in this way you can made more cases fallthrough in the same one even if they are not one over each other\n\nswitch (enum) {\n\tcase .One:\n\t\t// do something\n\t\treswitch .Two\n\tcase .OneAndAHalf\n\t\t// so something that you don’t want to do for .One\n\t\treswitch .Two\n\tcase .Two:\n\t\t// do something else that you may want to do for .One and .Two\n\tdefault:\n\t\t// and so one\n}\n\nI must say that this is a side effect that can be used to messed up the code flow in a way that is not intended, but is a new behaviour that gives more power to the switch statement.\n\nThe reswitch keyword in addition is not a mere fallthrough on the new case without doing the optional checking attached to it, but is intended to be a new call and all the check are executed.\n\nswitch (enum) {\n\tcase .One:\n\t\t// do something\n\t\tx = 0;\n\t\treswitch .Two\n\tcase .OneAndAHalf\n\t\t// so something that you don’t want to do for .One\n\t\treswitch .Two\n\tcase .Two where x > 0:\n\t\t// do something else that you may want to do for .One and .Two\n\t\telement = array[x]\n\tdefault:\n\t\t// and so one\n}\n(I’m going by memory and by writing this snippets in the mail app directly, so the code must be incorrect in the syntax and for this I’m sorry).\n\nIn this case if enum is .One the only case that is executed is case .One and the code doesn’t fallthrough in the .Two case because we are made the where invalid by changing the x to a value less than 1.\n\nNow I don’t remember who was the first one who mede this proposal, and I don’t know if he is working on a first draft to lay down the things better, but for me this can be a nice improvement and a neat break with the C-switch behaviour that Swift has trying to change from the very first beta disallowing the implicit fallthrough.\n\nI can be completely wrong but I see the `fallthrough`keyword as a “temporary” implementation for ease the transition from Obj-C to Swift and is time to improve it and made the switch statement even more powerful.\n\n- Jacopo\nSent from my iPad\n\nOn 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n\n> tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.\n> \n> Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.\n> \n> I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)\n> \n> Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:\n> \n> https://gist.github.com/cbarrett/23b24a9fe76efdf006df <https://gist.github.com/cbarrett/23b24a9fe76efdf006df>\n> \n> This technique is very extensible — for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.\n> \n> Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type — low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.\n> \n> Thanks,\n> -Colin\n> \n>> On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>> \n>> +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.\n>> \n>> If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don't introduce an infinite \"switch\" loop.\n>> \n>> Sent from my iPad\n>> \n>> On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>> \n>>> Very much thinking out loud and not really the implications, I wonder if we might just use \"continue\" instead of \"reswitch\".\n>>> \n>>> I very much like specifying what case to fall through into, no matter how we spell it.\n>>> \n>>> - Steve\n>>> \n>>> On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>> \n>>>>> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>>>>> On Dec 4, 2015, at 11:37 PM, John Calsbeek <john.calsbeek+lists at gmail.com <mailto:john.calsbeek+lists at gmail.com>> wrote:\n>>>>>> `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.\n>>>>>> \n>>>>>> It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.\n>>>>> \n>>>>> Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.\n>>>>> \n>>>>> On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.\n>>>> \n>>>> Oh, I see that Joe already brought this up, spelled “reswitch”.\n>>>> \n>>>> John.\n>>>> \n>>>>> \n>>>>> John.\n>>>>> \n>>>>>> \n>>>>>> One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).\n>>>>>> \n>>>>>> switch op {\n>>>>>> case LOAD_INDIRECT:\n>>>>>>    in0 = memory[in1]\n>>>>>>    fallthrough\n>>>>>> case LOAD:\n>>>>>>    out0 = memory[in0]\n>>>>>> //...\n>>>>>> }\n>>>>>> \n>>>>>> I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.\n>>>>>> \n>>>>>> Cheers,\n>>>>>> John\n>>>>>> \n>>>>>>> On Dec 4, 2015, at 2:42 PM, John McCall <rjmccall at apple.com <mailto:rjmccall at apple.com>> wrote:\n>>>>>>> \n>>>>>>>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard <kevin at sb.org <mailto:kevin at sb.org>> wrote:\n>>>>>>>> It's not actually Duff's Device. Duff's Device relies on the fact that C switch statements don't actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it's a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.\n>>>>>>> \n>>>>>>> To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.\n>>>>>>> \n>>>>>>> But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.\n>>>>>>> \n>>>>>>> John.\n>>>>>>> \n>>>>>>>>  \n>>>>>>>> Steve's code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It's a good example of one of the uses of `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's Device in Swift.\n>>>>>>>>  \n>>>>>>>> -Kevin Ballard\n>>>>>>>>  \n>>>>>>>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:\n>>>>>>>>> Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.\n>>>>>>>>>  \n>>>>>>>>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:\n>>>>>>>>>>  \n>>>>>>>>>> Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it. \n>>>>>>>>>>  \n>>>>>>>>>> True fact: On all of gist.github.com <http://gist.github.com/>, there are only 22 gist results for \"fallthrough language:swift\".\n>>>>>>>>>> Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:\n>>>>>>>>>> case .Enum1, .Enum2:\n>>>>>>>>>> expressed as \n>>>>>>>>>> case .Enum1: fallthrough\n>>>>>>>>>> case .Enum2:\n>>>>>>>>>>  \n>>>>>>>>>> And then there's streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea <https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea>   I'm pretty sure that ponies were harmed in the production of whatever that last bit is.\n>>>>>>>>>>  \n>>>>>>>>>>  \n>>>>>>>>>>  \n>>>>>>>>>>  \n>>>>>>>>>>> On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com <mailto:jalkut at red-sweater.com> wrote:\n>>>>>>>>>>>  \n>>>>>>>>>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the \"fallthrough\" keyword from the language?\n>>>>>>>>>>>  \n>>>>>>>>>>> My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.\n>>>>>>>>>>>  \n>>>>>>>>>>> The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:\n>>>>>>>>>>>  \n>>>>>>>>>>> \"The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.\"\n>>>>>>>>>>>  \n>>>>>>>>>>> To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.\n>>>>>>>>>>>  \n>>>>>>>>>>> I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.\n>>>>>>>>>>>  \n>>>>>>>>>>> In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.\n>>>>>>>>>>>  \n>>>>>>>>>>> Thoughts?\n>>>>>>>>>>>  \n>>>>>>>>>>> Daniel\n>>>>>>>>>>>  \n>>>>>>>>>>> _______________________________________________\n>>>>>>>>>>> swift-evolution mailing list\n>>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>>>>>>> \n>>>>>>>>>>  \n>>>>>>>>>> \n>>>>>>>>>> _______________________________________________\n>>>>>>>>>> swift-evolution mailing list\n>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>>>>>> \n>>>>>>>>>  \n>>>>>>>>> \n>>>>>>>>> _______________________________________________\n>>>>>>>>> swift-evolution mailing list\n>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>>>>>  \n>>>>>>>> \n>>>>>>>> _______________________________________________\n>>>>>>>> swift-evolution mailing list\n>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>>>> \n>>>>>>>  _______________________________________________\n>>>>>>> swift-evolution mailing list\n>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>>> \n>>>>>> _______________________________________________\n>>>>>> swift-evolution mailing list\n>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>> \n>>>>> \n>>>>> _______________________________________________\n>>>>> swift-evolution mailing list\n>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>> \n>>>> \n>>>> _______________________________________________\n>>>> swift-evolution mailing list\n>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>> \n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>> \n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n> \n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000629.html" , "inReplyTo" : "071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com" , "date" : { "$date" : 1449432397000} , "subject" : "[swift-evolution] Proposal: Remove the \"fallthrough\" keyword" , "references" : [ "3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com" , "AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com" , "8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com" , "1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com" , "02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com" , "E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com" , "444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com" , "EF1675F6-7918-4262-B535-696104BFC405@apple.com" , "CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com" , "D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org" , "071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com"] , "descendants" : [ "ECE284CE-EDE3-4071-ABB6-821820F1FC44@jacopo.giola.org" , "EF9FEF97-C7B8-4D54-B406-2B62FDD15B59@springsandstruts.com" , "98973CF0-B5A8-491F-A8D0-DA73456FF01B@jacopo.giola.org" , "CAKCGC8B0UPGUHeJ_1n8XsGoo+E6Anyj_+_R7WsT76rV1Q-qu2w@mail.gmail.com" , "E7877054-1CF7-4596-800A-0D3C578A0CF1@portableinnovations.de" , "CAKCGC8Cp52O7DX6wWSc3J6FR8Xmoo_WLBgjGBa6fSXzNHhdHEg@mail.gmail.com" , "D7B06EA6-A46C-4920-9E09-CB99B96242AA@jacopo.giola.org" , "1449442122.2380087.459714713.0AC4A201@webmail.messagingengine.com" , "D9340CB2-A696-478A-BAE7-F93ED39CB2DC@red-sweater.com" , "CEA837D7-E2B1-48DC-A53B-D216F96DD8DF@apple.com" , "2423784D-3B84-41CE-9BE2-0850BFE5A3C0@apple.com" , "2A8EA416-B4FF-45B3-9C6D-F94059151129@apple.com" , "82BBEAF7-A512-460A-998C-054AE6D70BEB@springsandstruts.com" , "9C8A3DCA-B80C-4D1F-9528-DD65C0020680@apple.com" , "CAKCGC8BL6SHkO0T_Rg6Ren-NfCLs+eGBb6Zm9aFuZ5rMkWJXtQ@mail.gmail.com" , "AC2407AD-ABFF-4657-A04C-F37E52466316@springsandstruts.com" , "1449524366.1229815.460824345.0E2309C2@webmail.messagingengine.com" , "1449524552.1230499.460828169.5289846B@webmail.messagingengine.com" , "6BABB1A5-55CD-43AF-8D5D-9758F55AD611@apple.com" , "266A61BA-1890-46D7-8969-4A0225EA60B4@springsandstruts.com" , "37FA3360-5F23-462D-BE9B-3743253D2693@apple.com" , "C19956A6-C9B2-45CC-8C91-DA2215EBEA5C@alkaline-solutions.com" , "6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com" , "6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org" , "A56C416E-E246-44FC-A681-3DD66171DF30@springsandstruts.com" , "CADQN+5atyJ78vi0xssjOxh2ka_-jZTaO3ZabxFdY80YqJHFmxg@mail.gmail.com" , "CAKCGC8DHCxwtiU82CjxChc6PaiB495WOCJBP0iq04uw7iWcQmA@mail.gmail.com" , "DEBE0A49-3E5A-431F-8559-63EBA7214068@jacopo.giola.org" , "CAKCGC8DbhMOX6bHtzXQcAhjHQSw1wSSoX-TBUtew0arWA=4pSw@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CADS5KKXGd3L=b+mTPwn=L9CeyVDMorYVQgJoBPxFgngozcWwmQ@mail.gmail.com"}} , "_id" : "CADS5KKXGd3L=b+mTPwn=L9CeyVDMorYVQgJoBPxFgngozcWwmQ@mail.gmail.com" , "from" : "p at greendale.se (Per Melin)" , "mailingList" : "swift-evolution" , "content" : "On Sat, Dec 5, 2015 at 7:15 PM, Chris Lattner <clattner at apple.com> wrote:\n\n> Further, it is important to consider whether the code written using this\n> will actually be *better* than the code written with these things as\n> statements.  For example, the “switch” blocks tend to be very large, and\n> turning them into expressions encourages additional indentation.\n\n\nIf you give functions implicit return at the same time – as in Haskell,\nErlang, Scala, Rust, Ruby, Lisp/Scheme/Clojure, etc –  there would be no\nneed for additional indentation half of the time.\n\nI really, really like it in many of the mentioned languages, but I expect\nthat the C crowd will vehemently disagree. And maybe Swift is sufficiently\ndifferent from those languages that it makes less sense here. For example,\nregardless of project, my average function body size in Erlang hovers\naround two lines. Not even Slava Pestov would factor Swift that\naggressively." , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000630.html" , "inReplyTo" : "7EDDCB03-B726-4557-91C4-3E7A724FAD94@apple.com" , "date" : { "$date" : 1449433074000} , "subject" : "[swift-evolution] Control Flow Expressions" , "references" : [ "DE55FD91-8C65-4BE0-9D74-30F7E42C7FFD@gmail.com" , "7EDDCB03-B726-4557-91C4-3E7A724FAD94@apple.com"] , "descendants" : [ "04492F1A-DC29-41D3-B9CD-44E87AA44E49@apple.com" , "B3409EB3-139D-4E3E-A038-8FAF66900BF9@mac.com" , "CAAcV4sYgcx0zs664Q3Ab8qvxmTmzvoYOYA-Ya7U4YNM9YPHEsg@mail.gmail.com" , "CAAcV4saMd7NArJb_pGDNSBw8bjgrKt=LQ943C0P_5AZoWk_Bgw@mail.gmail.com" , "FE43B84C-3DE6-4D96-A1C3-9A566934C9D3@gmail.com" , "0F76202A-15E5-4F3A-AEE1-35F254569186@gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAKCGC8AVDe6W9X=XvFEnbkae8xom2Us8xczKFShqKu2+kPnRJA@mail.gmail.com"}} , "_id" : "CAKCGC8AVDe6W9X=XvFEnbkae8xom2Us8xczKFShqKu2+kPnRJA@mail.gmail.com" , "from" : "alexl.mail+swift at gmail.com (Alex Lew)" , "mailingList" : "swift-evolution" , "content" : "Thanks for the feedback, Matthew. It's sensible to me to consider dropping\nthe ternary operator. I like it because the analogy \"C's if is to Swift's\nif as C's ternary operator is to Swift's ternary operator\" is (sort of)\nsatisfied. But it is also confusing, both for the reasons you mention, and\nbecause ? has other meanings in Swift:\n\n // compiler error without space betw thatColor and ?\nlet thisColor = thatColor?\n     case .Red: .Green\n     default: .Blue\n\nOn the other hand, is it really worth it to have control flow expressions\nif they don't let your code look nicer?\n\nlet thisColor = switch thatColor {\n     case .Red:\n          return .Green;\n     default:\n          return .Yellow;\n}\n\nreally isn't much nicer than\n\nlet thisColor: Color\nswitch thatColor {\n     case .Red:\n          thisColor = .Green\n     default:\n          thisColor = .Yellow\n}\n\nMaybe we could do a compromise, something like\n\nlet thisColor = switch thatColor\n     case .Red: .Green // must be an expression\n     default: .Yellow      // must be an expression\n\nOr we could introduce a new keyword? Like *match*:\n\nlet thisColor = match thatColor\n      case .Red: .Green    // must be an expression\n      default: .Yellow         // must be an expression\n\n\nI sort of like the new-keyword approach, because even though this is\nsimilar to a switch, it's not a switch: there's no fallthrough, you can't\nput statements inside, etc.\n\nThe problem with all these proposals:\n\nlet thisColor = match thatColor\n     case .Red: match thatOtherColor\n                           case .Blue: .Green\n                           case .Pink: .Yellow\n                           default: .Orange\n     default: .Orange\n\nis ambiguous. (Does case .Pink match thatColor or thatOtherColor? We can\nknow because of exhaustiveness checking, but this won't always work.) You\ncould solve this problem either by using parentheses around the whole\nexpression when necessary\n\nlet thisColor = match thatColor\n     case .Red: (match thatOtherColor\n                           case .Blue: .Green\n                           case .Pink: .Yellow\n                           default: .Orange)\n     default: .Orange\n\nor by adding curly braces in again\n\nlet thisColor = match thatColor {\n     case .Red: match thatOtherColor {\n                           case .Blue: .Green\n                           case .Pink: .Yellow\n                           default: .Orange\n                        }\n     default: .Orange\n}\n\nBut that starts to look like switch again. (Of course, the best way to\nhandle this is as a programmer is to just switch on the tuple (thatColor,\nthatOtherColor), but the language should allow for nested control\nexpressions.)\n\n\nOn Sun, Dec 6, 2015 at 2:48 PM, Matthew Johnson via swift-evolution <\nswift-evolution at swift.org> wrote:\n\n> I am not a fan of this approach based on the ternary operator.  The\n> ternary operator is already a bit of an anomaly in that all other operators\n> are unary or binary and do not perform any control flow (beyond possibly\n> short circuiting an autoclosure argument).\n>\n> I would much rather features that perform control flow continue to use\n> keywords, but allow them to be expressions.\n>\n> Once we have control flow expressions I would like to see the ternary\n> operator removed from the language as it would no longer server a purpose.\n> Removing the ternary operator seems to fit nicely with the direction to\n> remove some features that are carried over from C-based languages but don’t\n> necessarily fit with the direction Swift is heading.\n>\n>\n> On Dec 6, 2015, at 1:19 PM, Kevin Lundberg via swift-evolution <\n> swift-evolution at swift.org> wrote:\n>\n> Ostensibly, case may not be necessary if you could delimit each case on\n> one line with something (perhaps a comma, or something else if that would\n> not fit well within the grammar):\n>\n> let thisColor = thatColor ? .Blue: .Red, .Green: .Blue, .Red: .Green,\n> default: .Yellow\n>\n> On Sun, Dec 6, 2015, at 01:57 PM, Paul Ossenbruggen via swift-evolution\n> wrote:\n>\n> I like this too, seems more powerful.  Also, would single line expressions\n> be allowed?  If not would case be required for example:\n>\n> let myFavoriteColor = yourFavoriteColor ?\n>     case .Blue: .Red\n>     case .Green: .Blue\n>     case .Red: .Green\n>     default: .Yellow\n>\n>\n>\n> On Dec 6, 2015, at 9:11 AM, Sean Heber via swift-evolution <\n> swift-evolution at swift.org> wrote:\n>\n> I really like this train of thought. +1\n>\n> l8r\n> Sean\n>\n> On Dec 6, 2015, at 11:02 AM, Alex Lew via swift-evolution <\n> swift-evolution at swift.org> wrote:\n>\n> What if we left the if { ...} else { ... } syntax alone (as a statement),\n> and updated the ternary expression to be a more general pattern matching\n> expression (closer to \"switch\")? Something like\n>\n> let x = condition ?\n>    true: \"Hello\"\n>    false: \"Goodbye\"\n>\n> let x = optionalValue ?\n>    .Some(let unwrapped): \"Hello, \\(unwrapped)\"\n>    .None: \"To Whom It May Concern\"\n>\n> let myFavoriteColor = yourFavoriteColor ?\n>     .Blue: .Red\n>     .Green: .Blue\n>     .Red: .Green\n>\n> let quadrant = (x, y) ?\n>     let (x, y) where x < 50 && y < 50: \"top left\"\n>     let (x, y) where x < 50 && y > 50: \"bottom left\"\n>     let (x, y) where x > 50 && y < 50: \"top right\"\n>     default: \"bottom right\"\n>\n> The colon comes from the fact that this is sort of a light-weight\n> expression-based \"switch\" statement, where each branch can only contain an\n> expression, not a series of statements.\n>\n> This is very similar to pattern matching expressions in languages like\n> Haskell, ML, and Coq.\n>\n> On Sun, Dec 6, 2015 at 11:25 AM, Thorsten Seitz <thorsten.seitz at web.de> wrote:\n>\n>\n>\n>\n> Am 06.12.2015 um 01:28 schrieb Alex Lew via swift-evolution <\n> swift-evolution at swift.org>:\n>\n> I don't think you can just get rid of the if statement in favor of an\n> expression. You still want to be able to do this:\n>\n> if (condition) {\n>     funcWithSideEffectsThatReturnsInt()\n> } else {\n>     funcWithSideEffectsThatReturnsString()\n> }\n>\n> but that's not a valid expression (what is its type?).\n>\n>\n>\n> That would actually be no problem if Swift’s type system would have union\n> types (Ceylon has union and intersection types which are quite awesome and\n> enable lots of nice things quite naturally, see\n> http://ceylon-lang.org/documentation/1.2/tour/types/).\n>\n> In that case the type of such an expression would just be the union of\n> both types, which is written Int | String in Ceylon.\n>\n>\n> -Thorsten\n>\n>\n>\n>\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>\n> *_______________________________________________*\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>\n> Untracked with Trackbuster <https://trackbuster.com/?sig>\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000631.html" , "inReplyTo" : "11462DA4-ACDD-4CF3-BD57-47886B655970@anandabits.com" , "date" : { "$date" : 1449433469000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com" , "CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com" , "C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com" , "18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com" , "2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io" , "BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com" , "CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com" , "CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com" , "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com" , "BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com" , "909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net" , "0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com" , "49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net" , "CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com" , "49EEA2E6-55F2-49DE-A59F-A13017626370@web.de" , "CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com" , "4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com" , "1449429569.1342623.459603529.32C935BC@webmail.messagingengine.com" , "11462DA4-ACDD-4CF3-BD57-47886B655970@anandabits.com"] , "descendants" : [ "07270E34-E284-4FF0-B2EA-6DBB54FF78B5@portableinnovations.de" , "45B71AF5-DD4F-4E9C-A128-5B8041917564@me.com" , "CAKCGC8BmmCk55=6UC_qk_C+ZNq2JfGpOPO5cJ=SK2784kmvbGg@mail.gmail.com" , "B6DDD94B-0755-4D40-94F0-D2469A644818@portableinnovations.de" , "CAKCGC8AerqpPTrwdmPAvhmp-fLt-v=LXw4z0t+2o93g9GmAaxw@mail.gmail.com" , "54E5D8F5-616D-41EB-A550-E639FE861575@gmail.com" , "CAKCGC8CsJ7g_Fu8fnQ5Mv=yAzbSvb0Z+iNmdXKnJaAcWR2UKuw@mail.gmail.com" , "6830F74D-78FC-4B20-A6D5-683185B30164@gmail.com" , "691A92C4-1A5F-4CAE-AF50-F6AAA3A3F32C@portableinnovations.de" , "D35074A6-1C34-4BA3-AAF1-8CFE1992A522@me.com" , "1EE735A6-FF0F-4E49-BE7D-AC7E6C8A87EC@tarantsov.com" , "3D250DE5-09BC-4A6B-AF59-E1D714DF709A@tarantsov.com" , "BB6A4434-E2B1-4192-8450-90D636E6A7F5@fastmail.fm" , "0ED79E6D-A89A-4F3E-9269-6216BD10EB22@sealedabstract.com" , "CAAcV4sb9eMhuLGL3QsBw4bFxj1FQrokCAanKjEFRNNReE8zWOQ@mail.gmail.com" , "7253CF12-DBD4-483D-941F-04851E5AD394@tarantsov.com" , "CAAcV4sbo4=Hdzp+yx-km-CnhNDm2uQ-gDJsvdug_Pg-MjTPC=Q@mail.gmail.com" , "CAAcV4sbAk_eSdjz7bQ6ggdZNE+thmj7-wT_pG2+eRMKDVba+wA@mail.gmail.com" , "7B70F158-5B8A-425B-980C-CD08210342D4@me.com" , "0DF0732F-0958-47C1-A6C3-62A8AB2F4386@icloud.com" , "6DA2FDFF-F978-4ECA-9E2B-F757F6D8BBF3@icloud.com" , "2116BFD1-25BC-4B9F-A3A6-08758782BB88@anandabits.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/4A5C6452-0A1B-42A3-AFD4-3DEA04E310C6@icloud.com"}} , "_id" : "4A5C6452-0A1B-42A3-AFD4-3DEA04E310C6@icloud.com" , "from" : "possen at gmail.com (Paul Ossenbruggen)" , "mailingList" : "swift-evolution" , "content" : "I prefer making “case” optional if it can be accommodated, for compactness on a single line but maybe can be provided for those doing multiline so it is more explicit. \n\nif not ? how about expression “switch?” to separate expression switch, from the switch statement? One issue is if is if ? is reserved for optionals.  So:\n\nlet myColor = yourColor switch? .Blue :  .Red, .Green: .Blue, .Red: .Green, default: .Yellow\n\nor could be optionally with case with semicolons to separate, as a line continuation:\n\nlet myColor = yourColor switch? case .Blue : .Red; case .Green: .Blue;  case .Red: .Green; default: .Yellow\n \nBut “case\" would be mostly for multiline:\n\nlet myColor = yourColor switch?\n\tcase .Blue :  .Reds\n\tcase .Green: .Blue \n\tcase .Red: .Green\n\tdefault: .Yellow\n\ncould also be written as:\n\nlet myColor = yourColor switch?\n\t.Blue :  .Reds\n\t.Green: .Blue \n\t.Red: .Green\n\tdefault: .Yellow\n\nAlso, ”if\" could be expressionized: \n\nlet myColor = condition if?  .Blue; .Red\n\n\n> On Dec 6, 2015, at 11:48 AM, Matthew Johnson via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> I am not a fan of this approach based on the ternary operator.  The ternary operator is already a bit of an anomaly in that all other operators are unary or binary and do not perform any control flow (beyond possibly short circuiting an autoclosure argument).\n> \n> I would much rather features that perform control flow continue to use keywords, but allow them to be expressions.  \n> \n> Once we have control flow expressions I would like to see the ternary operator removed from the language as it would no longer server a purpose.  Removing the ternary operator seems to fit nicely with the direction to remove some features that are carried over from C-based languages but don’t necessarily fit with the direction Swift is heading.\n> \n> \n>> On Dec 6, 2015, at 1:19 PM, Kevin Lundberg via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>> \n>> Ostensibly, case may not be necessary if you could delimit each case on one line with something (perhaps a comma, or something else if that would not fit well within the grammar):\n>>  \n>> let thisColor = thatColor ? .Blue: .Red, .Green: .Blue, .Red: .Green, default: .Yellow\n>>  \n>> On Sun, Dec 6, 2015, at 01:57 PM, Paul Ossenbruggen via swift-evolution wrote:\n>>> I like this too, seems more powerful.  Also, would single line expressions be allowed?  If not would case be required for example:\n>>>  \n>>> let myFavoriteColor = yourFavoriteColor ?\n>>>     case .Blue: .Red\n>>>     case .Green: .Blue\n>>>     case .Red: .Green\n>>>     default: .Yellow\n>>>  \n>>>  \n>>>> On Dec 6, 2015, at 9:11 AM, Sean Heber via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>>>  \n>>>> I really like this train of thought. +1\n>>>>  \n>>>> l8r\n>>>> Sean\n>>>>  \n>>>> On Dec 6, 2015, at 11:02 AM, Alex Lew via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>>>> What if we left the if { ...} else { ... } syntax alone (as a statement), and updated the ternary expression to be a more general pattern matching expression (closer to \"switch\")? Something like\n>>>>>  \n>>>>> let x = condition ?\n>>>>>    true: \"Hello\"\n>>>>>    false: \"Goodbye\"\n>>>>>  \n>>>>> let x = optionalValue ?\n>>>>>    .Some(let unwrapped): \"Hello, \\(unwrapped)\"\n>>>>>    .None: \"To Whom It May Concern\"\n>>>>>  \n>>>>> let myFavoriteColor = yourFavoriteColor ?\n>>>>>     .Blue: .Red\n>>>>>     .Green: .Blue\n>>>>>     .Red: .Green\n>>>>>  \n>>>>> let quadrant = (x, y) ?\n>>>>>     let (x, y) where x < 50 && y < 50: \"top left\"\n>>>>>     let (x, y) where x < 50 && y > 50: \"bottom left\"\n>>>>>     let (x, y) where x > 50 && y < 50: \"top right\"\n>>>>>     default: \"bottom right\"\n>>>>>  \n>>>>> The colon comes from the fact that this is sort of a light-weight expression-based \"switch\" statement, where each branch can only contain an expression, not a series of statements.\n>>>>>  \n>>>>> This is very similar to pattern matching expressions in languages like Haskell, ML, and Coq.\n>>>>>  \n>>>>> On Sun, Dec 6, 2015 at 11:25 AM, Thorsten Seitz<thorsten.seitz at web.de <mailto:thorsten.seitz at web.de>>wrote:\n>>>>>  \n>>>>>> Am 06.12.2015 um 01:28 schrieb Alex Lew via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>>:\n>>>>>>  \n>>>>>> I don't think you can just get rid of the if statement in favor of an expression. You still want to be able to do this:\n>>>>>>  \n>>>>>> if (condition) {\n>>>>>>     funcWithSideEffectsThatReturnsInt()\n>>>>>> } else {\n>>>>>>     funcWithSideEffectsThatReturnsString()\n>>>>>> }\n>>>>>>  \n>>>>>> but that's not a valid expression (what is its type?).\n>>>>>  \n>>>>>  \n>>>>> That would actually be no problem if Swift’s type system would have union types (Ceylon has union and intersection types which are quite awesome and enable lots of nice things quite naturally, seehttp://ceylon-lang.org/documentation/1.2/tour/types/ <http://ceylon-lang.org/documentation/1.2/tour/types/>).\n>>>>>  \n>>>>> In that case the type of such an expression would just be the union of both types, which is writtenInt | Stringin Ceylon.\n>>>>>  \n>>>>>  \n>>>>> -Thorsten\n>>>>>  \n>>>>>  \n>>>>>  \n>>>>> \n>>>>> _______________________________________________\n>>>>> swift-evolution mailing list\n>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>> _______________________________________________\n>>>> swift-evolution mailing list\n>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>> \n>>> \n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>  \n>> \n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> \n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000633.html" , "inReplyTo" : "11462DA4-ACDD-4CF3-BD57-47886B655970@anandabits.com" , "date" : { "$date" : 1449433842000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com" , "CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com" , "C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com" , "18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com" , "2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io" , "BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com" , "CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com" , "CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com" , "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com" , "BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com" , "909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net" , "0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com" , "49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net" , "CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com" , "49EEA2E6-55F2-49DE-A59F-A13017626370@web.de" , "CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com" , "4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com" , "7D68F57E-C847-4E" , "0D-AF3A-" , "FD1F2DC928A9@icloud.com" , "1449429569.1342623.459603529.32C935BC@webmail.messagingengine.com" , "11462DA4-ACDD-4CF3-BD57-47886B655970@anandabits.com"] , "descendants" : [ "67057217-F4BC-4584-8B52-8EBA2CFA8CC7@portableinnovations.de"]} , { "_links" : { "self" : { "href" : "/charter/emails/DD7C743B-5E22-4603-AA6A-AF3F75B4DE62@ericasadun.com"}} , "_id" : "DD7C743B-5E22-4603-AA6A-AF3F75B4DE62@ericasadun.com" , "from" : "erica at ericasadun.com (Erica Sadun)" , "mailingList" : "swift-evolution" , "content" : "It's probably better at this point for me to collect my thoughts and summarize where I am at.\n\nhttps://gist.github.com/erica/eb32feb22ba99629285a <https://gist.github.com/erica/eb32feb22ba99629285a>\n\nPlease feel free to comment on-list about this proposal (github does not forward comment alerts) and\nthen I will start a new list thread as a Proposal rather than as a Request for Discussion.\n\nBest,\n\n-- E\n\n\n> On Dec 6, 2015, at 12:45 PM, ilya <ilya.nikokoshev at gmail.com> wrote:\n> \n> Sorry, did I misunderstand the question? \n> \n> Did you asked whether my definition will work for immutable value types? \n> If that's the question, the answer is still yes, the link has an example :) \n> \n> On Sun, Dec 6, 2015 at 10:43 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:\n> I was specifically referring to value types. I apologize for not being clearer.\n> \n> -- E\n> \n> \n>> On Dec 6, 2015, at 12:42 PM, ilya <ilya.nikokoshev at gmail.com <mailto:ilya.nikokoshev at gmail.com>> wrote:\n>> \n>> Yes, it works for immutable objects with the correct definition, see the playground contents at https://github.com/ilyannn/iOS-Swift-Materials/blob/master/Playgrounds/Configure.playground/Contents.swift <https://github.com/ilyannn/iOS-Swift-Materials/blob/master/Playgrounds/Configure.playground/Contents.swift>\n>> \n>> On Sun, Dec 6, 2015 at 8:10 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:\n>> I have developed something similar as well (http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/ <http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/>).\n>> \n>> Is yours capable of handling enums and structs that would otherwise be let after declaration because mine is not.\n>> \n>> -- E\n>> \n>> \n>>> On Dec 5, 2015, at 5:16 PM, ilya via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>> \n>>> > PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.  Here's one example: ...\n>>> \n>>> FWIW, I created a configuration operator more then a year ago, and use it in all of my Swift projects:\n>>> \n>>> let task = NSTask() +=+ {\n>>>     $0.launchPath = \"/usr/bin/mdfind\"\n>>>     $0.arguments = [\"kMDItemDisplayName == *.playground\"]\n>>>     $0.standardOutput = pipe\n>>> }\n>>> \n>>> Note you can also use the configured object in the rhs:\n>>> \n>>> let questionLabel = UILabel() +=+ {\n>>>     $0.textAlignment = .Center\n>>>     $0.font =  UIFont(name:\"DnealianManuscript\", size: 72)\n>>>     $0.text = currentQuestion.questionText\n>>>     $0.numberOfLines = 0\n>>>     view.addSubview($0)\n>>> }\n>>> \n>>> This $0. certainly looks ugly and it would be great to be able to simplify this. I don't llike the following much though (dot-syntax can be ambiguos here, and using simply a method name is even worse):\n>>> \n>>> let questionLabel = UILabel() +=+ {\n>>>     .textAlignment = .Center\n>>>     .font =  UIFont(name:\"DnealianManuscript\", size: 72)\n>>>     .text = currentQuestion.questionText\n>>>     .numberOfLines = 0\n>>>     view.addSubview($0)\n>>> }\n>>> \n>>> Actually I would be happy with something like\n>>> \n>>> let questionLabel = UILabel() .{\n>>>     ..textAlignment = .Center\n>>>     ..font = UIFont(name:\"DnealianManuscript\", size: 72)\n>>>     ..text = currentQuestion.questionText\n>>>     ..numberOfLines = 0\n>>>     view.addSubview($0)\n>>> }\n>>> \n>>> Other thoughts?\n>>> \n>>>   \n>>>  _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>> \n>> \n> \n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000632.html" , "inReplyTo" : "CAPh90aHJuiYVOPu+9poXapDq9q4dzYAnS=fm3ke1ODz3neheOg@mail.gmail.com" , "date" : { "$date" : 1449433843000} , "subject" : "[swift-evolution] Request for Discussion: Setup closures" , "references" : [ "CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com" , "8837F311-F6F8-462E-90E0-88981C537EFD@ericasadun.com" , "CAPh90aEHX5aWQOnpkDJxeTt3DXOH6Xdqq1BXYVr_tvB63QKx1g@mail.gmail.com" , "F757A1B0-69AA-40E0-BB72-9A043CE6D93D@ericasadun.com" , "CAPh90aHJuiYVOPu+9poXapDq9q4dzYAnS=fm3ke1ODz3neheOg@mail.gmail.com"] , "descendants" : [ "F833B947-4FFD-485E-912A-31B50140660F@anandabits.com" , "F6635EA0-2342-451E-8675-FF1819BD715C@anandabits.com" , "2F1E045F-3242-4943-9471-B40D6B476C97@anandabits.com" , "35BE2387-2F9C-491F-B71F-1635243ABADA@ericasadun.com" , "38E11489-CE79-4690-8567-98FD7793B4FF@gmail.com" , "159233D0-A835-4435-840E-A9594DDCA37D@ericasadun.com" , "CAKCGC8AOx_ffGe1AjpQJt9ULr3zwTBsnphJCht92se7-Hfi_+g@mail.gmail.com" , "DC82287B-4583-47F3-9389-B756C91436F5@alkaline-solutions.com" , "CC9D9491-212A-4D20-8CC2-34FD984F6463@portableinnovations.de" , "EF05B911-5728-47F4-AB13-F960FF2B21A4@portableinnovations.de" , "F379B44A-9B6F-47BD-95B0-9FC795BC035B@architechies.com" , "BB9D9FE2-F252-41F4-A3EA-2D8053A7579C@gmx.de" , "1F3D7F58-0EC6-4541-9734-A95CE62BAF6E@anandabits.com" , "2139FFE7-79C5-4981-A036-250F2D5EF0A4@ericasadun.com" , "24FE9022-00E3-459C-8A71-540BCF436286@apple.com" , "E904EA6A-6422-49F6-9C5E-07BCDC7D3543@gmx.de" , "98A80B8C-AC32-408D-AD8F-CDE0EB782B4C@apple.com" , "03F8648F-236A-46A5-8D21-CA066DBA1932@anandabits.com" , "D49345E8-5E22-46C8-9EF2-EF0DB4D32D87@apple.com" , "77AE5195-4E57-4814-A228-AF23723C853B@ericasadun.com" , "B818E6F9-1526-4725-BCDA-AB8C36F3CED7@maven.de" , "6A18AB5F-3794-42A6-8142-AAA7B2B61000@apple.com" , "9520AAC7-B49D-4CB7-96EE-E9891BAC9268@ericasadun.com" , "5981B70E-98D3-4A99-AF49-106254DFEB54@apple.com" , "86e837d7-cac3-438b-8297-4f6f401b641f@Spark" , "315B39D9-AE33-438B-8EFF-CC4796EECAAF@pobox.com" , "731CB499-F42F-45D4-8A3B-8D7B963D3709@monod-broca.fr" , "CADcs6kNOmo32YcBHOjmsV3eKiJ4yo0nDxz+5mjWNtp3JG0FsOA@mail.gmail.com" , "616C48D0-D626-487E-861C-CF125879BABB@ericasadun.com" , "3A77268A-D52E-4821-9488-671491506835@monod-broca.fr" , "B5AE3C08-FB9F-4024-B6BF-ECAADC1196E8@pobox.com" , "52D7FF3E-4E16-447D-AFCF-6915ABF999C1@gmx.de" , "98E5A56D-2912-4725-8E5E-14F25153B184@gmx.de" , "3C9B366C-D4A8-4777-8CF9-E46B52F806E2@pobox.com" , "CAPh90aE1m68_kDFqOGuO-u6qP3WKtqSJS9XMU-KKrO0N3yV0kg@mail.gmail.com" , "0674FFD1-76FB-4376-9F34-0FF8B7560798@anandabits.com" , "5B0D18B8-0255-4F2E-86E3-253058585BDB@fifthace.com" , "512C0649-506C-41B3-BBB9-BBF6B80437FE@ericasadun.com" , "CADcs6kOfPJ73WdN-UHTZAPs7Zx_MmSUjrKy6r=EMphLdGfti8w@mail.gmail.com" , "ED9A9872-62B4-4957-B708-94F3015365C5@alkaline-solutions.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/9FCB65CF-491B-4F21-B664-AE6623E7C669@michelf.ca"}} , "_id" : "9FCB65CF-491B-4F21-B664-AE6623E7C669@michelf.ca" , "from" : "michel.fortin at michelf.ca (Michel Fortin)" , "mailingList" : "swift-evolution" , "content" : "There is actually one good reason I see in favor of keeping the C-style for loop, and only one: ease of porting existing code to Swift.\n\nIf you are porting code from another language that uses C-style for loops, currently you can keep the loop as is while you translate all the syntactic differences everywhere. If Swift didn't had a C-style for loop, then you'd need to rethink the control flow at the same time you are converting everything else, increasing the risk of errors during what is already a delicate operation.\n\nC-style for loops are very common in code you can find everywhere because many languages have it, and therefore there is a lot of algorithms, sometime tricky algorithms you don't want to mess up, that rely on such loops. Even if you had the desire to convert all of them to for-in loops in your port, rewriting the control flow *at the same time* you are addressing all the other porting issues is much worse than doing it in a separate step *after* the crude port has been tested to work.\n\nIn other words: you should avoid refactoring everything in one step. The C-style for loop enables that.\n\n-- \nMichel Fortin\nmichel.fortin at michelf.ca\nhttps://michelf.ca" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000634.html" , "inReplyTo" : "40642775-F58D-49B0-9BF3-38913FD6924C@ericasadun.com" , "date" : { "$date" : 1449434277000} , "subject" : "[swift-evolution] C-style For Loops" , "references" : [ "AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de" , "CAAcV4sZVC8M4yo+XEdWoGzKyG7rDYuy7ox=Rk3cdbXjFuSD4Sg@mail.gmail.com" , "40642775-F58D-49B0-9BF3-38913FD6924C@ericasadun.com"] , "descendants" : [ "2CF98787-3994-47AA-8B84-13C9AC7A4154@fifthace.com" , "CAPh90aFQs-RA4W++PCgG7n58p0F5NOp9jmJsz7hZxfkOZktVcA@mail.gmail.com" , "3F9880E8-7BEA-4275-A939-940041861EC5@michelf.ca" , "5664F2B9.5080808@klundberg.com" , "5567A331-3420-448B-9A1F-484D44F7A792@michelf.ca" , "2F9C0A4A-4005-462F-83DD-795C6E838C3B@pobox.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/0DF0732F-0958-47C1-A6C3-62A8AB2F4386@icloud.com"}} , "_id" : "0DF0732F-0958-47C1-A6C3-62A8AB2F4386@icloud.com" , "from" : "possen at gmail.com (Paul Ossenbruggen)" , "mailingList" : "swift-evolution" , "content" : "Yep probably does need braces: So for switch? if? suggestion i just made. \n\nlet myColor = yourColor switch? { .Blue :  .Red, .Green: .Blue, .Red: .Green, default: .Yellow }\n\nlet myColor = yourColor switch? { case .Blue : .Red; case .Green: .Blue;  case .Red: .Green; default: .Yellow }\n\nlet myColor = yourColor switch? {\n\tcase .Blue :  .Reds\n\tcase .Green: .Blue \n\tcase .Red: .Green\n\tdefault: .Yellow\n}\n\nlet myColor = yourColor switch? {\n\t.Blue :  .Reds\n\t.Green: .Blue \n\t.Red: .Green\n\tdefault: .Yellow\n}\n\nlet myColor = condition if?  { .Blue; .Red }\n\nI don’t find that looks bad. \n\n- Paul \n\n\n> On Dec 6, 2015, at 12:24 PM, Alex Lew via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> Thanks for the feedback, Matthew. It's sensible to me to consider dropping the ternary operator. I like it because the analogy \"C's if is to Swift's if as C's ternary operator is to Swift's ternary operator\" is (sort of) satisfied. But it is also confusing, both for the reasons you mention, and because ? has other meanings in Swift:\n> \n>  // compiler error without space betw thatColor and ?\n> let thisColor = thatColor? \n>      case .Red: .Green\n>      default: .Blue\n> \n> On the other hand, is it really worth it to have control flow expressions if they don't let your code look nicer?\n> \n> let thisColor = switch thatColor {\n>      case .Red:\n>           return .Green;\n>      default:\n>           return .Yellow;\n> }\n> \n> really isn't much nicer than\n> \n> let thisColor: Color\n> switch thatColor {\n>      case .Red:\n>           thisColor = .Green\n>      default:\n>           thisColor = .Yellow\n> }\n> \n> Maybe we could do a compromise, something like\n> \n> let thisColor = switch thatColor\n>      case .Red: .Green // must be an expression\n>      default: .Yellow      // must be an expression\n> \n> Or we could introduce a new keyword? Like match:\n> \n> let thisColor = match thatColor\n>       case .Red: .Green    // must be an expression\n>       default: .Yellow         // must be an expression\n> \n> \n> I sort of like the new-keyword approach, because even though this is similar to a switch, it's not a switch: there's no fallthrough, you can't put statements inside, etc.\n> \n> The problem with all these proposals:\n> \n> let thisColor = match thatColor\n>      case .Red: match thatOtherColor\n>                            case .Blue: .Green\n>                            case .Pink: .Yellow\n>                            default: .Orange\n>      default: .Orange\n> \n> is ambiguous. (Does case .Pink match thatColor or thatOtherColor? We can know because of exhaustiveness checking, but this won't always work.) You could solve this problem either by using parentheses around the whole expression when necessary\n> \n> let thisColor = match thatColor\n>      case .Red: (match thatOtherColor\n>                            case .Blue: .Green\n>                            case .Pink: .Yellow\n>                            default: .Orange)\n>      default: .Orange\n> \n> or by adding curly braces in again\n> \n> let thisColor = match thatColor {\n>      case .Red: match thatOtherColor {\n>                            case .Blue: .Green\n>                            case .Pink: .Yellow\n>                            default: .Orange\n>                         }\n>      default: .Orange\n> }\n> \n> But that starts to look like switch again. (Of course, the best way to handle this is as a programmer is to just switch on the tuple (thatColor, thatOtherColor), but the language should allow for nested control expressions.)\n> \n> \n> On Sun, Dec 6, 2015 at 2:48 PM, Matthew Johnson via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n> I am not a fan of this approach based on the ternary operator.  The ternary operator is already a bit of an anomaly in that all other operators are unary or binary and do not perform any control flow (beyond possibly short circuiting an autoclosure argument).\n> \n> I would much rather features that perform control flow continue to use keywords, but allow them to be expressions.  \n> \n> Once we have control flow expressions I would like to see the ternary operator removed from the language as it would no longer server a purpose.  Removing the ternary operator seems to fit nicely with the direction to remove some features that are carried over from C-based languages but don’t necessarily fit with the direction Swift is heading.\n> \n> \n>> On Dec 6, 2015, at 1:19 PM, Kevin Lundberg via swift-evolution < swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>> \n>> Ostensibly, case may not be necessary if you could delimit each case on one line with something (perhaps a comma, or something else if that would not fit well within the grammar): \n>>  \n>> let thisColor = thatColor ? .Blue: .Red, .Green: .Blue, .Red: .Green, default: .Yellow \n>>  \n>> On Sun, Dec 6, 2015, at 01:57 PM, Paul Ossenbruggen via swift-evolution wrote: \n>>> I like this too, seems more powerful.  Also, would single line expressions be allowed?  If not would case be required for example: \n>>>  \n>>> let myFavoriteColor = yourFavoriteColor ? \n>>>     case .Blue: .Red \n>>>     case .Green: .Blue \n>>>     case .Red: .Green \n>>>     default: .Yellow \n>>>  \n>>>  \n>>>> On Dec 6, 2015, at 9:11 AM, Sean Heber via swift-evolution < swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote: \n>>>>  \n>>>> I really like this train of thought. +1 \n>>>>  \n>>>> l8r \n>>>> Sean \n>>>>  \n>>>> On Dec 6, 2015, at 11:02 AM, Alex Lew via swift-evolution < swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote: \n>>>>> What if we left the if { ...} else { ... } syntax alone (as a statement), and updated the ternary expression to be a more general pattern matching expression (closer to \"switch\")? Something like \n>>>>>  \n>>>>> let x = condition ? \n>>>>>    true: \"Hello\" \n>>>>>    false: \"Goodbye\" \n>>>>>  \n>>>>> let x = optionalValue ? \n>>>>>    .Some(let unwrapped): \"Hello, \\(unwrapped)\" \n>>>>>    .None: \"To Whom It May Concern\" \n>>>>>  \n>>>>> let myFavoriteColor = yourFavoriteColor ? \n>>>>>     .Blue: .Red \n>>>>>     .Green: .Blue \n>>>>>     .Red: .Green \n>>>>>  \n>>>>> let quadrant = (x, y) ? \n>>>>>     let (x, y) where x < 50 && y < 50: \"top left\" \n>>>>>     let (x, y) where x < 50 && y > 50: \"bottom left\" \n>>>>>     let (x, y) where x > 50 && y < 50: \"top right\" \n>>>>>     default: \"bottom right\" \n>>>>>  \n>>>>> The colon comes from the fact that this is sort of a light-weight expression-based \"switch\" statement, where each branch can only contain an expression, not a series of statements. \n>>>>>  \n>>>>> This is very similar to pattern matching expressions in languages like Haskell, ML, and Coq. \n>>>>>  \n>>>>> On Sun, Dec 6, 2015 at 11:25 AM, Thorsten Seitz <thorsten.seitz at web.de <mailto:thorsten.seitz at web.de>> wrote: \n>>>>>  \n>>>>>> Am 06.12.2015 um 01:28 schrieb Alex Lew via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>>: \n>>>>>>  \n>>>>>> I don't think you can just get rid of the if statement in favor of an expression. You still want to be able to do this: \n>>>>>>  \n>>>>>> if (condition) { \n>>>>>>     funcWithSideEffectsThatReturnsInt() \n>>>>>> } else { \n>>>>>>     funcWithSideEffectsThatReturnsString() \n>>>>>> } \n>>>>>>  \n>>>>>> but that's not a valid expression (what is its type?). \n>>>>>  \n>>>>>  \n>>>>> That would actually be no problem if Swift’s type system would have union types (Ceylon has union and intersection types which are quite awesome and enable lots of nice things quite naturally, see http://ceylon-lang.org/documentation/1.2/tour/types/ <http://ceylon-lang.org/documentation/1.2/tour/types/>). \n>>>>>  \n>>>>> In that case the type of such an expression would just be the union of both types, which is written Int | String in Ceylon. \n>>>>>  \n>>>>>  \n>>>>> -Thorsten \n>>>>>  \n>>>>>  \n>>>>>  \n>>>>> \n>>>>> _______________________________________________ \n>>>>> swift-evolution mailing list \n>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org> \n>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution> \n>>>> _______________________________________________ \n>>>> swift-evolution mailing list \n>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org> \n>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution> \n>>> \n>>> \n>>> _______________________________________________ \n>>> swift-evolution mailing list \n>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org> \n>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution> \n>>  \n>> _______________________________________________ \n>> swift-evolution mailing list \n>> swift-evolution at swift.org <mailto:swift-evolution at swift.org> \n>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution> \n> \n> Untracked with Trackbuster <https://trackbuster.com/?sig>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n> \n> \n>  _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000640.html" , "inReplyTo" : "CAKCGC8AVDe6W9X=XvFEnbkae8xom2Us8xczKFShqKu2+kPnRJA@mail.gmail.com" , "date" : { "$date" : 1449434810000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com" , "CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com" , "C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com" , "18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com" , "2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io" , "BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com" , "CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com" , "CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com" , "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com" , "BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com" , "909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net" , "0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com" , "49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net" , "CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com" , "49EEA2E6-55F2-49DE-A59F-A13017626370@web.de" , "CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com" , "4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com" , "1449429569.1342623.459603529.32C935BC@webmail.messagingengine.com" , "11462DA4-ACDD-4CF3-BD57-47886B655970@anandabits.com" , "CAKCGC8AVDe6W9X=XvFEnbkae8xom2Us8xczKFShqKu2+kPnRJA@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/C19956A6-C9B2-45CC-8C91-DA2215EBEA5C@alkaline-solutions.com"}} , "_id" : "C19956A6-C9B2-45CC-8C91-DA2215EBEA5C@alkaline-solutions.com" , "from" : "david at alkaline-solutions.com (David Waite)" , "mailingList" : "swift-evolution" , "content" : "To cope with the pattern matching cases, I would say that reswitch either has to:\n1. Be limited specifically to a switch without pattern matching or enum values with associated data (such as Optional.Some). This would likely need to go beyond the limitations on fall through, which only limit value-binding patterns\n2. Use instead of trying to treat the value of a reswitch as a label, treat it as a expression to re-execute the switch statement over:\n\nswitch(optionalThing) {\ncase .None:\n\tprint(“assuming default value”)\t\n\treswitch “default”\ncase .Some(let str):\n\tprint(“processing value \\(str)”);\n}\n\nThis does however have non-intuitive behavior - when the second case statement is hit, “str\" is no longer equal to \"optionalThing!”. For that reason, one might find it clearer to require an explicit reassignment, effectively treating the switch as a loop: \n\nswitch(optionalThing) {\ncase .None:\n\tprint(“assuming default value”)\t\n\toptionalThing = “default”\n\treswitch\ncase .Some(let str):\n\tprint(“processing value \\(str)”);\n}\n\nThe existing “continue” keyword seems a poor choice to recycle for this purpose; “repeat” or “retry” might be more appropriate than “reswitch\"\n\n-DW\n\n> On Dec 6, 2015, at 1:06 PM, Jacopo Andrea Giola via swift-evolution <swift-evolution at swift.org> wrote:\n> \n>  Hi Colin,\n> \n> the initial proposal was indeed to remove entirely the `fallthrough` keyword but many people expressed your similar concern and from that point the discussion was steered through an \"enhancement\" and better refinement of the keyword.\n> \n> The new idea is to substitute the old keyword with \"reswitch\" passing the desired new value on which the switch is applied.\n> So something like this:\n> \n> switch (enum) {\n> \tcase .One:\n> \t\t// do something\n> \t\treswitch .Two\n> \tcase .Two:\n> \t\t// do something else\n> \tdefault:\n> \t\t// and so one\n> }\n> \n> This new behaviour, IMO, is better suited for Swift because is more declarative of the developer intent and doesn't carry over unintentional misbehaviour.\n> Is more declarative because you are forced to state in which case you want to go, and even if the order of the switch’ cases will change in the future, you don't fall in the wrong case by mistake.\n> \n> switch (enum) {\n> \tcase .One:\n> \t\t// do something\n> \t\treswitch .Two\n> \tcase .OneAndAHalf\n> \t\t// maybe this change is not made by you but by a messed up merge\n> \tcase .Two:\n> \t\t// do something else\n> \tdefault:\n> \t\t// and so one\n> }\n> \n> In this case if you are using the fallthrough keyboard your code is now broken by accident, and depending on what are you trying to do inside the cases you can have a hidden bug that your tests are not seeing right away. \n> \n> Another advantage is that in this way you can made more cases fallthrough in the same one even if they are not one over each other\n> \n> switch (enum) {\n> \tcase .One:\n> \t\t// do something\n> \t\treswitch .Two\n> \tcase .OneAndAHalf\n> \t\t// so something that you don’t want to do for .One\n> \t\treswitch .Two\n> \tcase .Two:\n> \t\t// do something else that you may want to do for .One and .Two\n> \tdefault:\n> \t\t// and so one\n> }\n> \n> I must say that this is a side effect that can be used to messed up the code flow in a way that is not intended, but is a new behaviour that gives more power to the switch statement.\n> \n> The reswitch keyword in addition is not a mere fallthrough on the new case without doing the optional checking attached to it, but is intended to be a new call and all the check are executed.\n> \n> switch (enum) {\n> \tcase .One:\n> \t\t// do something\n> \t\tx = 0;\n> \t\treswitch .Two\n> \tcase .OneAndAHalf\n> \t\t// so something that you don’t want to do for .One\n> \t\treswitch .Two\n> \tcase .Two where x > 0:\n> \t\t// do something else that you may want to do for .One and .Two\n> \t\telement = array[x]\n> \tdefault:\n> \t\t// and so one\n> }\n> (I’m going by memory and by writing this snippets in the mail app directly, so the code must be incorrect in the syntax and for this I’m sorry).\n> \n> In this case if enum is .One the only case that is executed is case .One and the code doesn’t fallthrough in the .Two case because we are made the where invalid by changing the x to a value less than 1.\n> \n> Now I don’t remember who was the first one who mede this proposal, and I don’t know if he is working on a first draft to lay down the things better, but for me this can be a nice improvement and a neat break with the C-switch behaviour that Swift has trying to change from the very first beta disallowing the implicit fallthrough.\n> \n> I can be completely wrong but I see the `fallthrough`keyword as a “temporary” implementation for ease the transition from Obj-C to Swift and is time to improve it and made the switch statement even more powerful.\n> \n> - Jacopo\n> Sent from my iPad\n> \n> On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n> \n>> tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.\n>> \n>> Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.\n>> \n>> I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)\n>> \n>> Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:\n>> \n>> https://gist.github.com/cbarrett/23b24a9fe76efdf006df <https://gist.github.com/cbarrett/23b24a9fe76efdf006df>\n>> \n>> This technique is very extensible — for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.\n>> \n>> Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type — low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.\n>> \n>> Thanks,\n>> -Colin\n>> \n>>> On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>> \n>>> +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.\n>>> \n>>> If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don't introduce an infinite \"switch\" loop.\n>>> \n>>> Sent from my iPad\n>>> \n>>> On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>> \n>>>> Very much thinking out loud and not really the implications, I wonder if we might just use \"continue\" instead of \"reswitch\".\n>>>> \n>>>> I very much like specifying what case to fall through into, no matter how we spell it.\n>>>> \n>>>> - Steve\n>>>> \n>>>> On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>>> \n>>>>>> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>>>>>> On Dec 4, 2015, at 11:37 PM, John Calsbeek <john.calsbeek+lists at gmail.com <mailto:john.calsbeek+lists at gmail.com>> wrote:\n>>>>>>> `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.\n>>>>>>> \n>>>>>>> It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.\n>>>>>> \n>>>>>> Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.\n>>>>>> \n>>>>>> On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.\n>>>>> \n>>>>> Oh, I see that Joe already brought this up, spelled “reswitch”.\n>>>>> \n>>>>> John.\n>>>>> \n>>>>>> \n>>>>>> John.\n>>>>>> \n>>>>>>> \n>>>>>>> One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).\n>>>>>>> \n>>>>>>> switch op {\n>>>>>>> case LOAD_INDIRECT:\n>>>>>>>    in0 = memory[in1]\n>>>>>>>    fallthrough\n>>>>>>> case LOAD:\n>>>>>>>    out0 = memory[in0]\n>>>>>>> //...\n>>>>>>> }\n>>>>>>> \n>>>>>>> I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.\n>>>>>>> \n>>>>>>> Cheers,\n>>>>>>> John\n>>>>>>> \n>>>>>>>> On Dec 4, 2015, at 2:42 PM, John McCall <rjmccall at apple.com <mailto:rjmccall at apple.com>> wrote:\n>>>>>>>> \n>>>>>>>>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard <kevin at sb.org <mailto:kevin at sb.org>> wrote:\n>>>>>>>>> It's not actually Duff's Device. Duff's Device relies on the fact that C switch statements don't actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it's a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.\n>>>>>>>> \n>>>>>>>> To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.\n>>>>>>>> \n>>>>>>>> But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.\n>>>>>>>> \n>>>>>>>> John.\n>>>>>>>> \n>>>>>>>>>  \n>>>>>>>>> Steve's code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It's a good example of one of the uses of `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's Device in Swift.\n>>>>>>>>>  \n>>>>>>>>> -Kevin Ballard\n>>>>>>>>>  \n>>>>>>>>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:\n>>>>>>>>>> Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.\n>>>>>>>>>>  \n>>>>>>>>>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:\n>>>>>>>>>>>  \n>>>>>>>>>>> Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it. \n>>>>>>>>>>>  \n>>>>>>>>>>> True fact: On all of gist.github.com <http://gist.github.com/>, there are only 22 gist results for \"fallthrough language:swift\".\n>>>>>>>>>>> Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:\n>>>>>>>>>>> case .Enum1, .Enum2:\n>>>>>>>>>>> expressed as \n>>>>>>>>>>> case .Enum1: fallthrough\n>>>>>>>>>>> case .Enum2:\n>>>>>>>>>>>  \n>>>>>>>>>>> And then there's streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea <https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea>   I'm pretty sure that ponies were harmed in the production of whatever that last bit is.\n>>>>>>>>>>>  \n>>>>>>>>>>>  \n>>>>>>>>>>>  \n>>>>>>>>>>>  \n>>>>>>>>>>>> On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com <mailto:jalkut at red-sweater.com> wrote:\n>>>>>>>>>>>>  \n>>>>>>>>>>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the \"fallthrough\" keyword from the language?\n>>>>>>>>>>>>  \n>>>>>>>>>>>> My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.\n>>>>>>>>>>>>  \n>>>>>>>>>>>> The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:\n>>>>>>>>>>>>  \n>>>>>>>>>>>> \"The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.\"\n>>>>>>>>>>>>  \n>>>>>>>>>>>> To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.\n>>>>>>>>>>>>  \n>>>>>>>>>>>> I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.\n>>>>>>>>>>>>  \n>>>>>>>>>>>> In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.\n>>>>>>>>>>>>  \n>>>>>>>>>>>> Thoughts?\n>>>>>>>>>>>>  \n>>>>>>>>>>>> Daniel\n>>>>>>>>>>>>  \n>>>>>>>>>>>> _______________________________________________\n>>>>>>>>>>>> swift-evolution mailing list\n>>>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>>>>>>>> \n>>>>>>>>>>>  \n>>>>>>>>>>> \n>>>>>>>>>>> _______________________________________________\n>>>>>>>>>>> swift-evolution mailing list\n>>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>>>>>>> \n>>>>>>>>>>  \n>>>>>>>>>> \n>>>>>>>>>> _______________________________________________\n>>>>>>>>>> swift-evolution mailing list\n>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>>>>>>  \n>>>>>>>>> \n>>>>>>>>> _______________________________________________\n>>>>>>>>> swift-evolution mailing list\n>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>>>>> \n>>>>>>>>  _______________________________________________\n>>>>>>>> swift-evolution mailing list\n>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>>>> _______________________________________________\n>>>>>>> swift-evolution mailing list\n>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>>> \n>>>>>> _______________________________________________\n>>>>>> swift-evolution mailing list\n>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>> \n>>>>> _______________________________________________\n>>>>> swift-evolution mailing list\n>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>> _______________________________________________\n>>>> swift-evolution mailing list\n>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>> \n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>  _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000641.html" , "inReplyTo" : "CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org" , "date" : { "$date" : 1449434885000} , "subject" : "[swift-evolution] Proposal: Remove the \"fallthrough\" keyword" , "references" : [ "3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com" , "AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com" , "8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com" , "1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com" , "02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com" , "E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com" , "444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com" , "EF1675F6-7918-4262-B535-696104BFC405@apple.com" , "CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com" , "D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org" , "071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com" , "CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org"] , "descendants" : [ "2423784D-3B84-41CE-9BE2-0850BFE5A3C0@apple.com" , "DEBE0A49-3E5A-431F-8559-63EBA7214068@jacopo.giola.org"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAPh90aE1m68_kDFqOGuO-u6qP3WKtqSJS9XMU-KKrO0N3yV0kg@mail.gmail.com"}} , "_id" : "CAPh90aE1m68_kDFqOGuO-u6qP3WKtqSJS9XMU-KKrO0N3yV0kg@mail.gmail.com" , "from" : "ilya.nikokoshev at gmail.com (ilya)" , "mailingList" : "swift-evolution" , "content" : "I applaud honest description of drawbacks in the proposal :)\n\nThere examples given, I think, demonstrate that using self without any\nspecial access leads to unresolvable ambiguities.\n\nIf one wants to work \"inside\" the configured object, this seems like a good\njob for a private initializer. All of the ambiguities will be resolved,\nbecause extracting the init away removes its ability to capture names from\nthe local context.\n\nAlternatively, I think it makes sense to continue working on configuration\nsyntax, with \"default\" access to local context and \"explicit\" access to the\nobject. Let's just replace $0 with something else.\n\nHopefully I don't sounds too pessimistic. Erica's proposal looks going in\nthe right direction to me.\nOn Sun, Dec 6, 2015 at 23:30 Erica Sadun via swift-evolution <\nswift-evolution at swift.org> wrote:\n\n> It's probably better at this point for me to collect my thoughts and\n> summarize where I am at.\n>\n> https://gist.github.com/erica/eb32feb22ba99629285a\n>\n> Please feel free to comment on-list about this proposal (github does not\n> forward comment alerts) and\n> then I will start a new list thread as a Proposal rather than as a Request\n> for Discussion.\n>\n> Best,\n>\n> -- E\n>\n>\n> On Dec 6, 2015, at 12:45 PM, ilya <ilya.nikokoshev at gmail.com> wrote:\n>\n> Sorry, did I misunderstand the question?\n>\n> Did you asked whether my definition will work for immutable value types?\n> If that's the question, the answer is still yes, the link has an example\n> :)\n>\n> On Sun, Dec 6, 2015 at 10:43 PM, Erica Sadun <erica at ericasadun.com> wrote:\n>\n>> I was specifically referring to value types. I apologize for not being\n>> clearer.\n>>\n>> -- E\n>>\n>>\n>> On Dec 6, 2015, at 12:42 PM, ilya <ilya.nikokoshev at gmail.com> wrote:\n>>\n>> Yes, it works for immutable objects with the correct definition, see the\n>> playground contents at\n>> https://github.com/ilyannn/iOS-Swift-Materials/blob/master/Playgrounds/Configure.playground/Contents.swift\n>>\n>> On Sun, Dec 6, 2015 at 8:10 PM, Erica Sadun <erica at ericasadun.com> wrote:\n>>\n>>> I have developed something similar as well (\n>>> http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/\n>>> ).\n>>>\n>>> Is yours capable of handling enums and structs that would otherwise be\n>>> let after declaration because mine is not.\n>>>\n>>> -- E\n>>>\n>>>\n>>> On Dec 5, 2015, at 5:16 PM, ilya via swift-evolution <\n>>> swift-evolution at swift.org> wrote:\n>>>\n>>> > PROBLEM: With many Apple-supplied classes, typical initializers fail\n>>> to fully set up an instance for use.  Here's one example: ...\n>>>\n>>> FWIW, I created a configuration operator more then a year ago, and use\n>>> it in all of my Swift projects:\n>>>\n>>> let task = NSTask() +=+ {\n>>>     $0.launchPath = \"/usr/bin/mdfind\"\n>>>     $0.arguments = [\"kMDItemDisplayName == *.playground\"]\n>>>     $0.standardOutput = pipe\n>>> }\n>>>\n>>> Note you can also use the configured object in the rhs:\n>>>\n>>> let questionLabel = UILabel() +=+ {\n>>>     $0.textAlignment = .Center\n>>>     $0.font =  UIFont(name:\"DnealianManuscript\", size: 72)\n>>>     $0.text = currentQuestion.questionText\n>>>     $0.numberOfLines = 0\n>>>     view.addSubview($0)\n>>> }\n>>>\n>>> This $0. certainly looks ugly and it would be great to be able to\n>>> simplify this. I don't llike the following much though (dot-syntax can be\n>>> ambiguos here, and using simply a method name is even worse):\n>>>\n>>> let questionLabel = UILabel() +=+ {\n>>>     .textAlignment = .Center\n>>>     .font =  UIFont(name:\"DnealianManuscript\", size: 72)\n>>>     .text = currentQuestion.questionText\n>>>     .numberOfLines = 0\n>>>     view.addSubview($0)\n>>> }\n>>>\n>>> Actually I would be happy with something like\n>>>\n>>> let questionLabel = UILabel() .{\n>>>     ..textAlignment = .Center\n>>>     ..font = UIFont(name:\"DnealianManuscript\", size: 72)\n>>>     ..text = currentQuestion.questionText\n>>>     ..numberOfLines = 0\n>>>     view.addSubview($0)\n>>> }\n>>>\n>>> Other thoughts?\n>>>\n>>>\n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>\n>>>\n>>>\n>>\n>>\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000642.html" , "inReplyTo" : "DD7C743B-5E22-4603-AA6A-AF3F75B4DE62@ericasadun.com" , "date" : { "$date" : 1449434926000} , "subject" : "[swift-evolution] Request for Discussion: Setup closures" , "references" : [ "CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com" , "8837F311-F6F8-462E-90E0-88981C537EFD@ericasadun.com" , "CAPh90aEHX5aWQOnpkDJxeTt3DXOH6Xdqq1BXYVr_tvB63QKx1g@mail.gmail.com" , "F757A1B0-69AA-40E0-BB72-9A043CE6D93D@ericasadun.com" , "CAPh90aHJuiYVOPu+9poXapDq9q4dzYAnS=fm3ke1ODz3neheOg@mail.gmail.com" , "DD7C743B-5E22-4603-AA6A-AF3F75B4DE62@ericasadun.com"] , "descendants" : [ "F833B947-4FFD-485E-912A-31B50140660F@anandabits.com" , "F6635EA0-2342-451E-8675-FF1819BD715C@anandabits.com" , "2F1E045F-3242-4943-9471-B40D6B476C97@anandabits.com" , "35BE2387-2F9C-491F-B71F-1635243ABADA@ericasadun.com" , "38E11489-CE79-4690-8567-98FD7793B4FF@gmail.com" , "159233D0-A835-4435-840E-A9594DDCA37D@ericasadun.com" , "CAKCGC8AOx_ffGe1AjpQJt9ULr3zwTBsnphJCht92se7-Hfi_+g@mail.gmail.com" , "DC82287B-4583-47F3-9389-B756C91436F5@alkaline-solutions.com" , "CC9D9491-212A-4D20-8CC2-34FD984F6463@portableinnovations.de" , "EF05B911-5728-47F4-AB13-F960FF2B21A4@portableinnovations.de" , "F379B44A-9B6F-47BD-95B0-9FC795BC035B@architechies.com" , "BB9D9FE2-F252-41F4-A3EA-2D8053A7579C@gmx.de" , "1F3D7F58-0EC6-4541-9734-A95CE62BAF6E@anandabits.com" , "2139FFE7-79C5-4981-A036-250F2D5EF0A4@ericasadun.com" , "24FE9022-00E3-459C-8A71-540BCF436286@apple.com" , "E904EA6A-6422-49F6-9C5E-07BCDC7D3543@gmx.de" , "98A80B8C-AC32-408D-AD8F-CDE0EB782B4C@apple.com" , "03F8648F-236A-46A5-8D21-CA066DBA1932@anandabits.com" , "D49345E8-5E22-46C8-9EF2-EF0DB4D32D87@apple.com" , "77AE5195-4E57-4814-A228-AF23723C853B@ericasadun.com" , "B818E6F9-1526-4725-BCDA-AB8C36F3CED7@maven.de" , "6A18AB5F-3794-42A6-8142-AAA7B2B61000@apple.com" , "9520AAC7-B49D-4CB7-96EE-E9891BAC9268@ericasadun.com" , "5981B70E-98D3-4A99-AF49-106254DFEB54@apple.com" , "86e837d7-cac3-438b-8297-4f6f401b641f@Spark" , "315B39D9-AE33-438B-8EFF-CC4796EECAAF@pobox.com" , "731CB499-F42F-45D4-8A3B-8D7B963D3709@monod-broca.fr" , "CADcs6kNOmo32YcBHOjmsV3eKiJ4yo0nDxz+5mjWNtp3JG0FsOA@mail.gmail.com" , "616C48D0-D626-487E-861C-CF125879BABB@ericasadun.com" , "3A77268A-D52E-4821-9488-671491506835@monod-broca.fr" , "B5AE3C08-FB9F-4024-B6BF-ECAADC1196E8@pobox.com" , "52D7FF3E-4E16-447D-AFCF-6915ABF999C1@gmx.de" , "98E5A56D-2912-4725-8E5E-14F25153B184@gmx.de" , "3C9B366C-D4A8-4777-8CF9-E46B52F806E2@pobox.com" , "0674FFD1-76FB-4376-9F34-0FF8B7560798@anandabits.com" , "5B0D18B8-0255-4F2E-86E3-253058585BDB@fifthace.com" , "512C0649-506C-41B3-BBB9-BBF6B80437FE@ericasadun.com" , "CADcs6kOfPJ73WdN-UHTZAPs7Zx_MmSUjrKy6r=EMphLdGfti8w@mail.gmail.com" , "ED9A9872-62B4-4957-B708-94F3015365C5@alkaline-solutions.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com"}} , "_id" : "6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com" , "from" : "colin at springsandstruts.com (Colin Barrett)" , "mailingList" : "swift-evolution" , "content" : "Apologies, Jacopo, for missing the updated proposal, and thank you for your patience in summarizing it again.\n\nI’ve only glanced through it but my concern here is that it introduces a whole class of new and creative “foot-guns\" :) In particular, it allows this construction to loop arbitrarily and creatively, particularly in the case of associated values.\n\nI’m not sure why not checking the case statement is considered a problem for the fallthrough keyword. Assuming it’s impossible to fallthrough to a case that introduces binders (what would they be bound to?), and that this is statically checked (both of which seem reasonable assumptions to me, although if I’m wrong feel free to correct me), isn’t it the entire point of the fallthrough keyword that it skips checking the case statement? I can understand how that might be somewhat confusing (and perhaps it should be documented less prominently) but I’m not sure how it’s a *problem*, exactly...\n\nI think I’m still on the side of keeping fallthrough. What’s the downside of doing nothing? For instance in the case of ++ and -- those features complicate the design of a numerics library.\n\nThanks,\n-Colin\n\n> On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola <swift-evolution at jacopo.giola.org> wrote:\n> \n>  Hi Colin,\n> \n> the initial proposal was indeed to remove entirely the `fallthrough` keyword but many people expressed your similar concern and from that point the discussion was steered through an \"enhancement\" and better refinement of the keyword.\n> \n> The new idea is to substitute the old keyword with \"reswitch\" passing the desired new value on which the switch is applied.\n> So something like this:\n> \n> switch (enum) {\n> \tcase .One:\n> \t\t// do something\n> \t\treswitch .Two\n> \tcase .Two:\n> \t\t// do something else\n> \tdefault:\n> \t\t// and so one\n> }\n> \n> This new behaviour, IMO, is better suited for Swift because is more declarative of the developer intent and doesn't carry over unintentional misbehaviour.\n> Is more declarative because you are forced to state in which case you want to go, and even if the order of the switch’ cases will change in the future, you don't fall in the wrong case by mistake.\n> \n> switch (enum) {\n> \tcase .One:\n> \t\t// do something\n> \t\treswitch .Two\n> \tcase .OneAndAHalf\n> \t\t// maybe this change is not made by you but by a messed up merge\n> \tcase .Two:\n> \t\t// do something else\n> \tdefault:\n> \t\t// and so one\n> }\n> \n> In this case if you are using the fallthrough keyboard your code is now broken by accident, and depending on what are you trying to do inside the cases you can have a hidden bug that your tests are not seeing right away. \n> \n> Another advantage is that in this way you can made more cases fallthrough in the same one even if they are not one over each other\n> \n> switch (enum) {\n> \tcase .One:\n> \t\t// do something\n> \t\treswitch .Two\n> \tcase .OneAndAHalf\n> \t\t// so something that you don’t want to do for .One\n> \t\treswitch .Two\n> \tcase .Two:\n> \t\t// do something else that you may want to do for .One and .Two\n> \tdefault:\n> \t\t// and so one\n> }\n> \n> I must say that this is a side effect that can be used to messed up the code flow in a way that is not intended, but is a new behaviour that gives more power to the switch statement.\n> \n> The reswitch keyword in addition is not a mere fallthrough on the new case without doing the optional checking attached to it, but is intended to be a new call and all the check are executed.\n> \n> switch (enum) {\n> \tcase .One:\n> \t\t// do something\n> \t\tx = 0;\n> \t\treswitch .Two\n> \tcase .OneAndAHalf\n> \t\t// so something that you don’t want to do for .One\n> \t\treswitch .Two\n> \tcase .Two where x > 0:\n> \t\t// do something else that you may want to do for .One and .Two\n> \t\telement = array[x]\n> \tdefault:\n> \t\t// and so one\n> }\n> (I’m going by memory and by writing this snippets in the mail app directly, so the code must be incorrect in the syntax and for this I’m sorry).\n> \n> In this case if enum is .One the only case that is executed is case .One and the code doesn’t fallthrough in the .Two case because we are made the where invalid by changing the x to a value less than 1.\n> \n> Now I don’t remember who was the first one who mede this proposal, and I don’t know if he is working on a first draft to lay down the things better, but for me this can be a nice improvement and a neat break with the C-switch behaviour that Swift has trying to change from the very first beta disallowing the implicit fallthrough.\n> \n> I can be completely wrong but I see the `fallthrough`keyword as a “temporary” implementation for ease the transition from Obj-C to Swift and is time to improve it and made the switch statement even more powerful.\n> \n> - Jacopo\n> Sent from my iPad\n> \n> On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n> \n>> tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.\n>> \n>> Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.\n>> \n>> I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)\n>> \n>> Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:\n>> \n>> https://gist.github.com/cbarrett/23b24a9fe76efdf006df <https://gist.github.com/cbarrett/23b24a9fe76efdf006df>\n>> \n>> This technique is very extensible — for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.\n>> \n>> Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type — low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.\n>> \n>> Thanks,\n>> -Colin\n>> \n>>> On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>> \n>>> +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.\n>>> \n>>> If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don't introduce an infinite \"switch\" loop.\n>>> \n>>> Sent from my iPad\n>>> \n>>> On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>> \n>>>> Very much thinking out loud and not really the implications, I wonder if we might just use \"continue\" instead of \"reswitch\".\n>>>> \n>>>> I very much like specifying what case to fall through into, no matter how we spell it.\n>>>> \n>>>> - Steve\n>>>> \n>>>> On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>>> \n>>>>>> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>>>>>> On Dec 4, 2015, at 11:37 PM, John Calsbeek <john.calsbeek+lists at gmail.com <mailto:john.calsbeek+lists at gmail.com>> wrote:\n>>>>>>> `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.\n>>>>>>> \n>>>>>>> It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.\n>>>>>> \n>>>>>> Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.\n>>>>>> \n>>>>>> On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.\n>>>>> \n>>>>> Oh, I see that Joe already brought this up, spelled “reswitch”.\n>>>>> \n>>>>> John.\n>>>>> \n>>>>>> \n>>>>>> John.\n>>>>>> \n>>>>>>> \n>>>>>>> One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).\n>>>>>>> \n>>>>>>> switch op {\n>>>>>>> case LOAD_INDIRECT:\n>>>>>>>    in0 = memory[in1]\n>>>>>>>    fallthrough\n>>>>>>> case LOAD:\n>>>>>>>    out0 = memory[in0]\n>>>>>>> //...\n>>>>>>> }\n>>>>>>> \n>>>>>>> I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.\n>>>>>>> \n>>>>>>> Cheers,\n>>>>>>> John\n>>>>>>> \n>>>>>>>> On Dec 4, 2015, at 2:42 PM, John McCall <rjmccall at apple.com <mailto:rjmccall at apple.com>> wrote:\n>>>>>>>> \n>>>>>>>>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard <kevin at sb.org <mailto:kevin at sb.org>> wrote:\n>>>>>>>>> It's not actually Duff's Device. Duff's Device relies on the fact that C switch statements don't actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it's a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.\n>>>>>>>> \n>>>>>>>> To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.\n>>>>>>>> \n>>>>>>>> But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.\n>>>>>>>> \n>>>>>>>> John.\n>>>>>>>> \n>>>>>>>>>  \n>>>>>>>>> Steve's code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It's a good example of one of the uses of `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's Device in Swift.\n>>>>>>>>>  \n>>>>>>>>> -Kevin Ballard\n>>>>>>>>>  \n>>>>>>>>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:\n>>>>>>>>>> Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.\n>>>>>>>>>>  \n>>>>>>>>>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:\n>>>>>>>>>>>  \n>>>>>>>>>>> Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it. \n>>>>>>>>>>>  \n>>>>>>>>>>> True fact: On all of gist.github.com <http://gist.github.com/>, there are only 22 gist results for \"fallthrough language:swift\".\n>>>>>>>>>>> Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:\n>>>>>>>>>>> case .Enum1, .Enum2:\n>>>>>>>>>>> expressed as \n>>>>>>>>>>> case .Enum1: fallthrough\n>>>>>>>>>>> case .Enum2:\n>>>>>>>>>>>  \n>>>>>>>>>>> And then there's streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea <https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea>   I'm pretty sure that ponies were harmed in the production of whatever that last bit is.\n>>>>>>>>>>>  \n>>>>>>>>>>>  \n>>>>>>>>>>>  \n>>>>>>>>>>>  \n>>>>>>>>>>>> On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com <mailto:jalkut at red-sweater.com> wrote:\n>>>>>>>>>>>>  \n>>>>>>>>>>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the \"fallthrough\" keyword from the language?\n>>>>>>>>>>>>  \n>>>>>>>>>>>> My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.\n>>>>>>>>>>>>  \n>>>>>>>>>>>> The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:\n>>>>>>>>>>>>  \n>>>>>>>>>>>> \"The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.\"\n>>>>>>>>>>>>  \n>>>>>>>>>>>> To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.\n>>>>>>>>>>>>  \n>>>>>>>>>>>> I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.\n>>>>>>>>>>>>  \n>>>>>>>>>>>> In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.\n>>>>>>>>>>>>  \n>>>>>>>>>>>> Thoughts?\n>>>>>>>>>>>>  \n>>>>>>>>>>>> Daniel\n>>>>>>>>>>>>  \n>>>>>>>>>>>> _______________________________________________\n>>>>>>>>>>>> swift-evolution mailing list\n>>>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>>>>>>>> \n>>>>>>>>>>>  \n>>>>>>>>>>> \n>>>>>>>>>>> _______________________________________________\n>>>>>>>>>>> swift-evolution mailing list\n>>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>>>>>>> \n>>>>>>>>>>  \n>>>>>>>>>> \n>>>>>>>>>> _______________________________________________\n>>>>>>>>>> swift-evolution mailing list\n>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>>>>>>  \n>>>>>>>>> \n>>>>>>>>> _______________________________________________\n>>>>>>>>> swift-evolution mailing list\n>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>>>>> \n>>>>>>>>  _______________________________________________\n>>>>>>>> swift-evolution mailing list\n>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>>>> \n>>>>>>> _______________________________________________\n>>>>>>> swift-evolution mailing list\n>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>>> \n>>>>>> \n>>>>>> _______________________________________________\n>>>>>> swift-evolution mailing list\n>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>> \n>>>>> \n>>>>> _______________________________________________\n>>>>> swift-evolution mailing list\n>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>> \n>>>> _______________________________________________\n>>>> swift-evolution mailing list\n>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>> \n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>> \n>> \n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000643.html" , "inReplyTo" : "CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org" , "date" : { "$date" : 1449435172000} , "subject" : "[swift-evolution] Proposal: Remove the \"fallthrough\" keyword" , "references" : [ "3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com" , "AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com" , "8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com" , "1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com" , "02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com" , "E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com" , "444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com" , "EF1675F6-7918-4262-B535-696104BFC405@apple.com" , "CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com" , "D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org" , "071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com" , "CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org"] , "descendants" : [ "ECE284CE-EDE3-4071-ABB6-821820F1FC44@jacopo.giola.org" , "EF9FEF97-C7B8-4D54-B406-2B62FDD15B59@springsandstruts.com" , "98973CF0-B5A8-491F-A8D0-DA73456FF01B@jacopo.giola.org" , "CAKCGC8B0UPGUHeJ_1n8XsGoo+E6Anyj_+_R7WsT76rV1Q-qu2w@mail.gmail.com" , "E7877054-1CF7-4596-800A-0D3C578A0CF1@portableinnovations.de" , "CAKCGC8Cp52O7DX6wWSc3J6FR8Xmoo_WLBgjGBa6fSXzNHhdHEg@mail.gmail.com" , "D7B06EA6-A46C-4920-9E09-CB99B96242AA@jacopo.giola.org" , "1449442122.2380087.459714713.0AC4A201@webmail.messagingengine.com" , "D9340CB2-A696-478A-BAE7-F93ED39CB2DC@red-sweater.com" , "CEA837D7-E2B1-48DC-A53B-D216F96DD8DF@apple.com" , "2A8EA416-B4FF-45B3-9C6D-F94059151129@apple.com" , "82BBEAF7-A512-460A-998C-054AE6D70BEB@springsandstruts.com" , "9C8A3DCA-B80C-4D1F-9528-DD65C0020680@apple.com" , "CAKCGC8BL6SHkO0T_Rg6Ren-NfCLs+eGBb6Zm9aFuZ5rMkWJXtQ@mail.gmail.com" , "AC2407AD-ABFF-4657-A04C-F37E52466316@springsandstruts.com" , "1449524366.1229815.460824345.0E2309C2@webmail.messagingengine.com" , "1449524552.1230499.460828169.5289846B@webmail.messagingengine.com" , "6BABB1A5-55CD-43AF-8D5D-9758F55AD611@apple.com" , "266A61BA-1890-46D7-8969-4A0225EA60B4@springsandstruts.com" , "37FA3360-5F23-462D-BE9B-3743253D2693@apple.com" , "6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org" , "A56C416E-E246-44FC-A681-3DD66171DF30@springsandstruts.com" , "CADQN+5atyJ78vi0xssjOxh2ka_-jZTaO3ZabxFdY80YqJHFmxg@mail.gmail.com" , "CAKCGC8DHCxwtiU82CjxChc6PaiB495WOCJBP0iq04uw7iWcQmA@mail.gmail.com" , "CAKCGC8DbhMOX6bHtzXQcAhjHQSw1wSSoX-TBUtew0arWA=4pSw@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAKCGC8AG8DS208+zXzu0mpjN62r1At8ro=FgjEevp-wr-5KtyA@mail.gmail.com"}} , "_id" : "CAKCGC8AG8DS208+zXzu0mpjN62r1At8ro=FgjEevp-wr-5KtyA@mail.gmail.com" , "from" : "alexl.mail+swift at gmail.com (Alex Lew)" , "mailingList" : "swift-evolution" , "content" : "Hmm. Something about braces inside expressions just feels wrong to me.\n\nI also read switch? and if? as being some optional-related versions of\nswitch and if. And I don't love putting the condition /\nvalue-to-switch-on *before\n*the keyword, if we're going to use a keyword.\n\n(Also: exhaustiveness checking *could *theoretically allow resolution of\nambiguity in nested switch expressions. We would just have to require that\nas soon as you've exhausted all possibilities, you don't add more cases and\nthe expression is over.)\n\nOn Sun, Dec 6, 2015 at 3:46 PM, Paul Ossenbruggen <possen at gmail.com> wrote:\n\n> Yep probably does need braces: So for switch? if? suggestion i just made.\n>\n> let myColor = yourColor switch? { .Blue :  .Red, .Green: .Blue, .Red:\n> .Green, default: .Yellow }\n>\n> let myColor = yourColor switch? { case .Blue : .Red; case .Green: .Blue;\n>  case .Red: .Green; default: .Yellow }\n>\n> let myColor = yourColor switch? {\n> case .Blue :  .Reds\n> case .Green: .Blue\n> case .Red: .Green\n> default: .Yellow\n> }\n>\n> let myColor = yourColor switch? {\n> .Blue :  .Reds\n> .Green: .Blue\n> .Red: .Green\n> default: .Yellow\n> }\n>\n> let myColor = condition if?  { .Blue; .Red }\n>\n> I don’t find that looks bad.\n>\n> - Paul\n>\n>\n> On Dec 6, 2015, at 12:24 PM, Alex Lew via swift-evolution <\n> swift-evolution at swift.org> wrote:\n>\n> Thanks for the feedback, Matthew. It's sensible to me to consider dropping\n> the ternary operator. I like it because the analogy \"C's if is to Swift's\n> if as C's ternary operator is to Swift's ternary operator\" is (sort of)\n> satisfied. But it is also confusing, both for the reasons you mention, and\n> because ? has other meanings in Swift:\n>\n>  // compiler error without space betw thatColor and ?\n> let thisColor = thatColor?\n>      case .Red: .Green\n>      default: .Blue\n>\n> On the other hand, is it really worth it to have control flow expressions\n> if they don't let your code look nicer?\n>\n> let thisColor = switch thatColor {\n>      case .Red:\n>           return .Green;\n>      default:\n>           return .Yellow;\n> }\n>\n> really isn't much nicer than\n>\n> let thisColor: Color\n> switch thatColor {\n>      case .Red:\n>           thisColor = .Green\n>      default:\n>           thisColor = .Yellow\n> }\n>\n> Maybe we could do a compromise, something like\n>\n> let thisColor = switch thatColor\n>      case .Red: .Green // must be an expression\n>      default: .Yellow      // must be an expression\n>\n> Or we could introduce a new keyword? Like *match*:\n>\n> let thisColor = match thatColor\n>       case .Red: .Green    // must be an expression\n>       default: .Yellow         // must be an expression\n>\n>\n> I sort of like the new-keyword approach, because even though this is\n> similar to a switch, it's not a switch: there's no fallthrough, you can't\n> put statements inside, etc.\n>\n> The problem with all these proposals:\n>\n> let thisColor = match thatColor\n>      case .Red: match thatOtherColor\n>                            case .Blue: .Green\n>                            case .Pink: .Yellow\n>                            default: .Orange\n>      default: .Orange\n>\n> is ambiguous. (Does case .Pink match thatColor or thatOtherColor? We can\n> know because of exhaustiveness checking, but this won't always work.) You\n> could solve this problem either by using parentheses around the whole\n> expression when necessary\n>\n> let thisColor = match thatColor\n>      case .Red: (match thatOtherColor\n>                            case .Blue: .Green\n>                            case .Pink: .Yellow\n>                            default: .Orange)\n>      default: .Orange\n>\n> or by adding curly braces in again\n>\n> let thisColor = match thatColor {\n>      case .Red: match thatOtherColor {\n>                            case .Blue: .Green\n>                            case .Pink: .Yellow\n>                            default: .Orange\n>                         }\n>      default: .Orange\n> }\n>\n> But that starts to look like switch again. (Of course, the best way to\n> handle this is as a programmer is to just switch on the tuple (thatColor,\n> thatOtherColor), but the language should allow for nested control\n> expressions.)\n>\n>\n> On Sun, Dec 6, 2015 at 2:48 PM, Matthew Johnson via swift-evolution <\n> swift-evolution at swift.org> wrote:\n>\n>> I am not a fan of this approach based on the ternary operator.  The\n>> ternary operator is already a bit of an anomaly in that all other operators\n>> are unary or binary and do not perform any control flow (beyond possibly\n>> short circuiting an autoclosure argument).\n>>\n>> I would much rather features that perform control flow continue to use\n>> keywords, but allow them to be expressions.\n>>\n>> Once we have control flow expressions I would like to see the ternary\n>> operator removed from the language as it would no longer server a purpose.\n>> Removing the ternary operator seems to fit nicely with the direction to\n>> remove some features that are carried over from C-based languages but don’t\n>> necessarily fit with the direction Swift is heading.\n>>\n>>\n>> On Dec 6, 2015, at 1:19 PM, Kevin Lundberg via swift-evolution <\n>> swift-evolution at swift.org> wrote:\n>>\n>> Ostensibly, case may not be necessary if you could delimit each case on\n>> one line with something (perhaps a comma, or something else if that would\n>> not fit well within the grammar):\n>>\n>> let thisColor = thatColor ? .Blue: .Red, .Green: .Blue, .Red: .Green,\n>> default: .Yellow\n>>\n>> On Sun, Dec 6, 2015, at 01:57 PM, Paul Ossenbruggen via swift-evolution\n>> wrote:\n>>\n>> I like this too, seems more powerful.  Also, would single line\n>> expressions be allowed?  If not would case be required for example:\n>>\n>> let myFavoriteColor = yourFavoriteColor ?\n>>     case .Blue: .Red\n>>     case .Green: .Blue\n>>     case .Red: .Green\n>>     default: .Yellow\n>>\n>>\n>>\n>> On Dec 6, 2015, at 9:11 AM, Sean Heber via swift-evolution <\n>> swift-evolution at swift.org> wrote:\n>>\n>> I really like this train of thought. +1\n>>\n>> l8r\n>> Sean\n>>\n>> On Dec 6, 2015, at 11:02 AM, Alex Lew via swift-evolution <\n>> swift-evolution at swift.org> wrote:\n>>\n>> What if we left the if { ...} else { ... } syntax alone (as a statement),\n>> and updated the ternary expression to be a more general pattern matching\n>> expression (closer to \"switch\")? Something like\n>>\n>> let x = condition ?\n>>    true: \"Hello\"\n>>    false: \"Goodbye\"\n>>\n>> let x = optionalValue ?\n>>    .Some(let unwrapped): \"Hello, \\(unwrapped)\"\n>>    .None: \"To Whom It May Concern\"\n>>\n>> let myFavoriteColor = yourFavoriteColor ?\n>>     .Blue: .Red\n>>     .Green: .Blue\n>>     .Red: .Green\n>>\n>> let quadrant = (x, y) ?\n>>     let (x, y) where x < 50 && y < 50: \"top left\"\n>>     let (x, y) where x < 50 && y > 50: \"bottom left\"\n>>     let (x, y) where x > 50 && y < 50: \"top right\"\n>>     default: \"bottom right\"\n>>\n>> The colon comes from the fact that this is sort of a light-weight\n>> expression-based \"switch\" statement, where each branch can only contain an\n>> expression, not a series of statements.\n>>\n>> This is very similar to pattern matching expressions in languages like\n>> Haskell, ML, and Coq.\n>>\n>> On Sun, Dec 6, 2015 at 11:25 AM, Thorsten Seitz <thorsten.seitz at web.de>\n>> wrote:\n>>\n>>\n>>\n>> Am 06.12.2015 um 01:28 schrieb Alex Lew via swift-evolution <\n>> swift-evolution at swift.org>:\n>>\n>> I don't think you can just get rid of the if statement in favor of an\n>> expression. You still want to be able to do this:\n>>\n>> if (condition) {\n>>     funcWithSideEffectsThatReturnsInt()\n>> } else {\n>>     funcWithSideEffectsThatReturnsString()\n>> }\n>>\n>> but that's not a valid expression (what is its type?).\n>>\n>>\n>>\n>> That would actually be no problem if Swift’s type system would have union\n>> types (Ceylon has union and intersection types which are quite awesome and\n>> enable lots of nice things quite naturally, see\n>> http://ceylon-lang.org/documentation/1.2/tour/types/).\n>>\n>> In that case the type of such an expression would just be the union of\n>> both types, which is written Int | String in Ceylon.\n>>\n>>\n>> -Thorsten\n>>\n>>\n>>\n>>\n>>\n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>\n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>\n>>\n>> *_______________________________________________*\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>\n>>\n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>\n>>\n>> Untracked with Trackbuster <https://trackbuster.com/?sig>\n>>\n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>\n>>\n>  _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000644.html" , "date" : { "$date" : 1449435275000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ ""] , "inReplyTo" :  null  , "descendants" : [ "1C7496F7-41F5-4F46-A8B7-889D4A9FC49B@gmail.com" , "CAKCGC8AdPMD1ySZnucpn-kMpy-X4=O0Xhd6aoOazyr6SAmLLUA@mail.gmail.com" , "63E46D4F-9E50-4BD8-AB36-A4510BDFF4B0@gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/2CF98787-3994-47AA-8B84-13C9AC7A4154@fifthace.com"}} , "_id" : "2CF98787-3994-47AA-8B84-13C9AC7A4154@fifthace.com" , "from" : "sean at fifthace.com (Sean Heber)" , "mailingList" : "swift-evolution" , "content" : "This is the exact scenario that lead to my own code base having a few cases of C-style (all of which I've now trivially removed). Even so, I do not believe it is worth keeping it around for this reason.\n\nl8r\nSean\n\n> On Dec 6, 2015, at 2:37 PM, Michel Fortin via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> There is actually one good reason I see in favor of keeping the C-style for loop, and only one: ease of porting existing code to Swift.\n> \n> If you are porting code from another language that uses C-style for loops, currently you can keep the loop as is while you translate all the syntactic differences everywhere. If Swift didn't had a C-style for loop, then you'd need to rethink the control flow at the same time you are converting everything else, increasing the risk of errors during what is already a delicate operation.\n> \n> C-style for loops are very common in code you can find everywhere because many languages have it, and therefore there is a lot of algorithms, sometime tricky algorithms you don't want to mess up, that rely on such loops. Even if you had the desire to convert all of them to for-in loops in your port, rewriting the control flow *at the same time* you are addressing all the other porting issues is much worse than doing it in a separate step *after* the crude port has been tested to work.\n> \n> In other words: you should avoid refactoring everything in one step. The C-style for loop enables that.\n> \n> -- \n> Michel Fortin\n> michel.fortin at michelf.ca\n> https://michelf.ca\n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000645.html" , "inReplyTo" : "9FCB65CF-491B-4F21-B664-AE6623E7C669@michelf.ca" , "date" : { "$date" : 1449435850000} , "subject" : "[swift-evolution] C-style For Loops" , "references" : [ "AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de" , "CAAcV4sZVC8M4yo+XEdWoGzKyG7rDYuy7ox=Rk3cdbXjFuSD4Sg@mail.gmail.com" , "40642775-F58D-49B0-9BF3-38913FD6924C@ericasadun.com" , "9FCB65CF-491B-4F21-B664-AE6623E7C669@michelf.ca"] , "descendants" : [ "CAPh90aFQs-RA4W++PCgG7n58p0F5NOp9jmJsz7hZxfkOZktVcA@mail.gmail.com" , "3F9880E8-7BEA-4275-A939-940041861EC5@michelf.ca" , "5664F2B9.5080808@klundberg.com" , "5567A331-3420-448B-9A1F-484D44F7A792@michelf.ca"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAAdsSdrj_WW_h4nDOct-CquOY-ae8Nm40r-DqjV0wpYfAcq84A@mail.gmail.com"}} , "_id" : "CAAdsSdrj_WW_h4nDOct-CquOY-ae8Nm40r-DqjV0wpYfAcq84A@mail.gmail.com" , "from" : "bek at termestrup.dk (Morten Bek Ditlevsen)" , "mailingList" : "swift-evolution" , "content" : "+1 from here too!\nsøn. 6. dec. 2015 kl. 21.43 skrev Ilya Belenkiy via swift-evolution <\nswift-evolution at swift.org>:\n\n> +1\n>\n> On Sat, Dec 5, 2015 at 10:17 PM Matthew Johnson via swift-evolution <\n> swift-evolution at swift.org> wrote:\n>\n>> +1 to this.  Subscripts should also be able to throw and currently cannot.\n>>\n>>\n>> On Dec 5, 2015, at 9:08 PM, Nikolai Vazquez via swift-evolution <\n>> swift-evolution at swift.org> wrote:\n>>\n>> One of the aspects of Swift that I like is computed properties for\n>> structures and classes. It allows for adding logic when obtaining values or\n>> for having the returned value be dependent on another.\n>>\n>> As of the `ErrorType` protocol introduction in Swift 2, we can throw\n>> errors when it comes to functions and initializers. However, this does not\n>> apply to getters and setters.\n>>\n>> ```swift\n>> struct File<Data> {\n>>     var contents: Data {\n>>         get throws { ... }\n>>         set throws { ... }\n>>     }\n>> }\n>> ```\n>>\n>> A better example would be getting and setting the current working\n>> directory of the process:\n>>\n>> ```swift\n>> import Foundation\n>>\n>> extension Process {\n>>     static var workingDirectory: String {\n>>         get {\n>>             let fileManager = NSFileManager.defaultManager()\n>>             return fileManager.currentDirectoryPath\n>>         }\n>>         set throws {\n>>             let fileManager = NSFileManager.defaultManager()\n>>             guard fileManager.changeCurrentDirectoryPath(newValue) else {\n>>                 throw Error(\"...\")\n>>             }\n>>         }\n>>     }\n>> }\n>>\n>>\n>>\n>> ```\n>>\n>>\n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>\n>>\n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000646.html" , "inReplyTo" : "CAOFcyhsX__8shDyX6Zk369Z15-LC1KJ=E=bXqWo99JNCKvs-Gw@mail.gmail.com" , "date" : { "$date" : 1449435855000} , "subject" : "[swift-evolution] Proposal: Allow Getters and Setters to Throw" , "references" : [ "CANhuES0ZoHNV5YXzS2UyUcqE=quzBXz7bHBrpNA=do-_LVNLOg@mail.gmail.com" , "DB6756E4-1448-4517-88B2-06FF1578D440@anandabits.com" , "CAOFcyhsX__8shDyX6Zk369Z15-LC1KJ=E=bXqWo99JNCKvs-Gw@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/ED9A9872-62B4-4957-B708-94F3015365C5@alkaline-solutions.com"}} , "_id" : "ED9A9872-62B4-4957-B708-94F3015365C5@alkaline-solutions.com" , "from" : "david at alkaline-solutions.com (David Waite)" , "mailingList" : "swift-evolution" , "content" : "I’m leaning away from “self in” style syntax - I think there are too many cases where you still want to be able to bind and access the self of the object your closure was declared within.\n\nI’m not sure you have to establish a new “self” however - have the type of object given to with is known, so the methods/functions available to it can be exposed as lexical scope. \n\nTo keep code clarity, use of methods/functions which shadow something in higher lexical scope should likely result in compiler errors.\n\n-DW\n\n> On Dec 6, 2015, at 1:48 PM, ilya via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> I applaud honest description of drawbacks in the proposal :) \n> \n> There examples given, I think, demonstrate that using self without any special access leads to unresolvable ambiguities. \n> \n> If one wants to work \"inside\" the configured object, this seems like a good job for a private initializer. All of the ambiguities will be resolved, because extracting the init away removes its ability to capture names from the local context. \n> \n> Alternatively, I think it makes sense to continue working on configuration syntax, with \"default\" access to local context and \"explicit\" access to the object. Let's just replace $0 with something else. \n> \n> Hopefully I don't sounds too pessimistic. Erica's proposal looks going in the right direction to me. \n> On Sun, Dec 6, 2015 at 23:30 Erica Sadun via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n> It's probably better at this point for me to collect my thoughts and summarize where I am at.\n> \n> https://gist.github.com/erica/eb32feb22ba99629285a <https://gist.github.com/erica/eb32feb22ba99629285a>\n> \n> Please feel free to comment on-list about this proposal (github does not forward comment alerts) and\n> then I will start a new list thread as a Proposal rather than as a Request for Discussion.\n> \n> Best,\n> \n> -- E\n> \n> \n>> On Dec 6, 2015, at 12:45 PM, ilya <ilya.nikokoshev at gmail.com <mailto:ilya.nikokoshev at gmail.com>> wrote:\n>> \n>> Sorry, did I misunderstand the question? \n>> \n>> Did you asked whether my definition will work for immutable value types? \n>> If that's the question, the answer is still yes, the link has an example :) \n>> \n>> On Sun, Dec 6, 2015 at 10:43 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:\n>> I was specifically referring to value types. I apologize for not being clearer.\n>> \n>> -- E\n>> \n>> \n>>> On Dec 6, 2015, at 12:42 PM, ilya <ilya.nikokoshev at gmail.com <mailto:ilya.nikokoshev at gmail.com>> wrote:\n>>> \n>>> Yes, it works for immutable objects with the correct definition, see the playground contents at https://github.com/ilyannn/iOS-Swift-Materials/blob/master/Playgrounds/Configure.playground/Contents.swift <https://github.com/ilyannn/iOS-Swift-Materials/blob/master/Playgrounds/Configure.playground/Contents.swift>\n>>> \n>>> On Sun, Dec 6, 2015 at 8:10 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:\n>>> I have developed something similar as well (http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/ <http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/>).\n>>> \n>>> Is yours capable of handling enums and structs that would otherwise be let after declaration because mine is not.\n>>> \n>>> -- E\n>>> \n>>> \n>>>> On Dec 5, 2015, at 5:16 PM, ilya via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>>> \n>>>> > PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.  Here's one example: ...\n>>>> \n>>>> FWIW, I created a configuration operator more then a year ago, and use it in all of my Swift projects:\n>>>> \n>>>> let task = NSTask() +=+ {\n>>>>     $0.launchPath = \"/usr/bin/mdfind\"\n>>>>     $0.arguments = [\"kMDItemDisplayName == *.playground\"]\n>>>>     $0.standardOutput = pipe\n>>>> }\n>>>> \n>>>> Note you can also use the configured object in the rhs:\n>>>> \n>>>> let questionLabel = UILabel() +=+ {\n>>>>     $0.textAlignment = .Center\n>>>>     $0.font =  UIFont(name:\"DnealianManuscript\", size: 72)\n>>>>     $0.text = currentQuestion.questionText\n>>>>     $0.numberOfLines = 0\n>>>>     view.addSubview($0)\n>>>> }\n>>>> \n>>>> This $0. certainly looks ugly and it would be great to be able to simplify this. I don't llike the following much though (dot-syntax can be ambiguos here, and using simply a method name is even worse):\n>>>> \n>>>> let questionLabel = UILabel() +=+ {\n>>>>     .textAlignment = .Center\n>>>>     .font =  UIFont(name:\"DnealianManuscript\", size: 72)\n>>>>     .text = currentQuestion.questionText\n>>>>     .numberOfLines = 0\n>>>>     view.addSubview($0)\n>>>> }\n>>>> \n>>>> Actually I would be happy with something like\n>>>> \n>>>> let questionLabel = UILabel() .{\n>>>>     ..textAlignment = .Center\n>>>>     ..font = UIFont(name:\"DnealianManuscript\", size: 72)\n>>>>     ..text = currentQuestion.questionText\n>>>>     ..numberOfLines = 0\n>>>>     view.addSubview($0)\n>>>> }\n>>>> \n>>>> Other thoughts?\n>>>> \n>>>>   \n>>>>  _______________________________________________\n>>>> swift-evolution mailing list\n>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>> \n>>> \n>> \n>> \n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>  _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000647.html" , "inReplyTo" : "CAPh90aE1m68_kDFqOGuO-u6qP3WKtqSJS9XMU-KKrO0N3yV0kg@mail.gmail.com" , "date" : { "$date" : 1449435877000} , "subject" : "[swift-evolution] Request for Discussion: Setup closures" , "references" : [ "CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com" , "8837F311-F6F8-462E-90E0-88981C537EFD@ericasadun.com" , "CAPh90aEHX5aWQOnpkDJxeTt3DXOH6Xdqq1BXYVr_tvB63QKx1g@mail.gmail.com" , "F757A1B0-69AA-40E0-BB72-9A043CE6D93D@ericasadun.com" , "CAPh90aHJuiYVOPu+9poXapDq9q4dzYAnS=fm3ke1ODz3neheOg@mail.gmail.com" , "DD7C743B-5E22-4603-AA6A-AF3F75B4DE62@ericasadun.com" , "CAPh90aE1m68_kDFqOGuO-u6qP3WKtqSJS9XMU-KKrO0N3yV0kg@mail.gmail.com"] , "descendants" : [ "F833B947-4FFD-485E-912A-31B50140660F@anandabits.com" , "F6635EA0-2342-451E-8675-FF1819BD715C@anandabits.com" , "2F1E045F-3242-4943-9471-B40D6B476C97@anandabits.com" , "35BE2387-2F9C-491F-B71F-1635243ABADA@ericasadun.com" , "38E11489-CE79-4690-8567-98FD7793B4FF@gmail.com" , "159233D0-A835-4435-840E-A9594DDCA37D@ericasadun.com" , "CAKCGC8AOx_ffGe1AjpQJt9ULr3zwTBsnphJCht92se7-Hfi_+g@mail.gmail.com" , "DC82287B-4583-47F3-9389-B756C91436F5@alkaline-solutions.com" , "CC9D9491-212A-4D20-8CC2-34FD984F6463@portableinnovations.de" , "EF05B911-5728-47F4-AB13-F960FF2B21A4@portableinnovations.de" , "F379B44A-9B6F-47BD-95B0-9FC795BC035B@architechies.com" , "BB9D9FE2-F252-41F4-A3EA-2D8053A7579C@gmx.de" , "1F3D7F58-0EC6-4541-9734-A95CE62BAF6E@anandabits.com" , "2139FFE7-79C5-4981-A036-250F2D5EF0A4@ericasadun.com" , "24FE9022-00E3-459C-8A71-540BCF436286@apple.com" , "E904EA6A-6422-49F6-9C5E-07BCDC7D3543@gmx.de" , "98A80B8C-AC32-408D-AD8F-CDE0EB782B4C@apple.com" , "03F8648F-236A-46A5-8D21-CA066DBA1932@anandabits.com" , "D49345E8-5E22-46C8-9EF2-EF0DB4D32D87@apple.com" , "77AE5195-4E57-4814-A228-AF23723C853B@ericasadun.com" , "B818E6F9-1526-4725-BCDA-AB8C36F3CED7@maven.de" , "6A18AB5F-3794-42A6-8142-AAA7B2B61000@apple.com" , "9520AAC7-B49D-4CB7-96EE-E9891BAC9268@ericasadun.com" , "5981B70E-98D3-4A99-AF49-106254DFEB54@apple.com" , "86e837d7-cac3-438b-8297-4f6f401b641f@Spark" , "315B39D9-AE33-438B-8EFF-CC4796EECAAF@pobox.com" , "731CB499-F42F-45D4-8A3B-8D7B963D3709@monod-broca.fr" , "CADcs6kNOmo32YcBHOjmsV3eKiJ4yo0nDxz+5mjWNtp3JG0FsOA@mail.gmail.com" , "616C48D0-D626-487E-861C-CF125879BABB@ericasadun.com" , "3A77268A-D52E-4821-9488-671491506835@monod-broca.fr" , "B5AE3C08-FB9F-4024-B6BF-ECAADC1196E8@pobox.com" , "52D7FF3E-4E16-447D-AFCF-6915ABF999C1@gmx.de" , "98E5A56D-2912-4725-8E5E-14F25153B184@gmx.de" , "3C9B366C-D4A8-4777-8CF9-E46B52F806E2@pobox.com" , "0674FFD1-76FB-4376-9F34-0FF8B7560798@anandabits.com" , "5B0D18B8-0255-4F2E-86E3-253058585BDB@fifthace.com" , "512C0649-506C-41B3-BBB9-BBF6B80437FE@ericasadun.com" , "CADcs6kOfPJ73WdN-UHTZAPs7Zx_MmSUjrKy6r=EMphLdGfti8w@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/512C0649-506C-41B3-BBB9-BBF6B80437FE@ericasadun.com"}} , "_id" : "512C0649-506C-41B3-BBB9-BBF6B80437FE@ericasadun.com" , "from" : "erica at ericasadun.com (Erica Sadun)" , "mailingList" : "swift-evolution" , "content" : "Do you want me to tweak that? Or remove it entirely? Also, I think I forgot to name-drop you slightly earlier as well\n\n> On Dec 6, 2015, at 2:04 PM, David Waite <david at alkaline-solutions.com> wrote:\n> \n> I’m leaning away from “self in” style syntax - I think there are too many cases where you still want to be able to bind and access the self of the object your closure was declared within.\n> \n> I’m not sure you have to establish a new “self” however - have the type of object given to with is known, so the methods/functions available to it can be exposed as lexical scope. \n> \n> To keep code clarity, use of methods/functions which shadow something in higher lexical scope should likely result in compiler errors.\n> \n> -DW\n> \n>> On Dec 6, 2015, at 1:48 PM, ilya via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>> \n>> I applaud honest description of drawbacks in the proposal :) \n>> \n>> There examples given, I think, demonstrate that using self without any special access leads to unresolvable ambiguities. \n>> \n>> If one wants to work \"inside\" the configured object, this seems like a good job for a private initializer. All of the ambiguities will be resolved, because extracting the init away removes its ability to capture names from the local context. \n>> \n>> Alternatively, I think it makes sense to continue working on configuration syntax, with \"default\" access to local context and \"explicit\" access to the object. Let's just replace $0 with something else. \n>> \n>> Hopefully I don't sounds too pessimistic. Erica's proposal looks going in the right direction to me. \n>> On Sun, Dec 6, 2015 at 23:30 Erica Sadun via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>> It's probably better at this point for me to collect my thoughts and summarize where I am at.\n>> \n>> https://gist.github.com/erica/eb32feb22ba99629285a <https://gist.github.com/erica/eb32feb22ba99629285a>\n>> \n>> Please feel free to comment on-list about this proposal (github does not forward comment alerts) and\n>> then I will start a new list thread as a Proposal rather than as a Request for Discussion.\n>> \n>> Best,\n>> \n>> -- E\n>> \n>> \n>>> On Dec 6, 2015, at 12:45 PM, ilya <ilya.nikokoshev at gmail.com <mailto:ilya.nikokoshev at gmail.com>> wrote:\n>>> \n>>> Sorry, did I misunderstand the question? \n>>> \n>>> Did you asked whether my definition will work for immutable value types? \n>>> If that's the question, the answer is still yes, the link has an example :) \n>>> \n>>> On Sun, Dec 6, 2015 at 10:43 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:\n>>> I was specifically referring to value types. I apologize for not being clearer.\n>>> \n>>> -- E\n>>> \n>>> \n>>>> On Dec 6, 2015, at 12:42 PM, ilya <ilya.nikokoshev at gmail.com <mailto:ilya.nikokoshev at gmail.com>> wrote:\n>>>> \n>>>> Yes, it works for immutable objects with the correct definition, see the playground contents at https://github.com/ilyannn/iOS-Swift-Materials/blob/master/Playgrounds/Configure.playground/Contents.swift <https://github.com/ilyannn/iOS-Swift-Materials/blob/master/Playgrounds/Configure.playground/Contents.swift>\n>>>> \n>>>> On Sun, Dec 6, 2015 at 8:10 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:\n>>>> I have developed something similar as well (http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/ <http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/>).\n>>>> \n>>>> Is yours capable of handling enums and structs that would otherwise be let after declaration because mine is not.\n>>>> \n>>>> -- E\n>>>> \n>>>> \n>>>>> On Dec 5, 2015, at 5:16 PM, ilya via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>>>> \n>>>>> > PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.  Here's one example: ...\n>>>>> \n>>>>> FWIW, I created a configuration operator more then a year ago, and use it in all of my Swift projects:\n>>>>> \n>>>>> let task = NSTask() +=+ {\n>>>>>     $0.launchPath = \"/usr/bin/mdfind\"\n>>>>>     $0.arguments = [\"kMDItemDisplayName == *.playground\"]\n>>>>>     $0.standardOutput = pipe\n>>>>> }\n>>>>> \n>>>>> Note you can also use the configured object in the rhs:\n>>>>> \n>>>>> let questionLabel = UILabel() +=+ {\n>>>>>     $0.textAlignment = .Center\n>>>>>     $0.font =  UIFont(name:\"DnealianManuscript\", size: 72)\n>>>>>     $0.text = currentQuestion.questionText\n>>>>>     $0.numberOfLines = 0\n>>>>>     view.addSubview($0)\n>>>>> }\n>>>>> \n>>>>> This $0. certainly looks ugly and it would be great to be able to simplify this. I don't llike the following much though (dot-syntax can be ambiguos here, and using simply a method name is even worse):\n>>>>> \n>>>>> let questionLabel = UILabel() +=+ {\n>>>>>     .textAlignment = .Center\n>>>>>     .font =  UIFont(name:\"DnealianManuscript\", size: 72)\n>>>>>     .text = currentQuestion.questionText\n>>>>>     .numberOfLines = 0\n>>>>>     view.addSubview($0)\n>>>>> }\n>>>>> \n>>>>> Actually I would be happy with something like\n>>>>> \n>>>>> let questionLabel = UILabel() .{\n>>>>>     ..textAlignment = .Center\n>>>>>     ..font = UIFont(name:\"DnealianManuscript\", size: 72)\n>>>>>     ..text = currentQuestion.questionText\n>>>>>     ..numberOfLines = 0\n>>>>>     view.addSubview($0)\n>>>>> }\n>>>>> \n>>>>> Other thoughts?\n>>>>> \n>>>>>   \n>>>>>  _______________________________________________\n>>>>> swift-evolution mailing list\n>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>> \n>>>> \n>>> \n>>> \n>> \n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>  _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000648.html" , "inReplyTo" : "ED9A9872-62B4-4957-B708-94F3015365C5@alkaline-solutions.com" , "date" : { "$date" : 1449435964000} , "subject" : "[swift-evolution] Request for Discussion: Setup closures" , "references" : [ "CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com" , "8837F311-F6F8-462E-90E0-88981C537EFD@ericasadun.com" , "CAPh90aEHX5aWQOnpkDJxeTt3DXOH6Xdqq1BXYVr_tvB63QKx1g@mail.gmail.com" , "F757A1B0-69AA-40E0-BB72-9A043CE6D93D@ericasadun.com" , "CAPh90aHJuiYVOPu+9poXapDq9q4dzYAnS=fm3ke1ODz3neheOg@mail.gmail.com" , "DD7C743B-5E22-4603-AA6A-AF3F75B4DE62@ericasadun.com" , "CAPh90aE1m68_kDFqOGuO-u6qP3WKtqSJS9XMU-KKrO0N3yV0kg@mail.gmail.com" , "ED9A9872-62B4-4957-B708-94F3015365C5@alkaline-solutions.com"] , "descendants" : [ "F833B947-4FFD-485E-912A-31B50140660F@anandabits.com" , "F6635EA0-2342-451E-8675-FF1819BD715C@anandabits.com" , "2F1E045F-3242-4943-9471-B40D6B476C97@anandabits.com" , "35BE2387-2F9C-491F-B71F-1635243ABADA@ericasadun.com" , "38E11489-CE79-4690-8567-98FD7793B4FF@gmail.com" , "159233D0-A835-4435-840E-A9594DDCA37D@ericasadun.com" , "CAKCGC8AOx_ffGe1AjpQJt9ULr3zwTBsnphJCht92se7-Hfi_+g@mail.gmail.com" , "DC82287B-4583-47F3-9389-B756C91436F5@alkaline-solutions.com" , "CC9D9491-212A-4D20-8CC2-34FD984F6463@portableinnovations.de" , "EF05B911-5728-47F4-AB13-F960FF2B21A4@portableinnovations.de" , "F379B44A-9B6F-47BD-95B0-9FC795BC035B@architechies.com" , "BB9D9FE2-F252-41F4-A3EA-2D8053A7579C@gmx.de" , "1F3D7F58-0EC6-4541-9734-A95CE62BAF6E@anandabits.com" , "2139FFE7-79C5-4981-A036-250F2D5EF0A4@ericasadun.com" , "24FE9022-00E3-459C-8A71-540BCF436286@apple.com" , "E904EA6A-6422-49F6-9C5E-07BCDC7D3543@gmx.de" , "98A80B8C-AC32-408D-AD8F-CDE0EB782B4C@apple.com" , "03F8648F-236A-46A5-8D21-CA066DBA1932@anandabits.com" , "D49345E8-5E22-46C8-9EF2-EF0DB4D32D87@apple.com" , "77AE5195-4E57-4814-A228-AF23723C853B@ericasadun.com" , "B818E6F9-1526-4725-BCDA-AB8C36F3CED7@maven.de" , "6A18AB5F-3794-42A6-8142-AAA7B2B61000@apple.com" , "9520AAC7-B49D-4CB7-96EE-E9891BAC9268@ericasadun.com" , "5981B70E-98D3-4A99-AF49-106254DFEB54@apple.com" , "86e837d7-cac3-438b-8297-4f6f401b641f@Spark" , "315B39D9-AE33-438B-8EFF-CC4796EECAAF@pobox.com" , "731CB499-F42F-45D4-8A3B-8D7B963D3709@monod-broca.fr" , "CADcs6kNOmo32YcBHOjmsV3eKiJ4yo0nDxz+5mjWNtp3JG0FsOA@mail.gmail.com" , "616C48D0-D626-487E-861C-CF125879BABB@ericasadun.com" , "3A77268A-D52E-4821-9488-671491506835@monod-broca.fr" , "B5AE3C08-FB9F-4024-B6BF-ECAADC1196E8@pobox.com" , "52D7FF3E-4E16-447D-AFCF-6915ABF999C1@gmx.de" , "98E5A56D-2912-4725-8E5E-14F25153B184@gmx.de" , "3C9B366C-D4A8-4777-8CF9-E46B52F806E2@pobox.com" , "0674FFD1-76FB-4376-9F34-0FF8B7560798@anandabits.com" , "5B0D18B8-0255-4F2E-86E3-253058585BDB@fifthace.com" , "CADcs6kOfPJ73WdN-UHTZAPs7Zx_MmSUjrKy6r=EMphLdGfti8w@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/DEBE0A49-3E5A-431F-8559-63EBA7214068@jacopo.giola.org"}} , "_id" : "DEBE0A49-3E5A-431F-8559-63EBA7214068@jacopo.giola.org" , "from" : "swift-evolution at jacopo.giola.org (Jacopo Andrea Giola)" , "mailingList" : "swift-evolution" , "content" : "Hi David,\n\nsorry but I don’t understand what do you mean in your first point can you elaborate further?\n\n2. your reswitch will throw a compile error, because you are try to call the switch with a different type, I imagine that to reswitch you can only pass a valid match to optionalThins so you have to pass a `String?` and yes, the proposal is to re execute the switch on the new value.\n\n3. Your second example can’t be always valid because optionalThing can be a constant, I’m imagining that in the new switch execution optionalThing is being shadowed by the new value, but at the end of the execution optionalThing is the old value again.\n\n\n> On 06 Dec 2015, at 21:48, David Waite <david at alkaline-solutions.com> wrote:\n> \n> To cope with the pattern matching cases, I would say that reswitch either has to:\n> 1. Be limited specifically to a switch without pattern matching or enum values with associated data (such as Optional.Some). This would likely need to go beyond the limitations on fall through, which only limit value-binding patterns\n> 2. Use instead of trying to treat the value of a reswitch as a label, treat it as a expression to re-execute the switch statement over:\n> \n> switch(optionalThing) {\n> case .None:\n> \tprint(“assuming default value”)\t\n> \treswitch “default”\n> case .Some(let str):\n> \tprint(“processing value \\(str)”);\n> }\n> \n> This does however have non-intuitive behavior - when the second case statement is hit, “str\" is no longer equal to \"optionalThing!”. For that reason, one might find it clearer to require an explicit reassignment, effectively treating the switch as a loop: \n> \n> switch(optionalThing) {\n> case .None:\n> \tprint(“assuming default value”)\t\n> \toptionalThing = “default”\n> \treswitch\n> case .Some(let str):\n> \tprint(“processing value \\(str)”);\n> }\n> \n> The existing “continue” keyword seems a poor choice to recycle for this purpose; “repeat” or “retry” might be more appropriate than “reswitch\"\n> \n> -DW\n> \n>> On Dec 6, 2015, at 1:06 PM, Jacopo Andrea Giola via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>> \n>>  Hi Colin,\n>> \n>> the initial proposal was indeed to remove entirely the `fallthrough` keyword but many people expressed your similar concern and from that point the discussion was steered through an \"enhancement\" and better refinement of the keyword.\n>> \n>> The new idea is to substitute the old keyword with \"reswitch\" passing the desired new value on which the switch is applied.\n>> So something like this:\n>> \n>> switch (enum) {\n>> \tcase .One:\n>> \t\t// do something\n>> \t\treswitch .Two\n>> \tcase .Two:\n>> \t\t// do something else\n>> \tdefault:\n>> \t\t// and so one\n>> }\n>> \n>> This new behaviour, IMO, is better suited for Swift because is more declarative of the developer intent and doesn't carry over unintentional misbehaviour.\n>> Is more declarative because you are forced to state in which case you want to go, and even if the order of the switch’ cases will change in the future, you don't fall in the wrong case by mistake.\n>> \n>> switch (enum) {\n>> \tcase .One:\n>> \t\t// do something\n>> \t\treswitch .Two\n>> \tcase .OneAndAHalf\n>> \t\t// maybe this change is not made by you but by a messed up merge\n>> \tcase .Two:\n>> \t\t// do something else\n>> \tdefault:\n>> \t\t// and so one\n>> }\n>> \n>> In this case if you are using the fallthrough keyboard your code is now broken by accident, and depending on what are you trying to do inside the cases you can have a hidden bug that your tests are not seeing right away. \n>> \n>> Another advantage is that in this way you can made more cases fallthrough in the same one even if they are not one over each other\n>> \n>> switch (enum) {\n>> \tcase .One:\n>> \t\t// do something\n>> \t\treswitch .Two\n>> \tcase .OneAndAHalf\n>> \t\t// so something that you don’t want to do for .One\n>> \t\treswitch .Two\n>> \tcase .Two:\n>> \t\t// do something else that you may want to do for .One and .Two\n>> \tdefault:\n>> \t\t// and so one\n>> }\n>> \n>> I must say that this is a side effect that can be used to messed up the code flow in a way that is not intended, but is a new behaviour that gives more power to the switch statement.\n>> \n>> The reswitch keyword in addition is not a mere fallthrough on the new case without doing the optional checking attached to it, but is intended to be a new call and all the check are executed.\n>> \n>> switch (enum) {\n>> \tcase .One:\n>> \t\t// do something\n>> \t\tx = 0;\n>> \t\treswitch .Two\n>> \tcase .OneAndAHalf\n>> \t\t// so something that you don’t want to do for .One\n>> \t\treswitch .Two\n>> \tcase .Two where x > 0:\n>> \t\t// do something else that you may want to do for .One and .Two\n>> \t\telement = array[x]\n>> \tdefault:\n>> \t\t// and so one\n>> }\n>> (I’m going by memory and by writing this snippets in the mail app directly, so the code must be incorrect in the syntax and for this I’m sorry).\n>> \n>> In this case if enum is .One the only case that is executed is case .One and the code doesn’t fallthrough in the .Two case because we are made the where invalid by changing the x to a value less than 1.\n>> \n>> Now I don’t remember who was the first one who mede this proposal, and I don’t know if he is working on a first draft to lay down the things better, but for me this can be a nice improvement and a neat break with the C-switch behaviour that Swift has trying to change from the very first beta disallowing the implicit fallthrough.\n>> \n>> I can be completely wrong but I see the `fallthrough`keyword as a “temporary” implementation for ease the transition from Obj-C to Swift and is time to improve it and made the switch statement even more powerful.\n>> \n>> - Jacopo\n>> Sent from my iPad\n>> \n>> On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>> \n>>> tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.\n>>> \n>>> Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.\n>>> \n>>> I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)\n>>> \n>>> Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:\n>>> \n>>> https://gist.github.com/cbarrett/23b24a9fe76efdf006df <https://gist.github.com/cbarrett/23b24a9fe76efdf006df>\n>>> \n>>> This technique is very extensible — for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.\n>>> \n>>> Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type — low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.\n>>> \n>>> Thanks,\n>>> -Colin\n>>> \n>>>> On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>>> \n>>>> +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.\n>>>> \n>>>> If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don't introduce an infinite \"switch\" loop.\n>>>> \n>>>> Sent from my iPad\n>>>> \n>>>> On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>>> \n>>>>> Very much thinking out loud and not really the implications, I wonder if we might just use \"continue\" instead of \"reswitch\".\n>>>>> \n>>>>> I very much like specifying what case to fall through into, no matter how we spell it.\n>>>>> \n>>>>> - Steve\n>>>>> \n>>>>> On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>>>> \n>>>>>>> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>>>>>>> On Dec 4, 2015, at 11:37 PM, John Calsbeek <john.calsbeek+lists at gmail.com <mailto:john.calsbeek+lists at gmail.com>> wrote:\n>>>>>>>> `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.\n>>>>>>>> \n>>>>>>>> It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.\n>>>>>>> \n>>>>>>> Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.\n>>>>>>> \n>>>>>>> On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.\n>>>>>> \n>>>>>> Oh, I see that Joe already brought this up, spelled “reswitch”.\n>>>>>> \n>>>>>> John.\n>>>>>> \n>>>>>>> \n>>>>>>> John.\n>>>>>>> \n>>>>>>>> \n>>>>>>>> One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).\n>>>>>>>> \n>>>>>>>> switch op {\n>>>>>>>> case LOAD_INDIRECT:\n>>>>>>>>    in0 = memory[in1]\n>>>>>>>>    fallthrough\n>>>>>>>> case LOAD:\n>>>>>>>>    out0 = memory[in0]\n>>>>>>>> //...\n>>>>>>>> }\n>>>>>>>> \n>>>>>>>> I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.\n>>>>>>>> \n>>>>>>>> Cheers,\n>>>>>>>> John\n>>>>>>>> \n>>>>>>>>> On Dec 4, 2015, at 2:42 PM, John McCall <rjmccall at apple.com <mailto:rjmccall at apple.com>> wrote:\n>>>>>>>>> \n>>>>>>>>>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard <kevin at sb.org <mailto:kevin at sb.org>> wrote:\n>>>>>>>>>> It's not actually Duff's Device. Duff's Device relies on the fact that C switch statements don't actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it's a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.\n>>>>>>>>> \n>>>>>>>>> To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.\n>>>>>>>>> \n>>>>>>>>> But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.\n>>>>>>>>> \n>>>>>>>>> John.\n>>>>>>>>> \n>>>>>>>>>>  \n>>>>>>>>>> Steve's code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It's a good example of one of the uses of `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's Device in Swift.\n>>>>>>>>>>  \n>>>>>>>>>> -Kevin Ballard\n>>>>>>>>>>  \n>>>>>>>>>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:\n>>>>>>>>>>> Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.\n>>>>>>>>>>>  \n>>>>>>>>>>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:\n>>>>>>>>>>>>  \n>>>>>>>>>>>> Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it. \n>>>>>>>>>>>>  \n>>>>>>>>>>>> True fact: On all of gist.github.com <http://gist.github.com/>, there are only 22 gist results for \"fallthrough language:swift\".\n>>>>>>>>>>>> Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:\n>>>>>>>>>>>> case .Enum1, .Enum2:\n>>>>>>>>>>>> expressed as \n>>>>>>>>>>>> case .Enum1: fallthrough\n>>>>>>>>>>>> case .Enum2:\n>>>>>>>>>>>>  \n>>>>>>>>>>>> And then there's streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea <https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea>   I'm pretty sure that ponies were harmed in the production of whatever that last bit is.\n>>>>>>>>>>>>  \n>>>>>>>>>>>>  \n>>>>>>>>>>>>  \n>>>>>>>>>>>>  \n>>>>>>>>>>>>> On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com <mailto:jalkut at red-sweater.com> wrote:\n>>>>>>>>>>>>>  \n>>>>>>>>>>>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the \"fallthrough\" keyword from the language?\n>>>>>>>>>>>>>  \n>>>>>>>>>>>>> My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.\n>>>>>>>>>>>>>  \n>>>>>>>>>>>>> The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:\n>>>>>>>>>>>>>  \n>>>>>>>>>>>>> \"The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.\"\n>>>>>>>>>>>>>  \n>>>>>>>>>>>>> To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.\n>>>>>>>>>>>>>  \n>>>>>>>>>>>>> I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.\n>>>>>>>>>>>>>  \n>>>>>>>>>>>>> In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.\n>>>>>>>>>>>>>  \n>>>>>>>>>>>>> Thoughts?\n>>>>>>>>>>>>>  \n>>>>>>>>>>>>> Daniel\n>>>>>>>>>>>>>  \n>>>>>>>>>>>>> _______________________________________________\n>>>>>>>>>>>>> swift-evolution mailing list\n>>>>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>>>>>>>>> \n>>>>>>>>>>>>  \n>>>>>>>>>>>> \n>>>>>>>>>>>> _______________________________________________\n>>>>>>>>>>>> swift-evolution mailing list\n>>>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>>>>>>>> \n>>>>>>>>>>>  \n>>>>>>>>>>> \n>>>>>>>>>>> _______________________________________________\n>>>>>>>>>>> swift-evolution mailing list\n>>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>>>>>>>  \n>>>>>>>>>> \n>>>>>>>>>> _______________________________________________\n>>>>>>>>>> swift-evolution mailing list\n>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>>>>>> \n>>>>>>>>>  _______________________________________________\n>>>>>>>>> swift-evolution mailing list\n>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>>>>> _______________________________________________\n>>>>>>>> swift-evolution mailing list\n>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>>>> \n>>>>>>> _______________________________________________\n>>>>>>> swift-evolution mailing list\n>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>>> \n>>>>>> _______________________________________________\n>>>>>> swift-evolution mailing list\n>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>> _______________________________________________\n>>>>> swift-evolution mailing list\n>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>> _______________________________________________\n>>>> swift-evolution mailing list\n>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>> \n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>  _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000649.html" , "inReplyTo" : "C19956A6-C9B2-45CC-8C91-DA2215EBEA5C@alkaline-solutions.com" , "date" : { "$date" : 1449436094000} , "subject" : "[swift-evolution] Proposal: Remove the \"fallthrough\" keyword" , "references" : [ "3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com" , "AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com" , "8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com" , "1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com" , "02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com" , "E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com" , "444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com" , "EF1675F6-7918-4262-B535-696104BFC405@apple.com" , "CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com" , "D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org" , "071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com" , "CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org" , "C19956A6-C9B2-45CC-8C91-DA2215EBEA5C@alkaline-solutions.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAPh90aFQs-RA4W++PCgG7n58p0F5NOp9jmJsz7hZxfkOZktVcA@mail.gmail.com"}} , "_id" : "CAPh90aFQs-RA4W++PCgG7n58p0F5NOp9jmJsz7hZxfkOZktVcA@mail.gmail.com" , "from" : "ilya.nikokoshev at gmail.com (ilya)" , "mailingList" : "swift-evolution" , "content" : "There are a couple of ways of solving this issue:\n\n1 refactor to where loop first, then convert to Swift\n2 leave a fixit in Xcode that will perform while loop conversion\nOn Mon, Dec 7, 2015 at 00:04 Sean Heber via swift-evolution <\nswift-evolution at swift.org> wrote:\n\n> This is the exact scenario that lead to my own code base having a few\n> cases of C-style (all of which I've now trivially removed). Even so, I do\n> not believe it is worth keeping it around for this reason.\n>\n> l8r\n> Sean\n>\n> > On Dec 6, 2015, at 2:37 PM, Michel Fortin via swift-evolution <\n> swift-evolution at swift.org> wrote:\n> >\n> > There is actually one good reason I see in favor of keeping the C-style\n> for loop, and only one: ease of porting existing code to Swift.\n> >\n> > If you are porting code from another language that uses C-style for\n> loops, currently you can keep the loop as is while you translate all the\n> syntactic differences everywhere. If Swift didn't had a C-style for loop,\n> then you'd need to rethink the control flow at the same time you are\n> converting everything else, increasing the risk of errors during what is\n> already a delicate operation.\n> >\n> > C-style for loops are very common in code you can find everywhere\n> because many languages have it, and therefore there is a lot of algorithms,\n> sometime tricky algorithms you don't want to mess up, that rely on such\n> loops. Even if you had the desire to convert all of them to for-in loops in\n> your port, rewriting the control flow *at the same time* you are addressing\n> all the other porting issues is much worse than doing it in a separate step\n> *after* the crude port has been tested to work.\n> >\n> > In other words: you should avoid refactoring everything in one step. The\n> C-style for loop enables that.\n> >\n> > --\n> > Michel Fortin\n> > michel.fortin at michelf.ca\n> > https://michelf.ca\n> >\n> > _______________________________________________\n> > swift-evolution mailing list\n> > swift-evolution at swift.org\n> > https://lists.swift.org/mailman/listinfo/swift-evolution\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000650.html" , "inReplyTo" : "2CF98787-3994-47AA-8B84-13C9AC7A4154@fifthace.com" , "date" : { "$date" : 1449436112000} , "subject" : "[swift-evolution] C-style For Loops" , "references" : [ "AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de" , "CAAcV4sZVC8M4yo+XEdWoGzKyG7rDYuy7ox=Rk3cdbXjFuSD4Sg@mail.gmail.com" , "40642775-F58D-49B0-9BF3-38913FD6924C@ericasadun.com" , "9FCB65CF-491B-4F21-B664-AE6623E7C669@michelf.ca" , "2CF98787-3994-47AA-8B84-13C9AC7A4154@fifthace.com"] , "descendants" : [ "3F9880E8-7BEA-4275-A939-940041861EC5@michelf.ca" , "5664F2B9.5080808@klundberg.com" , "5567A331-3420-448B-9A1F-484D44F7A792@michelf.ca"]} , { "_links" : { "self" : { "href" : "/charter/emails/AD0908AC-1F8F-44A4-B059-8E811CE3D661@aol.com"}} , "_id" : "AD0908AC-1F8F-44A4-B059-8E811CE3D661@aol.com" , "from" : "cloutiertyler at aol.com (Tyler Fleming Cloutier)" , "mailingList" : "swift-evolution" , "content" : "> Lowered Readability and Maintainability\n> \n> I have aesthetic reasons for disliking the for-loop. The C-style loop is harder to read especially for those not coming from C-style languages, easier to mess up at edge conditions, and is commonly used for side-effects which, in a language focused on safety, is not a feature to be encouraged. \n> \n> For example, one side effect that was mentioned on-list yesterday was the incrementor, which is guaranteed in C-style to execute late:\n> Roland King writes:\n> \n> for var floatingThing = start ; floatingThing <= end ; floatingThing += delta\n> {\n> \t// more than a few lines of code with early escape continues\n> }\n> \n> shows intent of the loop very clearly, start, condition and increment all together at the top, and however you loop you always execute the increment part of the statement. Convert that to a while(), if you have a continue in the body, you have a good chance of not incrementing at all, or duplicating the increment code before every continue. So you can’t always nicely turn for into while. I second the point below about the loop variable being local to the for as well, I also like that. \n> \n> Late incrementor management is a feature that can be mimicked with defer, as pointed out by several other list members.\n> \n\nDefer wouldn’t accomplish the exact same behavior because it would run if an exception was thrown, which is not the same as the last clause of a for loop, but perhaps is close enough.\n\nThe only other concern I would have is not being able to scope my variables to the loop. I didn’t see it addressed, but perhaps its not very important in the end anyway.\n\nSomething like the following might be nice to scope the variable exclusively to the loop.\n\nfor var x = 0 while (someCondition()) {\n\t// code\n}" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000651.html" , "inReplyTo" : "40642775-F58D-49B0-9BF3-38913FD6924C@ericasadun.com" , "date" : { "$date" : 1449436423000} , "subject" : "[swift-evolution] C-style For Loops" , "references" : [ "AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de" , "CAAcV4sZVC8M4yo+XEdWoGzKyG7rDYuy7ox=Rk3cdbXjFuSD4Sg@mail.gmail.com" , "40642775-F58D-49B0-9BF3-38913FD6924C@ericasadun.com"] , "descendants" : [ "75C3B397-E687-4D6A-A5E2-D918502E8484@ericasadun.com" , "CAB8TY2OSDRXUcxtMj7-isuaRmkMXafwsxiquqzedxZ+A+0kyPw@mail.gmail.com" , "E332A59C-7036-42AB-A54A-BE0FE97766EA@aol.com" , "A3B09B02-2438-4658-8073-BEBA8F1A5441@aol.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CADcs6kOfPJ73WdN-UHTZAPs7Zx_MmSUjrKy6r=EMphLdGfti8w@mail.gmail.com"}} , "_id" : "CADcs6kOfPJ73WdN-UHTZAPs7Zx_MmSUjrKy6r=EMphLdGfti8w@mail.gmail.com" , "from" : "jtbandes at gmail.com (Jacob Bandes-Storch)" , "mailingList" : "swift-evolution" , "content" : "It seems like setting properties just after init is the main use case here.\n\nI'm not against this idea, but I want to point out that this doesn't *need*\nto be solved by a change to the language. You can easily define a convenience\ninit for UILabel that takes textAlignment, font, text, and numberOfLines as\nparameters. They could have default values so you can specify just the ones\nyou need.\n\nI like the idea of being able to do configure objects/values conveniently,\nbut I'm not sure how to justify a language change for it. Perhaps we just\nneed better autogeneration of initializers during Obj-C header import.\n\nJacob Bandes-Storch\n\nOn Sun, Dec 6, 2015 at 1:06 PM, Erica Sadun via swift-evolution <\nswift-evolution at swift.org> wrote:\n\n> Do you want me to tweak that? Or remove it entirely? Also, I think I\n> forgot to name-drop you slightly earlier as well\n>\n> On Dec 6, 2015, at 2:04 PM, David Waite <david at alkaline-solutions.com>\n> wrote:\n>\n> I’m leaning away from “self in” style syntax - I think there are too many\n> cases where you still want to be able to bind and access the self of the\n> object your closure was declared within.\n>\n> I’m not sure you have to establish a new “self” however - have the type of\n> object given to with is known, so the methods/functions available to it can\n> be exposed as lexical scope.\n>\n> To keep code clarity, use of methods/functions which shadow something in\n> higher lexical scope should likely result in compiler errors.\n>\n> -DW\n>\n> On Dec 6, 2015, at 1:48 PM, ilya via swift-evolution <\n> swift-evolution at swift.org> wrote:\n>\n> I applaud honest description of drawbacks in the proposal :)\n>\n> There examples given, I think, demonstrate that using self without any\n> special access leads to unresolvable ambiguities.\n>\n> If one wants to work \"inside\" the configured object, this seems like a\n> good job for a private initializer. All of the ambiguities will be\n> resolved, because extracting the init away removes its ability to capture\n> names from the local context.\n>\n> Alternatively, I think it makes sense to continue working on configuration\n> syntax, with \"default\" access to local context and \"explicit\" access to the\n> object. Let's just replace $0 with something else.\n>\n> Hopefully I don't sounds too pessimistic. Erica's proposal looks going in\n> the right direction to me.\n> On Sun, Dec 6, 2015 at 23:30 Erica Sadun via swift-evolution <\n> swift-evolution at swift.org> wrote:\n>\n>> It's probably better at this point for me to collect my thoughts and\n>> summarize where I am at.\n>>\n>> https://gist.github.com/erica/eb32feb22ba99629285a\n>>\n>> Please feel free to comment on-list about this proposal (github does not\n>> forward comment alerts) and\n>> then I will start a new list thread as a Proposal rather than as a\n>> Request for Discussion.\n>>\n>> Best,\n>>\n>> -- E\n>>\n>>\n>> On Dec 6, 2015, at 12:45 PM, ilya <ilya.nikokoshev at gmail.com> wrote:\n>>\n>> Sorry, did I misunderstand the question?\n>>\n>> Did you asked whether my definition will work for immutable value types?\n>> If that's the question, the answer is still yes, the link has an example\n>> :)\n>>\n>> On Sun, Dec 6, 2015 at 10:43 PM, Erica Sadun <erica at ericasadun.com>\n>> wrote:\n>>\n>>> I was specifically referring to value types. I apologize for not being\n>>> clearer.\n>>>\n>>> -- E\n>>>\n>>>\n>>> On Dec 6, 2015, at 12:42 PM, ilya <ilya.nikokoshev at gmail.com> wrote:\n>>>\n>>> Yes, it works for immutable objects with the correct definition, see the\n>>> playground contents at\n>>> https://github.com/ilyannn/iOS-Swift-Materials/blob/master/Playgrounds/Configure.playground/Contents.swift\n>>>\n>>> On Sun, Dec 6, 2015 at 8:10 PM, Erica Sadun <erica at ericasadun.com>\n>>> wrote:\n>>>\n>>>> I have developed something similar as well (\n>>>> http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/\n>>>> ).\n>>>>\n>>>> Is yours capable of handling enums and structs that would otherwise be\n>>>> let after declaration because mine is not.\n>>>>\n>>>> -- E\n>>>>\n>>>>\n>>>> On Dec 5, 2015, at 5:16 PM, ilya via swift-evolution <\n>>>> swift-evolution at swift.org> wrote:\n>>>>\n>>>> > PROBLEM: With many Apple-supplied classes, typical initializers fail\n>>>> to fully set up an instance for use.  Here's one example: ...\n>>>>\n>>>> FWIW, I created a configuration operator more then a year ago, and use\n>>>> it in all of my Swift projects:\n>>>>\n>>>> let task = NSTask() +=+ {\n>>>>     $0.launchPath = \"/usr/bin/mdfind\"\n>>>>     $0.arguments = [\"kMDItemDisplayName == *.playground\"]\n>>>>     $0.standardOutput = pipe\n>>>> }\n>>>>\n>>>> Note you can also use the configured object in the rhs:\n>>>>\n>>>> let questionLabel = UILabel() +=+ {\n>>>>     $0.textAlignment = .Center\n>>>>     $0.font =  UIFont(name:\"DnealianManuscript\", size: 72)\n>>>>     $0.text = currentQuestion.questionText\n>>>>     $0.numberOfLines = 0\n>>>>     view.addSubview($0)\n>>>> }\n>>>>\n>>>> This $0. certainly looks ugly and it would be great to be able to\n>>>> simplify this. I don't llike the following much though (dot-syntax can be\n>>>> ambiguos here, and using simply a method name is even worse):\n>>>>\n>>>> let questionLabel = UILabel() +=+ {\n>>>>     .textAlignment = .Center\n>>>>     .font =  UIFont(name:\"DnealianManuscript\", size: 72)\n>>>>     .text = currentQuestion.questionText\n>>>>     .numberOfLines = 0\n>>>>     view.addSubview($0)\n>>>> }\n>>>>\n>>>> Actually I would be happy with something like\n>>>>\n>>>> let questionLabel = UILabel() .{\n>>>>     ..textAlignment = .Center\n>>>>     ..font = UIFont(name:\"DnealianManuscript\", size: 72)\n>>>>     ..text = currentQuestion.questionText\n>>>>     ..numberOfLines = 0\n>>>>     view.addSubview($0)\n>>>> }\n>>>>\n>>>> Other thoughts?\n>>>>\n>>>>\n>>>>  _______________________________________________\n>>>> swift-evolution mailing list\n>>>> swift-evolution at swift.org\n>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>>\n>>>>\n>>>>\n>>>\n>>>\n>>\n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>\n>  _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>\n>\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000652.html" , "inReplyTo" : "512C0649-506C-41B3-BBB9-BBF6B80437FE@ericasadun.com" , "date" : { "$date" : 1449436438000} , "subject" : "[swift-evolution] Request for Discussion: Setup closures" , "references" : [ "CAPh90aGKa7pvQuuqzKDZu=1+mP2KNQM703h+38hwo752q5s6Aw@mail.gmail.com" , "8837F311-F6F8-462E-90E0-88981C537EFD@ericasadun.com" , "CAPh90aEHX5aWQOnpkDJxeTt3DXOH6Xdqq1BXYVr_tvB63QKx1g@mail.gmail.com" , "F757A1B0-69AA-40E0-BB72-9A043CE6D93D@ericasadun.com" , "CAPh90aHJuiYVOPu+9poXapDq9q4dzYAnS=fm3ke1ODz3neheOg@mail.gmail.com" , "DD7C743B-5E22-4603-AA6A-AF3F75B4DE62@ericasadun.com" , "CAPh90aE1m68_kDFqOGuO-u6qP3WKtqSJS9XMU-KKrO0N3yV0kg@mail.gmail.com" , "ED9A9872-62B4-4957-B708-94F3015365C5@alkaline-solutions.com" , "512C0649-506C-41B3-BBB9-BBF6B80437FE@ericasadun.com"] , "descendants" : [ "F833B947-4FFD-485E-912A-31B50140660F@anandabits.com" , "F6635EA0-2342-451E-8675-FF1819BD715C@anandabits.com" , "2F1E045F-3242-4943-9471-B40D6B476C97@anandabits.com" , "35BE2387-2F9C-491F-B71F-1635243ABADA@ericasadun.com" , "38E11489-CE79-4690-8567-98FD7793B4FF@gmail.com" , "159233D0-A835-4435-840E-A9594DDCA37D@ericasadun.com" , "CAKCGC8AOx_ffGe1AjpQJt9ULr3zwTBsnphJCht92se7-Hfi_+g@mail.gmail.com" , "DC82287B-4583-47F3-9389-B756C91436F5@alkaline-solutions.com" , "CC9D9491-212A-4D20-8CC2-34FD984F6463@portableinnovations.de" , "EF05B911-5728-47F4-AB13-F960FF2B21A4@portableinnovations.de" , "F379B44A-9B6F-47BD-95B0-9FC795BC035B@architechies.com" , "BB9D9FE2-F252-41F4-A3EA-2D8053A7579C@gmx.de" , "1F3D7F58-0EC6-4541-9734-A95CE62BAF6E@anandabits.com" , "2139FFE7-79C5-4981-A036-250F2D5EF0A4@ericasadun.com" , "24FE9022-00E3-459C-8A71-540BCF436286@apple.com" , "E904EA6A-6422-49F6-9C5E-07BCDC7D3543@gmx.de" , "98A80B8C-AC32-408D-AD8F-CDE0EB782B4C@apple.com" , "03F8648F-236A-46A5-8D21-CA066DBA1932@anandabits.com" , "D49345E8-5E22-46C8-9EF2-EF0DB4D32D87@apple.com" , "77AE5195-4E57-4814-A228-AF23723C853B@ericasadun.com" , "B818E6F9-1526-4725-BCDA-AB8C36F3CED7@maven.de" , "6A18AB5F-3794-42A6-8142-AAA7B2B61000@apple.com" , "9520AAC7-B49D-4CB7-96EE-E9891BAC9268@ericasadun.com" , "5981B70E-98D3-4A99-AF49-106254DFEB54@apple.com" , "86e837d7-cac3-438b-8297-4f6f401b641f@Spark" , "315B39D9-AE33-438B-8EFF-CC4796EECAAF@pobox.com" , "731CB499-F42F-45D4-8A3B-8D7B963D3709@monod-broca.fr" , "CADcs6kNOmo32YcBHOjmsV3eKiJ4yo0nDxz+5mjWNtp3JG0FsOA@mail.gmail.com" , "616C48D0-D626-487E-861C-CF125879BABB@ericasadun.com" , "3A77268A-D52E-4821-9488-671491506835@monod-broca.fr" , "B5AE3C08-FB9F-4024-B6BF-ECAADC1196E8@pobox.com" , "52D7FF3E-4E16-447D-AFCF-6915ABF999C1@gmx.de" , "98E5A56D-2912-4725-8E5E-14F25153B184@gmx.de" , "3C9B366C-D4A8-4777-8CF9-E46B52F806E2@pobox.com" , "0674FFD1-76FB-4376-9F34-0FF8B7560798@anandabits.com" , "5B0D18B8-0255-4F2E-86E3-253058585BDB@fifthace.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org"}} , "_id" : "6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org" , "from" : "swift-evolution at jacopo.giola.org (Jacopo Andrea Giola)" , "mailingList" : "swift-evolution" , "content" : "Yes, I’m aware that at this time the reswitch can be abused and maybe can be better refined to disallow such cases.\n\nChecking the case statement is not a problem by itself, but can be a problem if is coupled with a where clause that is not true when you fallthrought.\n\nI’ve written a really bad draft here https://gist.github.com/JGiola/f735212789bf2f697847 <https://gist.github.com/JGiola/f735212789bf2f697847>\nIf anyone wants to jump in and elaborate further is welcome. I will try to stay on par with this thread but I’m really bad at writing so every help is welcome.\n\nAnd if I remember correctly Daniel Jakult was the first one to made this proposal so if he wants to take on and then made the official proposal has every right to do so and I will be very glad if my gist can be a first reference :)\n\n- Jacopo\n\n> On 06 Dec 2015, at 21:52, Colin Barrett <colin at springsandstruts.com> wrote:\n> \n> Apologies, Jacopo, for missing the updated proposal, and thank you for your patience in summarizing it again.\n> \n> I’ve only glanced through it but my concern here is that it introduces a whole class of new and creative “foot-guns\" :) In particular, it allows this construction to loop arbitrarily and creatively, particularly in the case of associated values.\n> \n> I’m not sure why not checking the case statement is considered a problem for the fallthrough keyword. Assuming it’s impossible to fallthrough to a case that introduces binders (what would they be bound to?), and that this is statically checked (both of which seem reasonable assumptions to me, although if I’m wrong feel free to correct me), isn’t it the entire point of the fallthrough keyword that it skips checking the case statement? I can understand how that might be somewhat confusing (and perhaps it should be documented less prominently) but I’m not sure how it’s a *problem*, exactly...\n> \n> I think I’m still on the side of keeping fallthrough. What’s the downside of doing nothing? For instance in the case of ++ and -- those features complicate the design of a numerics library.\n> \n> Thanks,\n> -Colin\n> \n>> On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola <swift-evolution at jacopo.giola.org <mailto:swift-evolution at jacopo.giola.org>> wrote:\n>> \n>>  Hi Colin,\n>> \n>> the initial proposal was indeed to remove entirely the `fallthrough` keyword but many people expressed your similar concern and from that point the discussion was steered through an \"enhancement\" and better refinement of the keyword.\n>> \n>> The new idea is to substitute the old keyword with \"reswitch\" passing the desired new value on which the switch is applied.\n>> So something like this:\n>> \n>> switch (enum) {\n>> \tcase .One:\n>> \t\t// do something\n>> \t\treswitch .Two\n>> \tcase .Two:\n>> \t\t// do something else\n>> \tdefault:\n>> \t\t// and so one\n>> }\n>> \n>> This new behaviour, IMO, is better suited for Swift because is more declarative of the developer intent and doesn't carry over unintentional misbehaviour.\n>> Is more declarative because you are forced to state in which case you want to go, and even if the order of the switch’ cases will change in the future, you don't fall in the wrong case by mistake.\n>> \n>> switch (enum) {\n>> \tcase .One:\n>> \t\t// do something\n>> \t\treswitch .Two\n>> \tcase .OneAndAHalf\n>> \t\t// maybe this change is not made by you but by a messed up merge\n>> \tcase .Two:\n>> \t\t// do something else\n>> \tdefault:\n>> \t\t// and so one\n>> }\n>> \n>> In this case if you are using the fallthrough keyboard your code is now broken by accident, and depending on what are you trying to do inside the cases you can have a hidden bug that your tests are not seeing right away. \n>> \n>> Another advantage is that in this way you can made more cases fallthrough in the same one even if they are not one over each other\n>> \n>> switch (enum) {\n>> \tcase .One:\n>> \t\t// do something\n>> \t\treswitch .Two\n>> \tcase .OneAndAHalf\n>> \t\t// so something that you don’t want to do for .One\n>> \t\treswitch .Two\n>> \tcase .Two:\n>> \t\t// do something else that you may want to do for .One and .Two\n>> \tdefault:\n>> \t\t// and so one\n>> }\n>> \n>> I must say that this is a side effect that can be used to messed up the code flow in a way that is not intended, but is a new behaviour that gives more power to the switch statement.\n>> \n>> The reswitch keyword in addition is not a mere fallthrough on the new case without doing the optional checking attached to it, but is intended to be a new call and all the check are executed.\n>> \n>> switch (enum) {\n>> \tcase .One:\n>> \t\t// do something\n>> \t\tx = 0;\n>> \t\treswitch .Two\n>> \tcase .OneAndAHalf\n>> \t\t// so something that you don’t want to do for .One\n>> \t\treswitch .Two\n>> \tcase .Two where x > 0:\n>> \t\t// do something else that you may want to do for .One and .Two\n>> \t\telement = array[x]\n>> \tdefault:\n>> \t\t// and so one\n>> }\n>> (I’m going by memory and by writing this snippets in the mail app directly, so the code must be incorrect in the syntax and for this I’m sorry).\n>> \n>> In this case if enum is .One the only case that is executed is case .One and the code doesn’t fallthrough in the .Two case because we are made the where invalid by changing the x to a value less than 1.\n>> \n>> Now I don’t remember who was the first one who mede this proposal, and I don’t know if he is working on a first draft to lay down the things better, but for me this can be a nice improvement and a neat break with the C-switch behaviour that Swift has trying to change from the very first beta disallowing the implicit fallthrough.\n>> \n>> I can be completely wrong but I see the `fallthrough`keyword as a “temporary” implementation for ease the transition from Obj-C to Swift and is time to improve it and made the switch statement even more powerful.\n>> \n>> - Jacopo\n>> Sent from my iPad\n>> \n>> On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>> \n>>> tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.\n>>> \n>>> Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.\n>>> \n>>> I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)\n>>> \n>>> Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:\n>>> \n>>> https://gist.github.com/cbarrett/23b24a9fe76efdf006df <https://gist.github.com/cbarrett/23b24a9fe76efdf006df>\n>>> \n>>> This technique is very extensible — for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.\n>>> \n>>> Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type — low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.\n>>> \n>>> Thanks,\n>>> -Colin\n>>> \n>>>> On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>>> \n>>>> +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.\n>>>> \n>>>> If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don't introduce an infinite \"switch\" loop.\n>>>> \n>>>> Sent from my iPad\n>>>> \n>>>> On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>>> \n>>>>> Very much thinking out loud and not really the implications, I wonder if we might just use \"continue\" instead of \"reswitch\".\n>>>>> \n>>>>> I very much like specifying what case to fall through into, no matter how we spell it.\n>>>>> \n>>>>> - Steve\n>>>>> \n>>>>> On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>>>> \n>>>>>>> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>>>>>>> On Dec 4, 2015, at 11:37 PM, John Calsbeek <john.calsbeek+lists at gmail.com <mailto:john.calsbeek+lists at gmail.com>> wrote:\n>>>>>>>> `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.\n>>>>>>>> \n>>>>>>>> It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.\n>>>>>>> \n>>>>>>> Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.\n>>>>>>> \n>>>>>>> On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.\n>>>>>> \n>>>>>> Oh, I see that Joe already brought this up, spelled “reswitch”.\n>>>>>> \n>>>>>> John.\n>>>>>> \n>>>>>>> \n>>>>>>> John.\n>>>>>>> \n>>>>>>>> \n>>>>>>>> One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).\n>>>>>>>> \n>>>>>>>> switch op {\n>>>>>>>> case LOAD_INDIRECT:\n>>>>>>>>    in0 = memory[in1]\n>>>>>>>>    fallthrough\n>>>>>>>> case LOAD:\n>>>>>>>>    out0 = memory[in0]\n>>>>>>>> //...\n>>>>>>>> }\n>>>>>>>> \n>>>>>>>> I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.\n>>>>>>>> \n>>>>>>>> Cheers,\n>>>>>>>> John\n>>>>>>>> \n>>>>>>>>> On Dec 4, 2015, at 2:42 PM, John McCall <rjmccall at apple.com <mailto:rjmccall at apple.com>> wrote:\n>>>>>>>>> \n>>>>>>>>>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard <kevin at sb.org <mailto:kevin at sb.org>> wrote:\n>>>>>>>>>> It's not actually Duff's Device. Duff's Device relies on the fact that C switch statements don't actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it's a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.\n>>>>>>>>> \n>>>>>>>>> To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.\n>>>>>>>>> \n>>>>>>>>> But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.\n>>>>>>>>> \n>>>>>>>>> John.\n>>>>>>>>> \n>>>>>>>>>>  \n>>>>>>>>>> Steve's code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It's a good example of one of the uses of `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's Device in Swift.\n>>>>>>>>>>  \n>>>>>>>>>> -Kevin Ballard\n>>>>>>>>>>  \n>>>>>>>>>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:\n>>>>>>>>>>> Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.\n>>>>>>>>>>>  \n>>>>>>>>>>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:\n>>>>>>>>>>>>  \n>>>>>>>>>>>> Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it. \n>>>>>>>>>>>>  \n>>>>>>>>>>>> True fact: On all of gist.github.com <http://gist.github.com/>, there are only 22 gist results for \"fallthrough language:swift\".\n>>>>>>>>>>>> Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:\n>>>>>>>>>>>> case .Enum1, .Enum2:\n>>>>>>>>>>>> expressed as \n>>>>>>>>>>>> case .Enum1: fallthrough\n>>>>>>>>>>>> case .Enum2:\n>>>>>>>>>>>>  \n>>>>>>>>>>>> And then there's streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea <https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea>   I'm pretty sure that ponies were harmed in the production of whatever that last bit is.\n>>>>>>>>>>>>  \n>>>>>>>>>>>>  \n>>>>>>>>>>>>  \n>>>>>>>>>>>>  \n>>>>>>>>>>>>> On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com <mailto:jalkut at red-sweater.com> wrote:\n>>>>>>>>>>>>>  \n>>>>>>>>>>>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the \"fallthrough\" keyword from the language?\n>>>>>>>>>>>>>  \n>>>>>>>>>>>>> My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.\n>>>>>>>>>>>>>  \n>>>>>>>>>>>>> The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:\n>>>>>>>>>>>>>  \n>>>>>>>>>>>>> \"The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.\"\n>>>>>>>>>>>>>  \n>>>>>>>>>>>>> To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.\n>>>>>>>>>>>>>  \n>>>>>>>>>>>>> I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.\n>>>>>>>>>>>>>  \n>>>>>>>>>>>>> In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.\n>>>>>>>>>>>>>  \n>>>>>>>>>>>>> Thoughts?\n>>>>>>>>>>>>>  \n>>>>>>>>>>>>> Daniel\n>>>>>>>>>>>>>  \n>>>>>>>>>>>>> _______________________________________________\n>>>>>>>>>>>>> swift-evolution mailing list\n>>>>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>>>>>>>>> \n>>>>>>>>>>>>  \n>>>>>>>>>>>> \n>>>>>>>>>>>> _______________________________________________\n>>>>>>>>>>>> swift-evolution mailing list\n>>>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>>>>>>>> \n>>>>>>>>>>>  \n>>>>>>>>>>> \n>>>>>>>>>>> _______________________________________________\n>>>>>>>>>>> swift-evolution mailing list\n>>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>>>>>>>  \n>>>>>>>>>> \n>>>>>>>>>> _______________________________________________\n>>>>>>>>>> swift-evolution mailing list\n>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>>>>>> \n>>>>>>>>>  _______________________________________________\n>>>>>>>>> swift-evolution mailing list\n>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>>>>> \n>>>>>>>> _______________________________________________\n>>>>>>>> swift-evolution mailing list\n>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>>>> \n>>>>>>> \n>>>>>>> _______________________________________________\n>>>>>>> swift-evolution mailing list\n>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>>> \n>>>>>> \n>>>>>> _______________________________________________\n>>>>>> swift-evolution mailing list\n>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>> \n>>>>> _______________________________________________\n>>>>> swift-evolution mailing list\n>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>> \n>>>> _______________________________________________\n>>>> swift-evolution mailing list\n>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>> \n>>> \n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000653.html" , "inReplyTo" : "6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com" , "date" : { "$date" : 1449436481000} , "subject" : "[swift-evolution] Proposal: Remove the \"fallthrough\" keyword" , "references" : [ "3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com" , "AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com" , "8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com" , "1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com" , "02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com" , "E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com" , "444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com" , "EF1675F6-7918-4262-B535-696104BFC405@apple.com" , "CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com" , "D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org" , "071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com" , "CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org" , "6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com"] , "descendants" : [ "ECE284CE-EDE3-4071-ABB6-821820F1FC44@jacopo.giola.org" , "EF9FEF97-C7B8-4D54-B406-2B62FDD15B59@springsandstruts.com" , "98973CF0-B5A8-491F-A8D0-DA73456FF01B@jacopo.giola.org" , "CAKCGC8B0UPGUHeJ_1n8XsGoo+E6Anyj_+_R7WsT76rV1Q-qu2w@mail.gmail.com" , "E7877054-1CF7-4596-800A-0D3C578A0CF1@portableinnovations.de" , "CAKCGC8Cp52O7DX6wWSc3J6FR8Xmoo_WLBgjGBa6fSXzNHhdHEg@mail.gmail.com" , "D7B06EA6-A46C-4920-9E09-CB99B96242AA@jacopo.giola.org" , "1449442122.2380087.459714713.0AC4A201@webmail.messagingengine.com" , "D9340CB2-A696-478A-BAE7-F93ED39CB2DC@red-sweater.com" , "CEA837D7-E2B1-48DC-A53B-D216F96DD8DF@apple.com" , "2A8EA416-B4FF-45B3-9C6D-F94059151129@apple.com" , "82BBEAF7-A512-460A-998C-054AE6D70BEB@springsandstruts.com" , "9C8A3DCA-B80C-4D1F-9528-DD65C0020680@apple.com" , "CAKCGC8BL6SHkO0T_Rg6Ren-NfCLs+eGBb6Zm9aFuZ5rMkWJXtQ@mail.gmail.com" , "AC2407AD-ABFF-4657-A04C-F37E52466316@springsandstruts.com" , "1449524366.1229815.460824345.0E2309C2@webmail.messagingengine.com" , "1449524552.1230499.460828169.5289846B@webmail.messagingengine.com" , "6BABB1A5-55CD-43AF-8D5D-9758F55AD611@apple.com" , "266A61BA-1890-46D7-8969-4A0225EA60B4@springsandstruts.com" , "37FA3360-5F23-462D-BE9B-3743253D2693@apple.com" , "A56C416E-E246-44FC-A681-3DD66171DF30@springsandstruts.com" , "CADQN+5atyJ78vi0xssjOxh2ka_-jZTaO3ZabxFdY80YqJHFmxg@mail.gmail.com" , "CAKCGC8DHCxwtiU82CjxChc6PaiB495WOCJBP0iq04uw7iWcQmA@mail.gmail.com" , "CAKCGC8DbhMOX6bHtzXQcAhjHQSw1wSSoX-TBUtew0arWA=4pSw@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/1C7496F7-41F5-4F46-A8B7-889D4A9FC49B@gmail.com"}} , "_id" : "1C7496F7-41F5-4F46-A8B7-889D4A9FC49B@gmail.com" , "from" : "possen at gmail.com (Paul Ossenbruggen)" , "mailingList" : "swift-evolution" , "content" : "I agree that ? may imply optional, this may be similar to what you suggested, just filling in the example: Not sure parenthesis are better than braces though:\n\net myColor = match yourColor ( .Blue :  .Red, .Green: .Blue, .Red: .Green, default: .Yellow )\n\nlet myColor = match yourColor ( case .Blue : .Red; case .Green: .Blue;  case .Red: .Green; default: .Yellow )\n\nlet myColor = match yourColor (\n\tcase .Blue :  .Reds\n\tcase .Green: .Blue \n\tcase .Red: .Green\n\tdefault: .Yellow\n)\n\nlet myColor = match yourColor (\n\t.Blue :  .Reds\n\t.Green: .Blue \n\t.Red: .Green\n\tdefault: .Yellow\n)\n\nlet myColor = match boollCondition ( .Blue, .Red ) \n\n\n\n> On Dec 6, 2015, at 12:54 PM, Alex Lew <alexl.mail+swift at gmail.com> wrote:\n> \n> Hmm. Something about braces inside expressions just feels wrong to me.\n> \n> I also read switch? and if? as being some optional-related versions of switch and if. And I don't love putting the condition / value-to-switch-on before the keyword, if we're going to use a keyword.\n> \n> (Also: exhaustiveness checking could theoretically allow resolution of ambiguity in nested switch expressions. We would just have to require that as soon as you've exhausted all possibilities, you don't add more cases and the expression is over.)\n> \n> On Sun, Dec 6, 2015 at 3:46 PM, Paul Ossenbruggen <possen at gmail.com <mailto:possen at gmail.com>> wrote:\n> Yep probably does need braces: So for switch? if? suggestion i just made. \n> \n> let myColor = yourColor switch? { .Blue :  .Red, .Green: .Blue, .Red: .Green, default: .Yellow }\n> \n> let myColor = yourColor switch? { case .Blue : .Red; case .Green: .Blue;  case .Red: .Green; default: .Yellow }\n> \n> let myColor = yourColor switch? {\n> \tcase .Blue :  .Reds\n> \tcase .Green: .Blue \n> \tcase .Red: .Green\n> \tdefault: .Yellow\n> }\n> \n> let myColor = yourColor switch? {\n> \t.Blue :  .Reds\n> \t.Green: .Blue \n> \t.Red: .Green\n> \tdefault: .Yellow\n> }\n> \n> let myColor = condition if?  { .Blue; .Red }\n> \n> I don’t find that looks bad. \n> \n> - Paul \n> \n> \n>> On Dec 6, 2015, at 12:24 PM, Alex Lew via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>> \n>> Thanks for the feedback, Matthew. It's sensible to me to consider dropping the ternary operator. I like it because the analogy \"C's if is to Swift's if as C's ternary operator is to Swift's ternary operator\" is (sort of) satisfied. But it is also confusing, both for the reasons you mention, and because ? has other meanings in Swift:\n>> \n>>  // compiler error without space betw thatColor and ?\n>> let thisColor = thatColor? \n>>      case .Red: .Green\n>>      default: .Blue\n>> \n>> On the other hand, is it really worth it to have control flow expressions if they don't let your code look nicer?\n>> \n>> let thisColor = switch thatColor {\n>>      case .Red:\n>>           return .Green;\n>>      default:\n>>           return .Yellow;\n>> }\n>> \n>> really isn't much nicer than\n>> \n>> let thisColor: Color\n>> switch thatColor {\n>>      case .Red:\n>>           thisColor = .Green\n>>      default:\n>>           thisColor = .Yellow\n>> }\n>> \n>> Maybe we could do a compromise, something like\n>> \n>> let thisColor = switch thatColor\n>>      case .Red: .Green // must be an expression\n>>      default: .Yellow      // must be an expression\n>> \n>> Or we could introduce a new keyword? Like match:\n>> \n>> let thisColor = match thatColor\n>>       case .Red: .Green    // must be an expression\n>>       default: .Yellow         // must be an expression\n>> \n>> \n>> I sort of like the new-keyword approach, because even though this is similar to a switch, it's not a switch: there's no fallthrough, you can't put statements inside, etc.\n>> \n>> The problem with all these proposals:\n>> \n>> let thisColor = match thatColor\n>>      case .Red: match thatOtherColor\n>>                            case .Blue: .Green\n>>                            case .Pink: .Yellow\n>>                            default: .Orange\n>>      default: .Orange\n>> \n>> is ambiguous. (Does case .Pink match thatColor or thatOtherColor? We can know because of exhaustiveness checking, but this won't always work.) You could solve this problem either by using parentheses around the whole expression when necessary\n>> \n>> let thisColor = match thatColor\n>>      case .Red: (match thatOtherColor\n>>                            case .Blue: .Green\n>>                            case .Pink: .Yellow\n>>                            default: .Orange)\n>>      default: .Orange\n>> \n>> or by adding curly braces in again\n>> \n>> let thisColor = match thatColor {\n>>      case .Red: match thatOtherColor {\n>>                            case .Blue: .Green\n>>                            case .Pink: .Yellow\n>>                            default: .Orange\n>>                         }\n>>      default: .Orange\n>> }\n>> \n>> But that starts to look like switch again. (Of course, the best way to handle this is as a programmer is to just switch on the tuple (thatColor, thatOtherColor), but the language should allow for nested control expressions.)\n>> \n>> \n>> On Sun, Dec 6, 2015 at 2:48 PM, Matthew Johnson via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>> I am not a fan of this approach based on the ternary operator.  The ternary operator is already a bit of an anomaly in that all other operators are unary or binary and do not perform any control flow (beyond possibly short circuiting an autoclosure argument).\n>> \n>> I would much rather features that perform control flow continue to use keywords, but allow them to be expressions.  \n>> \n>> Once we have control flow expressions I would like to see the ternary operator removed from the language as it would no longer server a purpose.  Removing the ternary operator seems to fit nicely with the direction to remove some features that are carried over from C-based languages but don’t necessarily fit with the direction Swift is heading.\n>> \n>> \n>>> On Dec 6, 2015, at 1:19 PM, Kevin Lundberg via swift-evolution < swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>> \n>>> Ostensibly, case may not be necessary if you could delimit each case on one line with something (perhaps a comma, or something else if that would not fit well within the grammar): \n>>>  \n>>> let thisColor = thatColor ? .Blue: .Red, .Green: .Blue, .Red: .Green, default: .Yellow \n>>>  \n>>> On Sun, Dec 6, 2015, at 01:57 PM, Paul Ossenbruggen via swift-evolution wrote: \n>>>> I like this too, seems more powerful.  Also, would single line expressions be allowed?  If not would case be required for example: \n>>>>  \n>>>> let myFavoriteColor = yourFavoriteColor ? \n>>>>     case .Blue: .Red \n>>>>     case .Green: .Blue \n>>>>     case .Red: .Green \n>>>>     default: .Yellow \n>>>>  \n>>>>  \n>>>>> On Dec 6, 2015, at 9:11 AM, Sean Heber via swift-evolution < swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote: \n>>>>>  \n>>>>> I really like this train of thought. +1 \n>>>>>  \n>>>>> l8r \n>>>>> Sean \n>>>>>  \n>>>>> On Dec 6, 2015, at 11:02 AM, Alex Lew via swift-evolution < swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote: \n>>>>>> What if we left the if { ...} else { ... } syntax alone (as a statement), and updated the ternary expression to be a more general pattern matching expression (closer to \"switch\")? Something like \n>>>>>>  \n>>>>>> let x = condition ? \n>>>>>>    true: \"Hello\" \n>>>>>>    false: \"Goodbye\" \n>>>>>>  \n>>>>>> let x = optionalValue ? \n>>>>>>    .Some(let unwrapped): \"Hello, \\(unwrapped)\" \n>>>>>>    .None: \"To Whom It May Concern\" \n>>>>>>  \n>>>>>> let myFavoriteColor = yourFavoriteColor ? \n>>>>>>     .Blue: .Red \n>>>>>>     .Green: .Blue \n>>>>>>     .Red: .Green \n>>>>>>  \n>>>>>> let quadrant = (x, y) ? \n>>>>>>     let (x, y) where x < 50 && y < 50: \"top left\" \n>>>>>>     let (x, y) where x < 50 && y > 50: \"bottom left\" \n>>>>>>     let (x, y) where x > 50 && y < 50: \"top right\" \n>>>>>>     default: \"bottom right\" \n>>>>>>  \n>>>>>> The colon comes from the fact that this is sort of a light-weight expression-based \"switch\" statement, where each branch can only contain an expression, not a series of statements. \n>>>>>>  \n>>>>>> This is very similar to pattern matching expressions in languages like Haskell, ML, and Coq. \n>>>>>>  \n>>>>>> On Sun, Dec 6, 2015 at 11:25 AM, Thorsten Seitz <thorsten.seitz at web.de <mailto:thorsten.seitz at web.de>> wrote: \n>>>>>>  \n>>>>>>> Am 06.12.2015 um 01:28 schrieb Alex Lew via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>>: \n>>>>>>>  \n>>>>>>> I don't think you can just get rid of the if statement in favor of an expression. You still want to be able to do this: \n>>>>>>>  \n>>>>>>> if (condition) { \n>>>>>>>     funcWithSideEffectsThatReturnsInt() \n>>>>>>> } else { \n>>>>>>>     funcWithSideEffectsThatReturnsString() \n>>>>>>> } \n>>>>>>>  \n>>>>>>> but that's not a valid expression (what is its type?). \n>>>>>>  \n>>>>>>  \n>>>>>> That would actually be no problem if Swift’s type system would have union types (Ceylon has union and intersection types which are quite awesome and enable lots of nice things quite naturally, see http://ceylon-lang.org/documentation/1.2/tour/types/ <http://ceylon-lang.org/documentation/1.2/tour/types/>). \n>>>>>>  \n>>>>>> In that case the type of such an expression would just be the union of both types, which is written Int | String in Ceylon. \n>>>>>>  \n>>>>>>  \n>>>>>> -Thorsten \n>>>>>>  \n>>>>>>  \n>>>>>>  \n>>>>>> \n>>>>>> _______________________________________________ \n>>>>>> swift-evolution mailing list \n>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org> \n>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution> \n>>>>> _______________________________________________ \n>>>>> swift-evolution mailing list \n>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org> \n>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution> \n>>>> \n>>>> \n>>>> _______________________________________________ \n>>>> swift-evolution mailing list \n>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org> \n>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution> \n>>>  \n>>> _______________________________________________ \n>>> swift-evolution mailing list \n>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org> \n>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution> \n>> \n>> Untracked with Trackbuster <https://trackbuster.com/?sig>\n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>> \n>> \n>>  _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000654.html" , "inReplyTo" : "CAKCGC8AG8DS208+zXzu0mpjN62r1At8ro=FgjEevp-wr-5KtyA@mail.gmail.com" , "date" : { "$date" : 1449436640000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAKCGC8AG8DS208+zXzu0mpjN62r1At8ro=FgjEevp-wr-5KtyA@mail.gmail.com"] , "descendants" : [ "CAKCGC8AdPMD1ySZnucpn-kMpy-X4=O0Xhd6aoOazyr6SAmLLUA@mail.gmail.com" , "63E46D4F-9E50-4BD8-AB36-A4510BDFF4B0@gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/A56C416E-E246-44FC-A681-3DD66171DF30@springsandstruts.com"}} , "_id" : "A56C416E-E246-44FC-A681-3DD66171DF30@springsandstruts.com" , "from" : "colin at springsandstruts.com (Colin Barrett)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 6, 2015, at 4:14 PM, Jacopo Andrea Giola <swift-evolution at jacopo.giola.org> wrote:\n> \n> Yes, I’m aware that at this time the reswitch can be abused and maybe can be better refined to disallow such cases.\n\nI’m curious, how do you propose to do this?\n\n> Checking the case statement is not a problem by itself, but can be a problem if is coupled with a where clause that is not true when you fallthrought.\n\nIn your document you give the example:\n\n> case .Three where x > 0:\n\nNow I may be wrong but I feel as though most of the uses of where clauses are also ones that reference variables bound in a `case let`. For instance:\n\n> case .Four(x) where x > 0:\n\nIn that case, fallthrough would required to evaluating the case part anyway, as per my postulated rules below.\n\nIn any case, I appreciate you taking the time to discuss your proposal, even if I didn’t end up convinced. Thanks.\n\n-Colin\n\n> I’ve written a really bad draft here https://gist.github.com/JGiola/f735212789bf2f697847\n> If anyone wants to jump in and elaborate further is welcome. I will try to stay on par with this thread but I’m really bad at writing so every help is welcome.\n> \n> And if I remember correctly Daniel Jakult was the first one to made this proposal so if he wants to take on and then made the official proposal has every right to do so and I will be very glad if my gist can be a first reference :)\n> \n> - Jacopo\n> \n>> On 06 Dec 2015, at 21:52, Colin Barrett <colin at springsandstruts.com> wrote:\n>> \n>> Apologies, Jacopo, for missing the updated proposal, and thank you for your patience in summarizing it again.\n>> \n>> I’ve only glanced through it but my concern here is that it introduces a whole class of new and creative “foot-guns\" :) In particular, it allows this construction to loop arbitrarily and creatively, particularly in the case of associated values.\n>> \n>> I’m not sure why not checking the case statement is considered a problem for the fallthrough keyword. Assuming it’s impossible to fallthrough to a case that introduces binders (what would they be bound to?), and that this is statically checked (both of which seem reasonable assumptions to me, although if I’m wrong feel free to correct me), isn’t it the entire point of the fallthrough keyword that it skips checking the case statement? I can understand how that might be somewhat confusing (and perhaps it should be documented less prominently) but I’m not sure how it’s a *problem*, exactly...\n>> \n>> I think I’m still on the side of keeping fallthrough. What’s the downside of doing nothing? For instance in the case of ++ and -- those features complicate the design of a numerics library.\n>> \n>> Thanks,\n>> -Colin\n>> \n>>> On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola <swift-evolution at jacopo.giola.org> wrote:\n>>> \n>>>  Hi Colin,\n>>> \n>>> the initial proposal was indeed to remove entirely the `fallthrough` keyword but many people expressed your similar concern and from that point the discussion was steered through an \"enhancement\" and better refinement of the keyword.\n>>> \n>>> The new idea is to substitute the old keyword with \"reswitch\" passing the desired new value on which the switch is applied.\n>>> So something like this:\n>>> \n>>> switch (enum) {\n>>> \tcase .One:\n>>> \t\t// do something\n>>> \t\treswitch .Two\n>>> \tcase .Two:\n>>> \t\t// do something else\n>>> \tdefault:\n>>> \t\t// and so one\n>>> }\n>>> \n>>> This new behaviour, IMO, is better suited for Swift because is more declarative of the developer intent and doesn't carry over unintentional misbehaviour.\n>>> Is more declarative because you are forced to state in which case you want to go, and even if the order of the switch’ cases will change in the future, you don't fall in the wrong case by mistake.\n>>> \n>>> switch (enum) {\n>>> \tcase .One:\n>>> \t\t// do something\n>>> \t\treswitch .Two\n>>> \tcase .OneAndAHalf\n>>> \t\t// maybe this change is not made by you but by a messed up merge\n>>> \tcase .Two:\n>>> \t\t// do something else\n>>> \tdefault:\n>>> \t\t// and so one\n>>> }\n>>> \n>>> In this case if you are using the fallthrough keyboard your code is now broken by accident, and depending on what are you trying to do inside the cases you can have a hidden bug that your tests are not seeing right away. \n>>> \n>>> Another advantage is that in this way you can made more cases fallthrough in the same one even if they are not one over each other\n>>> \n>>> switch (enum) {\n>>> \tcase .One:\n>>> \t\t// do something\n>>> \t\treswitch .Two\n>>> \tcase .OneAndAHalf\n>>> \t\t// so something that you don’t want to do for .One\n>>> \t\treswitch .Two\n>>> \tcase .Two:\n>>> \t\t// do something else that you may want to do for .One and .Two\n>>> \tdefault:\n>>> \t\t// and so one\n>>> }\n>>> \n>>> I must say that this is a side effect that can be used to messed up the code flow in a way that is not intended, but is a new behaviour that gives more power to the switch statement.\n>>> \n>>> The reswitch keyword in addition is not a mere fallthrough on the new case without doing the optional checking attached to it, but is intended to be a new call and all the check are executed.\n>>> \n>>> switch (enum) {\n>>> \tcase .One:\n>>> \t\t// do something\n>>> \t\tx = 0;\n>>> \t\treswitch .Two\n>>> \tcase .OneAndAHalf\n>>> \t\t// so something that you don’t want to do for .One\n>>> \t\treswitch .Two\n>>> \tcase .Two where x > 0:\n>>> \t\t// do something else that you may want to do for .One and .Two\n>>> \t\telement = array[x]\n>>> \tdefault:\n>>> \t\t// and so one\n>>> }\n>>> (I’m going by memory and by writing this snippets in the mail app directly, so the code must be incorrect in the syntax and for this I’m sorry).\n>>> \n>>> In this case if enum is .One the only case that is executed is case .One and the code doesn’t fallthrough in the .Two case because we are made the where invalid by changing the x to a value less than 1.\n>>> \n>>> Now I don’t remember who was the first one who mede this proposal, and I don’t know if he is working on a first draft to lay down the things better, but for me this can be a nice improvement and a neat break with the C-switch behaviour that Swift has trying to change from the very first beta disallowing the implicit fallthrough.\n>>> \n>>> I can be completely wrong but I see the `fallthrough`keyword as a “temporary” implementation for ease the transition from Obj-C to Swift and is time to improve it and made the switch statement even more powerful.\n>>> \n>>> - Jacopo\n>>> Sent from my iPad\n>>> \n>>> On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution <swift-evolution at swift.org> wrote:\n>>> \n>>>> tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.\n>>>> \n>>>> Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.\n>>>> \n>>>> I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)\n>>>> \n>>>> Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:\n>>>> \n>>>> https://gist.github.com/cbarrett/23b24a9fe76efdf006df\n>>>> \n>>>> This technique is very extensible — for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.\n>>>> \n>>>> Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type — low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.\n>>>> \n>>>> Thanks,\n>>>> -Colin\n>>>> \n>>>>> On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution <swift-evolution at swift.org> wrote:\n>>>>> \n>>>>> +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.\n>>>>> \n>>>>> If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don't introduce an infinite \"switch\" loop.\n>>>>> \n>>>>> Sent from my iPad\n>>>>> \n>>>>> On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution <swift-evolution at swift.org> wrote:\n>>>>> \n>>>>>> Very much thinking out loud and not really the implications, I wonder if we might just use \"continue\" instead of \"reswitch\".\n>>>>>> \n>>>>>> I very much like specifying what case to fall through into, no matter how we spell it.\n>>>>>> \n>>>>>> - Steve\n>>>>>> \n>>>>>> On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution <swift-evolution at swift.org> wrote:\n>>>>>> \n>>>>>>>> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution <swift-evolution at swift.org> wrote:\n>>>>>>>>> On Dec 4, 2015, at 11:37 PM, John Calsbeek <john.calsbeek+lists at gmail.com> wrote:\n>>>>>>>>> `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.\n>>>>>>>>> \n>>>>>>>>> It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.\n>>>>>>>> \n>>>>>>>> Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.\n>>>>>>>> \n>>>>>>>> On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.\n>>>>>>> \n>>>>>>> Oh, I see that Joe already brought this up, spelled “reswitch”.\n>>>>>>> \n>>>>>>> John.\n>>>>>>> \n>>>>>>>> \n>>>>>>>> John.\n>>>>>>>> \n>>>>>>>>> \n>>>>>>>>> One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).\n>>>>>>>>> \n>>>>>>>>> switch op {\n>>>>>>>>> case LOAD_INDIRECT:\n>>>>>>>>>    in0 = memory[in1]\n>>>>>>>>>    fallthrough\n>>>>>>>>> case LOAD:\n>>>>>>>>>    out0 = memory[in0]\n>>>>>>>>> //...\n>>>>>>>>> }\n>>>>>>>>> \n>>>>>>>>> I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.\n>>>>>>>>> \n>>>>>>>>> Cheers,\n>>>>>>>>> John\n>>>>>>>>> \n>>>>>>>>>> On Dec 4, 2015, at 2:42 PM, John McCall <rjmccall at apple.com> wrote:\n>>>>>>>>>> \n>>>>>>>>>>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard <kevin at sb.org> wrote:\n>>>>>>>>>>> It's not actually Duff's Device. Duff's Device relies on the fact that C switch statements don't actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it's a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.\n>>>>>>>>>> \n>>>>>>>>>> To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.\n>>>>>>>>>> \n>>>>>>>>>> But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.\n>>>>>>>>>> \n>>>>>>>>>> John.\n>>>>>>>>>> \n>>>>>>>>>>>  \n>>>>>>>>>>> Steve's code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It's a good example of one of the uses of `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's Device in Swift.\n>>>>>>>>>>>  \n>>>>>>>>>>> -Kevin Ballard\n>>>>>>>>>>>  \n>>>>>>>>>>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:\n>>>>>>>>>>>> Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.\n>>>>>>>>>>>>  \n>>>>>>>>>>>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun <erica at ericasadun.com> wrote:\n>>>>>>>>>>>>>  \n>>>>>>>>>>>>> Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it. \n>>>>>>>>>>>>>  \n>>>>>>>>>>>>> True fact: On all of gist.github.com, there are only 22 gist results for \"fallthrough language:swift\".\n>>>>>>>>>>>>> Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:\n>>>>>>>>>>>>> case .Enum1, .Enum2:\n>>>>>>>>>>>>> expressed as \n>>>>>>>>>>>>> case .Enum1: fallthrough\n>>>>>>>>>>>>> case .Enum2:\n>>>>>>>>>>>>>  \n>>>>>>>>>>>>> And then there's streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea   I'm pretty sure that ponies were harmed in the production of whatever that last bit is.\n>>>>>>>>>>>>>  \n>>>>>>>>>>>>>  \n>>>>>>>>>>>>>  \n>>>>>>>>>>>>>  \n>>>>>>>>>>>>>> On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com wrote:\n>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the \"fallthrough\" keyword from the language?\n>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>> My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.\n>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>> The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:\n>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>> \"The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.\"\n>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>> To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.\n>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>> I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.\n>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>> In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.\n>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>> Thoughts?\n>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>> Daniel\n>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>> _______________________________________________\n>>>>>>>>>>>>>> swift-evolution mailing list\n>>>>>>>>>>>>>> swift-evolution at swift.org\n>>>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>>>>>>>>>>>  \n>>>>>>>>>>>>> \n>>>>>>>>>>>>> _______________________________________________\n>>>>>>>>>>>>> swift-evolution mailing list\n>>>>>>>>>>>>> swift-evolution at swift.org\n>>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>>>>>>>>>>  \n>>>>>>>>>>>> \n>>>>>>>>>>>> _______________________________________________\n>>>>>>>>>>>> swift-evolution mailing list\n>>>>>>>>>>>> swift-evolution at swift.org\n>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>>>>>>>>>  \n>>>>>>>>>>> \n>>>>>>>>>>> _______________________________________________\n>>>>>>>>>>> swift-evolution mailing list\n>>>>>>>>>>> swift-evolution at swift.org\n>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>>>>>>>> \n>>>>>>>>>>  _______________________________________________\n>>>>>>>>>> swift-evolution mailing list\n>>>>>>>>>> swift-evolution at swift.org\n>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>>>>>>> \n>>>>>>>>> \n>>>>>>>>> _______________________________________________\n>>>>>>>>> swift-evolution mailing list\n>>>>>>>>> swift-evolution at swift.org\n>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>>>>>> \n>>>>>>>> \n>>>>>>>> _______________________________________________\n>>>>>>>> swift-evolution mailing list\n>>>>>>>> swift-evolution at swift.org\n>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>>>>> \n>>>>>>> \n>>>>>>> _______________________________________________\n>>>>>>> swift-evolution mailing list\n>>>>>>> swift-evolution at swift.org\n>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>>>> \n>>>>>> _______________________________________________\n>>>>>> swift-evolution mailing list\n>>>>>> swift-evolution at swift.org\n>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>>> \n>>>>> _______________________________________________\n>>>>> swift-evolution mailing list\n>>>>> swift-evolution at swift.org\n>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>> \n>>>> \n>>>> _______________________________________________\n>>>> swift-evolution mailing list\n>>>> swift-evolution at swift.org\n>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>> \n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000655.html" , "inReplyTo" : "6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org" , "date" : { "$date" : 1449436984000} , "subject" : "[swift-evolution] Proposal: Remove the \"fallthrough\" keyword" , "references" : [ "3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com" , "AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com" , "8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com" , "1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com" , "02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com" , "E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com" , "444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com" , "EF1675F6-7918-4262-B535-696104BFC405@apple.com" , "CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com" , "D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org" , "071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com" , "CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org" , "6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com" , "6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org"] , "descendants" : [ "98973CF0-B5A8-491F-A8D0-DA73456FF01B@jacopo.giola.org" , "D7B06EA6-A46C-4920-9E09-CB99B96242AA@jacopo.giola.org" , "1449442122.2380087.459714713.0AC4A201@webmail.messagingengine.com" , "CEA837D7-E2B1-48DC-A53B-D216F96DD8DF@apple.com" , "CADQN+5atyJ78vi0xssjOxh2ka_-jZTaO3ZabxFdY80YqJHFmxg@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CADQN+5atyJ78vi0xssjOxh2ka_-jZTaO3ZabxFdY80YqJHFmxg@mail.gmail.com"}} , "_id" : "CADQN+5atyJ78vi0xssjOxh2ka_-jZTaO3ZabxFdY80YqJHFmxg@mail.gmail.com" , "from" : "dan.appel00 at gmail.com (Dan Appel)" , "mailingList" : "swift-evolution" , "content" : "For better or worse, I would like to note that `reswitch` is essentially a\nsafer `goto`, so keep in mind all the bad things that can be done with it.\n\nOn Sun, Dec 6, 2015 at 1:23 PM Colin Barrett via swift-evolution <\nswift-evolution at swift.org> wrote:\n\n>\n> > On Dec 6, 2015, at 4:14 PM, Jacopo Andrea Giola <\n> swift-evolution at jacopo.giola.org> wrote:\n> >\n> > Yes, I’m aware that at this time the reswitch can be abused and maybe\n> can be better refined to disallow such cases.\n>\n> I’m curious, how do you propose to do this?\n>\n> > Checking the case statement is not a problem by itself, but can be a\n> problem if is coupled with a where clause that is not true when you\n> fallthrought.\n>\n> In your document you give the example:\n>\n> > case .Three where x > 0:\n>\n> Now I may be wrong but I feel as though most of the uses of where clauses\n> are also ones that reference variables bound in a `case let`. For instance:\n>\n> > case .Four(x) where x > 0:\n>\n> In that case, fallthrough would required to evaluating the case part\n> anyway, as per my postulated rules below.\n>\n> In any case, I appreciate you taking the time to discuss your proposal,\n> even if I didn’t end up convinced. Thanks.\n>\n> -Colin\n>\n> > I’ve written a really bad draft here\n> https://gist.github.com/JGiola/f735212789bf2f697847\n> > If anyone wants to jump in and elaborate further is welcome. I will try\n> to stay on par with this thread but I’m really bad at writing so every help\n> is welcome.\n> >\n> > And if I remember correctly Daniel Jakult was the first one to made this\n> proposal so if he wants to take on and then made the official proposal has\n> every right to do so and I will be very glad if my gist can be a first\n> reference :)\n> >\n> > - Jacopo\n> >\n> >> On 06 Dec 2015, at 21:52, Colin Barrett <colin at springsandstruts.com>\n> wrote:\n> >>\n> >> Apologies, Jacopo, for missing the updated proposal, and thank you for\n> your patience in summarizing it again.\n> >>\n> >> I’ve only glanced through it but my concern here is that it introduces\n> a whole class of new and creative “foot-guns\" :) In particular, it allows\n> this construction to loop arbitrarily and creatively, particularly in the\n> case of associated values.\n> >>\n> >> I’m not sure why not checking the case statement is considered a\n> problem for the fallthrough keyword. Assuming it’s impossible to\n> fallthrough to a case that introduces binders (what would they be bound\n> to?), and that this is statically checked (both of which seem reasonable\n> assumptions to me, although if I’m wrong feel free to correct me), isn’t it\n> the entire point of the fallthrough keyword that it skips checking the case\n> statement? I can understand how that might be somewhat confusing (and\n> perhaps it should be documented less prominently) but I’m not sure how it’s\n> a *problem*, exactly...\n> >>\n> >> I think I’m still on the side of keeping fallthrough. What’s the\n> downside of doing nothing? For instance in the case of ++ and -- those\n> features complicate the design of a numerics library.\n> >>\n> >> Thanks,\n> >> -Colin\n> >>\n> >>> On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola <\n> swift-evolution at jacopo.giola.org> wrote:\n> >>>\n> >>>  Hi Colin,\n> >>>\n> >>> the initial proposal was indeed to remove entirely the `fallthrough`\n> keyword but many people expressed your similar concern and from that point\n> the discussion was steered through an \"enhancement\" and better refinement\n> of the keyword.\n> >>>\n> >>> The new idea is to substitute the old keyword with \"reswitch\" passing\n> the desired new value on which the switch is applied.\n> >>> So something like this:\n> >>>\n> >>> switch (enum) {\n> >>>     case .One:\n> >>>             // do something\n> >>>             reswitch .Two\n> >>>     case .Two:\n> >>>             // do something else\n> >>>     default:\n> >>>             // and so one\n> >>> }\n> >>>\n> >>> This new behaviour, IMO, is better suited for Swift because is more\n> declarative of the developer intent and doesn't carry over unintentional\n> misbehaviour.\n> >>> Is more declarative because you are forced to state in which case you\n> want to go, and even if the order of the switch’ cases will change in the\n> future, you don't fall in the wrong case by mistake.\n> >>>\n> >>> switch (enum) {\n> >>>     case .One:\n> >>>             // do something\n> >>>             reswitch .Two\n> >>>     case .OneAndAHalf\n> >>>             // maybe this change is not made by you but by a messed up\n> merge\n> >>>     case .Two:\n> >>>             // do something else\n> >>>     default:\n> >>>             // and so one\n> >>> }\n> >>>\n> >>> In this case if you are using the fallthrough keyboard your code is\n> now broken by accident, and depending on what are you trying to do inside\n> the cases you can have a hidden bug that your tests are not seeing right\n> away.\n> >>>\n> >>> Another advantage is that in this way you can made more cases\n> fallthrough in the same one even if they are not one over each other\n> >>>\n> >>> switch (enum) {\n> >>>     case .One:\n> >>>             // do something\n> >>>             reswitch .Two\n> >>>     case .OneAndAHalf\n> >>>             // so something that you don’t want to do for .One\n> >>>             reswitch .Two\n> >>>     case .Two:\n> >>>             // do something else that you may want to do for .One and\n> .Two\n> >>>     default:\n> >>>             // and so one\n> >>> }\n> >>>\n> >>> I must say that this is a side effect that can be used to messed up\n> the code flow in a way that is not intended, but is a new behaviour that\n> gives more power to the switch statement.\n> >>>\n> >>> The reswitch keyword in addition is not a mere fallthrough on the new\n> case without doing the optional checking attached to it, but is intended to\n> be a new call and all the check are executed.\n> >>>\n> >>> switch (enum) {\n> >>>     case .One:\n> >>>             // do something\n> >>>             x = 0;\n> >>>             reswitch .Two\n> >>>     case .OneAndAHalf\n> >>>             // so something that you don’t want to do for .One\n> >>>             reswitch .Two\n> >>>     case .Two where x > 0:\n> >>>             // do something else that you may want to do for .One and\n> .Two\n> >>>             element = array[x]\n> >>>     default:\n> >>>             // and so one\n> >>> }\n> >>> (I’m going by memory and by writing this snippets in the mail app\n> directly, so the code must be incorrect in the syntax and for this I’m\n> sorry).\n> >>>\n> >>> In this case if enum is .One the only case that is executed is case\n> .One and the code doesn’t fallthrough in the .Two case because we are made\n> the where invalid by changing the x to a value less than 1.\n> >>>\n> >>> Now I don’t remember who was the first one who mede this proposal, and\n> I don’t know if he is working on a first draft to lay down the things\n> better, but for me this can be a nice improvement and a neat break with the\n> C-switch behaviour that Swift has trying to change from the very first beta\n> disallowing the implicit fallthrough.\n> >>>\n> >>> I can be completely wrong but I see the `fallthrough`keyword as a\n> “temporary” implementation for ease the transition from Obj-C to Swift and\n> is time to improve it and made the switch statement even more powerful.\n> >>>\n> >>> - Jacopo\n> >>> Sent from my iPad\n> >>>\n> >>> On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution <\n> swift-evolution at swift.org> wrote:\n> >>>\n> >>>> tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us\n> anything; and has at least minimal utility, as I try to demonstrate.\n> >>>>\n> >>>> Apologies for jumping into this thread at an awkward point, but I’ve\n> only just now subscribed to this list.\n> >>>>\n> >>>> I think the fallthrough keyword is useful in certain circumstances.\n> I’ve also yet to see an example of where it creates a negative impact,\n> either in code, optimization, or what have you. Other than “It’s like\n> something in C, and C is old and busted” I’m unsure of the rationale for\n> removing it. (Feel free to point me in the right direction.)\n> >>>>\n> >>>> Consider the Planet enum from the documentation. One of the simplest\n> way to define the number of a planet (i.e. its 1-based index in the\n> ordering of planets wrt. distance from the sun) is using a switch and\n> fall-through:\n> >>>>\n> >>>> https://gist.github.com/cbarrett/23b24a9fe76efdf006df\n> >>>>\n> >>>> This technique is very extensible — for instance imagine computing\n> the force induced by the gravity of the other planets on a particular\n> planet. All that would need to change is the case statements.\n> >>>>\n> >>>> Yes, you could write this by putting the planets into a list and\n> mapping or folding (or looping) over that, but unless the compiler can\n> “unroll” that construct, you’re paying for an allocation simply bc of your\n> choice of control flow. But in fact, you could imagine generalizing this\n> construct into the implementation of fold for the Planet type —\n> low-overhead folds for monomorphic types seems like a pretty compelling an\n> natural use case for fallthrough to me.\n> >>>>\n> >>>> Thanks,\n> >>>> -Colin\n> >>>>\n> >>>>> On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution <\n> swift-evolution at swift.org> wrote:\n> >>>>>\n> >>>>> +1 for this idea, but I will prefer the reswitch keyword instead of\n> overloading continue with a new syntax.\n> >>>>>\n> >>>>> If this proposal is accepted, it must be coupled with a compiler\n> check that the reswitch statements don't introduce an infinite \"switch\"\n> loop.\n> >>>>>\n> >>>>> Sent from my iPad\n> >>>>>\n> >>>>> On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution <\n> swift-evolution at swift.org> wrote:\n> >>>>>\n> >>>>>> Very much thinking out loud and not really the implications, I\n> wonder if we might just use \"continue\" instead of \"reswitch\".\n> >>>>>>\n> >>>>>> I very much like specifying what case to fall through into, no\n> matter how we spell it.\n> >>>>>>\n> >>>>>> - Steve\n> >>>>>>\n> >>>>>> On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution <\n> swift-evolution at swift.org> wrote:\n> >>>>>>\n> >>>>>>>> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution <\n> swift-evolution at swift.org> wrote:\n> >>>>>>>>> On Dec 4, 2015, at 11:37 PM, John Calsbeek <\n> john.calsbeek+lists at gmail.com> wrote:\n> >>>>>>>>> `fallthrough` is conceptually similar to `goto` in that both\n> allow natural expression of concepts that exist at the instruction level\n> but are otherwise difficult to express with nested control structures.\n> `fallthrough` is perhaps slightly less objectionable because control flow\n> remains local, but it has a similar role.\n> >>>>>>>>>\n> >>>>>>>>> It is not particularly natural to write `switch` statements with\n> `fallthrough` in the reverse order that can be seen in Duff’s Device and\n> similar constructs (case 7 falls through to 6 which falls through to 5,\n> etc.). It’s just because you know for certain that all the code in case 6\n> would be duplicated in case 7, so 7 can transfer into 6 without a jump\n> instruction. Communicating that to the compiler without `fallthrough`\n> requires deeply nested `if`s.\n> >>>>>>>>\n> >>>>>>>> Right.  One idea that I’ve always had for “fallthrough” is that\n> we might parameterize it in the future; parameterized it would mean “repeat\n> the switch with this new value”, so that unparameterized fallthrough would\n> mean “repeat the switch with a notional value that ends up in the next\n> case”.  There’s a very common pattern in switches of deferring to another\n> case that I’ve always found very awkward to write in C, and while sometimes\n> there’s no choice but to extract a helper function, there’s a\n> still-fairly-structural code pattern here that I think we can sensibly\n> support.\n> >>>>>>>>\n> >>>>>>>> On the other hand, there’s an argument that this is an\n> inappropriate extension for “fallthrough” specifically, which is one reason\n> we’ve never pursued it.\n> >>>>>>>\n> >>>>>>> Oh, I see that Joe already brought this up, spelled “reswitch”.\n> >>>>>>>\n> >>>>>>> John.\n> >>>>>>>\n> >>>>>>>>\n> >>>>>>>> John.\n> >>>>>>>>\n> >>>>>>>>>\n> >>>>>>>>> One defense comes to mind: there is talk of Swift aiming at\n> systems programming. Is writing a threaded interpreter loop within the\n> potential scope of Swift? That’s a use case that could make use of both\n> `fallthrough` and `goto` (computed goto, really).\n> >>>>>>>>>\n> >>>>>>>>> switch op {\n> >>>>>>>>> case LOAD_INDIRECT:\n> >>>>>>>>>    in0 = memory[in1]\n> >>>>>>>>>    fallthrough\n> >>>>>>>>> case LOAD:\n> >>>>>>>>>    out0 = memory[in0]\n> >>>>>>>>> //...\n> >>>>>>>>> }\n> >>>>>>>>>\n> >>>>>>>>> I am personally interested in the prospect of a language that\n> can scale up to high-level concepts and down to “portable assembler,” but I\n> don’t know if that is the right direction for Swift’s evolution.\n> >>>>>>>>>\n> >>>>>>>>> Cheers,\n> >>>>>>>>> John\n> >>>>>>>>>\n> >>>>>>>>>> On Dec 4, 2015, at 2:42 PM, John McCall <rjmccall at apple.com>\n> wrote:\n> >>>>>>>>>>\n> >>>>>>>>>>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard <kevin at sb.org>\n> wrote:\n> >>>>>>>>>>> It's not actually Duff's Device. Duff's Device relies on the\n> fact that C switch statements don't actually introduce a new scope, and so\n> it overlaps a switch with a do-while loop. This lets it only test the\n> number of bytes once, to jump into the middle of the loop, and then it\n> switches over to a while loop that decrements a counter every 8\n> instructions. Basically, it's a trick for manual loop unrolling that deals\n> with non-multiple-of-8 counts efficiently.\n> >>>>>>>>>>\n> >>>>>>>>>> To be pedantic, C switch statements do introduce a new scope.\n> What Duff’s Device exploits is that switch is allowed to jump into (almost)\n> arbitrary scopes, and cases can appear anywhere recursively inside a switch.\n> >>>>>>>>>>\n> >>>>>>>>>> But your point that Swift’s switch requires cases to be at the\n> top level within a switch and thus prevents the use of Duff’s Device is\n> 100% correct.\n> >>>>>>>>>>\n> >>>>>>>>>> John.\n> >>>>>>>>>>\n> >>>>>>>>>>>\n> >>>>>>>>>>> Steve's code is also an example of manual loop unrolling that\n> deals with non-multiple-of-8 counts, but it has calculate the number of\n> bytes on every iteration instead of once. It's a good example of one of the\n> uses of `fallthrough`, it's just not Duff's Device. It's impossible to use\n> Duff's Device in Swift.\n> >>>>>>>>>>>\n> >>>>>>>>>>> -Kevin Ballard\n> >>>>>>>>>>>\n> >>>>>>>>>>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:\n> >>>>>>>>>>>> Streza’s source code is an example of Duff’s Device, which is\n> a big place where switch fallthrough is arguably the cleanest way to do\n> things and the reason why I’d personally prefer to keep it as part of the\n> language.\n> >>>>>>>>>>>>\n> >>>>>>>>>>>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun <\n> erica at ericasadun.com> wrote:\n> >>>>>>>>>>>>>\n> >>>>>>>>>>>>> Oh let it die, let it die. Any time I use fallthrough I find\n> myself re-factoring to stop using it.\n> >>>>>>>>>>>>>\n> >>>>>>>>>>>>> True fact: On all of gist.github.com, there are only 22\n> gist results for \"fallthrough language:swift\".\n> >>>>>>>>>>>>> Half of those are people just testing out the feature. Most\n> of the remaining ones are just complex cases:\n> >>>>>>>>>>>>> case .Enum1, .Enum2:\n> >>>>>>>>>>>>> expressed as\n> >>>>>>>>>>>>> case .Enum1: fallthrough\n> >>>>>>>>>>>>> case .Enum2:\n> >>>>>>>>>>>>>\n> >>>>>>>>>>>>> And then there's streza:\n> https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea   I'm pretty\n> sure that ponies were harmed in the production of whatever that last bit is.\n> >>>>>>>>>>>>>\n> >>>>>>>>>>>>>\n> >>>>>>>>>>>>>\n> >>>>>>>>>>>>>\n> >>>>>>>>>>>>>> On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com wrote:\n> >>>>>>>>>>>>>>\n> >>>>>>>>>>>>>> In the spirit of some other proposals that remove C or C++\n> style artifacts, what do folks think about the possibility of removing the\n> \"fallthrough\" keyword from the language?\n> >>>>>>>>>>>>>>\n> >>>>>>>>>>>>>> My understanding is this keyword is only used for the\n> archaic seeming purpose of perpetuating C-style fallthrough from one switch\n> statement to the subsequent one. The documentation hedges the use of this\n> keyword in forbidding terms that make it clear its use is not encouraged.\n> The presence of the keyword, while an improvement over C’s implicit\n> fallthrough, is a mark of inelegance on an otherwise well-designed,\n> opinionated implementation of swtich statements.\n> >>>>>>>>>>>>>>\n> >>>>>>>>>>>>>> The ugliness of fallthrough’s C-style behavior even demands\n> a caveat in the documentation:\n> >>>>>>>>>>>>>>\n> >>>>>>>>>>>>>> \"The fallthrough keyword does not check the case conditions\n> for the switch case that it causes execution to fall into. The fallthrough\n> keyword simply causes code execution to move directly to the statements\n> inside the next case (or default case) block, as in C’s standard switch\n> statement behavior.\"\n> >>>>>>>>>>>>>>\n> >>>>>>>>>>>>>> To my mind, the caveat explains just what is wrong with\n> fallthrough, both in C or Swift: coded that is clearly labeled with\n> deliberate conditions can nonetheless be reached.\n> >>>>>>>>>>>>>>\n> >>>>>>>>>>>>>> I quipped about this on Twitter, and the most common\n> pushback I got seemed to be from people who either did not know about\n> Swift’s support for comma-separated case statements, or harbored an\n> aesthetic preference for clustering such cases together with fallthrough\n> statements.\n> >>>>>>>>>>>>>>\n> >>>>>>>>>>>>>> In my opinion, unless somebody can think of a strong\n> defense for supporting intentional fallthrough in Swift, removing the\n> keyword would be a move in the direction of minimizing the language’s\n> complexity while also discouraging poor coding style in switch statements.\n> >>>>>>>>>>>>>>\n> >>>>>>>>>>>>>> Thoughts?\n> >>>>>>>>>>>>>>\n> >>>>>>>>>>>>>> Daniel\n> >>>>>>>>>>>>>>\n> >>>>>>>>>>>>>> _______________________________________________\n> >>>>>>>>>>>>>> swift-evolution mailing list\n> >>>>>>>>>>>>>> swift-evolution at swift.org\n> >>>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> >>>>>>>>>>>>>\n> >>>>>>>>>>>>>\n> >>>>>>>>>>>>> _______________________________________________\n> >>>>>>>>>>>>> swift-evolution mailing list\n> >>>>>>>>>>>>> swift-evolution at swift.org\n> >>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> >>>>>>>>>>>>\n> >>>>>>>>>>>>\n> >>>>>>>>>>>> _______________________________________________\n> >>>>>>>>>>>> swift-evolution mailing list\n> >>>>>>>>>>>> swift-evolution at swift.org\n> >>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> >>>>>>>>>>>\n> >>>>>>>>>>>\n> >>>>>>>>>>> _______________________________________________\n> >>>>>>>>>>> swift-evolution mailing list\n> >>>>>>>>>>> swift-evolution at swift.org\n> >>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> >>>>>>>>>>\n> >>>>>>>>>>  _______________________________________________\n> >>>>>>>>>> swift-evolution mailing list\n> >>>>>>>>>> swift-evolution at swift.org\n> >>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> >>>>>>>>>\n> >>>>>>>>>\n> >>>>>>>>> _______________________________________________\n> >>>>>>>>> swift-evolution mailing list\n> >>>>>>>>> swift-evolution at swift.org\n> >>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> >>>>>>>>\n> >>>>>>>>\n> >>>>>>>> _______________________________________________\n> >>>>>>>> swift-evolution mailing list\n> >>>>>>>> swift-evolution at swift.org\n> >>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> >>>>>>>\n> >>>>>>>\n> >>>>>>> _______________________________________________\n> >>>>>>> swift-evolution mailing list\n> >>>>>>> swift-evolution at swift.org\n> >>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> >>>>>>\n> >>>>>> _______________________________________________\n> >>>>>> swift-evolution mailing list\n> >>>>>> swift-evolution at swift.org\n> >>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> >>>>>\n> >>>>> _______________________________________________\n> >>>>> swift-evolution mailing list\n> >>>>> swift-evolution at swift.org\n> >>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> >>>>\n> >>>>\n> >>>> _______________________________________________\n> >>>> swift-evolution mailing list\n> >>>> swift-evolution at swift.org\n> >>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> >>\n> >\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n-- \nDan Appel" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000656.html" , "inReplyTo" : "A56C416E-E246-44FC-A681-3DD66171DF30@springsandstruts.com" , "date" : { "$date" : 1449437162000} , "subject" : "[swift-evolution] Proposal: Remove the \"fallthrough\" keyword" , "references" : [ "3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com" , "AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com" , "8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com" , "1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com" , "02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com" , "E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com" , "444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com" , "EF1675F6-7918-4262-B535-696104BFC405@apple.com" , "CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com" , "D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org" , "071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com" , "CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org" , "6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com" , "6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org" , "A56C416E-E246-44FC-A681-3DD66171DF30@springsandstruts.com"] , "descendants" : [ "98973CF0-B5A8-491F-A8D0-DA73456FF01B@jacopo.giola.org"]} , { "_links" : { "self" : { "href" : "/charter/emails/2F2A126F-228D-479F-99A1-C40B472BBD44@me.com"}} , "_id" : "2F2A126F-228D-479F-99A1-C40B472BBD44@me.com" , "from" : "a.michail at me.com (Amir Michail)" , "mailingList" : "swift-evolution" , "content" : "It’s very irritating trying to initialize a list of lists with static data and unpredictably encountering expression too complex errors.\n\nOne could then try to incrementally initialize such a list of lists with append for each row say.\n\nSuch initialization with simple 2d static data should never result in an expression too complex error." , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000657.html" , "date" : { "$date" : 1449437172000} , "subject" : "[swift-evolution] [Request] [Idea] Should be able to initialize list of lists with 2d static data without unexpected errors." , "references" : [ ""] , "inReplyTo" :  null  , "descendants" : [ "44256317-DBE6-428B-9E38-7410464FE58A@apple.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/75C3B397-E687-4D6A-A5E2-D918502E8484@ericasadun.com"}} , "_id" : "75C3B397-E687-4D6A-A5E2-D918502E8484@ericasadun.com" , "from" : "erica at ericasadun.com (Erica Sadun)" , "mailingList" : "swift-evolution" , "content" : "A slightly updated proposal write-up with everyone's feedback: https://gist.github.com/erica/56d533b75d0a36e3908f <https://gist.github.com/erica/56d533b75d0a36e3908f>\n\n\n> On Dec 6, 2015, at 2:13 PM, Tyler Fleming Cloutier <cloutiertyler at aol.com> wrote:\n> \n> \n>> Lowered Readability and Maintainability\n>> \n>> I have aesthetic reasons for disliking the for-loop. The C-style loop is harder to read especially for those not coming from C-style languages, easier to mess up at edge conditions, and is commonly used for side-effects which, in a language focused on safety, is not a feature to be encouraged. \n>> \n>> For example, one side effect that was mentioned on-list yesterday was the incrementor, which is guaranteed in C-style to execute late:\n>> Roland King writes:\n>> \n>> for var floatingThing = start ; floatingThing <= end ; floatingThing += delta\n>> {\n>> \t// more than a few lines of code with early escape continues\n>> }\n>> \n>> shows intent of the loop very clearly, start, condition and increment all together at the top, and however you loop you always execute the increment part of the statement. Convert that to a while(), if you have a continue in the body, you have a good chance of not incrementing at all, or duplicating the increment code before every continue. So you can’t always nicely turn for into while. I second the point below about the loop variable being local to the for as well, I also like that. \n>> \n>> Late incrementor management is a feature that can be mimicked with defer, as pointed out by several other list members.\n>> \n> \n> Defer wouldn’t accomplish the exact same behavior because it would run if an exception was thrown, which is not the same as the last clause of a for loop, but perhaps is close enough.\n> \n> The only other concern I would have is not being able to scope my variables to the loop. I didn’t see it addressed, but perhaps its not very important in the end anyway.\n> \n> Something like the following might be nice to scope the variable exclusively to the loop.\n> \n> for var x = 0 while (someCondition()) {\n> \t// code\n> }" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000658.html" , "inReplyTo" : "AD0908AC-1F8F-44A4-B059-8E811CE3D661@aol.com" , "date" : { "$date" : 1449437211000} , "subject" : "[swift-evolution] C-style For Loops" , "references" : [ "AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de" , "CAAcV4sZVC8M4yo+XEdWoGzKyG7rDYuy7ox=Rk3cdbXjFuSD4Sg@mail.gmail.com" , "40642775-F58D-49B0-9BF3-38913FD6924C@ericasadun.com" , "AD0908AC-1F8F-44A4-B059-8E811CE3D661@aol.com"] , "descendants" : [ "E332A59C-7036-42AB-A54A-BE0FE97766EA@aol.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAB8TY2OSDRXUcxtMj7-isuaRmkMXafwsxiquqzedxZ+A+0kyPw@mail.gmail.com"}} , "_id" : "CAB8TY2OSDRXUcxtMj7-isuaRmkMXafwsxiquqzedxZ+A+0kyPw@mail.gmail.com" , "from" : "jj at johanjensen.dk (Johan Jensen)" , "mailingList" : "swift-evolution" , "content" : "Well, it is possible to just add an extra scope around the variable and the\nloop:\n\ndo {\n    var i = 0\n    while i < 10 {\n        print(i)\n        i += 1\n    }\n}\n\n—Johan\n\nOn Sun, Dec 6, 2015 at 10:13 PM, Tyler Fleming Cloutier via swift-evolution\n<swift-evolution at swift.org> wrote:\n\n>\n> *Lowered Readability and Maintainability*\n>\n> I have aesthetic reasons for disliking the for-loop. The C-style loop is\n> harder to read especially for those not coming from C-style languages,\n> easier to mess up at edge conditions, and is commonly used for side-effects\n> which, in a language focused on safety, is not a feature to be encouraged.\n>\n> For example, one side effect that was mentioned on-list yesterday was the\n> incrementor, which is guaranteed in C-style to execute late:\n> Roland King writes:\n>\n>\n> for var floatingThing = start ; floatingThing <= end ; floatingThing +=\n> delta\n> {\n> // more than a few lines of code with early escape continues\n> }\n>\n> shows intent of the loop very clearly, start, condition and increment all\n> together at the top, and however you loop you always execute the increment\n> part of the statement. Convert that to a while(), if you have a continue in\n> the body, you have a good chance of not incrementing at all, or duplicating\n> the increment code before every continue. So you can’t always nicely turn\n> for into while. I second the point below about the loop variable being\n> local to the for as well, I also like that.\n>\n> Late incrementor management is a feature that can be mimicked with defer,\n> as pointed out by several other list members.\n>\n>\n>\n> Defer wouldn’t accomplish the exact same behavior because it would run if\n> an exception was thrown, which is not the same as the last clause of a for\n> loop, but perhaps is close enough.\n>\n> The only other concern I would have is not being able to scope my\n> variables to the loop. I didn’t see it addressed, but perhaps its not very\n> important in the end anyway.\n>\n> Something like the following might be nice to scope the variable\n> exclusively to the loop.\n>\n> for var x = 0 while (someCondition()) {\n> // code\n> }\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000659.html" , "inReplyTo" : "AD0908AC-1F8F-44A4-B059-8E811CE3D661@aol.com" , "date" : { "$date" : 1449437238000} , "subject" : "[swift-evolution] C-style For Loops" , "references" : [ "AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de" , "CAAcV4sZVC8M4yo+XEdWoGzKyG7rDYuy7ox=Rk3cdbXjFuSD4Sg@mail.gmail.com" , "40642775-F58D-49B0-9BF3-38913FD6924C@ericasadun.com" , "AD0908AC-1F8F-44A4-B059-8E811CE3D661@aol.com"] , "descendants" : [ "A3B09B02-2438-4658-8073-BEBA8F1A5441@aol.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAKCGC8DbhMOX6bHtzXQcAhjHQSw1wSSoX-TBUtew0arWA=4pSw@mail.gmail.com"}} , "_id" : "CAKCGC8DbhMOX6bHtzXQcAhjHQSw1wSSoX-TBUtew0arWA=4pSw@mail.gmail.com" , "from" : "alexl.mail+swift at gmail.com (Alex Lew)" , "mailingList" : "swift-evolution" , "content" : "It seems reswitch *should* be useable even in cases that aren't a simple\n\"goto\". Or am I missing something?\n\nFor instance, rewriting the example from earlier:\n\nswitch op {\ncase let .LOAD_INDIRECT(out, in):\n    reswitch(.LOAD(out, memory[in]))\ncase let .LOAD(out, in):\n    setReg(out, in)\n// ...\n}\n\nor, a switch that calculates whether some number n is in a Lisp-style list\nof numbers\n\nswitch lst {\ncase .Cons(let m, _) where m == n:\n     return true\ncase .Cons(_, let rest):\n    reswitch(rest)\ncase .Empty:\n     return false\n}\n\nI like reswitch: in some cases, the compiler could optimize to a\nfallthrough, and in others, you could actually re-switch. But maybe I'm\nmissing something.\n\nOn Sun, Dec 6, 2015 at 4:14 PM, Jacopo Andrea Giola via swift-evolution <\nswift-evolution at swift.org> wrote:\n\n> Yes, I’m aware that at this time the reswitch can be abused and maybe can\n> be better refined to disallow such cases.\n>\n> Checking the case statement is not a problem by itself, but can be a\n> problem if is coupled with a where clause that is not true when you\n> fallthrought.\n>\n> I’ve written a really bad draft here\n> https://gist.github.com/JGiola/f735212789bf2f697847\n> If anyone wants to jump in and elaborate further is welcome. I will try to\n> stay on par with this thread but I’m really bad at writing so every help is\n> welcome.\n>\n> And if I remember correctly Daniel Jakult was the first one to made this\n> proposal so if he wants to take on and then made the official proposal has\n> every right to do so and I will be very glad if my gist can be a first\n> reference :)\n>\n> - Jacopo\n>\n> On 06 Dec 2015, at 21:52, Colin Barrett < colin at springsandstruts.com>\n> wrote:\n>\n> Apologies, Jacopo, for missing the updated proposal, and thank you for\n> your patience in summarizing it again.\n>\n> I’ve only glanced through it but my concern here is that it introduces a\n> whole class of new and creative “foot-guns\" :) In particular, it allows\n> this construction to loop arbitrarily and creatively, particularly in the\n> case of associated values.\n>\n> I’m not sure why not checking the case statement is considered a problem\n> for the fallthrough keyword. Assuming it’s impossible to fallthrough to a\n> case that introduces binders (what would they be bound to?), and that this\n> is statically checked (both of which seem reasonable assumptions to me,\n> although if I’m wrong feel free to correct me), isn’t it the entire point\n> of the fallthrough keyword that it skips checking the case statement? I can\n> understand how that might be somewhat confusing (and perhaps it should be\n> documented less prominently) but I’m not sure how it’s a *problem*,\n> exactly...\n>\n> I think I’m still on the side of keeping fallthrough. What’s the downside\n> of doing nothing? For instance in the case of ++ and -- those features\n> complicate the design of a numerics library.\n>\n> Thanks,\n> -Colin\n>\n> On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola <\n> swift-evolution at jacopo.giola.org> wrote:\n>\n>  Hi Colin,\n>\n> the initial proposal was indeed to remove entirely the `fallthrough`\n> keyword but many people expressed your similar concern and from that point\n> the discussion was steered through an \"enhancement\" and better refinement\n> of the keyword.\n>\n> The new idea is to substitute the old keyword with \"reswitch\" passing the\n> desired new value on which the switch is applied.\n> So something like this:\n>\n> switch (enum) {\n> case .One:\n> // do something\n> reswitch .Two\n> case .Two:\n> // do something else\n> default:\n> // and so one\n> }\n>\n> This new behaviour, IMO, is better suited for Swift because is more\n> declarative of the developer intent and doesn't carry over unintentional\n> misbehaviour.\n> Is more declarative because you are forced to state in which case you want\n> to go, and even if the order of the switch’ cases will change in the\n> future, you don't fall in the wrong case by mistake.\n>\n> switch (enum) {\n> case .One:\n> // do something\n> reswitch .Two\n> case .OneAndAHalf\n> // maybe this change is not made by you but by a messed up merge\n> case .Two:\n> // do something else\n> default:\n> // and so one\n> }\n>\n> In this case if you are using the fallthrough keyboard your code is now\n> broken by accident, and depending on what are you trying to do inside the\n> cases you can have a hidden bug that your tests are not seeing right away.\n>\n> Another advantage is that in this way you can made more cases fallthrough\n> in the same one even if they are not one over each other\n>\n> switch (enum) {\n> case .One:\n> // do something\n> reswitch .Two\n> case .OneAndAHalf\n> // so something that you don’t want to do for .One\n> reswitch .Two\n> case .Two:\n> // do something else that you may want to do for .One and .Two\n> default:\n> // and so one\n> }\n>\n> I must say that this is a side effect that can be used to messed up the\n> code flow in a way that is not intended, but is a new behaviour that gives\n> more power to the switch statement.\n>\n> The reswitch keyword in addition is not a mere fallthrough on the new case\n> without doing the optional checking attached to it, but is intended to be a\n> new call and all the check are executed.\n>\n> switch (enum) {\n> case .One:\n> // do something\n> x = 0;\n> reswitch .Two\n> case .OneAndAHalf\n> // so something that you don’t want to do for .One\n> reswitch .Two\n> case .Two where x > 0:\n> // do something else that you may want to do for .One and .Two\n> element = array[x]\n> default:\n> // and so one\n> }\n> (I’m going by memory and by writing this snippets in the mail app\n> directly, so the code must be incorrect in the syntax and for this I’m\n> sorry).\n>\n> In this case if enum is .One the only case that is executed is case .One\n> and the code doesn’t fallthrough in the .Two case because we are made the\n> where invalid by changing the x to a value less than 1.\n>\n> Now I don’t remember who was the first one who mede this proposal, and I\n> don’t know if he is working on a first draft to lay down the things better,\n> but for me this can be a nice improvement and a neat break with the\n> C-switch behaviour that Swift has trying to change from the very first beta\n> disallowing the implicit fallthrough.\n>\n> I can be completely wrong but I see the `fallthrough`keyword as a\n> “temporary” implementation for ease the transition from Obj-C to Swift and\n> is time to improve it and made the switch statement even more powerful.\n>\n> - Jacopo\n> Sent from my iPad\n>\n> On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution <\n> swift-evolution at swift.org> wrote:\n>\n> tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us\n> anything; and has at least minimal utility, as I try to demonstrate.\n>\n> Apologies for jumping into this thread at an awkward point, but I’ve only\n> just now subscribed to this list.\n>\n> I think the fallthrough keyword is useful in certain circumstances. I’ve\n> also yet to see an example of where it creates a negative impact, either in\n> code, optimization, or what have you. Other than “It’s like something in C,\n> and C is old and busted” I’m unsure of the rationale for removing it. (Feel\n> free to point me in the right direction.)\n>\n> Consider the Planet enum from the documentation. One of the simplest way\n> to define the number of a planet (i.e. its 1-based index in the ordering of\n> planets wrt. distance from the sun) is using a switch and fall-through:\n>\n> https://gist.github.com/cbarrett/23b24a9fe76efdf006df\n>\n> This technique is very extensible — for instance imagine computing the\n> force induced by the gravity of the other planets on a particular planet.\n> All that would need to change is the case statements.\n>\n> Yes, you could write this by putting the planets into a list and mapping\n> or folding (or looping) over that, but unless the compiler can “unroll”\n> that construct, you’re paying for an allocation simply bc of your choice of\n> control flow. But in fact, you could imagine generalizing this construct\n> into the implementation of fold for the Planet type — low-overhead folds\n> for monomorphic types seems like a pretty compelling an natural use case\n> for fallthrough to me.\n>\n> Thanks,\n> -Colin\n>\n> On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution <\n> swift-evolution at swift.org> wrote:\n>\n> +1 for this idea, but I will prefer the reswitch keyword instead of\n> overloading continue with a new syntax.\n>\n> If this proposal is accepted, it must be coupled with a compiler check\n> that the reswitch statements don't introduce an infinite \"switch\" loop.\n>\n> Sent from my iPad\n>\n> On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution <\n> swift-evolution at swift.org> wrote:\n>\n> Very much thinking out loud and not really the implications, I wonder if\n> we might just use \"continue\" instead of \"reswitch\".\n>\n> I very much like specifying what case to fall through into, no matter how\n> we spell it.\n>\n> - Steve\n>\n> On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution <\n> swift-evolution at swift.org> wrote:\n>\n> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution <\n> swift-evolution at swift.org> wrote:\n>\n> On Dec 4, 2015, at 11:37 PM, John Calsbeek < john.calsbeek+lists at gmail.com>\n> wrote:\n> `fallthrough` is conceptually similar to `goto` in that both allow natural\n> expression of concepts that exist at the instruction level but are\n> otherwise difficult to express with nested control structures.\n> `fallthrough` is perhaps slightly less objectionable because control flow\n> remains local, but it has a similar role.\n>\n> It is not particularly natural to write `switch` statements with\n> `fallthrough` in the reverse order that can be seen in Duff’s Device and\n> similar constructs (case 7 falls through to 6 which falls through to 5,\n> etc.). It’s just because you know for certain that all the code in case 6\n> would be duplicated in case 7, so 7 can transfer into 6 without a jump\n> instruction. Communicating that to the compiler without `fallthrough`\n> requires deeply nested `if`s.\n>\n>\n> Right.  One idea that I’ve always had for “fallthrough” is that we might\n> parameterize it in the future; parameterized it would mean “repeat the\n> switch with this new value”, so that unparameterized fallthrough would mean\n> “repeat the switch with a notional value that ends up in the next case”.\n> There’s a very common pattern in switches of deferring to another case that\n> I’ve always found very awkward to write in C, and while sometimes there’s\n> no choice but to extract a helper function, there’s a\n> still-fairly-structural code pattern here that I think we can sensibly\n> support.\n>\n> On the other hand, there’s an argument that this is an inappropriate\n> extension for “fallthrough” specifically, which is one reason we’ve never\n> pursued it.\n>\n>\n> Oh, I see that Joe already brought this up, spelled “reswitch”.\n>\n> John.\n>\n>\n> John.\n>\n>\n> One defense comes to mind: there is talk of Swift aiming at systems\n> programming. Is writing a threaded interpreter loop within the potential\n> scope of Swift? That’s a use case that could make use of both `fallthrough`\n> and `goto` (computed goto, really).\n>\n> switch op {\n> case LOAD_INDIRECT:\n>    in0 = memory[in1]\n>    fallthrough\n> case LOAD:\n>    out0 = memory[in0]\n> //...\n> }\n>\n> I am personally interested in the prospect of a language that can scale up\n> to high-level concepts and down to “portable assembler,” but I don’t know\n> if that is the right direction for Swift’s evolution.\n>\n> Cheers,\n> John\n>\n> On Dec 4, 2015, at 2:42 PM, John McCall < rjmccall at apple.com> wrote:\n>\n> On Dec 4, 2015, at 2:33 PM, Kevin Ballard < kevin at sb.org> wrote:\n> It's not actually Duff's Device. Duff's Device relies on the fact that C\n> switch statements don't actually introduce a new scope, and so it overlaps\n> a switch with a do-while loop. This lets it only test the number of bytes\n> once, to jump into the middle of the loop, and then it switches over to a\n> while loop that decrements a counter every 8 instructions. Basically, it's\n> a trick for manual loop unrolling that deals with non-multiple-of-8 counts\n> efficiently.\n>\n>\n> To be pedantic, C switch statements do introduce a new scope.  What Duff’s\n> Device exploits is that switch is allowed to jump into (almost) arbitrary\n> scopes, and cases can appear anywhere recursively inside a switch.\n>\n> But your point that Swift’s switch requires cases to be at the top level\n> within a switch and thus prevents the use of Duff’s Device is 100% correct.\n>\n> John.\n>\n>\n> Steve's code is also an example of manual loop unrolling that deals with\n> non-multiple-of-8 counts, but it has calculate the number of bytes on every\n> iteration instead of once. It's a good example of one of the uses of\n> `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's\n> Device in Swift.\n>\n> -Kevin Ballard\n>\n> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:\n>\n> Streza’s source code is an example of Duff’s Device, which is a big place\n> where switch fallthrough is arguably the cleanest way to do things and the\n> reason why I’d personally prefer to keep it as part of the language.\n>\n>\n> On Dec 4, 2015, at 2:12 PM, Erica Sadun < erica at ericasadun.com> wrote:\n>\n> Oh let it die, let it die. Any time I use fallthrough I find myself\n> re-factoring to stop using it.\n>\n> *True fact*: On all of   gist.github.com, there are only 22 gist results\n> for \"fallthrough language:swift\".\n> Half of those are people just testing out the feature. Most of the\n> remaining ones are just complex cases:\n> *case .Enum1, .Enum2:*\n> expressed as\n> *case .Enum1: fallthrough*\n> *case .Enum2:*\n>\n> And then there's streza:\n> https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea    I'm pretty\n> sure that ponies were harmed in the production of whatever that last bit\n> is.\n>\n>\n>\n>\n>\n> On Dec 4, 2015, at 3:05 PM,   jalkut at red-sweater.com  wrote:\n>\n> In the spirit of some other proposals that remove C or C++ style\n> artifacts, what do folks think about the possibility of removing the\n> \"fallthrough\" keyword from the language?\n>\n> My understanding is this keyword is only used for the archaic seeming\n> purpose of perpetuating C-style fallthrough from one switch statement to\n> the subsequent one. The documentation hedges the use of this keyword in\n> forbidding terms that make it clear its use is not encouraged. The presence\n> of the keyword, while an improvement over C’s implicit fallthrough, is a\n> mark of inelegance on an otherwise well-designed, opinionated\n> implementation of swtich statements.\n>\n> The ugliness of fallthrough’s C-style behavior even demands a caveat in\n> the documentation:\n>\n> \"The fallthrough keyword does not check the case conditions for the switch\n> case that it causes execution to fall into. The fallthrough keyword simply\n> causes code execution to move directly to the statements inside the next\n> case (or default case) block, as in C’s standard switch statement\n> behavior.\"\n>\n> To my mind, the caveat explains just what is wrong with fallthrough, both\n> in C or Swift: coded that is clearly labeled with deliberate conditions can\n> nonetheless be reached.\n>\n> I quipped about this on Twitter, and the most common pushback I got seemed\n> to be from people who either did not know about Swift’s support for\n> comma-separated case statements, or harbored an aesthetic preference for\n> clustering such cases together with fallthrough statements.\n>\n> In my opinion, unless somebody can think of a strong defense for\n> supporting intentional fallthrough in Swift, removing the keyword would be\n> a move in the direction of minimizing the language’s complexity while also\n> discouraging poor coding style in switch statements.\n>\n> Thoughts?\n>\n> Daniel\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>\n>\n> *_______________________________________________*\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>\n>  _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>\n>\n> Untracked with Trackbuster <https://trackbuster.com/?sig>\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000660.html" , "inReplyTo" : "6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org" , "date" : { "$date" : 1449437285000} , "subject" : "[swift-evolution] Proposal: Remove the \"fallthrough\" keyword" , "references" : [ "3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com" , "AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com" , "8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com" , "1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com" , "02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com" , "E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com" , "444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com" , "EF1675F6-7918-4262-B535-696104BFC405@apple.com" , "CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com" , "D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org" , "071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com" , "CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org" , "6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com" , "6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org"] , "descendants" : [ "ECE284CE-EDE3-4071-ABB6-821820F1FC44@jacopo.giola.org" , "EF9FEF97-C7B8-4D54-B406-2B62FDD15B59@springsandstruts.com" , "CAKCGC8B0UPGUHeJ_1n8XsGoo+E6Anyj_+_R7WsT76rV1Q-qu2w@mail.gmail.com" , "E7877054-1CF7-4596-800A-0D3C578A0CF1@portableinnovations.de" , "CAKCGC8Cp52O7DX6wWSc3J6FR8Xmoo_WLBgjGBa6fSXzNHhdHEg@mail.gmail.com" , "CAKCGC8DHCxwtiU82CjxChc6PaiB495WOCJBP0iq04uw7iWcQmA@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAKCGC8AdPMD1ySZnucpn-kMpy-X4=O0Xhd6aoOazyr6SAmLLUA@mail.gmail.com"}} , "_id" : "CAKCGC8AdPMD1ySZnucpn-kMpy-X4=O0Xhd6aoOazyr6SAmLLUA@mail.gmail.com" , "from" : "alexl.mail+swift at gmail.com (Alex Lew)" , "mailingList" : "swift-evolution" , "content" : "To clarify, I would want parens around the entire expression (only when\nnecessary). So\n\nlet myColor = match yourColor\ncase .Blue :  .Red\ncase .Green: .Blue\ncase .Red: .Green\ndefault: .Yellow\n\nor\n\nlet myColor = match boolCondition\n  case true: .Blue\n  case false: .Red\n\nor\n\nlet myColor = match boolCondition\n  case true: (match yourColor\n                      case .Red: .Blue\n                      default: .Yellow)\n  case false: .Red\n\nBut I actually think that the parens are unnecessary, as long as we require\nmatches to be exhaustive and for there to be no unreachable cases.\n\nOn Sun, Dec 6, 2015 at 4:17 PM, Paul Ossenbruggen <possen at gmail.com> wrote:\n\n> I agree that ? may imply optional, this may be similar to what you\n> suggested, just filling in the example: Not sure parenthesis are better\n> than braces though:\n>\n> et myColor = match yourColor ( .Blue :  .Red, .Green: .Blue, .Red: .Green,\n> default: .Yellow )\n>\n> let myColor = match yourColor ( case .Blue : .Red; case .Green: .Blue;\n>  case .Red: .Green; default: .Yellow )\n>\n> let myColor = match yourColor (\n> case .Blue :  .Reds\n> case .Green: .Blue\n> case .Red: .Green\n> default: .Yellow\n> )\n>\n> let myColor = match yourColor (\n> .Blue :  .Reds\n> .Green: .Blue\n> .Red: .Green\n> default: .Yellow\n> )\n>\n> let myColor = match boollCondition ( .Blue, .Red )\n>\n>\n>\n> On Dec 6, 2015, at 12:54 PM, Alex Lew < alexl.mail+swift at gmail.com>\n> wrote:\n>\n> Hmm. Something about braces inside expressions just feels wrong to me.\n>\n> I also read switch? and if? as being some optional-related versions of\n> switch and if. And I don't love putting the condition / value-to-switch-on *before\n> *the keyword, if we're going to use a keyword.\n>\n> (Also: exhaustiveness checking *could *theoretically allow resolution of\n> ambiguity in nested switch expressions. We would just have to require that\n> as soon as you've exhausted all possibilities, you don't add more cases and\n> the expression is over.)\n>\n> On Sun, Dec 6, 2015 at 3:46 PM, Paul Ossenbruggen <possen at gmail.com>\n> wrote:\n>\n>> Yep probably does need braces: So for switch? if? suggestion i just\n>> made.\n>>\n>> let myColor = yourColor switch? { .Blue :  .Red, .Green: .Blue, .Red:\n>> .Green, default: .Yellow }\n>>\n>> let myColor = yourColor switch? { case .Blue : .Red; case .Green: .Blue;\n>>  case .Red: .Green; default: .Yellow }\n>>\n>> let myColor = yourColor switch? {\n>> case .Blue :  .Reds\n>> case .Green: .Blue\n>> case .Red: .Green\n>> default: .Yellow\n>> }\n>>\n>> let myColor = yourColor switch? {\n>> .Blue :  .Reds\n>> .Green: .Blue\n>> .Red: .Green\n>> default: .Yellow\n>> }\n>>\n>> let myColor = condition if?  { .Blue; .Red }\n>>\n>> I don’t find that looks bad.\n>>\n>> - Paul\n>>\n>>\n>> On Dec 6, 2015, at 12:24 PM, Alex Lew via swift-evolution <\n>> swift-evolution at swift.org> wrote:\n>>\n>> Thanks for the feedback, Matthew. It's sensible to me to consider\n>> dropping the ternary operator. I like it because the analogy \"C's if is to\n>> Swift's if as C's ternary operator is to Swift's ternary operator\" is (sort\n>> of) satisfied. But it is also confusing, both for the reasons you mention,\n>> and because ? has other meanings in Swift:\n>>\n>>  // compiler error without space betw thatColor and ?\n>> let thisColor = thatColor?\n>>      case .Red: .Green\n>>      default: .Blue\n>>\n>> On the other hand, is it really worth it to have control flow expressions\n>> if they don't let your code look nicer?\n>>\n>> let thisColor = switch thatColor {\n>>      case .Red:\n>>           return .Green;\n>>      default:\n>>           return .Yellow;\n>> }\n>>\n>> really isn't much nicer than\n>>\n>> let thisColor: Color\n>> switch thatColor {\n>>      case .Red:\n>>           thisColor = .Green\n>>      default:\n>>           thisColor = .Yellow\n>> }\n>>\n>> Maybe we could do a compromise, something like\n>>\n>> let thisColor = switch thatColor\n>>      case .Red: .Green // must be an expression\n>>      default: .Yellow      // must be an expression\n>>\n>> Or we could introduce a new keyword? Like   *match*:\n>>\n>> let thisColor = match thatColor\n>>       case .Red: .Green    // must be an expression\n>>       default: .Yellow         // must be an expression\n>>\n>>\n>> I sort of like the new-keyword approach, because even though this is\n>> similar to a switch, it's not a switch: there's no fallthrough, you can't\n>> put statements inside, etc.\n>>\n>> The problem with all these proposals:\n>>\n>> let thisColor = match thatColor\n>>      case .Red: match thatOtherColor\n>>                            case .Blue: .Green\n>>                            case .Pink: .Yellow\n>>                            default: .Orange\n>>      default: .Orange\n>>\n>> is ambiguous. (Does case .Pink match thatColor or thatOtherColor? We can\n>> know because of exhaustiveness checking, but this won't always work.) You\n>> could solve this problem either by using parentheses around the whole\n>> expression when necessary\n>>\n>> let thisColor = match thatColor\n>>      case .Red: (match thatOtherColor\n>>                            case .Blue: .Green\n>>                            case .Pink: .Yellow\n>>                            default: .Orange)\n>>      default: .Orange\n>>\n>> or by adding curly braces in again\n>>\n>> let thisColor = match thatColor {\n>>      case .Red: match thatOtherColor {\n>>                            case .Blue: .Green\n>>                            case .Pink: .Yellow\n>>                            default: .Orange\n>>                         }\n>>      default: .Orange\n>> }\n>>\n>> But that starts to look like switch again. (Of course, the best way to\n>> handle this is as a programmer is to just switch on the tuple (thatColor,\n>> thatOtherColor), but the language should allow for nested control\n>> expressions.)\n>>\n>>\n>> On Sun, Dec 6, 2015 at 2:48 PM, Matthew Johnson via swift-evolution   <\n>> swift-evolution at swift.org>  wrote:\n>>\n>>> I am not a fan of this approach based on the ternary operator.  The\n>>> ternary operator is already a bit of an anomaly in that all other operators\n>>> are unary or binary and do not perform any control flow (beyond possibly\n>>> short circuiting an autoclosure argument).\n>>>\n>>> I would much rather features that perform control flow continue to use\n>>> keywords, but allow them to be expressions.\n>>>\n>>> Once we have control flow expressions I would like to see the ternary\n>>> operator removed from the language as it would no longer server a purpose.\n>>> Removing the ternary operator seems to fit nicely with the direction to\n>>> remove some features that are carried over from C-based languages but don’t\n>>> necessarily fit with the direction Swift is heading.\n>>>\n>>>\n>>> On Dec 6, 2015, at 1:19 PM, Kevin Lundberg via swift-evolution <\n>>> swift-evolution at swift.org> wrote:\n>>>\n>>> Ostensibly, case may not be necessary if you could delimit each case on\n>>> one line with something (perhaps a comma, or something else if that would\n>>> not fit well within the grammar):\n>>>\n>>> let thisColor = thatColor ? .Blue: .Red, .Green: .Blue, .Red: .Green,\n>>> default: .Yellow\n>>>\n>>> On Sun, Dec 6, 2015, at 01:57 PM, Paul Ossenbruggen via swift-evolution\n>>> wrote:\n>>>\n>>> I like this too, seems more powerful.  Also, would single line\n>>> expressions be allowed?  If not would case be required for example:\n>>>\n>>> let myFavoriteColor = yourFavoriteColor ?\n>>>      case .Blue: .Red\n>>>      case .Green: .Blue\n>>>      case .Red: .Green\n>>>      default: .Yellow\n>>>\n>>>\n>>>\n>>> On Dec 6, 2015, at 9:11 AM, Sean Heber via swift-evolution <\n>>> swift-evolution at swift.org> wrote:\n>>>\n>>> I really like this train of thought. +1\n>>>\n>>> l8r\n>>> Sean\n>>>\n>>> On Dec 6, 2015, at 11:02 AM, Alex Lew via swift-evolution <\n>>> swift-evolution at swift.org> wrote:\n>>>\n>>> What if we left the if { ...} else { ... } syntax alone (as a\n>>> statement), and updated the ternary expression to be a more general pattern\n>>> matching expression (closer to \"switch\")? Something like\n>>>\n>>> let x = condition ?\n>>>    true: \"Hello\"\n>>>    false: \"Goodbye\"\n>>>\n>>> let x = optionalValue ?\n>>>    .Some(let unwrapped): \"Hello, \\(unwrapped)\"\n>>>    .None: \"To Whom It May Concern\"\n>>>\n>>> let myFavoriteColor = yourFavoriteColor ?\n>>>      .Blue: .Red\n>>>      .Green: .Blue\n>>>      .Red: .Green\n>>>\n>>> let quadrant = (x, y) ?\n>>>      let (x, y) where x < 50 && y < 50: \"top left\"\n>>>      let (x, y) where x < 50 && y > 50: \"bottom left\"\n>>>      let (x, y) where x > 50 && y < 50: \"top right\"\n>>>      default: \"bottom right\"\n>>>\n>>> The colon comes from the fact that this is sort of a light-weight\n>>> expression-based \"switch\" statement, where each branch can only contain an\n>>> expression, not a series of statements.\n>>>\n>>> This is very similar to pattern matching expressions in languages like\n>>> Haskell, ML, and Coq.\n>>>\n>>> On Sun, Dec 6, 2015 at 11:25 AM, Thorsten Seitz   <thorsten.seitz at web.de\n>>> >   wrote:\n>>>\n>>>\n>>>\n>>> Am 06.12.2015 um 01:28 schrieb Alex Lew via swift-evolution <\n>>> swift-evolution at swift.org>:\n>>>\n>>> I don't think you can just get rid of the if statement in favor of an\n>>> expression. You still want to be able to do this:\n>>>\n>>> if (condition) {\n>>>     funcWithSideEffectsThatReturnsInt()\n>>> } else {\n>>>     funcWithSideEffectsThatReturnsString()\n>>> }\n>>>\n>>> but that's not a valid expression (what is its type?).\n>>>\n>>>\n>>>\n>>> That would actually be no problem if Swift’s type system would have\n>>> union types (Ceylon has union and intersection types which are quite\n>>> awesome and enable lots of nice things quite naturally, see\n>>> http://ceylon-lang.org/documentation/1.2/tour/types/).\n>>>\n>>> In that case the type of such an expression would just be the union of\n>>> both types, which is written   Int | String   in Ceylon.\n>>>\n>>>\n>>> -Thorsten\n>>>\n>>>\n>>>\n>>>\n>>>\n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>\n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>\n>>>\n>>> *_______________________________________________*\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>\n>>>\n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>\n>>>\n>>> Untracked with   Trackbuster <https://trackbuster.com/?sig>\n>>>\n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>\n>>>\n>>  _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>\n>>\n>>\n>\n> Untracked with Trackbuster <https://trackbuster.com/?sig>\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000661.html" , "inReplyTo" : "1C7496F7-41F5-4F46-A8B7-889D4A9FC49B@gmail.com" , "date" : { "$date" : 1449437534000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAKCGC8AG8DS208+zXzu0mpjN62r1At8ro=FgjEevp-wr-5KtyA@mail.gmail.com" , "1C7496F7-41F5-4F46-A8B7-889D4A9FC49B@gmail.com"] , "descendants" : [ "63E46D4F-9E50-4BD8-AB36-A4510BDFF4B0@gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/E332A59C-7036-42AB-A54A-BE0FE97766EA@aol.com"}} , "_id" : "E332A59C-7036-42AB-A54A-BE0FE97766EA@aol.com" , "from" : "cloutiertyler at aol.com (Tyler Fleming Cloutier)" , "mailingList" : "swift-evolution" , "content" : "Cool! Thanks for updating the proposal with those concerns!\n\nOne thing though, could you possibly change\n\nfor var x = 0 while (someCondition()) {\nto be \nfor var x = 0 while someCondition() {\nin the gist?\n\nI accidentally threw and extra set of parenthesis in there. Old habits die hard.\n\nTyler\n\n\n\n> On Dec 6, 2015, at 1:26 PM, Erica Sadun via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> A slightly updated proposal write-up with everyone's feedback: https://gist.github.com/erica/56d533b75d0a36e3908f <https://gist.github.com/erica/56d533b75d0a36e3908f>\n> \n> \n>> On Dec 6, 2015, at 2:13 PM, Tyler Fleming Cloutier <cloutiertyler at aol.com <mailto:cloutiertyler at aol.com>> wrote:\n>> \n>> \n>>> Lowered Readability and Maintainability\n>>> \n>>> I have aesthetic reasons for disliking the for-loop. The C-style loop is harder to read especially for those not coming from C-style languages, easier to mess up at edge conditions, and is commonly used for side-effects which, in a language focused on safety, is not a feature to be encouraged. \n>>> \n>>> For example, one side effect that was mentioned on-list yesterday was the incrementor, which is guaranteed in C-style to execute late:\n>>> Roland King writes:\n>>> \n>>> for var floatingThing = start ; floatingThing <= end ; floatingThing += delta\n>>> {\n>>> \t// more than a few lines of code with early escape continues\n>>> }\n>>> \n>>> shows intent of the loop very clearly, start, condition and increment all together at the top, and however you loop you always execute the increment part of the statement. Convert that to a while(), if you have a continue in the body, you have a good chance of not incrementing at all, or duplicating the increment code before every continue. So you can’t always nicely turn for into while. I second the point below about the loop variable being local to the for as well, I also like that. \n>>> \n>>> Late incrementor management is a feature that can be mimicked with defer, as pointed out by several other list members.\n>>> \n>> \n>> Defer wouldn’t accomplish the exact same behavior because it would run if an exception was thrown, which is not the same as the last clause of a for loop, but perhaps is close enough.\n>> \n>> The only other concern I would have is not being able to scope my variables to the loop. I didn’t see it addressed, but perhaps its not very important in the end anyway.\n>> \n>> Something like the following might be nice to scope the variable exclusively to the loop.\n>> \n>> for var x = 0 while (someCondition()) {\n>> \t// code\n>> }\n> \n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000662.html" , "inReplyTo" : "75C3B397-E687-4D6A-A5E2-D918502E8484@ericasadun.com" , "date" : { "$date" : 1449437573000} , "subject" : "[swift-evolution] C-style For Loops" , "references" : [ "AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de" , "CAAcV4sZVC8M4yo+XEdWoGzKyG7rDYuy7ox=Rk3cdbXjFuSD4Sg@mail.gmail.com" , "40642775-F58D-49B0-9BF3-38913FD6924C@ericasadun.com" , "AD0908AC-1F8F-44A4-B059-8E811CE3D661@aol.com" , "75C3B397-E687-4D6A-A5E2-D918502E8484@ericasadun.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/A3B09B02-2438-4658-8073-BEBA8F1A5441@aol.com"}} , "_id" : "A3B09B02-2438-4658-8073-BEBA8F1A5441@aol.com" , "from" : "cloutiertyler at aol.com (Tyler Fleming Cloutier)" , "mailingList" : "swift-evolution" , "content" : "This is true. Kind of an unfortunate extra level of indention though.\n\n\n> On Dec 6, 2015, at 1:27 PM, Johan Jensen <jj at johanjensen.dk> wrote:\n> \n> Well, it is possible to just add an extra scope around the variable and the loop:\n> \n> do {\n>     var i = 0\n>     while i < 10 {\n>         print(i)\n>         i += 1\n>     }\n> }\n> \n> —Johan\n> \n> On Sun, Dec 6, 2015 at 10:13 PM, Tyler Fleming Cloutier via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n> \n>> Lowered Readability and Maintainability\n>> \n>> I have aesthetic reasons for disliking the for-loop. The C-style loop is harder to read especially for those not coming from C-style languages, easier to mess up at edge conditions, and is commonly used for side-effects which, in a language focused on safety, is not a feature to be encouraged. \n>> \n>> For example, one side effect that was mentioned on-list yesterday was the incrementor, which is guaranteed in C-style to execute late:\n>> Roland King writes:\n>> \n>> for var floatingThing = start ; floatingThing <= end ; floatingThing += delta\n>> {\n>> \t// more than a few lines of code with early escape continues\n>> }\n>> \n>> shows intent of the loop very clearly, start, condition and increment all together at the top, and however you loop you always execute the increment part of the statement. Convert that to a while(), if you have a continue in the body, you have a good chance of not incrementing at all, or duplicating the increment code before every continue. So you can’t always nicely turn for into while. I second the point below about the loop variable being local to the for as well, I also like that. \n>> \n>> Late incrementor management is a feature that can be mimicked with defer, as pointed out by several other list members.\n>> \n> \n> Defer wouldn’t accomplish the exact same behavior because it would run if an exception was thrown, which is not the same as the last clause of a for loop, but perhaps is close enough.\n> \n> The only other concern I would have is not being able to scope my variables to the loop. I didn’t see it addressed, but perhaps its not very important in the end anyway.\n> \n> Something like the following might be nice to scope the variable exclusively to the loop.\n> \n> for var x = 0 while (someCondition()) {\n> \t// code\n> }\n> \n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n> \n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000663.html" , "inReplyTo" : "CAB8TY2OSDRXUcxtMj7-isuaRmkMXafwsxiquqzedxZ+A+0kyPw@mail.gmail.com" , "date" : { "$date" : 1449437673000} , "subject" : "[swift-evolution] C-style For Loops" , "references" : [ "AAC47A16-00F9-40AA-8DFD-BD523EF6307B@gmx.de" , "CAAcV4sZVC8M4yo+XEdWoGzKyG7rDYuy7ox=Rk3cdbXjFuSD4Sg@mail.gmail.com" , "40642775-F58D-49B0-9BF3-38913FD6924C@ericasadun.com" , "AD0908AC-1F8F-44A4-B059-8E811CE3D661@aol.com" , "CAB8TY2OSDRXUcxtMj7-isuaRmkMXafwsxiquqzedxZ+A+0kyPw@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/07270E34-E284-4FF0-B2EA-6DBB54FF78B5@portableinnovations.de"}} , "_id" : "07270E34-E284-4FF0-B2EA-6DBB54FF78B5@portableinnovations.de" , "from" : "thorsten at portableinnovations.de (thorsten at portableinnovations.de)" , "mailingList" : "swift-evolution" , "content" : "I would prefer the expression to match the statement. The only difference would be that all parts that were statements now have to be expressions.\n\nTherefore the switch-expression should simply look like follows:\n\nlet thisColor = switch thatColor {\n         case .Red: .Green // must be an expression\n         default: .Yellow      // must be an expression\n     }\n\nNo returns needed in the case clauses.\nFormatting this as a one-liner would just require adding semicolons (though I wouldn't recommend this).\n\n-Thorsten" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000665.html" , "inReplyTo" : "CAKCGC8AVDe6W9X=XvFEnbkae8xom2Us8xczKFShqKu2+kPnRJA@mail.gmail.com" , "date" : { "$date" : 1449437728000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com" , "CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com" , "C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com" , "18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com" , "2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io" , "BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com" , "CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com" , "CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com" , "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com" , "BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com" , "909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net" , "0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com" , "49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net" , "CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com" , "49EEA2E6-55F2-49DE-A59F-A13017626370@web.de" , "CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com" , "4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com" , "1449429569.13426" , "23.459603529.32C935BC@webmail.messagingengine.com" , "11462DA4-ACDD-4CF3-BD57-47886B655970@anandabits.com" , "CAKCGC8AVDe6W9X=XvFEnbkae8xom2Us8xczKFShqKu2+kPnRJA@mail.gmail.com"] , "descendants" : [ "45B71AF5-DD4F-4E9C-A128-5B8041917564@me.com" , "CAKCGC8BmmCk55=6UC_qk_C+ZNq2JfGpOPO5cJ=SK2784kmvbGg@mail.gmail.com" , "B6DDD94B-0755-4D40-94F0-D2469A644818@portableinnovations.de" , "CAKCGC8AerqpPTrwdmPAvhmp-fLt-v=LXw4z0t+2o93g9GmAaxw@mail.gmail.com" , "54E5D8F5-616D-41EB-A550-E639FE861575@gmail.com" , "CAKCGC8CsJ7g_Fu8fnQ5Mv=yAzbSvb0Z+iNmdXKnJaAcWR2UKuw@mail.gmail.com" , "6830F74D-78FC-4B20-A6D5-683185B30164@gmail.com" , "691A92C4-1A5F-4CAE-AF50-F6AAA3A3F32C@portableinnovations.de" , "D35074A6-1C34-4BA3-AAF1-8CFE1992A522@me.com" , "1EE735A6-FF0F-4E49-BE7D-AC7E6C8A87EC@tarantsov.com" , "3D250DE5-09BC-4A6B-AF59-E1D714DF709A@tarantsov.com" , "BB6A4434-E2B1-4192-8450-90D636E6A7F5@fastmail.fm" , "0ED79E6D-A89A-4F3E-9269-6216BD10EB22@sealedabstract.com" , "CAAcV4sb9eMhuLGL3QsBw4bFxj1FQrokCAanKjEFRNNReE8zWOQ@mail.gmail.com" , "7253CF12-DBD4-483D-941F-04851E5AD394@tarantsov.com" , "CAAcV4sbo4=Hdzp+yx-km-CnhNDm2uQ-gDJsvdug_Pg-MjTPC=Q@mail.gmail.com" , "CAAcV4sbAk_eSdjz7bQ6ggdZNE+thmj7-wT_pG2+eRMKDVba+wA@mail.gmail.com" , "7B70F158-5B8A-425B-980C-CD08210342D4@me.com" , "6DA2FDFF-F978-4ECA-9E2B-F757F6D8BBF3@icloud.com" , "2116BFD1-25BC-4B9F-A3A6-08758782BB88@anandabits.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAKCGC8DHCxwtiU82CjxChc6PaiB495WOCJBP0iq04uw7iWcQmA@mail.gmail.com"}} , "_id" : "CAKCGC8DHCxwtiU82CjxChc6PaiB495WOCJBP0iq04uw7iWcQmA@mail.gmail.com" , "from" : "alexl.mail+swift at gmail.com (Alex Lew)" , "mailingList" : "swift-evolution" , "content" : "One question: what is the result of this code?\n\nlet x = .One\n\nswitch x {\ncase .One:\n   reswitch(.Two)\ncase .Two:\n   return x\n}\n\n.One or .Two? In other words, is x rebound inside the switch when we\nreswitch?\n\nOn Sun, Dec 6, 2015 at 4:28 PM, Alex Lew <alexl.mail+swift at gmail.com> wrote:\n\n> It seems reswitch *should* be useable even in cases that aren't a simple\n> \"goto\". Or am I missing something?\n>\n> For instance, rewriting the example from earlier:\n>\n> switch op {\n> case let .LOAD_INDIRECT(out, in):\n>     reswitch(.LOAD(out, memory[in]))\n> case let .LOAD(out, in):\n>     setReg(out, in)\n> // ...\n> }\n>\n> or, a switch that calculates whether some number n is in a Lisp-style list\n> of numbers\n>\n> switch lst {\n> case .Cons(let m, _) where m == n:\n>      return true\n> case .Cons(_, let rest):\n>     reswitch(rest)\n> case .Empty:\n>      return false\n> }\n>\n> I like reswitch: in some cases, the compiler could optimize to a\n> fallthrough, and in others, you could actually re-switch. But maybe I'm\n> missing something.\n>\n> On Sun, Dec 6, 2015 at 4:14 PM, Jacopo Andrea Giola via swift-evolution <\n> swift-evolution at swift.org> wrote:\n>\n>> Yes, I’m aware that at this time the reswitch can be abused and maybe can\n>> be better refined to disallow such cases.\n>>\n>> Checking the case statement is not a problem by itself, but can be a\n>> problem if is coupled with a where clause that is not true when you\n>> fallthrought.\n>>\n>> I’ve written a really bad draft here\n>> https://gist.github.com/JGiola/f735212789bf2f697847\n>> If anyone wants to jump in and elaborate further is welcome. I will try\n>> to stay on par with this thread but I’m really bad at writing so every help\n>> is welcome.\n>>\n>> And if I remember correctly Daniel Jakult was the first one to made this\n>> proposal so if he wants to take on and then made the official proposal has\n>> every right to do so and I will be very glad if my gist can be a first\n>> reference :)\n>>\n>> - Jacopo\n>>\n>> On 06 Dec 2015, at 21:52, Colin Barrett < colin at springsandstruts.com>\n>> wrote:\n>>\n>> Apologies, Jacopo, for missing the updated proposal, and thank you for\n>> your patience in summarizing it again.\n>>\n>> I’ve only glanced through it but my concern here is that it introduces a\n>> whole class of new and creative “foot-guns\" :) In particular, it allows\n>> this construction to loop arbitrarily and creatively, particularly in the\n>> case of associated values.\n>>\n>> I’m not sure why not checking the case statement is considered a problem\n>> for the fallthrough keyword. Assuming it’s impossible to fallthrough to a\n>> case that introduces binders (what would they be bound to?), and that this\n>> is statically checked (both of which seem reasonable assumptions to me,\n>> although if I’m wrong feel free to correct me), isn’t it the entire point\n>> of the fallthrough keyword that it skips checking the case statement? I can\n>> understand how that might be somewhat confusing (and perhaps it should be\n>> documented less prominently) but I’m not sure how it’s a *problem*,\n>> exactly...\n>>\n>> I think I’m still on the side of keeping fallthrough. What’s the downside\n>> of doing nothing? For instance in the case of ++ and -- those features\n>> complicate the design of a numerics library.\n>>\n>> Thanks,\n>> -Colin\n>>\n>> On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola <\n>> swift-evolution at jacopo.giola.org> wrote:\n>>\n>>  Hi Colin,\n>>\n>> the initial proposal was indeed to remove entirely the `fallthrough`\n>> keyword but many people expressed your similar concern and from that point\n>> the discussion was steered through an \"enhancement\" and better refinement\n>> of the keyword.\n>>\n>> The new idea is to substitute the old keyword with \"reswitch\" passing the\n>> desired new value on which the switch is applied.\n>> So something like this:\n>>\n>> switch (enum) {\n>> case .One:\n>> // do something\n>> reswitch .Two\n>> case .Two:\n>> // do something else\n>> default:\n>> // and so one\n>> }\n>>\n>> This new behaviour, IMO, is better suited for Swift because is more\n>> declarative of the developer intent and doesn't carry over unintentional\n>> misbehaviour.\n>> Is more declarative because you are forced to state in which case you\n>> want to go, and even if the order of the switch’ cases will change in the\n>> future, you don't fall in the wrong case by mistake.\n>>\n>> switch (enum) {\n>> case .One:\n>> // do something\n>> reswitch .Two\n>> case .OneAndAHalf\n>> // maybe this change is not made by you but by a messed up merge\n>> case .Two:\n>> // do something else\n>> default:\n>> // and so one\n>> }\n>>\n>> In this case if you are using the fallthrough keyboard your code is now\n>> broken by accident, and depending on what are you trying to do inside the\n>> cases you can have a hidden bug that your tests are not seeing right away.\n>>\n>> Another advantage is that in this way you can made more cases fallthrough\n>> in the same one even if they are not one over each other\n>>\n>> switch (enum) {\n>> case .One:\n>> // do something\n>> reswitch .Two\n>> case .OneAndAHalf\n>> // so something that you don’t want to do for .One\n>> reswitch .Two\n>> case .Two:\n>> // do something else that you may want to do for .One and .Two\n>> default:\n>> // and so one\n>> }\n>>\n>> I must say that this is a side effect that can be used to messed up the\n>> code flow in a way that is not intended, but is a new behaviour that gives\n>> more power to the switch statement.\n>>\n>> The reswitch keyword in addition is not a mere fallthrough on the new\n>> case without doing the optional checking attached to it, but is intended to\n>> be a new call and all the check are executed.\n>>\n>> switch (enum) {\n>> case .One:\n>> // do something\n>> x = 0;\n>> reswitch .Two\n>> case .OneAndAHalf\n>> // so something that you don’t want to do for .One\n>> reswitch .Two\n>> case .Two where x > 0:\n>> // do something else that you may want to do for .One and .Two\n>> element = array[x]\n>> default:\n>> // and so one\n>> }\n>> (I’m going by memory and by writing this snippets in the mail app\n>> directly, so the code must be incorrect in the syntax and for this I’m\n>> sorry).\n>>\n>> In this case if enum is .One the only case that is executed is case .One\n>> and the code doesn’t fallthrough in the .Two case because we are made the\n>> where invalid by changing the x to a value less than 1.\n>>\n>> Now I don’t remember who was the first one who mede this proposal, and I\n>> don’t know if he is working on a first draft to lay down the things better,\n>> but for me this can be a nice improvement and a neat break with the\n>> C-switch behaviour that Swift has trying to change from the very first beta\n>> disallowing the implicit fallthrough.\n>>\n>> I can be completely wrong but I see the `fallthrough`keyword as a\n>> “temporary” implementation for ease the transition from Obj-C to Swift and\n>> is time to improve it and made the switch statement even more powerful.\n>>\n>> - Jacopo\n>> Sent from my iPad\n>>\n>> On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution <\n>> swift-evolution at swift.org> wrote:\n>>\n>> tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us\n>> anything; and has at least minimal utility, as I try to demonstrate.\n>>\n>> Apologies for jumping into this thread at an awkward point, but I’ve only\n>> just now subscribed to this list.\n>>\n>> I think the fallthrough keyword is useful in certain circumstances. I’ve\n>> also yet to see an example of where it creates a negative impact, either in\n>> code, optimization, or what have you. Other than “It’s like something in C,\n>> and C is old and busted” I’m unsure of the rationale for removing it. (Feel\n>> free to point me in the right direction.)\n>>\n>> Consider the Planet enum from the documentation. One of the simplest way\n>> to define the number of a planet (i.e. its 1-based index in the ordering of\n>> planets wrt. distance from the sun) is using a switch and fall-through:\n>>\n>> https://gist.github.com/cbarrett/23b24a9fe76efdf006df\n>>\n>> This technique is very extensible — for instance imagine computing the\n>> force induced by the gravity of the other planets on a particular planet.\n>> All that would need to change is the case statements.\n>>\n>> Yes, you could write this by putting the planets into a list and mapping\n>> or folding (or looping) over that, but unless the compiler can “unroll”\n>> that construct, you’re paying for an allocation simply bc of your choice of\n>> control flow. But in fact, you could imagine generalizing this construct\n>> into the implementation of fold for the Planet type — low-overhead folds\n>> for monomorphic types seems like a pretty compelling an natural use case\n>> for fallthrough to me.\n>>\n>> Thanks,\n>> -Colin\n>>\n>> On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution <\n>> swift-evolution at swift.org> wrote:\n>>\n>> +1 for this idea, but I will prefer the reswitch keyword instead of\n>> overloading continue with a new syntax.\n>>\n>> If this proposal is accepted, it must be coupled with a compiler check\n>> that the reswitch statements don't introduce an infinite \"switch\" loop.\n>>\n>> Sent from my iPad\n>>\n>> On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution <\n>> swift-evolution at swift.org> wrote:\n>>\n>> Very much thinking out loud and not really the implications, I wonder if\n>> we might just use \"continue\" instead of \"reswitch\".\n>>\n>> I very much like specifying what case to fall through into, no matter how\n>> we spell it.\n>>\n>> - Steve\n>>\n>> On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution <\n>> swift-evolution at swift.org> wrote:\n>>\n>> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution <\n>> swift-evolution at swift.org> wrote:\n>>\n>> On Dec 4, 2015, at 11:37 PM, John Calsbeek <\n>> john.calsbeek+lists at gmail.com> wrote:\n>> `fallthrough` is conceptually similar to `goto` in that both allow\n>> natural expression of concepts that exist at the instruction level but are\n>> otherwise difficult to express with nested control structures.\n>> `fallthrough` is perhaps slightly less objectionable because control flow\n>> remains local, but it has a similar role.\n>>\n>> It is not particularly natural to write `switch` statements with\n>> `fallthrough` in the reverse order that can be seen in Duff’s Device and\n>> similar constructs (case 7 falls through to 6 which falls through to 5,\n>> etc.). It’s just because you know for certain that all the code in case 6\n>> would be duplicated in case 7, so 7 can transfer into 6 without a jump\n>> instruction. Communicating that to the compiler without `fallthrough`\n>> requires deeply nested `if`s.\n>>\n>>\n>> Right.  One idea that I’ve always had for “fallthrough” is that we might\n>> parameterize it in the future; parameterized it would mean “repeat the\n>> switch with this new value”, so that unparameterized fallthrough would mean\n>> “repeat the switch with a notional value that ends up in the next case”.\n>> There’s a very common pattern in switches of deferring to another case that\n>> I’ve always found very awkward to write in C, and while sometimes there’s\n>> no choice but to extract a helper function, there’s a\n>> still-fairly-structural code pattern here that I think we can sensibly\n>> support.\n>>\n>> On the other hand, there’s an argument that this is an inappropriate\n>> extension for “fallthrough” specifically, which is one reason we’ve never\n>> pursued it.\n>>\n>>\n>> Oh, I see that Joe already brought this up, spelled “reswitch”.\n>>\n>> John.\n>>\n>>\n>> John.\n>>\n>>\n>> One defense comes to mind: there is talk of Swift aiming at systems\n>> programming. Is writing a threaded interpreter loop within the potential\n>> scope of Swift? That’s a use case that could make use of both `fallthrough`\n>> and `goto` (computed goto, really).\n>>\n>> switch op {\n>> case LOAD_INDIRECT:\n>>    in0 = memory[in1]\n>>    fallthrough\n>> case LOAD:\n>>    out0 = memory[in0]\n>> //...\n>> }\n>>\n>> I am personally interested in the prospect of a language that can scale\n>> up to high-level concepts and down to “portable assembler,” but I don’t\n>> know if that is the right direction for Swift’s evolution.\n>>\n>> Cheers,\n>> John\n>>\n>> On Dec 4, 2015, at 2:42 PM, John McCall < rjmccall at apple.com> wrote:\n>>\n>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard < kevin at sb.org> wrote:\n>> It's not actually Duff's Device. Duff's Device relies on the fact that C\n>> switch statements don't actually introduce a new scope, and so it overlaps\n>> a switch with a do-while loop. This lets it only test the number of bytes\n>> once, to jump into the middle of the loop, and then it switches over to a\n>> while loop that decrements a counter every 8 instructions. Basically, it's\n>> a trick for manual loop unrolling that deals with non-multiple-of-8 counts\n>> efficiently.\n>>\n>>\n>> To be pedantic, C switch statements do introduce a new scope.  What\n>> Duff’s Device exploits is that switch is allowed to jump into (almost)\n>> arbitrary scopes, and cases can appear anywhere recursively inside a\n>> switch.\n>>\n>> But your point that Swift’s switch requires cases to be at the top level\n>> within a switch and thus prevents the use of Duff’s Device is 100% correct.\n>>\n>> John.\n>>\n>>\n>> Steve's code is also an example of manual loop unrolling that deals with\n>> non-multiple-of-8 counts, but it has calculate the number of bytes on every\n>> iteration instead of once. It's a good example of one of the uses of\n>> `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's\n>> Device in Swift.\n>>\n>> -Kevin Ballard\n>>\n>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:\n>>\n>> Streza’s source code is an example of Duff’s Device, which is a big place\n>> where switch fallthrough is arguably the cleanest way to do things and the\n>> reason why I’d personally prefer to keep it as part of the language.\n>>\n>>\n>> On Dec 4, 2015, at 2:12 PM, Erica Sadun < erica at ericasadun.com> wrote:\n>>\n>> Oh let it die, let it die. Any time I use fallthrough I find myself\n>> re-factoring to stop using it.\n>>\n>> *True fact*: On all of   gist.github.com, there are only 22 gist results\n>> for \"fallthrough language:swift\".\n>> Half of those are people just testing out the feature. Most of the\n>> remaining ones are just complex cases:\n>> *case .Enum1, .Enum2:*\n>> expressed as\n>> *case .Enum1: fallthrough*\n>> *case .Enum2:*\n>>\n>> And then there's streza:\n>> https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea    I'm pretty\n>> sure that ponies were harmed in the production of whatever that last bit\n>> is.\n>>\n>>\n>>\n>>\n>>\n>> On Dec 4, 2015, at 3:05 PM,   jalkut at red-sweater.com  wrote:\n>>\n>> In the spirit of some other proposals that remove C or C++ style\n>> artifacts, what do folks think about the possibility of removing the\n>> \"fallthrough\" keyword from the language?\n>>\n>> My understanding is this keyword is only used for the archaic seeming\n>> purpose of perpetuating C-style fallthrough from one switch statement to\n>> the subsequent one. The documentation hedges the use of this keyword in\n>> forbidding terms that make it clear its use is not encouraged. The presence\n>> of the keyword, while an improvement over C’s implicit fallthrough, is a\n>> mark of inelegance on an otherwise well-designed, opinionated\n>> implementation of swtich statements.\n>>\n>> The ugliness of fallthrough’s C-style behavior even demands a caveat in\n>> the documentation:\n>>\n>> \"The fallthrough keyword does not check the case conditions for the\n>> switch case that it causes execution to fall into. The fallthrough keyword\n>> simply causes code execution to move directly to the statements inside the\n>> next case (or default case) block, as in C’s standard switch statement\n>> behavior.\"\n>>\n>> To my mind, the caveat explains just what is wrong with fallthrough, both\n>> in C or Swift: coded that is clearly labeled with deliberate conditions can\n>> nonetheless be reached.\n>>\n>> I quipped about this on Twitter, and the most common pushback I got\n>> seemed to be from people who either did not know about Swift’s support for\n>> comma-separated case statements, or harbored an aesthetic preference for\n>> clustering such cases together with fallthrough statements.\n>>\n>> In my opinion, unless somebody can think of a strong defense for\n>> supporting intentional fallthrough in Swift, removing the keyword would be\n>> a move in the direction of minimizing the language’s complexity while also\n>> discouraging poor coding style in switch statements.\n>>\n>> Thoughts?\n>>\n>> Daniel\n>>\n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>\n>>\n>>\n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>\n>>\n>>\n>> *_______________________________________________*\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>\n>>\n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>\n>>\n>>  _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>\n>>\n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>\n>>\n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>\n>>\n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>\n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>\n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>\n>>\n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>\n>>\n>>\n>> Untracked with Trackbuster <https://trackbuster.com/?sig>\n>>\n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>\n>>\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000664.html" , "inReplyTo" : "CAKCGC8DbhMOX6bHtzXQcAhjHQSw1wSSoX-TBUtew0arWA=4pSw@mail.gmail.com" , "date" : { "$date" : 1449437761000} , "subject" : "[swift-evolution] Proposal: Remove the \"fallthrough\" keyword" , "references" : [ "3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com" , "AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com" , "8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com" , "1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com" , "02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com" , "E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com" , "444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com" , "EF1675F6-7918-4262-B535-696104BFC405@apple.com" , "CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com" , "D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org" , "071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com" , "CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org" , "6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com" , "6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org" , "CAKCGC8DbhMOX6bHtzXQcAhjHQSw1wSSoX-TBUtew0arWA=4pSw@mail.gmail.com"] , "descendants" : [ "ECE284CE-EDE3-4071-ABB6-821820F1FC44@jacopo.giola.org" , "EF9FEF97-C7B8-4D54-B406-2B62FDD15B59@springsandstruts.com" , "CAKCGC8B0UPGUHeJ_1n8XsGoo+E6Anyj_+_R7WsT76rV1Q-qu2w@mail.gmail.com" , "CAKCGC8Cp52O7DX6wWSc3J6FR8Xmoo_WLBgjGBa6fSXzNHhdHEg@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAA9p5uv=U-=kLi0PSn+9YSNvnfcn6oDEqOss1q1UjLn-sU9xUQ@mail.gmail.com"}} , "_id" : "CAA9p5uv=U-=kLi0PSn+9YSNvnfcn6oDEqOss1q1UjLn-sU9xUQ@mail.gmail.com" , "from" : "tmandry at gmail.com (Tyler Mandry)" , "mailingList" : "swift-evolution" , "content" : "What isn't clear to me from Chris's or John's comments is why the `if let x? = foo` syntax was taken away. Was it for backward-compatibility? To me, this syntax does have special syntactic support.\n\nFor example:\n\n```\nfunc doSomething<T? where T: Equatable>(x: T?) -> T { print(\"Hello\")\nx = x + 1\n}\n```\n\nYou said:\n>Note the T? in brackets. If I pass an Int? to doSomething, the type is\n>\"unwrapped\" and T becomes Int. It seems like `if let x? = foo` would follow\n>the same pattern.\n\nWas the syntax taken away for reasons unlikely to change, or is it up for discussion? :)\n\n-- \nTyler Mandry" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000666.html" , "date" : { "$date" : 1449437938000} , "subject" : "[swift-evolution] [Proposal] Optional Binding Shorthand Syntax" , "references" : [ ""] , "inReplyTo" :  null  , "descendants" : [ "CAA9p5uv3WeXTKsuAg=H4h=sd0C23WTOwhuLLe=PkwEGM4Hvwxg@mail.gmail.com" , "CAKCGC8AjTGQRer0paqVGnbt4qR3M=T_95hTw44CF6QXQmzV1oQ@mail.gmail.com" , "CA66BF95-1A27-4B02-AE21-840DDEC185C0@apple.com" , "CAA9p5uvdrk_QnRtpm6gu1hKUMZaXsbV-VXY5xpUYSc4XMuxbsQ@mail.gmail.com" , "226B86CA-EFD5-4503-B1C1-2E242E64D107@apple.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAKCGC8AjTGQRer0paqVGnbt4qR3M=T_95hTw44CF6QXQmzV1oQ@mail.gmail.com"}} , "_id" : "CAKCGC8AjTGQRer0paqVGnbt4qR3M=T_95hTw44CF6QXQmzV1oQ@mail.gmail.com" , "from" : "alexl.mail+swift at gmail.com (Alex Lew)" , "mailingList" : "swift-evolution" , "content" : "let a: Int? = 3\nif case let b? = a {\n    print(b)\n}\n\nworks for me in Swift 2.2. Have they announced that they're taking this\naway?\n\n\nOn Sun, Dec 6, 2015 at 4:38 PM, Tyler Mandry via swift-evolution <\nswift-evolution at swift.org> wrote:\n\n> What isn't clear to me from Chris's or John's comments is why the `if let\n> x? = foo` syntax was taken away. Was it for backward-compatibility? To me,\n> this syntax does have special syntactic support, and also seems to make it\n> clearer what's going on. It's also analogous to Swift's type inference for\n> generic <T?> types, for example:\n>\n>    func doSomething<T? where T: Equatable>(x: T?) -> T { ... }\n>\n> Note the T? in brackets. If I pass an Int? to doSomething, the type is\n> \"unwrapped\" and T becomes Int. It seems like `if let x? = foo` would follow\n> the same pattern.\n>\n> Was the syntax taken away for reasons unlikely to change, or is it up for\n> discussion? :)\n>\n> --\n> Tyler Mandry\n>\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000667.html" , "inReplyTo" : "CAA9p5uv=U-=kLi0PSn+9YSNvnfcn6oDEqOss1q1UjLn-sU9xUQ@mail.gmail.com" , "date" : { "$date" : 1449438193000} , "subject" : "[swift-evolution] Proposal: Optional Binding Shorthand Syntax" , "references" : [ "CAA9p5uv=U-=kLi0PSn+9YSNvnfcn6oDEqOss1q1UjLn-sU9xUQ@mail.gmail.com"] , "descendants" : [ "CAA9p5uv3WeXTKsuAg=H4h=sd0C23WTOwhuLLe=PkwEGM4Hvwxg@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/67057217-F4BC-4584-8B52-8EBA2CFA8CC7@portableinnovations.de"}} , "_id" : "67057217-F4BC-4584-8B52-8EBA2CFA8CC7@portableinnovations.de" , "from" : "thorsten at portableinnovations.de (thorsten at portableinnovations.de)" , "mailingList" : "swift-evolution" , "content" : "I strongly dislike the one liner with only punctuation to separate the cases because it is very difficult to spot the pairs.\n\nI fail to see why we have to have new syntax for the expression case. \n\n-Thorsten \n\n> Am 06.12.2015 um 21:30 schrieb Paul Ossenbruggen via swift-evolution <swift-evolution at swift.org>:\n> \n> let myColor = yourColor switch? .Blue :  .Red, .Green: .Blue, .Red: .Green, default: .Yellow" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000668.html" , "inReplyTo" : "4A5C6452-0A1B-42A3-AFD4-3DEA04E310C6@icloud.com" , "date" : { "$date" : 1449438233000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com" , "CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com" , "C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com" , "18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com" , "2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io" , "BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com" , "CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com" , "CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com" , "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com" , "BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com" , "909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net" , "0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com" , "49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net" , "CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com" , "49EEA2E6-55F2-49DE-A59F-A13017626370@web.de" , "CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com" , "4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com" , "7D68F57E-C847-4E" , "0D-AF3A-" , "FD1F2DC928A9@icloud.com" , "1449429569.1342623.459603529.32C935BC@webmail.messagingengine.com" , "11462DA4-ACDD-4CF3-BD57-47886B655970@anandabits.com" , "4A5C6452-0A1B-42A3-AFD4-3DEA04E310C6@icloud.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/45B71AF5-DD4F-4E9C-A128-5B8041917564@me.com"}} , "_id" : "45B71AF5-DD4F-4E9C-A128-5B8041917564@me.com" , "from" : "salutis at me.com (Rudolf Adamkovic)" , "mailingList" : "swift-evolution" , "content" : "> On 06 Dec 2015, at 22:35, thorsten--- via swift-evolution <swift-evolution at swift.org> wrote:\n\n> \n> I would prefer the expression to match the statement. The only difference would be that all parts that were statements now have to be expressions.\n\n+1\n\n> \n> Therefore the switch-expression should simply look like follows:\n> \n> let thisColor = switch thatColor {\n>         case .Red: .Green // must be an expression\n>         default: .Yellow      // must be an expression\n>     }\n> \n> No returns needed in the case clauses.\n\nThis actually looks great. One simple rule and zero new keywords.\n\nReadable and simple to learn.\n\nFantastic!\n\n> Formatting this as a one-liner would just require adding semicolons (though I wouldn't recommend this).\n> \n> -Thorsten\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000669.html" , "inReplyTo" : "07270E34-E284-4FF0-B2EA-6DBB54FF78B5@portableinnovations.de" , "date" : { "$date" : 1449438261000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com" , "CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com" , "C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com" , "18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com" , "2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io" , "BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com" , "CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com" , "CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com" , "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com" , "BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com" , "909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net" , "0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com" , "49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net" , "CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com" , "49EEA2E6-55F2-49DE-A59F-A13017626370@web.de" , "CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com" , "4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com" , "\"1449429569.13426" , "23.459603529.32C935BC\"@webmail.messagingengine.com" , "11462DA4-ACDD-4CF3-BD57-47886B655970@anandabits.com" , "CAKCGC8AVDe6W9X=XvFEnbkae8xom2Us8xczKFShqKu2+kPnRJA@mail.gmail.com" , "07270E34-E284-4FF0-B2EA-6DBB54FF78B5@portableinnovations.de"] , "descendants" : [ "CAKCGC8BmmCk55=6UC_qk_C+ZNq2JfGpOPO5cJ=SK2784kmvbGg@mail.gmail.com" , "B6DDD94B-0755-4D40-94F0-D2469A644818@portableinnovations.de" , "CAKCGC8AerqpPTrwdmPAvhmp-fLt-v=LXw4z0t+2o93g9GmAaxw@mail.gmail.com" , "54E5D8F5-616D-41EB-A550-E639FE861575@gmail.com" , "CAKCGC8CsJ7g_Fu8fnQ5Mv=yAzbSvb0Z+iNmdXKnJaAcWR2UKuw@mail.gmail.com" , "6830F74D-78FC-4B20-A6D5-683185B30164@gmail.com" , "691A92C4-1A5F-4CAE-AF50-F6AAA3A3F32C@portableinnovations.de" , "D35074A6-1C34-4BA3-AAF1-8CFE1992A522@me.com" , "1EE735A6-FF0F-4E49-BE7D-AC7E6C8A87EC@tarantsov.com" , "3D250DE5-09BC-4A6B-AF59-E1D714DF709A@tarantsov.com" , "BB6A4434-E2B1-4192-8450-90D636E6A7F5@fastmail.fm" , "0ED79E6D-A89A-4F3E-9269-6216BD10EB22@sealedabstract.com" , "CAAcV4sb9eMhuLGL3QsBw4bFxj1FQrokCAanKjEFRNNReE8zWOQ@mail.gmail.com" , "7253CF12-DBD4-483D-941F-04851E5AD394@tarantsov.com" , "CAAcV4sbo4=Hdzp+yx-km-CnhNDm2uQ-gDJsvdug_Pg-MjTPC=Q@mail.gmail.com" , "CAAcV4sbAk_eSdjz7bQ6ggdZNE+thmj7-wT_pG2+eRMKDVba+wA@mail.gmail.com" , "7B70F158-5B8A-425B-980C-CD08210342D4@me.com" , "6DA2FDFF-F978-4ECA-9E2B-F757F6D8BBF3@icloud.com" , "2116BFD1-25BC-4B9F-A3A6-08758782BB88@anandabits.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAA9p5uv3WeXTKsuAg=H4h=sd0C23WTOwhuLLe=PkwEGM4Hvwxg@mail.gmail.com"}} , "_id" : "CAA9p5uv3WeXTKsuAg=H4h=sd0C23WTOwhuLLe=PkwEGM4Hvwxg@mail.gmail.com" , "from" : "tmandry at gmail.com (Tyler Mandry)" , "mailingList" : "swift-evolution" , "content" : "Ah no, it's just that they at one time had support for taking away `case`\nand doing `if let b? = a`. See the commit notes that Chris linked to here:\nhttps://github.com/apple/swift/commit/20f8f09ea8de5eb1c0cb559e59c8a8e8a0e115a9#diff-4513b692cdd5476630ebb66b73d5bf4b\n.\n\nI guess the current `if let b = a` syntax is what John was referring to as\nspecial syntactic support, but I still don't see why the `?` was taken out\nof the syntax.\n\nOn Sun, Dec 6, 2015 at 3:43 PM, Alex Lew <alexl.mail+swift at gmail.com> wrote:\n\n> let a: Int? = 3\n> if case let b? = a {\n>     print(b)\n> }\n>\n> works for me in Swift 2.2. Have they announced that they're taking this\n> away?\n>\n>\n> On Sun, Dec 6, 2015 at 4:38 PM, Tyler Mandry via swift-evolution <\n> swift-evolution at swift.org> wrote:\n>\n>> What isn't clear to me from Chris's or John's comments is why the `if let\n>> x? = foo` syntax was taken away. Was it for backward-compatibility? To me,\n>> this syntax does have special syntactic support, and also seems to make it\n>> clearer what's going on. It's also analogous to Swift's type inference for\n>> generic <T?> types, for example:\n>>\n>>    func doSomething<T? where T: Equatable>(x: T?) -> T { ... }\n>>\n>> Note the T? in brackets. If I pass an Int? to doSomething, the type is\n>> \"unwrapped\" and T becomes Int. It seems like `if let x? = foo` would follow\n>> the same pattern.\n>>\n>> Was the syntax taken away for reasons unlikely to change, or is it up for\n>> discussion? :)\n>>\n>> --\n>> Tyler Mandry\n>>\n>>\n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>\n>>\n>\n\n\n-- \nTyler Mandry" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000670.html" , "inReplyTo" : "CAKCGC8AjTGQRer0paqVGnbt4qR3M=T_95hTw44CF6QXQmzV1oQ@mail.gmail.com" , "date" : { "$date" : 1449438418000} , "subject" : "[swift-evolution] Proposal: Optional Binding Shorthand Syntax" , "references" : [ "CAA9p5uv=U-=kLi0PSn+9YSNvnfcn6oDEqOss1q1UjLn-sU9xUQ@mail.gmail.com" , "CAKCGC8AjTGQRer0paqVGnbt4qR3M=T_95hTw44CF6QXQmzV1oQ@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/ECE284CE-EDE3-4071-ABB6-821820F1FC44@jacopo.giola.org"}} , "_id" : "ECE284CE-EDE3-4071-ABB6-821820F1FC44@jacopo.giola.org" , "from" : "swift-evolution at jacopo.giola.org (Jacopo Andrea Giola)" , "mailingList" : "swift-evolution" , "content" : "The result is .Two, because you are returning from the reswitch and in that case the original x is shadowed by the new execution.\n\n- Jacopo\n\n> On 06 Dec 2015, at 22:36, Alex Lew <alexl.mail+swift at gmail.com> wrote:\n> \n> One question: what is the result of this code?\n> \n> let x = .One\n> \n> switch x {\n> case .One:\n>    reswitch(.Two)\n> case .Two:\n>    return x\n> }\n> \n> .One or .Two? In other words, is x rebound inside the switch when we reswitch?\n> \n> On Sun, Dec 6, 2015 at 4:28 PM, Alex Lew <alexl.mail+swift at gmail.com <mailto:alexl.mail+swift at gmail.com>> wrote:\n> It seems reswitch should be useable even in cases that aren't a simple \"goto\". Or am I missing something?\n> \n> For instance, rewriting the example from earlier:\n> \n> switch op {\n> case let .LOAD_INDIRECT(out, in):\n>     reswitch(.LOAD(out, memory[in]))\n> case let .LOAD(out, in):\n>     setReg(out, in)\n> // ...\n> }\n> \n> or, a switch that calculates whether some number n is in a Lisp-style list of numbers\n> \n> switch lst {\n> case .Cons(let m, _) where m == n:\n>      return true\n> case .Cons(_, let rest):\n>     reswitch(rest)\n> case .Empty:\n>      return false\n> }\n> \n> I like reswitch: in some cases, the compiler could optimize to a fallthrough, and in others, you could actually re-switch. But maybe I'm missing something.\n> \n> On Sun, Dec 6, 2015 at 4:14 PM, Jacopo Andrea Giola via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n> Yes, I’m aware that at this time the reswitch can be abused and maybe can be better refined to disallow such cases.\n> \n> Checking the case statement is not a problem by itself, but can be a problem if is coupled with a where clause that is not true when you fallthrought.\n> \n> I’ve written a really bad draft here https://gist.github.com/JGiola/f735212789bf2f697847 <https://gist.github.com/JGiola/f735212789bf2f697847>\n> If anyone wants to jump in and elaborate further is welcome. I will try to stay on par with this thread but I’m really bad at writing so every help is welcome.\n> \n> And if I remember correctly Daniel Jakult was the first one to made this proposal so if he wants to take on and then made the official proposal has every right to do so and I will be very glad if my gist can be a first reference :)\n> \n> - Jacopo\n> \n>> On 06 Dec 2015, at 21:52, Colin Barrett < colin at springsandstruts.com <mailto:colin at springsandstruts.com>> wrote:\n>> \n>> Apologies, Jacopo, for missing the updated proposal, and thank you for your patience in summarizing it again.\n>> \n>> I’ve only glanced through it but my concern here is that it introduces a whole class of new and creative “foot-guns\" :) In particular, it allows this construction to loop arbitrarily and creatively, particularly in the case of associated values.\n>> \n>> I’m not sure why not checking the case statement is considered a problem for the fallthrough keyword. Assuming it’s impossible to fallthrough to a case that introduces binders (what would they be bound to?), and that this is statically checked (both of which seem reasonable assumptions to me, although if I’m wrong feel free to correct me), isn’t it the entire point of the fallthrough keyword that it skips checking the case statement? I can understand how that might be somewhat confusing (and perhaps it should be documented less prominently) but I’m not sure how it’s a *problem*, exactly...\n>> \n>> I think I’m still on the side of keeping fallthrough. What’s the downside of doing nothing? For instance in the case of ++ and -- those features complicate the design of a numerics library.\n>> \n>> Thanks,\n>> -Colin\n>> \n>>> On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola < swift-evolution at jacopo.giola.org <mailto:swift-evolution at jacopo.giola.org>> wrote:\n>>> \n>>>  Hi Colin,\n>>> \n>>> the initial proposal was indeed to remove entirely the `fallthrough` keyword but many people expressed your similar concern and from that point the discussion was steered through an \"enhancement\" and better refinement of the keyword.\n>>> \n>>> The new idea is to substitute the old keyword with \"reswitch\" passing the desired new value on which the switch is applied.\n>>> So something like this:\n>>> \n>>> switch (enum) {\n>>>  case .One:\n>>>  // do something\n>>>  reswitch .Two\n>>>  case .Two:\n>>>  // do something else\n>>>  default:\n>>>  // and so one\n>>> }\n>>> \n>>> This new behaviour, IMO, is better suited for Swift because is more declarative of the developer intent and doesn't carry over unintentional misbehaviour.\n>>> Is more declarative because you are forced to state in which case you want to go, and even if the order of the switch’ cases will change in the future, you don't fall in the wrong case by mistake.\n>>> \n>>> switch (enum) {\n>>>  case .One:\n>>>  // do something\n>>>  reswitch .Two\n>>>  case .OneAndAHalf\n>>>  // maybe this change is not made by you but by a messed up merge\n>>>  case .Two:\n>>>  // do something else\n>>>  default:\n>>>  // and so one\n>>> }\n>>> \n>>> In this case if you are using the fallthrough keyboard your code is now broken by accident, and depending on what are you trying to do inside the cases you can have a hidden bug that your tests are not seeing right away. \n>>> \n>>> Another advantage is that in this way you can made more cases fallthrough in the same one even if they are not one over each other\n>>> \n>>> switch (enum) {\n>>>  case .One:\n>>>  // do something\n>>>  reswitch .Two\n>>>  case .OneAndAHalf\n>>>  // so something that you don’t want to do for .One\n>>>  reswitch .Two\n>>>  case .Two:\n>>>  // do something else that you may want to do for .One and .Two\n>>>  default:\n>>>  // and so one\n>>> }\n>>> \n>>> I must say that this is a side effect that can be used to messed up the code flow in a way that is not intended, but is a new behaviour that gives more power to the switch statement.\n>>> \n>>> The reswitch keyword in addition is not a mere fallthrough on the new case without doing the optional checking attached to it, but is intended to be a new call and all the check are executed.\n>>> \n>>> switch (enum) {\n>>>  case .One:\n>>>  // do something\n>>>  x = 0;\n>>>  reswitch .Two\n>>>  case .OneAndAHalf\n>>>  // so something that you don’t want to do for .One\n>>>  reswitch .Two\n>>>  case .Two where x > 0:\n>>>  // do something else that you may want to do for .One and .Two\n>>>  element = array[x]\n>>>  default:\n>>>  // and so one\n>>> }\n>>> (I’m going by memory and by writing this snippets in the mail app directly, so the code must be incorrect in the syntax and for this I’m sorry).\n>>> \n>>> In this case if enum is .One the only case that is executed is case .One and the code doesn’t fallthrough in the .Two case because we are made the where invalid by changing the x to a value less than 1.\n>>> \n>>> Now I don’t remember who was the first one who mede this proposal, and I don’t know if he is working on a first draft to lay down the things better, but for me this can be a nice improvement and a neat break with the C-switch behaviour that Swift has trying to change from the very first beta disallowing the implicit fallthrough.\n>>> \n>>> I can be completely wrong but I see the `fallthrough`keyword as a “temporary” implementation for ease the transition from Obj-C to Swift and is time to improve it and made the switch statement even more powerful.\n>>> \n>>> - Jacopo \n>>> Sent from my iPad\n>>> \n>>> On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution < swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote: \n>>> \n>>>> tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.\n>>>> \n>>>> Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.\n>>>> \n>>>> I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)\n>>>> \n>>>> Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:\n>>>> \n>>>> https://gist.github.com/cbarrett/23b24a9fe76efdf006df <https://gist.github.com/cbarrett/23b24a9fe76efdf006df>\n>>>> \n>>>> This technique is very extensible — for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.\n>>>> \n>>>> Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type — low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.\n>>>> \n>>>> Thanks,\n>>>> -Colin\n>>>> \n>>>>> On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution < swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>>>> \n>>>>> +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.\n>>>>> \n>>>>> If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don't introduce an infinite \"switch\" loop.\n>>>>> \n>>>>> Sent from my iPad\n>>>>> \n>>>>> On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution < swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote: \n>>>>> \n>>>>>> Very much thinking out loud and not really the implications, I wonder if we might just use \"continue\" instead of \"reswitch\".\n>>>>>> \n>>>>>> I very much like specifying what case to fall through into, no matter how we spell it. \n>>>>>> \n>>>>>> - Steve\n>>>>>> \n>>>>>> On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution < swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote: \n>>>>>> \n>>>>>>>> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution < swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>>>>>>>> On Dec 4, 2015, at 11:37 PM, John Calsbeek < john.calsbeek+lists at gmail.com <mailto:john.calsbeek+lists at gmail.com>> wrote:\n>>>>>>>>> `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.\n>>>>>>>>> \n>>>>>>>>> It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.\n>>>>>>>> \n>>>>>>>> Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.\n>>>>>>>> \n>>>>>>>> On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.\n>>>>>>> \n>>>>>>> Oh, I see that Joe already brought this up, spelled “reswitch”.\n>>>>>>> \n>>>>>>> John.\n>>>>>>> \n>>>>>>>> \n>>>>>>>> John.\n>>>>>>>> \n>>>>>>>>> \n>>>>>>>>> One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).\n>>>>>>>>> \n>>>>>>>>> switch op {\n>>>>>>>>> case LOAD_INDIRECT:\n>>>>>>>>>    in0 = memory[in1]\n>>>>>>>>>    fallthrough\n>>>>>>>>> case LOAD:\n>>>>>>>>>    out0 = memory[in0]\n>>>>>>>>> //...\n>>>>>>>>> }\n>>>>>>>>> \n>>>>>>>>> I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.\n>>>>>>>>> \n>>>>>>>>> Cheers,\n>>>>>>>>> John\n>>>>>>>>> \n>>>>>>>>>> On Dec 4, 2015, at 2:42 PM, John McCall < rjmccall at apple.com <mailto:rjmccall at apple.com>> wrote:\n>>>>>>>>>> \n>>>>>>>>>>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard < kevin at sb.org <mailto:kevin at sb.org>> wrote:\n>>>>>>>>>>> It's not actually Duff's Device. Duff's Device relies on the fact that C switch statements don't actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it's a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently. \n>>>>>>>>>> \n>>>>>>>>>> To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.\n>>>>>>>>>> \n>>>>>>>>>> But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.\n>>>>>>>>>> \n>>>>>>>>>> John.\n>>>>>>>>>> \n>>>>>>>>>>>  \n>>>>>>>>>>> Steve's code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It's a good example of one of the uses of `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's Device in Swift. \n>>>>>>>>>>>  \n>>>>>>>>>>> -Kevin Ballard\n>>>>>>>>>>>  \n>>>>>>>>>>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote: \n>>>>>>>>>>>> Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language. \n>>>>>>>>>>>>  \n>>>>>>>>>>>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun < erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote: \n>>>>>>>>>>>>>  \n>>>>>>>>>>>>> Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it.  \n>>>>>>>>>>>>>  \n>>>>>>>>>>>>> True fact: On all of   gist.github.com <http://gist.github.com/>, there are only 22 gist results for \"fallthrough language:swift\". \n>>>>>>>>>>>>> Half of those are people just testing out the feature. Most of the remaining ones are just complex cases: \n>>>>>>>>>>>>> case .Enum1, .Enum2: \n>>>>>>>>>>>>> expressed as  \n>>>>>>>>>>>>> case .Enum1: fallthrough \n>>>>>>>>>>>>> case .Enum2: \n>>>>>>>>>>>>>  \n>>>>>>>>>>>>> And then there's streza:   https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea <https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea>    I'm pretty sure that ponies were harmed in the production of whatever that last bit is. \n>>>>>>>>>>>>>  \n>>>>>>>>>>>>>  \n>>>>>>>>>>>>>  \n>>>>>>>>>>>>>  \n>>>>>>>>>>>>>> On Dec 4, 2015, at 3:05 PM,   jalkut at red-sweater.com <mailto:jalkut at red-sweater.com>  wrote: \n>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the \"fallthrough\" keyword from the language? \n>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>> My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements. \n>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>> The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation: \n>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>> \"The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.\" \n>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>> To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached. \n>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>> I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements. \n>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>> In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements. \n>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>> Thoughts? \n>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>> Daniel \n>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>> _______________________________________________ \n>>>>>>>>>>>>>> swift-evolution mailing list \n>>>>>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org> \n>>>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution> \n>>>>>>>>>>>>> \n>>>>>>>>>>>>>  \n>>>>>>>>>>>>> \n>>>>>>>>>>>>> _______________________________________________ \n>>>>>>>>>>>>> swift-evolution mailing list \n>>>>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org> \n>>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution> \n>>>>>>>>>>>> \n>>>>>>>>>>>>  \n>>>>>>>>>>>> \n>>>>>>>>>>>> _______________________________________________ \n>>>>>>>>>>>> swift-evolution mailing list \n>>>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org> \n>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution> \n>>>>>>>>>>>  \n>>>>>>>>>>> _______________________________________________ \n>>>>>>>>>>> swift-evolution mailing list \n>>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org> \n>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution> \n>>>>>>>>>> \n>>>>>>>>>>  _______________________________________________ \n>>>>>>>>>> swift-evolution mailing list \n>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org> \n>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>>>>>>>>> _______________________________________________ \n>>>>>>>>> swift-evolution mailing list \n>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org> \n>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution> \n>>>>>>>> \n>>>>>>>> _______________________________________________ \n>>>>>>>> swift-evolution mailing list \n>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org> \n>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution> \n>>>>>>> \n>>>>>>> _______________________________________________ \n>>>>>>> swift-evolution mailing list \n>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org> \n>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution> \n>>>>>> _______________________________________________ \n>>>>>> swift-evolution mailing list \n>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org> \n>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution> \n>>>>> _______________________________________________ \n>>>>> swift-evolution mailing list \n>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org> \n>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution> \n>>>> \n>>>> _______________________________________________ \n>>>> swift-evolution mailing list \n>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org> \n>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution> \n>> \n> \n> Untracked with Trackbuster <https://trackbuster.com/?sig>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n> \n> \n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000672.html" , "inReplyTo" : "CAKCGC8DHCxwtiU82CjxChc6PaiB495WOCJBP0iq04uw7iWcQmA@mail.gmail.com" , "date" : { "$date" : 1449438548000} , "subject" : "[swift-evolution] Proposal: Remove the \"fallthrough\" keyword" , "references" : [ "3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com" , "AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com" , "8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com" , "1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com" , "02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com" , "E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com" , "444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com" , "EF1675F6-7918-4262-B535-696104BFC405@apple.com" , "CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com" , "D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org" , "071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com" , "CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org" , "6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com" , "6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org" , "CAKCGC8DbhMOX6bHtzXQcAhjHQSw1wSSoX-TBUtew0arWA=4pSw@mail.gmail.com" , "CAKCGC8DHCxwtiU82CjxChc6PaiB495WOCJBP0iq04uw7iWcQmA@mail.gmail.com"] , "descendants" : [ "EF9FEF97-C7B8-4D54-B406-2B62FDD15B59@springsandstruts.com" , "CAKCGC8B0UPGUHeJ_1n8XsGoo+E6Anyj_+_R7WsT76rV1Q-qu2w@mail.gmail.com" , "CAKCGC8Cp52O7DX6wWSc3J6FR8Xmoo_WLBgjGBa6fSXzNHhdHEg@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CACyzo1jKFZZ2TLTxXYyd_o1j9d5HBAKmg3Doz7QN9O=JGViOtA@mail.gmail.com"}} , "_id" : "CACyzo1jKFZZ2TLTxXYyd_o1j9d5HBAKmg3Doz7QN9O=JGViOtA@mail.gmail.com" , "from" : "jp at jpsim.com (Jean-Pierre Simard)" , "mailingList" : "swift-evolution" , "content" : ">\n> Separate from compiler-enforced policies, I’d *love* to see someone tackle\n> implementing a \"go fmt” analog that reformats Swift code into a standard\n> style, as well as a “clang format”  tool that could be used by IDEs for\n> on-the-fly editing of code, as well as a “linter” / static analysis tool\n> which can flag potential issues while having a higher tolerance for false\n> positives.  These should be separate from the “always on” compiler\n> diagnostics though.\n\n\nI agree that a compiler cannot be too stylistically opinionated, and that\nan opt-in, standalone linter/formatter is preferable.\n\nAs others have mentioned, there's a community-built tool called SwiftLint\n<https://github.com/realm/SwiftLint> that does much of this today. It's an\nAST-assisted tool to enforce code style conventions & automatically correct\ncertain violations. Rules can be enabled/disabled and parameterized either\ninline in the source or via a YAML configuration file.\n\nOne of the tool's main limitations so far is that the Swift AST it operates\non is obtained from a reverse-engineered SourceKit interface and is\nincomplete.\n\nMyself and other SwiftLint contributors intend to replace the\nreverse-engineered SourceKit backend with more official tooling that was\njust open sourced, which will enable SwiftLint to do things like an\nopinionated go-fmt/clang-format style formatting (source->AST-source) and\nsome types of static analysis like identifying cyclomatic complexity.\n\nOne thing I'd like to discuss with relevant Swift project owners (notably\nArgyrios and Chris) is the possibility of moving SwiftLint development into\ngithub.com/apple, which would increase the tool's exposure and pace of\ndevelopment. I hope to make a more official proposal for how that\ntransition could happen in the upcoming week, probably in swift-dev.\n\nOn Sun, Dec 6, 2015 at 9:07 AM, Erica Sadun via swift-evolution <\nswift-evolution at swift.org> wrote:\n\n> On Dec 5, 2015, at 11:15 PM, Chris Lattner via swift-evolution <\n> swift-evolution at swift.org> wrote:\n> > Separate from compiler-enforced policies, I’d *love* to see someone\n> tackle implementing a \"go fmt” analog that reformats Swift code into a\n> standard style, as well as a “clang format”  tool that could be used by\n> IDEs for on-the-fly editing of code, as well as a “linter” / static\n> analysis tool which can flag potential issues while having a higher\n> tolerance for false positives.  These should be separate from the “always\n> on” compiler diagnostics though.\n> >\n> > -Chris\n>\n> I have a fairly minimal held-together-by-bandaids linter I put together:\n>\n> https://github.com/erica/testlint\n>\n> I have hesitated to develop it much further because I didn't want to be\n> committed to inter-process SourceKit hacking and did not yet have access to\n> a reliable parse tree. In its current state, it's a regex-based\n> line-by-line scan.\n>\n> The rules it follows are here:\n> https://github.com/erica/testlint/blob/master/testlint/sources/Linter.m\n> with fairly copious commenting\n>\n>\n> -- Erica\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000671.html" , "inReplyTo" : "9D5E0564-E4A2-4F64-8741-526CF79959F4@ericasadun.com" , "date" : { "$date" : 1449438550000} , "subject" : "[swift-evolution] \"bad smells\" should be compiler errors with suggestions on how to fix them" , "references" : [ "557CCA5F-E52F-439C-B224-AC4990140373@gmail.com" , "1449324589110.9d79fd62@Nodemailer" , "CF5C0804-061E-487B-9030-005E76177BD1@harlanhaskins.com" , "E4BE1F82-1BCB-4E27-B2E5-CDBE673EF7B8@me.com" , "49EF0786-90E4-4748-B532-E4C68D33458D@gmail.com" , "4F75A42F-4721-4932-85B7-912DFCA57C2D@apple.com" , "9D5E0564-E4A2-4F64-8741-526CF79959F4@ericasadun.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/63E46D4F-9E50-4BD8-AB36-A4510BDFF4B0@gmail.com"}} , "_id" : "63E46D4F-9E50-4BD8-AB36-A4510BDFF4B0@gmail.com" , "from" : "possen at gmail.com (possen p)" , "mailingList" : "swift-evolution" , "content" : "Got ya, so for a more complex example:\n\nlet myColor = (match yourColor \n\tcase .Blue :  .Reds\n\tcase .Green: .Blue \n\tcase .Red: match  shade .LightRed : LightGreen, .MediumRed :  .DarkGreen :  DarkRed \n\tdefault: .Yellow\n)\n\nfor booleans I would not want to list the true false cases out though.\n\nlet myColor = match boolCondition  .Blue, .Red \n\n\n\n> On Dec 6, 2015, at 1:32 PM, Alex Lew <alexl.mail+swift at gmail.com> wrote:\n> \n> To clarify, I would want parens around the entire expression (only when necessary). So\n> \n> let myColor = match yourColor\n>  case .Blue :  .Red\n>  case .Green: .Blue \n>  case .Red: .Green\n>  default: .Yellow\n> \n> or\n> \n> let myColor = match boolCondition\n>   case true: .Blue\n>   case false: .Red\n> \n> or\n> \n> let myColor = match boolCondition\n>   case true: (match yourColor\n>                       case .Red: .Blue\n>                       default: .Yellow)\n>   case false: .Red\n> \n> But I actually think that the parens are unnecessary, as long as we require matches to be exhaustive and for there to be no unreachable cases.\n> \n> On Sun, Dec 6, 2015 at 4:17 PM, Paul Ossenbruggen <possen at gmail.com <mailto:possen at gmail.com>> wrote:\n> I agree that ? may imply optional, this may be similar to what you suggested, just filling in the example: Not sure parenthesis are better than braces though:\n> \n> et myColor = match yourColor ( .Blue :  .Red, .Green: .Blue, .Red: .Green, default: .Yellow )\n> \n> let myColor = match yourColor ( case .Blue : .Red; case .Green: .Blue;  case .Red: .Green; default: .Yellow )\n> \n> let myColor = match yourColor (\n>   case .Blue :  .Reds\n>  case .Green: .Blue \n>  case .Red: .Green\n>  default: .Yellow\n> )\n> \n> let myColor = match yourColor (\n>   .Blue :  .Reds\n>  .Green: .Blue \n>  .Red: .Green\n>  default: .Yellow\n> )\n> \n> let myColor = match boollCondition ( .Blue, .Red ) \n> \n> \n> \n>> On Dec 6, 2015, at 12:54 PM, Alex Lew < alexl.mail+swift at gmail.com <mailto:alexl.mail+swift at gmail.com>> wrote:\n>> \n>> Hmm. Something about braces inside expressions just feels wrong to me.\n>> \n>> I also read switch? and if? as being some optional-related versions of switch and if. And I don't love putting the condition / value-to-switch-on before the keyword, if we're going to use a keyword.\n>> \n>> (Also: exhaustiveness checking could theoretically allow resolution of ambiguity in nested switch expressions. We would just have to require that as soon as you've exhausted all possibilities, you don't add more cases and the expression is over.)\n>> \n>> On Sun, Dec 6, 2015 at 3:46 PM, Paul Ossenbruggen <possen at gmail.com <mailto:possen at gmail.com>> wrote: \n>> Yep probably does need braces: So for switch? if? suggestion i just made. \n>> \n>> let myColor = yourColor switch? { .Blue :  .Red, .Green: .Blue, .Red: .Green, default: .Yellow }\n>> \n>> let myColor = yourColor switch? { case .Blue : .Red; case .Green: .Blue;  case .Red: .Green; default: .Yellow }\n>> \n>> let myColor = yourColor switch? {\n>>  case .Blue :  .Reds\n>>   case .Green: .Blue \n>>  case .Red: .Green\n>>  default: .Yellow\n>> }\n>> \n>> let myColor = yourColor switch? {\n>>  .Blue :  .Reds\n>>  .Green: .Blue \n>>  .Red: .Green\n>>  default: .Yellow\n>> }\n>> \n>> let myColor = condition if?  { .Blue; .Red }\n>> \n>> I don’t find that looks bad. \n>> \n>> - Paul \n>> \n>> \n>>> On Dec 6, 2015, at 12:24 PM, Alex Lew via swift-evolution < swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>> \n>>> Thanks for the feedback, Matthew. It's sensible to me to consider dropping the ternary operator. I like it because the analogy \"C's if is to Swift's if as C's ternary operator is to Swift's ternary operator\" is (sort of) satisfied. But it is also confusing, both for the reasons you mention, and because ? has other meanings in Swift:\n>>> \n>>>  // compiler error without space betw thatColor and ? \n>>> let thisColor = thatColor? \n>>>      case .Red: .Green\n>>>      default: .Blue\n>>> \n>>> On the other hand, is it really worth it to have control flow expressions if they don't let your code look nicer?\n>>> \n>>> let thisColor = switch thatColor {\n>>>      case .Red:\n>>>           return .Green;\n>>>      default:\n>>>           return .Yellow;\n>>> }\n>>> \n>>> really isn't much nicer than\n>>> \n>>> let thisColor: Color\n>>> switch thatColor {\n>>>      case .Red:\n>>>           thisColor = .Green\n>>>      default:\n>>>           thisColor = .Yellow\n>>> }\n>>> \n>>> Maybe we could do a compromise, something like\n>>> \n>>> let thisColor = switch thatColor\n>>>      case .Red: .Green // must be an expression\n>>>      default: .Yellow      // must be an expression\n>>> \n>>> Or we could introduce a new keyword? Like   match:\n>>> \n>>> let thisColor = match thatColor\n>>>       case .Red: .Green    // must be an expression\n>>>       default: .Yellow         // must be an expression\n>>> \n>>> \n>>> I sort of like the new-keyword approach, because even though this is similar to a switch, it's not a switch: there's no fallthrough, you can't put statements inside, etc.\n>>> \n>>> The problem with all these proposals:\n>>> \n>>> let thisColor = match thatColor\n>>>      case .Red: match thatOtherColor\n>>>                            case .Blue: .Green\n>>>                            case .Pink: .Yellow\n>>>                            default: .Orange\n>>>      default: .Orange\n>>> \n>>> is ambiguous. (Does case .Pink match thatColor or thatOtherColor? We can know because of exhaustiveness checking, but this won't always work.) You could solve this problem either by using parentheses around the whole expression when necessary\n>>> \n>>> let thisColor = match thatColor\n>>>      case .Red: (match thatOtherColor\n>>>                            case .Blue: .Green\n>>>                            case .Pink: .Yellow\n>>>                            default: .Orange)\n>>>      default: .Orange\n>>> \n>>> or by adding curly braces in again\n>>> \n>>> let thisColor = match thatColor {\n>>>      case .Red: match thatOtherColor {\n>>>                            case .Blue: .Green\n>>>                            case .Pink: .Yellow\n>>>                            default: .Orange\n>>>                         }\n>>>      default: .Orange\n>>> }\n>>> \n>>> But that starts to look like switch again. (Of course, the best way to handle this is as a programmer is to just switch on the tuple (thatColor, thatOtherColor), but the language should allow for nested control expressions.)\n>>> \n>>> \n>>> On Sun, Dec 6, 2015 at 2:48 PM, Matthew Johnson via swift-evolution   <swift-evolution at swift.org <mailto:swift-evolution at swift.org>>  wrote: \n>>> I am not a fan of this approach based on the ternary operator.  The ternary operator is already a bit of an anomaly in that all other operators are unary or binary and do not perform any control flow (beyond possibly short circuiting an autoclosure argument).\n>>> \n>>> I would much rather features that perform control flow continue to use keywords, but allow them to be expressions.  \n>>> \n>>> Once we have control flow expressions I would like to see the ternary operator removed from the language as it would no longer server a purpose.  Removing the ternary operator seems to fit nicely with the direction to remove some features that are carried over from C-based languages but don’t necessarily fit with the direction Swift is heading.\n>>> \n>>> \n>>>> On Dec 6, 2015, at 1:19 PM, Kevin Lundberg via swift-evolution <   swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>>>> \n>>>> Ostensibly, case may not be necessary if you could delimit each case on one line with something (perhaps a comma, or something else if that would not fit well within the grammar):   \n>>>>  \n>>>> let thisColor = thatColor ? .Blue: .Red, .Green: .Blue, .Red: .Green, default: .Yellow   \n>>>>  \n>>>> On Sun, Dec 6, 2015, at 01:57 PM, Paul Ossenbruggen via swift-evolution wrote:   \n>>>>> I like this too, seems more powerful.  Also, would single line expressions be allowed?  If not would case be required for example:   \n>>>>>  \n>>>>> let myFavoriteColor = yourFavoriteColor ?   \n>>>>>      case .Blue: .Red   \n>>>>>      case .Green: .Blue   \n>>>>>      case .Red: .Green   \n>>>>>      default: .Yellow   \n>>>>>  \n>>>>>  \n>>>>>> On Dec 6, 2015, at 9:11 AM, Sean Heber via swift-evolution <   swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:   \n>>>>>>  \n>>>>>> I really like this train of thought. +1   \n>>>>>>  \n>>>>>> l8r   \n>>>>>> Sean   \n>>>>>>  \n>>>>>> On Dec 6, 2015, at 11:02 AM, Alex Lew via swift-evolution <   swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:   \n>>>>>>> What if we left the if { ...} else { ... } syntax alone (as a statement), and updated the ternary expression to be a more general pattern matching expression (closer to \"switch\")? Something like   \n>>>>>>>  \n>>>>>>> let x = condition ?   \n>>>>>>>    true: \"Hello\"   \n>>>>>>>    false: \"Goodbye\"   \n>>>>>>>  \n>>>>>>> let x = optionalValue ?   \n>>>>>>>    .Some(let unwrapped): \"Hello, \\(unwrapped)\"   \n>>>>>>>    .None: \"To Whom It May Concern\"   \n>>>>>>>  \n>>>>>>> let myFavoriteColor = yourFavoriteColor ?   \n>>>>>>>      .Blue: .Red   \n>>>>>>>      .Green: .Blue   \n>>>>>>>      .Red: .Green   \n>>>>>>>  \n>>>>>>> let quadrant = (x, y) ?   \n>>>>>>>      let (x, y) where x < 50 && y < 50: \"top left\"   \n>>>>>>>      let (x, y) where x < 50 && y > 50: \"bottom left\"   \n>>>>>>>      let (x, y) where x > 50 && y < 50: \"top right\"   \n>>>>>>>      default: \"bottom right\"   \n>>>>>>>  \n>>>>>>> The colon comes from the fact that this is sort of a light-weight expression-based \"switch\" statement, where each branch can only contain an expression, not a series of statements.   \n>>>>>>>  \n>>>>>>> This is very similar to pattern matching expressions in languages like Haskell, ML, and Coq.   \n>>>>>>>  \n>>>>>>> On Sun, Dec 6, 2015 at 11:25 AM, Thorsten Seitz   <thorsten.seitz at web.de <mailto:thorsten.seitz at web.de>>   wrote:   \n>>>>>>>  \n>>>>>>>> Am 06.12.2015 um 01:28 schrieb Alex Lew via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>>:   \n>>>>>>>>  \n>>>>>>>> I don't think you can just get rid of the if statement in favor of an expression. You still want to be able to do this:   \n>>>>>>>>  \n>>>>>>>> if (condition) {   \n>>>>>>>>     funcWithSideEffectsThatReturnsInt()   \n>>>>>>>> } else {   \n>>>>>>>>     funcWithSideEffectsThatReturnsString()   \n>>>>>>>> }   \n>>>>>>>>  \n>>>>>>>> but that's not a valid expression (what is its type?).   \n>>>>>>>  \n>>>>>>>  \n>>>>>>> That would actually be no problem if Swift’s type system would have union types (Ceylon has union and intersection types which are quite awesome and enable lots of nice things quite naturally, see   http://ceylon-lang.org/documentation/1.2/tour/types/ <http://ceylon-lang.org/documentation/1.2/tour/types/>).   \n>>>>>>>  \n>>>>>>> In that case the type of such an expression would just be the union of both types, which is written   Int | String   in Ceylon.   \n>>>>>>>  \n>>>>>>>  \n>>>>>>> -Thorsten   \n>>>>>>>  \n>>>>>>>  \n>>>>>>>  \n>>>>>>> \n>>>>>>> _______________________________________________   \n>>>>>>> swift-evolution mailing list   \n>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>   \n>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>   \n>>>>>> _______________________________________________   \n>>>>>> swift-evolution mailing list   \n>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>   \n>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>   \n>>>>> \n>>>>> \n>>>>> _______________________________________________   \n>>>>> swift-evolution mailing list   \n>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>   \n>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>   \n>>>>  \n>>>> _______________________________________________   \n>>>> swift-evolution mailing list   \n>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>   \n>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>   \n>>> \n>>> Untracked with   Trackbuster <https://trackbuster.com/?sig>\n>>> _______________________________________________ \n>>> swift-evolution mailing list \n>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org> \n>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution> \n>>> \n>>> \n>>>  _______________________________________________ \n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n>> \n> \n> Untracked with Trackbuster <https://trackbuster.com/?sig>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000673.html" , "inReplyTo" : "CAKCGC8AdPMD1ySZnucpn-kMpy-X4=O0Xhd6aoOazyr6SAmLLUA@mail.gmail.com" , "date" : { "$date" : 1449438603000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAKCGC8AG8DS208+zXzu0mpjN62r1At8ro=FgjEevp-wr-5KtyA@mail.gmail.com" , "1C7496F7-41F5-4F46-A8B7-889D4A9FC49B@gmail.com" , "CAKCGC8AdPMD1ySZnucpn-kMpy-X4=O0Xhd6aoOazyr6SAmLLUA@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAKCGC8BmmCk55=6UC_qk_C+ZNq2JfGpOPO5cJ=SK2784kmvbGg@mail.gmail.com"}} , "_id" : "CAKCGC8BmmCk55=6UC_qk_C+ZNq2JfGpOPO5cJ=SK2784kmvbGg@mail.gmail.com" , "from" : "alexl.mail+swift at gmail.com (Alex Lew)" , "mailingList" : "swift-evolution" , "content" : "I agree that it's simplest to just reuse switch keyword, and keep braces.\n+1.\n\nWould you allow the same thing with if?\n\nlet thisColor = if condition { .Red } else { .Blue }\n\nOn Sun, Dec 6, 2015 at 4:44 PM, Rudolf Adamkovic <salutis at me.com> wrote:\n\n> > On 06 Dec 2015, at 22:35, thorsten--- via swift-evolution <\n> swift-evolution at swift.org> wrote:\n>\n> >\n> > I would prefer the expression to match the statement. The only\n> difference would be that all parts that were statements now have to be\n> expressions.\n>\n> +1\n>\n> >\n> > Therefore the switch-expression should simply look like follows:\n> >\n> > let thisColor = switch thatColor {\n> >         case .Red: .Green // must be an expression\n> >         default: .Yellow      // must be an expression\n> >     }\n> >\n> > No returns needed in the case clauses.\n>\n> This actually looks great. One simple rule and zero new keywords.\n>\n> Readable and simple to learn.\n>\n> Fantastic!\n>\n> > Formatting this as a one-liner would just require adding semicolons\n> (though I wouldn't recommend this).\n> >\n> > -Thorsten\n> > _______________________________________________\n> > swift-evolution mailing list\n> > swift-evolution at swift.org\n> > https://lists.swift.org/mailman/listinfo/swift-evolution\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000674.html" , "inReplyTo" : "45B71AF5-DD4F-4E9C-A128-5B8041917564@me.com" , "date" : { "$date" : 1449438721000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com" , "CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com" , "C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com" , "18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com" , "2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io" , "BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com" , "CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com" , "CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com" , "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com" , "BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com" , "909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net" , "0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com" , "49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net" , "CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com" , "49EEA2E6-55F2-49DE-A59F-A13017626370@web.de" , "CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com" , "4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com" , "11462DA4-ACDD-4CF3-BD57-47886B655970@anandabits.com" , "CAKCGC8AVDe6W9X=XvFEnbkae8xom2Us8xczKFShqKu2+kPnRJA@mail.gmail.com" , "07270E34-E284-4FF0-B2EA-6DBB54FF78B5@portableinnovations.de" , "45B71AF5-DD4F-4E9C-A128-5B8041917564@me.com"] , "descendants" : [ "B6DDD94B-0755-4D40-94F0-D2469A644818@portableinnovations.de" , "CAKCGC8AerqpPTrwdmPAvhmp-fLt-v=LXw4z0t+2o93g9GmAaxw@mail.gmail.com" , "54E5D8F5-616D-41EB-A550-E639FE861575@gmail.com" , "CAKCGC8CsJ7g_Fu8fnQ5Mv=yAzbSvb0Z+iNmdXKnJaAcWR2UKuw@mail.gmail.com" , "6830F74D-78FC-4B20-A6D5-683185B30164@gmail.com" , "691A92C4-1A5F-4CAE-AF50-F6AAA3A3F32C@portableinnovations.de" , "D35074A6-1C34-4BA3-AAF1-8CFE1992A522@me.com" , "1EE735A6-FF0F-4E49-BE7D-AC7E6C8A87EC@tarantsov.com" , "3D250DE5-09BC-4A6B-AF59-E1D714DF709A@tarantsov.com" , "BB6A4434-E2B1-4192-8450-90D636E6A7F5@fastmail.fm" , "0ED79E6D-A89A-4F3E-9269-6216BD10EB22@sealedabstract.com" , "CAAcV4sb9eMhuLGL3QsBw4bFxj1FQrokCAanKjEFRNNReE8zWOQ@mail.gmail.com" , "7253CF12-DBD4-483D-941F-04851E5AD394@tarantsov.com" , "CAAcV4sbo4=Hdzp+yx-km-CnhNDm2uQ-gDJsvdug_Pg-MjTPC=Q@mail.gmail.com" , "CAAcV4sbAk_eSdjz7bQ6ggdZNE+thmj7-wT_pG2+eRMKDVba+wA@mail.gmail.com" , "7B70F158-5B8A-425B-980C-CD08210342D4@me.com" , "6DA2FDFF-F978-4ECA-9E2B-F757F6D8BBF3@icloud.com" , "2116BFD1-25BC-4B9F-A3A6-08758782BB88@anandabits.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAKCGC8B0UPGUHeJ_1n8XsGoo+E6Anyj_+_R7WsT76rV1Q-qu2w@mail.gmail.com"}} , "_id" : "CAKCGC8B0UPGUHeJ_1n8XsGoo+E6Anyj_+_R7WsT76rV1Q-qu2w@mail.gmail.com" , "from" : "alexl.mail+swift at gmail.com (Alex Lew)" , "mailingList" : "swift-evolution" , "content" : "Makes sense! So what about this case?\n\nvar x = 1\nswitch x {\ncase 1:\n     reswitch(2)\ndefault:\n     x += 1\n}\nprint(x)\n\nDoes that print 1?\n\nOn Sun, Dec 6, 2015 at 4:49 PM, Jacopo Andrea Giola <\nswift-evolution at jacopo.giola.org> wrote:\n\n> The result is .Two, because you are returning from the reswitch and in\n> that case the original x is shadowed by the new execution.\n>\n> - Jacopo\n>\n> On 06 Dec 2015, at 22:36, Alex Lew <alexl.mail+swift at gmail.com> wrote:\n>\n> One question: what is the result of this code?\n>\n> let x = .One\n>\n> switch x {\n> case .One:\n>    reswitch(.Two)\n> case .Two:\n>    return x\n> }\n>\n> .One or .Two? In other words, is x rebound inside the switch when we\n> reswitch?\n>\n> On Sun, Dec 6, 2015 at 4:28 PM, Alex Lew <alexl.mail+swift at gmail.com>\n> wrote:\n>\n>> It seems reswitch *should* be useable even in cases that aren't a simple\n>> \"goto\". Or am I missing something?\n>>\n>> For instance, rewriting the example from earlier:\n>>\n>> switch op {\n>> case let .LOAD_INDIRECT(out, in):\n>>     reswitch(.LOAD(out, memory[in]))\n>> case let .LOAD(out, in):\n>>     setReg(out, in)\n>> // ...\n>> }\n>>\n>> or, a switch that calculates whether some number n is in a Lisp-style\n>> list of numbers\n>>\n>> switch lst {\n>> case .Cons(let m, _) where m == n:\n>>      return true\n>> case .Cons(_, let rest):\n>>     reswitch(rest)\n>> case .Empty:\n>>      return false\n>> }\n>>\n>> I like reswitch: in some cases, the compiler could optimize to a\n>> fallthrough, and in others, you could actually re-switch. But maybe I'm\n>> missing something.\n>>\n>> On Sun, Dec 6, 2015 at 4:14 PM, Jacopo Andrea Giola via swift-evolution <\n>> swift-evolution at swift.org> wrote:\n>>\n>>> Yes, I’m aware that at this time the reswitch can be abused and maybe\n>>> can be better refined to disallow such cases.\n>>>\n>>> Checking the case statement is not a problem by itself, but can be a\n>>> problem if is coupled with a where clause that is not true when you\n>>> fallthrought.\n>>>\n>>> I’ve written a really bad draft here\n>>> https://gist.github.com/JGiola/f735212789bf2f697847\n>>> If anyone wants to jump in and elaborate further is welcome. I will try\n>>> to stay on par with this thread but I’m really bad at writing so every help\n>>> is welcome.\n>>>\n>>> And if I remember correctly Daniel Jakult was the first one to made this\n>>> proposal so if he wants to take on and then made the official proposal has\n>>> every right to do so and I will be very glad if my gist can be a first\n>>> reference :)\n>>>\n>>> - Jacopo\n>>>\n>>> On 06 Dec 2015, at 21:52, Colin Barrett < colin at springsandstruts.com>\n>>> wrote:\n>>>\n>>> Apologies, Jacopo, for missing the updated proposal, and thank you for\n>>> your patience in summarizing it again.\n>>>\n>>> I’ve only glanced through it but my concern here is that it introduces a\n>>> whole class of new and creative “foot-guns\" :) In particular, it allows\n>>> this construction to loop arbitrarily and creatively, particularly in the\n>>> case of associated values.\n>>>\n>>> I’m not sure why not checking the case statement is considered a problem\n>>> for the fallthrough keyword. Assuming it’s impossible to fallthrough to a\n>>> case that introduces binders (what would they be bound to?), and that this\n>>> is statically checked (both of which seem reasonable assumptions to me,\n>>> although if I’m wrong feel free to correct me), isn’t it the entire point\n>>> of the fallthrough keyword that it skips checking the case statement? I can\n>>> understand how that might be somewhat confusing (and perhaps it should be\n>>> documented less prominently) but I’m not sure how it’s a *problem*,\n>>> exactly...\n>>>\n>>> I think I’m still on the side of keeping fallthrough. What’s the\n>>> downside of doing nothing? For instance in the case of ++ and -- those\n>>> features complicate the design of a numerics library.\n>>>\n>>> Thanks,\n>>> -Colin\n>>>\n>>> On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola <\n>>> swift-evolution at jacopo.giola.org> wrote:\n>>>\n>>>  Hi Colin,\n>>>\n>>> the initial proposal was indeed to remove entirely the `fallthrough`\n>>> keyword but many people expressed your similar concern and from that point\n>>> the discussion was steered through an \"enhancement\" and better refinement\n>>> of the keyword.\n>>>\n>>> The new idea is to substitute the old keyword with \"reswitch\" passing\n>>> the desired new value on which the switch is applied.\n>>> So something like this:\n>>>\n>>> switch (enum) {\n>>> case .One:\n>>> // do something\n>>> reswitch .Two\n>>> case .Two:\n>>> // do something else\n>>> default:\n>>> // and so one\n>>> }\n>>>\n>>> This new behaviour, IMO, is better suited for Swift because is more\n>>> declarative of the developer intent and doesn't carry over unintentional\n>>> misbehaviour.\n>>> Is more declarative because you are forced to state in which case you\n>>> want to go, and even if the order of the switch’ cases will change in the\n>>> future, you don't fall in the wrong case by mistake.\n>>>\n>>> switch (enum) {\n>>> case .One:\n>>> // do something\n>>> reswitch .Two\n>>> case .OneAndAHalf\n>>> // maybe this change is not made by you but by a messed up merge\n>>> case .Two:\n>>> // do something else\n>>> default:\n>>> // and so one\n>>> }\n>>>\n>>> In this case if you are using the fallthrough keyboard your code is now\n>>> broken by accident, and depending on what are you trying to do inside the\n>>> cases you can have a hidden bug that your tests are not seeing right away.\n>>>\n>>> Another advantage is that in this way you can made more\n>>> cases fallthrough in the same one even if they are not one over each other\n>>>\n>>> switch (enum) {\n>>> case .One:\n>>> // do something\n>>> reswitch .Two\n>>> case .OneAndAHalf\n>>> // so something that you don’t want to do for .One\n>>> reswitch .Two\n>>> case .Two:\n>>> // do something else that you may want to do for .One and .Two\n>>> default:\n>>> // and so one\n>>> }\n>>>\n>>> I must say that this is a side effect that can be used to messed up the\n>>> code flow in a way that is not intended, but is a new behaviour that gives\n>>> more power to the switch statement.\n>>>\n>>> The reswitch keyword in addition is not a mere fallthrough on the new\n>>> case without doing the optional checking attached to it, but is intended to\n>>> be a new call and all the check are executed.\n>>>\n>>> switch (enum) {\n>>> case .One:\n>>> // do something\n>>> x = 0;\n>>> reswitch .Two\n>>> case .OneAndAHalf\n>>> // so something that you don’t want to do for .One\n>>> reswitch .Two\n>>> case .Two where x > 0:\n>>> // do something else that you may want to do for .One and .Two\n>>> element = array[x]\n>>> default:\n>>> // and so one\n>>> }\n>>> (I’m going by memory and by writing this snippets in the mail app\n>>> directly, so the code must be incorrect in the syntax and for this I’m\n>>> sorry).\n>>>\n>>> In this case if enum is .One the only case that is executed is case .One\n>>> and the code doesn’t fallthrough in the .Two case because we are made the\n>>> where invalid by changing the x to a value less than 1.\n>>>\n>>> Now I don’t remember who was the first one who mede this proposal, and I\n>>> don’t know if he is working on a first draft to lay down the things better,\n>>> but for me this can be a nice improvement and a neat break with the\n>>> C-switch behaviour that Swift has trying to change from the very first beta\n>>> disallowing the implicit fallthrough.\n>>>\n>>> I can be completely wrong but I see the `fallthrough`keyword as a\n>>> “temporary” implementation for ease the transition from Obj-C to Swift and\n>>> is time to improve it and made the switch statement even more powerful.\n>>>\n>>> - Jacopo\n>>> Sent from my iPad\n>>>\n>>> On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution <\n>>> swift-evolution at swift.org> wrote:\n>>>\n>>> tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us\n>>> anything; and has at least minimal utility, as I try to demonstrate.\n>>>\n>>> Apologies for jumping into this thread at an awkward point, but I’ve\n>>> only just now subscribed to this list.\n>>>\n>>> I think the fallthrough keyword is useful in certain circumstances. I’ve\n>>> also yet to see an example of where it creates a negative impact, either in\n>>> code, optimization, or what have you. Other than “It’s like something in C,\n>>> and C is old and busted” I’m unsure of the rationale for removing it. (Feel\n>>> free to point me in the right direction.)\n>>>\n>>> Consider the Planet enum from the documentation. One of the simplest way\n>>> to define the number of a planet (i.e. its 1-based index in the ordering of\n>>> planets wrt. distance from the sun) is using a switch and fall-through:\n>>>\n>>> https://gist.github.com/cbarrett/23b24a9fe76efdf006df\n>>>\n>>> This technique is very extensible — for instance imagine computing the\n>>> force induced by the gravity of the other planets on a particular planet.\n>>> All that would need to change is the case statements.\n>>>\n>>> Yes, you could write this by putting the planets into a list and mapping\n>>> or folding (or looping) over that, but unless the compiler can “unroll”\n>>> that construct, you’re paying for an allocation simply bc of your choice of\n>>> control flow. But in fact, you could imagine generalizing this construct\n>>> into the implementation of fold for the Planet type — low-overhead folds\n>>> for monomorphic types seems like a pretty compelling an natural use case\n>>> for fallthrough to me.\n>>>\n>>> Thanks,\n>>> -Colin\n>>>\n>>> On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution <\n>>> swift-evolution at swift.org> wrote:\n>>>\n>>> +1 for this idea, but I will prefer the reswitch keyword instead of\n>>> overloading continue with a new syntax.\n>>>\n>>> If this proposal is accepted, it must be coupled with a compiler check\n>>> that the reswitch statements don't introduce an infinite \"switch\" loop.\n>>>\n>>> Sent from my iPad\n>>>\n>>> On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution <\n>>> swift-evolution at swift.org> wrote:\n>>>\n>>> Very much thinking out loud and not really the implications, I wonder if\n>>> we might just use \"continue\" instead of \"reswitch\".\n>>>\n>>> I very much like specifying what case to fall through into, no matter\n>>> how we spell it.\n>>>\n>>> - Steve\n>>>\n>>> On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution <\n>>> swift-evolution at swift.org> wrote:\n>>>\n>>> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution <\n>>> swift-evolution at swift.org> wrote:\n>>>\n>>> On Dec 4, 2015, at 11:37 PM, John Calsbeek <\n>>> john.calsbeek+lists at gmail.com> wrote:\n>>> `fallthrough` is conceptually similar to `goto` in that both allow\n>>> natural expression of concepts that exist at the instruction level but are\n>>> otherwise difficult to express with nested control structures.\n>>> `fallthrough` is perhaps slightly less objectionable because control flow\n>>> remains local, but it has a similar role.\n>>>\n>>> It is not particularly natural to write `switch` statements with\n>>> `fallthrough` in the reverse order that can be seen in Duff’s Device and\n>>> similar constructs (case 7 falls through to 6 which falls through to 5,\n>>> etc.). It’s just because you know for certain that all the code in case 6\n>>> would be duplicated in case 7, so 7 can transfer into 6 without a jump\n>>> instruction. Communicating that to the compiler without `fallthrough`\n>>> requires deeply nested `if`s.\n>>>\n>>>\n>>> Right.  One idea that I’ve always had for “fallthrough” is that we might\n>>> parameterize it in the future; parameterized it would mean “repeat the\n>>> switch with this new value”, so that unparameterized fallthrough would mean\n>>> “repeat the switch with a notional value that ends up in the next case”.\n>>> There’s a very common pattern in switches of deferring to another case that\n>>> I’ve always found very awkward to write in C, and while sometimes there’s\n>>> no choice but to extract a helper function, there’s a\n>>> still-fairly-structural code pattern here that I think we can sensibly\n>>> support.\n>>>\n>>> On the other hand, there’s an argument that this is an inappropriate\n>>> extension for “fallthrough” specifically, which is one reason we’ve never\n>>> pursued it.\n>>>\n>>>\n>>> Oh, I see that Joe already brought this up, spelled “reswitch”.\n>>>\n>>> John.\n>>>\n>>>\n>>> John.\n>>>\n>>>\n>>> One defense comes to mind: there is talk of Swift aiming at systems\n>>> programming. Is writing a threaded interpreter loop within the potential\n>>> scope of Swift? That’s a use case that could make use of both `fallthrough`\n>>> and `goto` (computed goto, really).\n>>>\n>>> switch op {\n>>> case LOAD_INDIRECT:\n>>>    in0 = memory[in1]\n>>>    fallthrough\n>>> case LOAD:\n>>>    out0 = memory[in0]\n>>> //...\n>>> }\n>>>\n>>> I am personally interested in the prospect of a language that can scale\n>>> up to high-level concepts and down to “portable assembler,” but I don’t\n>>> know if that is the right direction for Swift’s evolution.\n>>>\n>>> Cheers,\n>>> John\n>>>\n>>> On Dec 4, 2015, at 2:42 PM, John McCall < rjmccall at apple.com> wrote:\n>>>\n>>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard < kevin at sb.org> wrote:\n>>> It's not actually Duff's Device. Duff's Device relies on the fact that C\n>>> switch statements don't actually introduce a new scope, and so it overlaps\n>>> a switch with a do-while loop. This lets it only test the number of bytes\n>>> once, to jump into the middle of the loop, and then it switches over to a\n>>> while loop that decrements a counter every 8 instructions. Basically, it's\n>>> a trick for manual loop unrolling that deals with non-multiple-of-8 counts\n>>> efficiently.\n>>>\n>>>\n>>> To be pedantic, C switch statements do introduce a new scope.  What\n>>> Duff’s Device exploits is that switch is allowed to jump into (almost)\n>>> arbitrary scopes, and cases can appear anywhere recursively inside a\n>>> switch.\n>>>\n>>> But your point that Swift’s switch requires cases to be at the top level\n>>> within a switch and thus prevents the use of Duff’s Device is 100% correct.\n>>>\n>>> John.\n>>>\n>>>\n>>> Steve's code is also an example of manual loop unrolling that deals with\n>>> non-multiple-of-8 counts, but it has calculate the number of bytes on every\n>>> iteration instead of once. It's a good example of one of the uses of\n>>> `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's\n>>> Device in Swift.\n>>>\n>>> -Kevin Ballard\n>>>\n>>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:\n>>>\n>>> Streza’s source code is an example of Duff’s Device, which is a big\n>>> place where switch fallthrough is arguably the cleanest way to do things\n>>> and the reason why I’d personally prefer to keep it as part of the\n>>> language.\n>>>\n>>>\n>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun < erica at ericasadun.com> wrote:\n>>>\n>>> Oh let it die, let it die. Any time I use fallthrough I find myself\n>>> re-factoring to stop using it.\n>>>\n>>> *True fact*: On all of   gist.github.com, there are only 22 gist\n>>> results for \"fallthrough language:swift\".\n>>> Half of those are people just testing out the feature. Most of the\n>>> remaining ones are just complex cases:\n>>> *case .Enum1, .Enum2:*\n>>> expressed as\n>>> *case .Enum1: fallthrough*\n>>> *case .Enum2:*\n>>>\n>>> And then there's streza:\n>>> https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea    I'm pretty\n>>> sure that ponies were harmed in the production of whatever that last bit\n>>> is.\n>>>\n>>>\n>>>\n>>>\n>>>\n>>> On Dec 4, 2015, at 3:05 PM,   jalkut at red-sweater.com  wrote:\n>>>\n>>> In the spirit of some other proposals that remove C or C++ style\n>>> artifacts, what do folks think about the possibility of removing the\n>>> \"fallthrough\" keyword from the language?\n>>>\n>>> My understanding is this keyword is only used for the archaic seeming\n>>> purpose of perpetuating C-style fallthrough from one switch statement to\n>>> the subsequent one. The documentation hedges the use of this keyword in\n>>> forbidding terms that make it clear its use is not encouraged. The presence\n>>> of the keyword, while an improvement over C’s implicit fallthrough, is a\n>>> mark of inelegance on an otherwise well-designed, opinionated\n>>> implementation of swtich statements.\n>>>\n>>> The ugliness of fallthrough’s C-style behavior even demands a caveat in\n>>> the documentation:\n>>>\n>>> \"The fallthrough keyword does not check the case conditions for the\n>>> switch case that it causes execution to fall into. The fallthrough keyword\n>>> simply causes code execution to move directly to the statements inside the\n>>> next case (or default case) block, as in C’s standard switch statement\n>>> behavior.\"\n>>>\n>>> To my mind, the caveat explains just what is wrong with fallthrough,\n>>> both in C or Swift: coded that is clearly labeled with deliberate\n>>> conditions can nonetheless be reached.\n>>>\n>>> I quipped about this on Twitter, and the most common pushback I got\n>>> seemed to be from people who either did not know about Swift’s support for\n>>> comma-separated case statements, or harbored an aesthetic preference for\n>>> clustering such cases together with fallthrough statements.\n>>>\n>>> In my opinion, unless somebody can think of a strong defense for\n>>> supporting intentional fallthrough in Swift, removing the keyword would be\n>>> a move in the direction of minimizing the language’s complexity while also\n>>> discouraging poor coding style in switch statements.\n>>>\n>>> Thoughts?\n>>>\n>>> Daniel\n>>>\n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>\n>>>\n>>>\n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>\n>>>\n>>>\n>>> *_______________________________________________*\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>\n>>>\n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>\n>>>\n>>>  _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>\n>>>\n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>\n>>>\n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>\n>>>\n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>\n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>\n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>\n>>>\n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>\n>>>\n>>>\n>>> Untracked with Trackbuster <https://trackbuster.com/?sig>\n>>>\n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>\n>>>\n>>\n>\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000675.html" , "inReplyTo" : "ECE284CE-EDE3-4071-ABB6-821820F1FC44@jacopo.giola.org" , "date" : { "$date" : 1449438912000} , "subject" : "[swift-evolution] Proposal: Remove the \"fallthrough\" keyword" , "references" : [ "3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com" , "AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com" , "8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com" , "1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com" , "02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com" , "E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com" , "444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com" , "EF1675F6-7918-4262-B535-696104BFC405@apple.com" , "CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com" , "D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org" , "071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com" , "CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org" , "6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com" , "6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org" , "CAKCGC8DbhMOX6bHtzXQcAhjHQSw1wSSoX-TBUtew0arWA=4pSw@mail.gmail.com" , "CAKCGC8DHCxwtiU82CjxChc6PaiB495WOCJBP0iq04uw7iWcQmA@mail.gmail.com" , "ECE284CE-EDE3-4071-ABB6-821820F1FC44@jacopo.giola.org"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAA9p5uvxy5ufiafCrmxrLZ11oQPOizzUbyWYsBkYOPNqbX22Ag@mail.gmail.com"}} , "_id" : "CAA9p5uvxy5ufiafCrmxrLZ11oQPOizzUbyWYsBkYOPNqbX22Ag@mail.gmail.com" , "from" : "tmandry at gmail.com (Erica Sadun)" , "mailingList" : "swift-evolution" , "content" : "I agree with Adrian here – the problem IMO is the fact that you can do `x <\n5` *at all* if x is optional.\n\nAllowing programmers to do `x? < 5` still doesn't make clear what the\nactual result of the operation will be if x is nil. In fact, I would\nactually *expect* the result of the operation to be a Bool?, not a Bool\nwhich is always false if x is nil.\n\n-- \nTyler Mandry" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000676.html" , "date" : { "$date" : 1449438963000} , "subject" : "[swift-evolution] [Accepted] SE-0039: Mandatory \"?\" suffix for identifiers associated with optional types" , "references" : [ ""] , "inReplyTo" :  null  , "descendants" : [ "24220A0F-DDDB-4CC7-ADE0-18ED197902E8@portableinnovations.de"]} , { "_links" : { "self" : { "href" : "/charter/emails/EF9FEF97-C7B8-4D54-B406-2B62FDD15B59@springsandstruts.com"}} , "_id" : "EF9FEF97-C7B8-4D54-B406-2B62FDD15B59@springsandstruts.com" , "from" : "colin at springsandstruts.com (Colin Barrett)" , "mailingList" : "swift-evolution" , "content" : "If you need control flow this complex, why not just use recursion? reswitch is, near as I can tell, a recursive call to an implicitly defined function (closing over the switch).\n\n-Colin \n\n> On Dec 6, 2015, at 4:49 PM, Jacopo Andrea Giola <swift-evolution at jacopo.giola.org> wrote:\n> \n> The result is .Two, because you are returning from the reswitch and in that case the original x is shadowed by the new execution.\n> \n> - Jacopo\n> \n>> On 06 Dec 2015, at 22:36, Alex Lew <alexl.mail+swift at gmail.com> wrote:\n>> \n>> One question: what is the result of this code?\n>> \n>> let x = .One\n>> \n>> switch x {\n>> case .One:\n>>    reswitch(.Two)\n>> case .Two:\n>>    return x\n>> }\n>> \n>> .One or .Two? In other words, is x rebound inside the switch when we reswitch?\n>> \n>>> On Sun, Dec 6, 2015 at 4:28 PM, Alex Lew <alexl.mail+swift at gmail.com> wrote:\n>>> It seems reswitch should be useable even in cases that aren't a simple \"goto\". Or am I missing something?\n>>> \n>>> For instance, rewriting the example from earlier:\n>>> \n>>> switch op {\n>>> case let .LOAD_INDIRECT(out, in):\n>>>     reswitch(.LOAD(out, memory[in]))\n>>> case let .LOAD(out, in):\n>>>     setReg(out, in)\n>>> // ...\n>>> }\n>>> \n>>> or, a switch that calculates whether some number n is in a Lisp-style list of numbers\n>>> \n>>> switch lst {\n>>> case .Cons(let m, _) where m == n:\n>>>      return true\n>>> case .Cons(_, let rest):\n>>>     reswitch(rest)\n>>> case .Empty:\n>>>      return false\n>>> }\n>>> \n>>> I like reswitch: in some cases, the compiler could optimize to a fallthrough, and in others, you could actually re-switch. But maybe I'm missing something.\n>>> \n>>>> On Sun, Dec 6, 2015 at 4:14 PM, Jacopo Andrea Giola via swift-evolution <swift-evolution at swift.org> wrote:\n>>>> Yes, I’m aware that at this time the reswitch can be abused and maybe can be better refined to disallow such cases.\n>>>> \n>>>> Checking the case statement is not a problem by itself, but can be a problem if is coupled with a where clause that is not true when you fallthrought.\n>>>> \n>>>> I’ve written a really bad draft here https://gist.github.com/JGiola/f735212789bf2f697847\n>>>> If anyone wants to jump in and elaborate further is welcome. I will try to stay on par with this thread but I’m really bad at writing so every help is welcome.\n>>>> \n>>>> And if I remember correctly Daniel Jakult was the first one to made this proposal so if he wants to take on and then made the official proposal has every right to do so and I will be very glad if my gist can be a first reference :)\n>>>> \n>>>> - Jacopo\n>>>> \n>>>>> On 06 Dec 2015, at 21:52, Colin Barrett < colin at springsandstruts.com> wrote:\n>>>>> \n>>>>> Apologies, Jacopo, for missing the updated proposal, and thank you for your patience in summarizing it again.\n>>>>> \n>>>>> I’ve only glanced through it but my concern here is that it introduces a whole class of new and creative “foot-guns\" :) In particular, it allows this construction to loop arbitrarily and creatively, particularly in the case of associated values.\n>>>>> \n>>>>> I’m not sure why not checking the case statement is considered a problem for the fallthrough keyword. Assuming it’s impossible to fallthrough to a case that introduces binders (what would they be bound to?), and that this is statically checked (both of which seem reasonable assumptions to me, although if I’m wrong feel free to correct me), isn’t it the entire point of the fallthrough keyword that it skips checking the case statement? I can understand how that might be somewhat confusing (and perhaps it should be documented less prominently) but I’m not sure how it’s a *problem*, exactly...\n>>>>> \n>>>>> I think I’m still on the side of keeping fallthrough. What’s the downside of doing nothing? For instance in the case of ++ and -- those features complicate the design of a numerics library.\n>>>>> \n>>>>> Thanks,\n>>>>> -Colin\n>>>>> \n>>>>>> On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola < swift-evolution at jacopo.giola.org> wrote:\n>>>>>> \n>>>>>>  Hi Colin,\n>>>>>> \n>>>>>> the initial proposal was indeed to remove entirely the `fallthrough` keyword but many people expressed your similar concern and from that point the discussion was steered through an \"enhancement\" and better refinement of the keyword.\n>>>>>> \n>>>>>> The new idea is to substitute the old keyword with \"reswitch\" passing the desired new value on which the switch is applied.\n>>>>>> So something like this:\n>>>>>> \n>>>>>> switch (enum) {\n>>>>>>  case .One:\n>>>>>>  // do something\n>>>>>>  reswitch .Two\n>>>>>>  case .Two:\n>>>>>>  // do something else\n>>>>>>  default:\n>>>>>>  // and so one\n>>>>>> }\n>>>>>> \n>>>>>> This new behaviour, IMO, is better suited for Swift because is more declarative of the developer intent and doesn't carry over unintentional misbehaviour.\n>>>>>> Is more declarative because you are forced to state in which case you want to go, and even if the order of the switch’ cases will change in the future, you don't fall in the wrong case by mistake.\n>>>>>> \n>>>>>> switch (enum) {\n>>>>>>  case .One:\n>>>>>>  // do something\n>>>>>>  reswitch .Two\n>>>>>>  case .OneAndAHalf\n>>>>>>  // maybe this change is not made by you but by a messed up merge\n>>>>>>  case .Two:\n>>>>>>  // do something else\n>>>>>>  default:\n>>>>>>  // and so one\n>>>>>> }\n>>>>>> \n>>>>>> In this case if you are using the fallthrough keyboard your code is now broken by accident, and depending on what are you trying to do inside the cases you can have a hidden bug that your tests are not seeing right away. \n>>>>>> \n>>>>>> Another advantage is that in this way you can made more cases fallthrough in the same one even if they are not one over each other\n>>>>>> \n>>>>>> switch (enum) {\n>>>>>>  case .One:\n>>>>>>  // do something\n>>>>>>  reswitch .Two\n>>>>>>  case .OneAndAHalf\n>>>>>>  // so something that you don’t want to do for .One\n>>>>>>  reswitch .Two\n>>>>>>  case .Two:\n>>>>>>  // do something else that you may want to do for .One and .Two\n>>>>>>  default:\n>>>>>>  // and so one\n>>>>>> }\n>>>>>> \n>>>>>> I must say that this is a side effect that can be used to messed up the code flow in a way that is not intended, but is a new behaviour that gives more power to the switch statement.\n>>>>>> \n>>>>>> The reswitch keyword in addition is not a mere fallthrough on the new case without doing the optional checking attached to it, but is intended to be a new call and all the check are executed.           \n>>>>>> \n>>>>>> switch (enum) {\n>>>>>>  case .One:\n>>>>>>  // do something\n>>>>>>  x = 0;\n>>>>>>  reswitch .Two\n>>>>>>  case .OneAndAHalf\n>>>>>>  // so something that you don’t want to do for .One\n>>>>>>  reswitch .Two\n>>>>>>  case .Two where x > 0:\n>>>>>>  // do something else that you may want to do for .One and .Two\n>>>>>>  element = array[x]\n>>>>>>  default:\n>>>>>>  // and so one\n>>>>>> }\n>>>>>> (I’m going by memory and by writing this snippets in the mail app directly, so the code must be incorrect in the syntax and for this I’m sorry).\n>>>>>> \n>>>>>> In this case if enum is .One the only case that is executed is case .One and the code doesn’t fallthrough in the .Two case because we are made the where invalid by changing the x to a value less than 1.\n>>>>>> \n>>>>>> Now I don’t remember who was the first one who mede this proposal, and I don’t know if he is working on a first draft to lay down the things better, but for me this can be a nice improvement and a neat break with the C-switch behaviour that Swift has trying to change from the very first beta disallowing the implicit fallthrough.\n>>>>>> \n>>>>>> I can be completely wrong but I see the `fallthrough`keyword as a “temporary” implementation for ease the transition from Obj-C to Swift and is time to improve it and made the switch statement even more powerful.\n>>>>>> \n>>>>>> - Jacopo \n>>>>>> Sent from my iPad\n>>>>>> \n>>>>>> On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution < swift-evolution at swift.org> wrote: \n>>>>>> \n>>>>>>> tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.\n>>>>>>> \n>>>>>>> Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.\n>>>>>>> \n>>>>>>> I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)\n>>>>>>> \n>>>>>>> Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:\n>>>>>>> \n>>>>>>> https://gist.github.com/cbarrett/23b24a9fe76efdf006df\n>>>>>>> \n>>>>>>> This technique is very extensible ― for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.\n>>>>>>> \n>>>>>>> Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type ― low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.\n>>>>>>> \n>>>>>>> Thanks,\n>>>>>>> -Colin\n>>>>>>> \n>>>>>>>> On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution < swift-evolution at swift.org> wrote:\n>>>>>>>> \n>>>>>>>> +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.\n>>>>>>>> \n>>>>>>>> If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don't introduce an infinite \"switch\" loop.\n>>>>>>>> \n>>>>>>>> Sent from my iPad\n>>>>>>>> \n>>>>>>>> On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution < swift-evolution at swift.org> wrote: \n>>>>>>>> \n>>>>>>>>> Very much thinking out loud and not really the implications, I wonder if we might just use \"continue\" instead of \"reswitch\".\n>>>>>>>>> \n>>>>>>>>> I very much like specifying what case to fall through into, no matter how we spell it. \n>>>>>>>>> \n>>>>>>>>> - Steve\n>>>>>>>>> \n>>>>>>>>> On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution < swift-evolution at swift.org> wrote: \n>>>>>>>>> \n>>>>>>>>>>> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution < swift-evolution at swift.org> wrote:\n>>>>>>>>>>>> On Dec 4, 2015, at 11:37 PM, John Calsbeek < john.calsbeek+lists at gmail.com> wrote:\n>>>>>>>>>>>> `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.\n>>>>>>>>>>>> \n>>>>>>>>>>>> It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.\n>>>>>>>>>>> \n>>>>>>>>>>> Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.\n>>>>>>>>>>> \n>>>>>>>>>>> On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.\n>>>>>>>>>> \n>>>>>>>>>> Oh, I see that Joe already brought this up, spelled “reswitch”.\n>>>>>>>>>> \n>>>>>>>>>> John.\n>>>>>>>>>> \n>>>>>>>>>>> \n>>>>>>>>>>> John.\n>>>>>>>>>>> \n>>>>>>>>>>>> \n>>>>>>>>>>>> One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).\n>>>>>>>>>>>> \n>>>>>>>>>>>> switch op {\n>>>>>>>>>>>> case LOAD_INDIRECT:\n>>>>>>>>>>>>    in0 = memory[in1]\n>>>>>>>>>>>>    fallthrough\n>>>>>>>>>>>> case LOAD:\n>>>>>>>>>>>>    out0 = memory[in0]\n>>>>>>>>>>>> //...\n>>>>>>>>>>>> }\n>>>>>>>>>>>> \n>>>>>>>>>>>> I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.\n>>>>>>>>>>>> \n>>>>>>>>>>>> Cheers,\n>>>>>>>>>>>> John\n>>>>>>>>>>>> \n>>>>>>>>>>>>> On Dec 4, 2015, at 2:42 PM, John McCall < rjmccall at apple.com> wrote:\n>>>>>>>>>>>>> \n>>>>>>>>>>>>>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard < kevin at sb.org> wrote:\n>>>>>>>>>>>>>> It's not actually Duff's Device. Duff's Device relies on the fact that C switch statements don't actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it's a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently. \n>>>>>>>>>>>>> \n>>>>>>>>>>>>> To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.\n>>>>>>>>>>>>> \n>>>>>>>>>>>>> But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.\n>>>>>>>>>>>>> \n>>>>>>>>>>>>> John.\n>>>>>>>>>>>>> \n>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>> Steve's code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It's a good example of one of the uses of `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's Device in Swift. \n>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>> -Kevin Ballard\n>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote: \n>>>>>>>>>>>>>>> Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language. \n>>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun < erica at ericasadun.com> wrote: \n>>>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>>>> Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it.  \n>>>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>>>> True fact: On all of   gist.github.com, there are only 22 gist results for \"fallthrough language:swift\". \n>>>>>>>>>>>>>>>> Half of those are people just testing out the feature. Most of the remaining ones are just complex cases: \n>>>>>>>>>>>>>>>> case .Enum1, .Enum2: \n>>>>>>>>>>>>>>>> expressed as  \n>>>>>>>>>>>>>>>> case .Enum1: fallthrough \n>>>>>>>>>>>>>>>> case .Enum2: \n>>>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>>>> And then there's streza:   https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea    I'm pretty sure that ponies were harmed in the production of whatever that last bit is. \n>>>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>>>>> On Dec 4, 2015, at 3:05 PM,   jalkut at red-sweater.com  wrote: \n>>>>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>>>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the \"fallthrough\" keyword from the language?                                               \n>>>>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>>>>> My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements. \n>>>>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>>>>> The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation: \n>>>>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>>>>> \"The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.\" \n>>>>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>>>>> To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached. \n>>>>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>>>>> I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements. \n>>>>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>>>>> In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements. \n>>>>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>>>>> Thoughts? \n>>>>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>>>>> Daniel \n>>>>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>>>>> _______________________________________________ \n>>>>>>>>>>>>>>>>> swift-evolution mailing list \n>>>>>>>>>>>>>>>>> swift-evolution at swift.org \n>>>>>>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution \n>>>>>>>>>>>>>>>> \n>>>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>>>> \n>>>>>>>>>>>>>>>> _______________________________________________ \n>>>>>>>>>>>>>>>> swift-evolution mailing list \n>>>>>>>>>>>>>>>> swift-evolution at swift.org \n>>>>>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution \n>>>>>>>>>>>>>>> \n>>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>>> \n>>>>>>>>>>>>>>> _______________________________________________ \n>>>>>>>>>>>>>>> swift-evolution mailing list \n>>>>>>>>>>>>>>> swift-evolution at swift.org \n>>>>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution \n>>>>>>>>>>>>>>  \n>>>>>>>>>>>>>> _______________________________________________ \n>>>>>>>>>>>>>> swift-evolution mailing list \n>>>>>>>>>>>>>> swift-evolution at swift.org \n>>>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution \n>>>>>>>>>>>>> \n>>>>>>>>>>>>>  _______________________________________________ \n>>>>>>>>>>>>> swift-evolution mailing list \n>>>>>>>>>>>>> swift-evolution at swift.org \n>>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>>>>>>>>>> \n>>>>>>>>>>>> _______________________________________________ \n>>>>>>>>>>>> swift-evolution mailing list \n>>>>>>>>>>>> swift-evolution at swift.org \n>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution \n>>>>>>>>>>> \n>>>>>>>>>>> _______________________________________________ \n>>>>>>>>>>> swift-evolution mailing list \n>>>>>>>>>>> swift-evolution at swift.org \n>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution \n>>>>>>>>>> \n>>>>>>>>>> _______________________________________________ \n>>>>>>>>>> swift-evolution mailing list \n>>>>>>>>>> swift-evolution at swift.org \n>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution \n>>>>>>>>> _______________________________________________ \n>>>>>>>>> swift-evolution mailing list \n>>>>>>>>> swift-evolution at swift.org \n>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution \n>>>>>>>> _______________________________________________ \n>>>>>>>> swift-evolution mailing list \n>>>>>>>> swift-evolution at swift.org \n>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution \n>>>>>>> \n>>>>>>> _______________________________________________ \n>>>>>>> swift-evolution mailing list \n>>>>>>> swift-evolution at swift.org \n>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution \n>>>>> \n>>>> \n>>>> Untracked with Trackbuster\n>>>> \n>>>> _______________________________________________\n>>>> swift-evolution mailing list\n>>>> swift-evolution at swift.org\n>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>> \n>>> \n>> \n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000677.html" , "inReplyTo" : "ECE284CE-EDE3-4071-ABB6-821820F1FC44@jacopo.giola.org" , "date" : { "$date" : 1449439060000} , "subject" : "[swift-evolution] Proposal: Remove the \"fallthrough\" keyword" , "references" : [ "3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com" , "AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com" , "8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com" , "1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com" , "02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com" , "E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com" , "444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com" , "EF1675F6-7918-4262-B535-696104BFC405@apple.com" , "CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com" , "D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org" , "071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com" , "CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org" , "6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com" , "6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org" , "CAKCGC8DbhMOX6bHtzXQcAhjHQSw1wSSoX-TBUtew0arWA=4pSw@mail.gmail.com" , "CAKCGC8DHCxwtiU82CjxChc6PaiB495WOCJBP0iq04uw7iWcQmA@mail.gmail.com" , "ECE284CE-EDE3-4071-ABB6-821820F1FC44@jacopo.giola.org"] , "descendants" : [ "CAKCGC8Cp52O7DX6wWSc3J6FR8Xmoo_WLBgjGBa6fSXzNHhdHEg@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/98973CF0-B5A8-491F-A8D0-DA73456FF01B@jacopo.giola.org"}} , "_id" : "98973CF0-B5A8-491F-A8D0-DA73456FF01B@jacopo.giola.org" , "from" : "swift-evolution at jacopo.giola.org (Jacopo Andrea Giola)" , "mailingList" : "swift-evolution" , "content" : "Dan, you are using the word “safer” so at least is an improvement :)\nbut I don’t see it as a goto. goto is used with arbitrary label that move your code flow around without been bound in some limited construct. reswitch is limited in scope inside a switch, can be called only on typed value of the main switch, and will retain the constraint of been called at the end of the case as fallthrought so it will not mess up the case execution but will only try to execute the switch again on another case.\n\n> On 06 Dec 2015, at 22:26, Dan Appel <dan.appel00 at gmail.com> wrote:\n> \n> For better or worse, I would like to note that `reswitch` is essentially a safer `goto`, so keep in mind all the bad things that can be done with it.\n> \n> On Sun, Dec 6, 2015 at 1:23 PM Colin Barrett via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n> \n> > On Dec 6, 2015, at 4:14 PM, Jacopo Andrea Giola <swift-evolution at jacopo.giola.org <mailto:swift-evolution at jacopo.giola.org>> wrote:\n> >\n> > Yes, I’m aware that at this time the reswitch can be abused and maybe can be better refined to disallow such cases.\n> \n> I’m curious, how do you propose to do this?\n> \n> > Checking the case statement is not a problem by itself, but can be a problem if is coupled with a where clause that is not true when you fallthrought.\n> \n> In your document you give the example:\n> \n> > case .Three where x > 0:\n> \n> Now I may be wrong but I feel as though most of the uses of where clauses are also ones that reference variables bound in a `case let`. For instance:\n> \n> > case .Four(x) where x > 0:\n> \n> In that case, fallthrough would required to evaluating the case part anyway, as per my postulated rules below.\n> \n> In any case, I appreciate you taking the time to discuss your proposal, even if I didn’t end up convinced. Thanks.\n> \n> -Colin\n> \n> > I’ve written a really bad draft here https://gist.github.com/JGiola/f735212789bf2f697847 <https://gist.github.com/JGiola/f735212789bf2f697847>\n> > If anyone wants to jump in and elaborate further is welcome. I will try to stay on par with this thread but I’m really bad at writing so every help is welcome.\n> >\n> > And if I remember correctly Daniel Jakult was the first one to made this proposal so if he wants to take on and then made the official proposal has every right to do so and I will be very glad if my gist can be a first reference :)\n> >\n> > - Jacopo\n> >\n> >> On 06 Dec 2015, at 21:52, Colin Barrett <colin at springsandstruts.com <mailto:colin at springsandstruts.com>> wrote:\n> >>\n> >> Apologies, Jacopo, for missing the updated proposal, and thank you for your patience in summarizing it again.\n> >>\n> >> I’ve only glanced through it but my concern here is that it introduces a whole class of new and creative “foot-guns\" :) In particular, it allows this construction to loop arbitrarily and creatively, particularly in the case of associated values.\n> >>\n> >> I’m not sure why not checking the case statement is considered a problem for the fallthrough keyword. Assuming it’s impossible to fallthrough to a case that introduces binders (what would they be bound to?), and that this is statically checked (both of which seem reasonable assumptions to me, although if I’m wrong feel free to correct me), isn’t it the entire point of the fallthrough keyword that it skips checking the case statement? I can understand how that might be somewhat confusing (and perhaps it should be documented less prominently) but I’m not sure how it’s a *problem*, exactly...\n> >>\n> >> I think I’m still on the side of keeping fallthrough. What’s the downside of doing nothing? For instance in the case of ++ and -- those features complicate the design of a numerics library.\n> >>\n> >> Thanks,\n> >> -Colin\n> >>\n> >>> On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola <swift-evolution at jacopo.giola.org <mailto:swift-evolution at jacopo.giola.org>> wrote:\n> >>>\n> >>>  Hi Colin,\n> >>>\n> >>> the initial proposal was indeed to remove entirely the `fallthrough` keyword but many people expressed your similar concern and from that point the discussion was steered through an \"enhancement\" and better refinement of the keyword.\n> >>>\n> >>> The new idea is to substitute the old keyword with \"reswitch\" passing the desired new value on which the switch is applied.\n> >>> So something like this:\n> >>>\n> >>> switch (enum) {\n> >>>     case .One:\n> >>>             // do something\n> >>>             reswitch .Two\n> >>>     case .Two:\n> >>>             // do something else\n> >>>     default:\n> >>>             // and so one\n> >>> }\n> >>>\n> >>> This new behaviour, IMO, is better suited for Swift because is more declarative of the developer intent and doesn't carry over unintentional misbehaviour.\n> >>> Is more declarative because you are forced to state in which case you want to go, and even if the order of the switch’ cases will change in the future, you don't fall in the wrong case by mistake.\n> >>>\n> >>> switch (enum) {\n> >>>     case .One:\n> >>>             // do something\n> >>>             reswitch .Two\n> >>>     case .OneAndAHalf\n> >>>             // maybe this change is not made by you but by a messed up merge\n> >>>     case .Two:\n> >>>             // do something else\n> >>>     default:\n> >>>             // and so one\n> >>> }\n> >>>\n> >>> In this case if you are using the fallthrough keyboard your code is now broken by accident, and depending on what are you trying to do inside the cases you can have a hidden bug that your tests are not seeing right away.\n> >>>\n> >>> Another advantage is that in this way you can made more cases fallthrough in the same one even if they are not one over each other\n> >>>\n> >>> switch (enum) {\n> >>>     case .One:\n> >>>             // do something\n> >>>             reswitch .Two\n> >>>     case .OneAndAHalf\n> >>>             // so something that you don’t want to do for .One\n> >>>             reswitch .Two\n> >>>     case .Two:\n> >>>             // do something else that you may want to do for .One and .Two\n> >>>     default:\n> >>>             // and so one\n> >>> }\n> >>>\n> >>> I must say that this is a side effect that can be used to messed up the code flow in a way that is not intended, but is a new behaviour that gives more power to the switch statement.\n> >>>\n> >>> The reswitch keyword in addition is not a mere fallthrough on the new case without doing the optional checking attached to it, but is intended to be a new call and all the check are executed.\n> >>>\n> >>> switch (enum) {\n> >>>     case .One:\n> >>>             // do something\n> >>>             x = 0;\n> >>>             reswitch .Two\n> >>>     case .OneAndAHalf\n> >>>             // so something that you don’t want to do for .One\n> >>>             reswitch .Two\n> >>>     case .Two where x > 0:\n> >>>             // do something else that you may want to do for .One and .Two\n> >>>             element = array[x]\n> >>>     default:\n> >>>             // and so one\n> >>> }\n> >>> (I’m going by memory and by writing this snippets in the mail app directly, so the code must be incorrect in the syntax and for this I’m sorry).\n> >>>\n> >>> In this case if enum is .One the only case that is executed is case .One and the code doesn’t fallthrough in the .Two case because we are made the where invalid by changing the x to a value less than 1.\n> >>>\n> >>> Now I don’t remember who was the first one who mede this proposal, and I don’t know if he is working on a first draft to lay down the things better, but for me this can be a nice improvement and a neat break with the C-switch behaviour that Swift has trying to change from the very first beta disallowing the implicit fallthrough.\n> >>>\n> >>> I can be completely wrong but I see the `fallthrough`keyword as a “temporary” implementation for ease the transition from Obj-C to Swift and is time to improve it and made the switch statement even more powerful.\n> >>>\n> >>> - Jacopo\n> >>> Sent from my iPad\n> >>>\n> >>> On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n> >>>\n> >>>> tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.\n> >>>>\n> >>>> Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.\n> >>>>\n> >>>> I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)\n> >>>>\n> >>>> Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:\n> >>>>\n> >>>> https://gist.github.com/cbarrett/23b24a9fe76efdf006df <https://gist.github.com/cbarrett/23b24a9fe76efdf006df>\n> >>>>\n> >>>> This technique is very extensible — for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.\n> >>>>\n> >>>> Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type — low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.\n> >>>>\n> >>>> Thanks,\n> >>>> -Colin\n> >>>>\n> >>>>> On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n> >>>>>\n> >>>>> +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.\n> >>>>>\n> >>>>> If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don't introduce an infinite \"switch\" loop.\n> >>>>>\n> >>>>> Sent from my iPad\n> >>>>>\n> >>>>> On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n> >>>>>\n> >>>>>> Very much thinking out loud and not really the implications, I wonder if we might just use \"continue\" instead of \"reswitch\".\n> >>>>>>\n> >>>>>> I very much like specifying what case to fall through into, no matter how we spell it.\n> >>>>>>\n> >>>>>> - Steve\n> >>>>>>\n> >>>>>> On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n> >>>>>>\n> >>>>>>>> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n> >>>>>>>>> On Dec 4, 2015, at 11:37 PM, John Calsbeek <john.calsbeek+lists at gmail.com <mailto:john.calsbeek%2Blists at gmail.com>> wrote:\n> >>>>>>>>> `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.\n> >>>>>>>>>\n> >>>>>>>>> It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.\n> >>>>>>>>\n> >>>>>>>> Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.\n> >>>>>>>>\n> >>>>>>>> On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.\n> >>>>>>>\n> >>>>>>> Oh, I see that Joe already brought this up, spelled “reswitch”.\n> >>>>>>>\n> >>>>>>> John.\n> >>>>>>>\n> >>>>>>>>\n> >>>>>>>> John.\n> >>>>>>>>\n> >>>>>>>>>\n> >>>>>>>>> One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).\n> >>>>>>>>>\n> >>>>>>>>> switch op {\n> >>>>>>>>> case LOAD_INDIRECT:\n> >>>>>>>>>    in0 = memory[in1]\n> >>>>>>>>>    fallthrough\n> >>>>>>>>> case LOAD:\n> >>>>>>>>>    out0 = memory[in0]\n> >>>>>>>>> //...\n> >>>>>>>>> }\n> >>>>>>>>>\n> >>>>>>>>> I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.\n> >>>>>>>>>\n> >>>>>>>>> Cheers,\n> >>>>>>>>> John\n> >>>>>>>>>\n> >>>>>>>>>> On Dec 4, 2015, at 2:42 PM, John McCall <rjmccall at apple.com <mailto:rjmccall at apple.com>> wrote:\n> >>>>>>>>>>\n> >>>>>>>>>>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard <kevin at sb.org <mailto:kevin at sb.org>> wrote:\n> >>>>>>>>>>> It's not actually Duff's Device. Duff's Device relies on the fact that C switch statements don't actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it's a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.\n> >>>>>>>>>>\n> >>>>>>>>>> To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.\n> >>>>>>>>>>\n> >>>>>>>>>> But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.\n> >>>>>>>>>>\n> >>>>>>>>>> John.\n> >>>>>>>>>>\n> >>>>>>>>>>>\n> >>>>>>>>>>> Steve's code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It's a good example of one of the uses of `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's Device in Swift.\n> >>>>>>>>>>>\n> >>>>>>>>>>> -Kevin Ballard\n> >>>>>>>>>>>\n> >>>>>>>>>>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:\n> >>>>>>>>>>>> Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.\n> >>>>>>>>>>>>\n> >>>>>>>>>>>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun <erica at ericasadun.com <mailto:erica at ericasadun.com>> wrote:\n> >>>>>>>>>>>>>\n> >>>>>>>>>>>>> Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it.\n> >>>>>>>>>>>>>\n> >>>>>>>>>>>>> True fact: On all of gist.github.com <http://gist.github.com/>, there are only 22 gist results for \"fallthrough language:swift\".\n> >>>>>>>>>>>>> Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:\n> >>>>>>>>>>>>> case .Enum1, .Enum2:\n> >>>>>>>>>>>>> expressed as\n> >>>>>>>>>>>>> case .Enum1: fallthrough\n> >>>>>>>>>>>>> case .Enum2:\n> >>>>>>>>>>>>>\n> >>>>>>>>>>>>> And then there's streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea <https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea>   I'm pretty sure that ponies were harmed in the production of whatever that last bit is.\n> >>>>>>>>>>>>>\n> >>>>>>>>>>>>>\n> >>>>>>>>>>>>>\n> >>>>>>>>>>>>>\n> >>>>>>>>>>>>>> On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com <mailto:jalkut at red-sweater.com> wrote:\n> >>>>>>>>>>>>>>\n> >>>>>>>>>>>>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the \"fallthrough\" keyword from the language?\n> >>>>>>>>>>>>>>\n> >>>>>>>>>>>>>> My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.\n> >>>>>>>>>>>>>>\n> >>>>>>>>>>>>>> The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:\n> >>>>>>>>>>>>>>\n> >>>>>>>>>>>>>> \"The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.\"\n> >>>>>>>>>>>>>>\n> >>>>>>>>>>>>>> To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.\n> >>>>>>>>>>>>>>\n> >>>>>>>>>>>>>> I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.\n> >>>>>>>>>>>>>>\n> >>>>>>>>>>>>>> In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.\n> >>>>>>>>>>>>>>\n> >>>>>>>>>>>>>> Thoughts?\n> >>>>>>>>>>>>>>\n> >>>>>>>>>>>>>> Daniel\n> >>>>>>>>>>>>>>\n> >>>>>>>>>>>>>> _______________________________________________\n> >>>>>>>>>>>>>> swift-evolution mailing list\n> >>>>>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> >>>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n> >>>>>>>>>>>>>\n> >>>>>>>>>>>>>\n> >>>>>>>>>>>>> _______________________________________________\n> >>>>>>>>>>>>> swift-evolution mailing list\n> >>>>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> >>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n> >>>>>>>>>>>>\n> >>>>>>>>>>>>\n> >>>>>>>>>>>> _______________________________________________\n> >>>>>>>>>>>> swift-evolution mailing list\n> >>>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> >>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n> >>>>>>>>>>>\n> >>>>>>>>>>>\n> >>>>>>>>>>> _______________________________________________\n> >>>>>>>>>>> swift-evolution mailing list\n> >>>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> >>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n> >>>>>>>>>>\n> >>>>>>>>>>  _______________________________________________\n> >>>>>>>>>> swift-evolution mailing list\n> >>>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> >>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n> >>>>>>>>>\n> >>>>>>>>>\n> >>>>>>>>> _______________________________________________\n> >>>>>>>>> swift-evolution mailing list\n> >>>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> >>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n> >>>>>>>>\n> >>>>>>>>\n> >>>>>>>> _______________________________________________\n> >>>>>>>> swift-evolution mailing list\n> >>>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> >>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n> >>>>>>>\n> >>>>>>>\n> >>>>>>> _______________________________________________\n> >>>>>>> swift-evolution mailing list\n> >>>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> >>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n> >>>>>>\n> >>>>>> _______________________________________________\n> >>>>>> swift-evolution mailing list\n> >>>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> >>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n> >>>>>\n> >>>>> _______________________________________________\n> >>>>> swift-evolution mailing list\n> >>>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> >>>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n> >>>>\n> >>>>\n> >>>> _______________________________________________\n> >>>> swift-evolution mailing list\n> >>>> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> >>>> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n> >>\n> >\n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n> -- \n> Dan Appel" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000678.html" , "inReplyTo" : "CADQN+5atyJ78vi0xssjOxh2ka_-jZTaO3ZabxFdY80YqJHFmxg@mail.gmail.com" , "date" : { "$date" : 1449439094000} , "subject" : "[swift-evolution] Proposal: Remove the \"fallthrough\" keyword" , "references" : [ "3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com" , "AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com" , "8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com" , "1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com" , "02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com" , "E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com" , "444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com" , "EF1675F6-7918-4262-B535-696104BFC405@apple.com" , "CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com" , "D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org" , "071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com" , "CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org" , "6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com" , "6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org" , "A56C416E-E246-44FC-A681-3DD66171DF30@springsandstruts.com" , "CADQN+5atyJ78vi0xssjOxh2ka_-jZTaO3ZabxFdY80YqJHFmxg@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/E7877054-1CF7-4596-800A-0D3C578A0CF1@portableinnovations.de"}} , "_id" : "E7877054-1CF7-4596-800A-0D3C578A0CF1@portableinnovations.de" , "from" : "thorsten at portableinnovations.de (thorsten at portableinnovations.de)" , "mailingList" : "swift-evolution" , "content" : "Initially I thought that reswitch (apart from the name :-) looked nice the example of Alex  seems to mix two parts of a recursive algorithm into one statement: pattern matching the head of a list and recursing.\n\nThen I realized that instead of introducing reswitch you can simply extract the switch into a method and call that recursively. This would have the added benefit that instead of \"reswitch\" the (hopefully) expressive name of the function would be used, making the intent clearer:\n\nfunc find(n: T, in list: List<T>) -> Bool {\n    switch list {\n    case .Cons(let m, _) where m == n:\n        return true\n    case .Cons(_, let rest):\n        return find(n, in: rest)\n    case .Empty:\n        return false\n    }\n}\n\n-Thorsten \n\n> Am 06.12.2015 um 22:28 schrieb Alex Lew via swift-evolution <swift-evolution at swift.org>:\n> \n> switch lst {\n> case .Cons(let m, _) where m == n:\n>      return true\n> case .Cons(_, let rest):\n>     reswitch(rest)\n> case .Empty:\n>      return false\n> }" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000679.html" , "inReplyTo" : "CAKCGC8DbhMOX6bHtzXQcAhjHQSw1wSSoX-TBUtew0arWA=4pSw@mail.gmail.com" , "date" : { "$date" : 1449439401000} , "subject" : "[swift-evolution] Proposal: Remove the \"fallthrough\" keyword" , "references" : [ "3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com" , "AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com" , "8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com" , "1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com" , "02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com" , "E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com" , "444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com" , "EF1675F6-7918-4262-B535-696104BFC405@apple.com" , "CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com" , "D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org" , "071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com" , "CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org" , "6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com" , "6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org" , "CAKCGC8DbhMOX6bHtzXQcAhjHQSw1wSSoX-TBUtew0arWA=4pSw@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAPh90aGVow3HRQD2zs7mZuFoZ3fxd2t4469nKrwXSS5FGzwiOw@mail.gmail.com"}} , "_id" : "CAPh90aGVow3HRQD2zs7mZuFoZ3fxd2t4469nKrwXSS5FGzwiOw@mail.gmail.com" , "from" : "ilya.nikokoshev at gmail.com (ilya)" , "mailingList" : "swift-evolution" , "content" : "Yes, I meant for the email to go to the list.\n\n> Nope, that doesn't work because of my comment above.  That's the change\nto Swift I am hoping will be adopted for 3.0.\n\nDid you try this? The idea is to write a function for multiplying a Number\nand an Int, so the rhs will create a Number which will then be set to the\nvariable. It should work actually.\n\nOn Mon, Dec 7, 2015 at 00:47 Don Wills <don.wills at portablesoftware.com>\nwrote:\n\n> Hello Ilya,\n>\n> On Dec 6, 2015, at 1:09 PM, ilya <ilya.nikokoshev at gmail.com> wrote:\n>\n>\n> On Sun, Dec 6, 2015 at 5:26 PM, Don Wills via swift-evolution <\n> swift-evolution at swift.org> wrote:\n>\n>> Silvan,\n>>\n>> Yes, I understand the concern you raise.  I too have held that general\n>> opinion of overloading operators in other languages for many years.  That\n>> said, overloading arithmetic and other operators causes the same\n>> opportunity for abuse.\n>>\n> For example, overloading + for integers to do something different (like\n>> rounding instead of truncation) would make maintenance of existing programs\n>> into a giant guessing game.\n>>\n>> That said, once the cat is out of the bag to overload operators, I don't\n>> see how adding support for = makes things any worse.\n>>\n>>\n> This is not really the same. You only use + explicitely, but the compiler\n> must insert some assigments automatically, for example by copying when the\n> function closes over some variables. It must know exactly what the\n> semantics in this case is to be able to compile correct program.\n>\n>\n> My example wasn't the best.  IMO, there is almost no conceptual difference\n> between \"amount = 5.5;\" and \"amount += 5.5;\".  The second example works\n> (that is += can be overloaded) where the first example is not allowed\n> because when I try to define the \"func = (...) {...}\" overload\n> implementation, the compiler squawks.\n>\n>\n> FYI, the reason for my suggestion is to add support for fixed decimal\n>> arithmetic just like that available in COBOL.  Yeh I can hear the groans\n>> now.\n>>\n>\n> I'm with you.\n>\n>\n>> However, for business applications, fixed decimal arithmetic is a basic\n>> feature that has been tossed away in new languages by language designers\n>> who don't actually labor in the trenches.\n>>\n>\n> I didn't look into the new Foundation, but doesn't it contain\n> NSDecimalNumber?\n>\n>>\n>>\n> I've built a simple class to do just that - here is some sample code that\n>> uses my Number class that gives an idea of what the code does:\n>>\n>> var amount = Number(left: 6, right: 2);\n>> var result = Number(left: 9, right: 2);\n>> amount <- 3.9;\n>> amount += 1;\n>> result <- amount * 4;\n>> print(result)\n>>\n>>\n> I'm not sure why you feel the need to overload = in this example. If\n> Number * Int -> Number is defined, you can just use\n>\n> result = amount * 4\n>\n>\n> Nope, that doesn't work because of my comment above.  That's the change to\n> Swift I am hoping will be adopted for 3.0.\n>\n> Did you mean to not post your email to me only?  I haven't figured out the\n> protocol for this email list yet.\n>\n> Don Wills\n>\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000680.html" , "inReplyTo" : "2164F4EC-E460-4BD5-8ABB-26EAFBE8D439@portablesoftware.com" , "date" : { "$date" : 1449439518000} , "subject" : "[swift-evolution] Overloading assignment operator" , "references" : [ "19FBB566-3CF3-4CB3-9658-751071B88288@portablesoftware.com" , "D022E424-6A10-4F16-A11C-41B3DF9485A8@icloud.com" , "93AC01C7-172B-41F8-B27E-803887706B87@portablesoftware.com" , "CAPh90aH=19TQOH5hxtnRwGg0igMgiazaGQeNQ0Hhqor1LtZc7w@mail.gmail.com" , "2164F4EC-E460-4BD5-8ABB-26EAFBE8D439@portablesoftware.com"] , "descendants" : [ "26787AE6-26C4-47D7-8529-043233D4A383@portablesoftware.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/24220A0F-DDDB-4CC7-ADE0-18ED197902E8@portableinnovations.de"}} , "_id" : "24220A0F-DDDB-4CC7-ADE0-18ED197902E8@portableinnovations.de" , "from" : "thorsten at portableinnovations.de (thorsten at portableinnovations.de)" , "mailingList" : "swift-evolution" , "content" : "+1. I also think that < should not be defined for Optional.\n\n-Thorsten \n\n> Am 06.12.2015 um 22:56 schrieb Tyler Mandry via swift-evolution <swift-evolution at swift.org>:\n> \n> I agree with Adrian here – the problem IMO is the fact that you can do `x < 5` at all if x is optional." , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000681.html" , "inReplyTo" : "CAA9p5uvxy5ufiafCrmxrLZ11oQPOizzUbyWYsBkYOPNqbX22Ag@mail.gmail.com" , "date" : { "$date" : 1449439736000} , "subject" : "[swift-evolution] mandatory \"?\" suffix for identifiers associated with optional types" , "references" : [ "CAA9p5uvxy5ufiafCrmxrLZ11oQPOizzUbyWYsBkYOPNqbX22Ag@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/D7B06EA6-A46C-4920-9E09-CB99B96242AA@jacopo.giola.org"}} , "_id" : "D7B06EA6-A46C-4920-9E09-CB99B96242AA@jacopo.giola.org" , "from" : "swift-evolution at jacopo.giola.org (Jacopo Andrea Giola)" , "mailingList" : "swift-evolution" , "content" : "> On 06 Dec 2015, at 22:23, Colin Barrett <colin at springsandstruts.com> wrote:\n> \n>> \n>> On Dec 6, 2015, at 4:14 PM, Jacopo Andrea Giola <swift-evolution at jacopo.giola.org> wrote:\n>> \n>> Yes, I’m aware that at this time the reswitch can be abused and maybe can be better refined to disallow such cases.\n> \n> I’m curious, how do you propose to do this?\n\nI really don’t know right now, I hope we can find a way.\n\n> \n>> Checking the case statement is not a problem by itself, but can be a problem if is coupled with a where clause that is not true when you fallthrought.\n> \n> In your document you give the example:\n> \n>> case .Three where x > 0:\n> \n> Now I may be wrong but I feel as though most of the uses of where clauses are also ones that reference variables bound in a `case let`. For instance:\n> \n>> case .Four(x) where x > 0:\n> \n> In that case, fallthrough would required to evaluating the case part anyway, as per my postulated rules below.\n\nYes, maybe my example is not the most correct one, I’ve tried to come up with something obvious and easy to read/write, but the problem will remain for falltrhought as for the Swift iBook:\n\nNOTE\nThe fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behaviour.\n\nFor me this behaviour is not something that marry together with the where clause that we can add to the switch's cases.\n\n> \n> In any case, I appreciate you taking the time to discuss your proposal, even if I didn’t end up convinced. Thanks.\n> \n> -Colin\n\nWell technically I wasn’t the original proposal, I’ve only appreciate the direction it took and now I’m here to try to spark more discussion to see if is a valid direction and if we can improve it :)\n\n> \n>> I’ve written a really bad draft here https://gist.github.com/JGiola/f735212789bf2f697847\n>> If anyone wants to jump in and elaborate further is welcome. I will try to stay on par with this thread but I’m really bad at writing so every help is welcome.\n>> \n>> And if I remember correctly Daniel Jakult was the first one to made this proposal so if he wants to take on and then made the official proposal has every right to do so and I will be very glad if my gist can be a first reference :)\n>> \n>> - Jacopo\n>> \n>>> On 06 Dec 2015, at 21:52, Colin Barrett <colin at springsandstruts.com> wrote:\n>>> \n>>> Apologies, Jacopo, for missing the updated proposal, and thank you for your patience in summarizing it again.\n>>> \n>>> I’ve only glanced through it but my concern here is that it introduces a whole class of new and creative “foot-guns\" :) In particular, it allows this construction to loop arbitrarily and creatively, particularly in the case of associated values.\n>>> \n>>> I’m not sure why not checking the case statement is considered a problem for the fallthrough keyword. Assuming it’s impossible to fallthrough to a case that introduces binders (what would they be bound to?), and that this is statically checked (both of which seem reasonable assumptions to me, although if I’m wrong feel free to correct me), isn’t it the entire point of the fallthrough keyword that it skips checking the case statement? I can understand how that might be somewhat confusing (and perhaps it should be documented less prominently) but I’m not sure how it’s a *problem*, exactly...\n>>> \n>>> I think I’m still on the side of keeping fallthrough. What’s the downside of doing nothing? For instance in the case of ++ and -- those features complicate the design of a numerics library.\n>>> \n>>> Thanks,\n>>> -Colin\n>>> \n>>>> On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola <swift-evolution at jacopo.giola.org> wrote:\n>>>> \n>>>> Hi Colin,\n>>>> \n>>>> the initial proposal was indeed to remove entirely the `fallthrough` keyword but many people expressed your similar concern and from that point the discussion was steered through an \"enhancement\" and better refinement of the keyword.\n>>>> \n>>>> The new idea is to substitute the old keyword with \"reswitch\" passing the desired new value on which the switch is applied.\n>>>> So something like this:\n>>>> \n>>>> switch (enum) {\n>>>> \tcase .One:\n>>>> \t\t// do something\n>>>> \t\treswitch .Two\n>>>> \tcase .Two:\n>>>> \t\t// do something else\n>>>> \tdefault:\n>>>> \t\t// and so one\n>>>> }\n>>>> \n>>>> This new behaviour, IMO, is better suited for Swift because is more declarative of the developer intent and doesn't carry over unintentional misbehaviour.\n>>>> Is more declarative because you are forced to state in which case you want to go, and even if the order of the switch’ cases will change in the future, you don't fall in the wrong case by mistake.\n>>>> \n>>>> switch (enum) {\n>>>> \tcase .One:\n>>>> \t\t// do something\n>>>> \t\treswitch .Two\n>>>> \tcase .OneAndAHalf\n>>>> \t\t// maybe this change is not made by you but by a messed up merge\n>>>> \tcase .Two:\n>>>> \t\t// do something else\n>>>> \tdefault:\n>>>> \t\t// and so one\n>>>> }\n>>>> \n>>>> In this case if you are using the fallthrough keyboard your code is now broken by accident, and depending on what are you trying to do inside the cases you can have a hidden bug that your tests are not seeing right away. \n>>>> \n>>>> Another advantage is that in this way you can made more cases fallthrough in the same one even if they are not one over each other\n>>>> \n>>>> switch (enum) {\n>>>> \tcase .One:\n>>>> \t\t// do something\n>>>> \t\treswitch .Two\n>>>> \tcase .OneAndAHalf\n>>>> \t\t// so something that you don’t want to do for .One\n>>>> \t\treswitch .Two\n>>>> \tcase .Two:\n>>>> \t\t// do something else that you may want to do for .One and .Two\n>>>> \tdefault:\n>>>> \t\t// and so one\n>>>> }\n>>>> \n>>>> I must say that this is a side effect that can be used to messed up the code flow in a way that is not intended, but is a new behaviour that gives more power to the switch statement.\n>>>> \n>>>> The reswitch keyword in addition is not a mere fallthrough on the new case without doing the optional checking attached to it, but is intended to be a new call and all the check are executed.\n>>>> \n>>>> switch (enum) {\n>>>> \tcase .One:\n>>>> \t\t// do something\n>>>> \t\tx = 0;\n>>>> \t\treswitch .Two\n>>>> \tcase .OneAndAHalf\n>>>> \t\t// so something that you don’t want to do for .One\n>>>> \t\treswitch .Two\n>>>> \tcase .Two where x > 0:\n>>>> \t\t// do something else that you may want to do for .One and .Two\n>>>> \t\telement = array[x]\n>>>> \tdefault:\n>>>> \t\t// and so one\n>>>> }\n>>>> (I’m going by memory and by writing this snippets in the mail app directly, so the code must be incorrect in the syntax and for this I’m sorry).\n>>>> \n>>>> In this case if enum is .One the only case that is executed is case .One and the code doesn’t fallthrough in the .Two case because we are made the where invalid by changing the x to a value less than 1.\n>>>> \n>>>> Now I don’t remember who was the first one who mede this proposal, and I don’t know if he is working on a first draft to lay down the things better, but for me this can be a nice improvement and a neat break with the C-switch behaviour that Swift has trying to change from the very first beta disallowing the implicit fallthrough.\n>>>> \n>>>> I can be completely wrong but I see the `fallthrough`keyword as a “temporary” implementation for ease the transition from Obj-C to Swift and is time to improve it and made the switch statement even more powerful.\n>>>> \n>>>> - Jacopo\n>>>> Sent from my iPad\n>>>> \n>>>> On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution <swift-evolution at swift.org> wrote:\n>>>> \n>>>>> tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.\n>>>>> \n>>>>> Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.\n>>>>> \n>>>>> I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)\n>>>>> \n>>>>> Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:\n>>>>> \n>>>>> https://gist.github.com/cbarrett/23b24a9fe76efdf006df\n>>>>> \n>>>>> This technique is very extensible — for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.\n>>>>> \n>>>>> Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type — low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.\n>>>>> \n>>>>> Thanks,\n>>>>> -Colin\n>>>>> \n>>>>>> On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution <swift-evolution at swift.org> wrote:\n>>>>>> \n>>>>>> +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.\n>>>>>> \n>>>>>> If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don't introduce an infinite \"switch\" loop.\n>>>>>> \n>>>>>> Sent from my iPad\n>>>>>> \n>>>>>> On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution <swift-evolution at swift.org> wrote:\n>>>>>> \n>>>>>>> Very much thinking out loud and not really the implications, I wonder if we might just use \"continue\" instead of \"reswitch\".\n>>>>>>> \n>>>>>>> I very much like specifying what case to fall through into, no matter how we spell it.\n>>>>>>> \n>>>>>>> - Steve\n>>>>>>> \n>>>>>>> On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution <swift-evolution at swift.org> wrote:\n>>>>>>> \n>>>>>>>>> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution <swift-evolution at swift.org> wrote:\n>>>>>>>>>> On Dec 4, 2015, at 11:37 PM, John Calsbeek <john.calsbeek+lists at gmail.com> wrote:\n>>>>>>>>>> `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.\n>>>>>>>>>> \n>>>>>>>>>> It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.\n>>>>>>>>> \n>>>>>>>>> Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.\n>>>>>>>>> \n>>>>>>>>> On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.\n>>>>>>>> \n>>>>>>>> Oh, I see that Joe already brought this up, spelled “reswitch”.\n>>>>>>>> \n>>>>>>>> John.\n>>>>>>>> \n>>>>>>>>> \n>>>>>>>>> John.\n>>>>>>>>> \n>>>>>>>>>> \n>>>>>>>>>> One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).\n>>>>>>>>>> \n>>>>>>>>>> switch op {\n>>>>>>>>>> case LOAD_INDIRECT:\n>>>>>>>>>>   in0 = memory[in1]\n>>>>>>>>>>   fallthrough\n>>>>>>>>>> case LOAD:\n>>>>>>>>>>   out0 = memory[in0]\n>>>>>>>>>> //...\n>>>>>>>>>> }\n>>>>>>>>>> \n>>>>>>>>>> I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.\n>>>>>>>>>> \n>>>>>>>>>> Cheers,\n>>>>>>>>>> John\n>>>>>>>>>> \n>>>>>>>>>>> On Dec 4, 2015, at 2:42 PM, John McCall <rjmccall at apple.com> wrote:\n>>>>>>>>>>> \n>>>>>>>>>>>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard <kevin at sb.org> wrote:\n>>>>>>>>>>>> It's not actually Duff's Device. Duff's Device relies on the fact that C switch statements don't actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it's a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.\n>>>>>>>>>>> \n>>>>>>>>>>> To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.\n>>>>>>>>>>> \n>>>>>>>>>>> But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.\n>>>>>>>>>>> \n>>>>>>>>>>> John.\n>>>>>>>>>>> \n>>>>>>>>>>>> \n>>>>>>>>>>>> Steve's code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It's a good example of one of the uses of `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's Device in Swift.\n>>>>>>>>>>>> \n>>>>>>>>>>>> -Kevin Ballard\n>>>>>>>>>>>> \n>>>>>>>>>>>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:\n>>>>>>>>>>>>> Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.\n>>>>>>>>>>>>> \n>>>>>>>>>>>>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun <erica at ericasadun.com> wrote:\n>>>>>>>>>>>>>> \n>>>>>>>>>>>>>> Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it. \n>>>>>>>>>>>>>> \n>>>>>>>>>>>>>> True fact: On all of gist.github.com, there are only 22 gist results for \"fallthrough language:swift\".\n>>>>>>>>>>>>>> Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:\n>>>>>>>>>>>>>> case .Enum1, .Enum2:\n>>>>>>>>>>>>>> expressed as \n>>>>>>>>>>>>>> case .Enum1: fallthrough\n>>>>>>>>>>>>>> case .Enum2:\n>>>>>>>>>>>>>> \n>>>>>>>>>>>>>> And then there's streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea   I'm pretty sure that ponies were harmed in the production of whatever that last bit is.\n>>>>>>>>>>>>>> \n>>>>>>>>>>>>>> \n>>>>>>>>>>>>>> \n>>>>>>>>>>>>>> \n>>>>>>>>>>>>>>> On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com wrote:\n>>>>>>>>>>>>>>> \n>>>>>>>>>>>>>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the \"fallthrough\" keyword from the language?\n>>>>>>>>>>>>>>> \n>>>>>>>>>>>>>>> My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.\n>>>>>>>>>>>>>>> \n>>>>>>>>>>>>>>> The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:\n>>>>>>>>>>>>>>> \n>>>>>>>>>>>>>>> \"The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.\"\n>>>>>>>>>>>>>>> \n>>>>>>>>>>>>>>> To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.\n>>>>>>>>>>>>>>> \n>>>>>>>>>>>>>>> I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.\n>>>>>>>>>>>>>>> \n>>>>>>>>>>>>>>> In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.\n>>>>>>>>>>>>>>> \n>>>>>>>>>>>>>>> Thoughts?\n>>>>>>>>>>>>>>> \n>>>>>>>>>>>>>>> Daniel\n>>>>>>>>>>>>>>> \n>>>>>>>>>>>>>>> _______________________________________________\n>>>>>>>>>>>>>>> swift-evolution mailing list\n>>>>>>>>>>>>>>> swift-evolution at swift.org\n>>>>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>>>>>>>>>>>> \n>>>>>>>>>>>>>> \n>>>>>>>>>>>>>> _______________________________________________\n>>>>>>>>>>>>>> swift-evolution mailing list\n>>>>>>>>>>>>>> swift-evolution at swift.org\n>>>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>>>>>>>>>>> \n>>>>>>>>>>>>> \n>>>>>>>>>>>>> _______________________________________________\n>>>>>>>>>>>>> swift-evolution mailing list\n>>>>>>>>>>>>> swift-evolution at swift.org\n>>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>>>>>>>>>> \n>>>>>>>>>>>> \n>>>>>>>>>>>> _______________________________________________\n>>>>>>>>>>>> swift-evolution mailing list\n>>>>>>>>>>>> swift-evolution at swift.org\n>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>>>>>>>>> \n>>>>>>>>>>> _______________________________________________\n>>>>>>>>>>> swift-evolution mailing list\n>>>>>>>>>>> swift-evolution at swift.org\n>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>>>>>>>> \n>>>>>>>>>> \n>>>>>>>>>> _______________________________________________\n>>>>>>>>>> swift-evolution mailing list\n>>>>>>>>>> swift-evolution at swift.org\n>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>>>>>>> \n>>>>>>>>> \n>>>>>>>>> _______________________________________________\n>>>>>>>>> swift-evolution mailing list\n>>>>>>>>> swift-evolution at swift.org\n>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>>>>>> \n>>>>>>>> \n>>>>>>>> _______________________________________________\n>>>>>>>> swift-evolution mailing list\n>>>>>>>> swift-evolution at swift.org\n>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>>>>> \n>>>>>>> _______________________________________________\n>>>>>>> swift-evolution mailing list\n>>>>>>> swift-evolution at swift.org\n>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>>>> \n>>>>>> _______________________________________________\n>>>>>> swift-evolution mailing list\n>>>>>> swift-evolution at swift.org\n>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>>> \n>>>>> \n>>>>> _______________________________________________\n>>>>> swift-evolution mailing list\n>>>>> swift-evolution at swift.org\n>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000686.html" , "inReplyTo" : "A56C416E-E246-44FC-A681-3DD66171DF30@springsandstruts.com" , "date" : { "$date" : 1449439781000} , "subject" : "[swift-evolution] Proposal: Remove the \"fallthrough\" keyword" , "references" : [ "3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com" , "AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com" , "8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com" , "1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com" , "02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com" , "E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com" , "444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com" , "EF1675F6-7918-4262-B535-696104BFC405@apple.com" , "CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com" , "D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org" , "071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com" , "CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org" , "6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com" , "6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org" , "A56C416E-E246-44FC-A681-3DD66171DF30@springsandstruts.com"] , "descendants" : [ "1449442122.2380087.459714713.0AC4A201@webmail.messagingengine.com" , "CEA837D7-E2B1-48DC-A53B-D216F96DD8DF@apple.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/6DA2FDFF-F978-4ECA-9E2B-F757F6D8BBF3@icloud.com"}} , "_id" : "6DA2FDFF-F978-4ECA-9E2B-F757F6D8BBF3@icloud.com" , "from" : "possen at gmail.com (Paul Ossenbruggen)" , "mailingList" : "swift-evolution" , "content" : "so the rule would have to be that the “switch\" or “if\" must return a value of compatible type. Not sure I love all the braces in the “if\" case but it does follow the existing language rules with the exception that it must be have an else.\n\nlet thisColor = if condition { .Red }   // illegal for expressions but not statements\n\nCan still do this for statements:\nif condition {\n\tx = 40\n}\n\nlikewise:\nlet thisColor = if condition { .Red } else { 21 } // illegal unless thisColor is Any \n\nunless: \nlet thisColor : Any = if condition { .Red } else { 21 } // illegal unless thisColor is Any \n\nIt would be nice to omit braces in this expression case but not for statements: \nlet thisColor = if condition .Red else .Blue \n\nin statements braces would be required: \n\nif condition {\n\tx = 32\n} else {\n\ty = 44\n}\n\n> >     }\n> On Dec 6, 2015, at 1:52 PM, Alex Lew via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> I agree that it's simplest to just reuse switch keyword, and keep braces. +1.  \n> \n> Would you allow the same thing with if?\n> \n> let thisColor = if condition { .Red } else { .Blue }\n> \n> On Sun, Dec 6, 2015 at 4:44 PM, Rudolf Adamkovic <salutis at me.com <mailto:salutis at me.com>> wrote:\n> > On 06 Dec 2015, at 22:35, thorsten--- via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n> \n> >\n> > I would prefer the expression to match the statement. The only difference would be that all parts that were statements now have to be expressions.\n> \n> +1\n> \n> >\n> > Therefore the switch-expression should simply look like follows:\n> >\n> > let thisColor = switch thatColor {\n> >         case .Red: .Green // must be an expression\n> >         default: .Yellow      // must be an expression\n> >     }\n> >\n> > No returns needed in the case clauses.\n> \n> This actually looks great. One simple rule and zero new keywords.\n> \n> Readable and simple to learn.\n> \n> Fantastic!\n> \n> > Formatting this as a one-liner would just require adding semicolons (though I wouldn't recommend this).\n> >\n> > -Thorsten\n> > _______________________________________________\n> > swift-evolution mailing list\n> > swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> > https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>\n> \n>  _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org <mailto:swift-evolution at swift.org>\n> https://lists.swift.org/mailman/listinfo/swift-evolution <https://lists.swift.org/mailman/listinfo/swift-evolution>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000682.html" , "inReplyTo" : "CAKCGC8BmmCk55=6UC_qk_C+ZNq2JfGpOPO5cJ=SK2784kmvbGg@mail.gmail.com" , "date" : { "$date" : 1449439895000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com" , "CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com" , "C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com" , "18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com" , "2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io" , "BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com" , "CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com" , "CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com" , "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com" , "BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com" , "909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net" , "0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com" , "49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net" , "CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com" , "49EEA2E6-55F2-49DE-A59F-A13017626370@web.de" , "CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com" , "4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com" , "11462DA4-ACDD-4CF3-BD57-47886B655970@anandabits.com" , "CAKCGC8AVDe6W9X=XvFEnbkae8xom2Us8xczKFShqKu2+kPnRJA@mail.gmail.com" , "07270E34-E284-4FF0-B2EA-6DBB54FF78B5@portableinnovations.de" , "45B71AF5-DD4F-4E9C-A128-5B8041917564@me.com" , "CAKCGC8BmmCk55=6UC_qk_C+ZNq2JfGpOPO5cJ=SK2784kmvbGg@mail.gmail.com"] , "descendants" : [ "54E5D8F5-616D-41EB-A550-E639FE861575@gmail.com" , "CAKCGC8CsJ7g_Fu8fnQ5Mv=yAzbSvb0Z+iNmdXKnJaAcWR2UKuw@mail.gmail.com" , "6830F74D-78FC-4B20-A6D5-683185B30164@gmail.com" , "691A92C4-1A5F-4CAE-AF50-F6AAA3A3F32C@portableinnovations.de" , "D35074A6-1C34-4BA3-AAF1-8CFE1992A522@me.com" , "1EE735A6-FF0F-4E49-BE7D-AC7E6C8A87EC@tarantsov.com" , "3D250DE5-09BC-4A6B-AF59-E1D714DF709A@tarantsov.com" , "BB6A4434-E2B1-4192-8450-90D636E6A7F5@fastmail.fm" , "0ED79E6D-A89A-4F3E-9269-6216BD10EB22@sealedabstract.com" , "CAAcV4sb9eMhuLGL3QsBw4bFxj1FQrokCAanKjEFRNNReE8zWOQ@mail.gmail.com" , "7253CF12-DBD4-483D-941F-04851E5AD394@tarantsov.com" , "CAAcV4sbo4=Hdzp+yx-km-CnhNDm2uQ-gDJsvdug_Pg-MjTPC=Q@mail.gmail.com" , "CAAcV4sbAk_eSdjz7bQ6ggdZNE+thmj7-wT_pG2+eRMKDVba+wA@mail.gmail.com" , "7B70F158-5B8A-425B-980C-CD08210342D4@me.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/26787AE6-26C4-47D7-8529-043233D4A383@portablesoftware.com"}} , "_id" : "26787AE6-26C4-47D7-8529-043233D4A383@portablesoftware.com" , "from" : "don.wills at portablesoftware.com (Don Wills)" , "mailingList" : "swift-evolution" , "content" : "Hello Ilya, \n\n> On Dec 6, 2015, at 3:05 PM, ilya <ilya.nikokoshev at gmail.com> wrote:\n> \n> Yes, I meant for the email to go to the list. \n> \n> > Nope, that doesn't work because of my comment above.  That's the change to Swift I am hoping will be adopted for 3.0.\n> \n> Did you try this? The idea is to write a function for multiplying a Number and an Int, so the rhs will create a Number which will then be set to the variable. It should work actually. \n\nYes, I've written a class named Number with many \"func <operator> ( ... ) { ... }\" implementations for the various permutations of Number, Double and operators.  They all work except for when <operator> is the equal sign.\n\nDon\n\n> On Mon, Dec 7, 2015 at 00:47 Don Wills <don.wills at portablesoftware.com <mailto:don.wills at portablesoftware.com>> wrote:\n> Hello Ilya,\n> \n> On Dec 6, 2015, at 1:09 PM, ilya <ilya.nikokoshev at gmail.com <mailto:ilya.nikokoshev at gmail.com>> wrote:\n>> \n>> On Sun, Dec 6, 2015 at 5:26 PM, Don Wills via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>> Silvan,\n>> \n>> Yes, I understand the concern you raise.  I too have held that general opinion of overloading operators in other languages for many years.  That said, overloading arithmetic and other operators causes the same opportunity for abuse.   \n>> For example, overloading + for integers to do something different (like rounding instead of truncation) would make maintenance of existing programs into a giant guessing game.\n>> \n>> That said, once the cat is out of the bag to overload operators, I don't see how adding support for = makes things any worse.\n>> \n>> \n>> This is not really the same. You only use + explicitely, but the compiler must insert some assigments automatically, for example by copying when the function closes over some variables. It must know exactly what the semantics in this case is to be able to compile correct program.\n> \n> My example wasn't the best.  IMO, there is almost no conceptual difference between \"amount = 5.5;\" and \"amount += 5.5;\".  The second example works (that is += can be overloaded) where the first example is not allowed because when I try to define the \"func = (...) {...}\" overload implementation, the compiler squawks.\n> \n> \n>> FYI, the reason for my suggestion is to add support for fixed decimal arithmetic just like that available in COBOL.  Yeh I can hear the groans now.  \n>> \n>> I'm with you.\n>>  \n>> However, for business applications, fixed decimal arithmetic is a basic feature that has been tossed away in new languages by language designers who don't actually labor in the trenches.\n>> \n>> I didn't look into the new Foundation, but doesn't it contain NSDecimalNumber? \n>>  \n>> I've built a simple class to do just that - here is some sample code that uses my Number class that gives an idea of what the code does:\n>> \n>> var amount = Number(left: 6, right: 2);\n>> var result = Number(left: 9, right: 2);\n>> amount <- 3.9;\n>> amount += 1;\n>> result <- amount * 4;\n>> print(result)\n>> \n>> \n>> I'm not sure why you feel the need to overload = in this example. If Number * Int -> Number is defined, you can just use\n>> \n>> result = amount * 4\n> \n> Nope, that doesn't work because of my comment above.  That's the change to Swift I am hoping will be adopted for 3.0.\n> \n> Did you mean to not post your email to me only?  I haven't figured out the protocol for this email list yet.\n> \n> Don Wills\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000683.html" , "inReplyTo" : "CAPh90aGVow3HRQD2zs7mZuFoZ3fxd2t4469nKrwXSS5FGzwiOw@mail.gmail.com" , "date" : { "$date" : 1449439902000} , "subject" : "[swift-evolution] Overloading assignment operator" , "references" : [ "19FBB566-3CF3-4CB3-9658-751071B88288@portablesoftware.com" , "D022E424-6A10-4F16-A11C-41B3DF9485A8@icloud.com" , "93AC01C7-172B-41F8-B27E-803887706B87@portablesoftware.com" , "CAPh90aH=19TQOH5hxtnRwGg0igMgiazaGQeNQ0Hhqor1LtZc7w@mail.gmail.com" , "2164F4EC-E460-4BD5-8ABB-26EAFBE8D439@portablesoftware.com" , "CAPh90aGVow3HRQD2zs7mZuFoZ3fxd2t4469nKrwXSS5FGzwiOw@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAKCGC8Cp52O7DX6wWSc3J6FR8Xmoo_WLBgjGBa6fSXzNHhdHEg@mail.gmail.com"}} , "_id" : "CAKCGC8Cp52O7DX6wWSc3J6FR8Xmoo_WLBgjGBa6fSXzNHhdHEg@mail.gmail.com" , "from" : "alexl.mail+swift at gmail.com (Alex Lew)" , "mailingList" : "swift-evolution" , "content" : "Yes, thanks, Colin -- semantically, I think it's exactly equivalent to a\nrecursive call to an implicitly defined function closing over the switch.\nIn practice, the compiler may be able to translate it to a true fallthrough\nin many cases.\n\nIn any case, I am not arguing for or against reswitch -- I kind of like it,\nbut also would be fine with keeping fallthrough as is. I just wanted to\nbetter understand what the proposed semantics of reswitch actually were\n(hence the var x question, which I guess would be similar to having your\nrecursive function declare a mutable parameter).\n\nOn Sun, Dec 6, 2015 at 4:57 PM, Colin Barrett <colin at springsandstruts.com>\nwrote:\n\n> If you need control flow this complex, why not just use recursion?\n> reswitch is, near as I can tell, a recursive call to an implicitly defined\n> function (closing over the switch).\n>\n> -Colin\n>\n> On Dec 6, 2015, at 4:49 PM, Jacopo Andrea Giola <\n> swift-evolution at jacopo.giola.org> wrote:\n>\n> The result is .Two, because you are returning from the reswitch and in\n> that case the original x is shadowed by the new execution.\n>\n> - Jacopo\n>\n> On 06 Dec 2015, at 22:36, Alex Lew <alexl.mail+swift at gmail.com> wrote:\n>\n> One question: what is the result of this code?\n>\n> let x = .One\n>\n> switch x {\n> case .One:\n>    reswitch(.Two)\n> case .Two:\n>    return x\n> }\n>\n> .One or .Two? In other words, is x rebound inside the switch when we\n> reswitch?\n>\n> On Sun, Dec 6, 2015 at 4:28 PM, Alex Lew <alexl.mail+swift at gmail.com>\n> wrote:\n>\n>> It seems reswitch *should* be useable even in cases that aren't a simple\n>> \"goto\". Or am I missing something?\n>>\n>> For instance, rewriting the example from earlier:\n>>\n>> switch op {\n>> case let .LOAD_INDIRECT(out, in):\n>>     reswitch(.LOAD(out, memory[in]))\n>> case let .LOAD(out, in):\n>>     setReg(out, in)\n>> // ...\n>> }\n>>\n>> or, a switch that calculates whether some number n is in a Lisp-style\n>> list of numbers\n>>\n>> switch lst {\n>> case .Cons(let m, _) where m == n:\n>>      return true\n>> case .Cons(_, let rest):\n>>     reswitch(rest)\n>> case .Empty:\n>>      return false\n>> }\n>>\n>> I like reswitch: in some cases, the compiler could optimize to a\n>> fallthrough, and in others, you could actually re-switch. But maybe I'm\n>> missing something.\n>>\n>> On Sun, Dec 6, 2015 at 4:14 PM, Jacopo Andrea Giola via swift-evolution <\n>> swift-evolution at swift.org> wrote:\n>>\n>>> Yes, I’m aware that at this time the reswitch can be abused and maybe\n>>> can be better refined to disallow such cases.\n>>>\n>>> Checking the case statement is not a problem by itself, but can be a\n>>> problem if is coupled with a where clause that is not true when you\n>>> fallthrought.\n>>>\n>>> I’ve written a really bad draft here\n>>> https://gist.github.com/JGiola/f735212789bf2f697847\n>>> If anyone wants to jump in and elaborate further is welcome. I will try\n>>> to stay on par with this thread but I’m really bad at writing so every help\n>>> is welcome.\n>>>\n>>> And if I remember correctly Daniel Jakult was the first one to made this\n>>> proposal so if he wants to take on and then made the official proposal has\n>>> every right to do so and I will be very glad if my gist can be a first\n>>> reference :)\n>>>\n>>> - Jacopo\n>>>\n>>> On 06 Dec 2015, at 21:52, Colin Barrett < colin at springsandstruts.com>\n>>> wrote:\n>>>\n>>> Apologies, Jacopo, for missing the updated proposal, and thank you for\n>>> your patience in summarizing it again.\n>>>\n>>> I’ve only glanced through it but my concern here is that it introduces a\n>>> whole class of new and creative “foot-guns\" :) In particular, it allows\n>>> this construction to loop arbitrarily and creatively, particularly in the\n>>> case of associated values.\n>>>\n>>> I’m not sure why not checking the case statement is considered a problem\n>>> for the fallthrough keyword. Assuming it’s impossible to fallthrough to a\n>>> case that introduces binders (what would they be bound to?), and that this\n>>> is statically checked (both of which seem reasonable assumptions to me,\n>>> although if I’m wrong feel free to correct me), isn’t it the entire point\n>>> of the fallthrough keyword that it skips checking the case statement? I can\n>>> understand how that might be somewhat confusing (and perhaps it should be\n>>> documented less prominently) but I’m not sure how it’s a *problem*,\n>>> exactly...\n>>>\n>>> I think I’m still on the side of keeping fallthrough. What’s the\n>>> downside of doing nothing? For instance in the case of ++ and -- those\n>>> features complicate the design of a numerics library.\n>>>\n>>> Thanks,\n>>> -Colin\n>>>\n>>> On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola <\n>>> swift-evolution at jacopo.giola.org> wrote:\n>>>\n>>>  Hi Colin,\n>>>\n>>> the initial proposal was indeed to remove entirely the `fallthrough`\n>>> keyword but many people expressed your similar concern and from that point\n>>> the discussion was steered through an \"enhancement\" and better refinement\n>>> of the keyword.\n>>>\n>>> The new idea is to substitute the old keyword with \"reswitch\" passing\n>>> the desired new value on which the switch is applied.\n>>> So something like this:\n>>>\n>>> switch (enum) {\n>>> case .One:\n>>> // do something\n>>> reswitch .Two\n>>> case .Two:\n>>> // do something else\n>>> default:\n>>> // and so one\n>>> }\n>>>\n>>> This new behaviour, IMO, is better suited for Swift because is more\n>>> declarative of the developer intent and doesn't carry over unintentional\n>>> misbehaviour.\n>>> Is more declarative because you are forced to state in which case you\n>>> want to go, and even if the order of the switch’ cases will change in the\n>>> future, you don't fall in the wrong case by mistake.\n>>>\n>>> switch (enum) {\n>>> case .One:\n>>> // do something\n>>> reswitch .Two\n>>> case .OneAndAHalf\n>>> // maybe this change is not made by you but by a messed up merge\n>>> case .Two:\n>>> // do something else\n>>> default:\n>>> // and so one\n>>> }\n>>>\n>>> In this case if you are using the fallthrough keyboard your code is now\n>>> broken by accident, and depending on what are you trying to do inside the\n>>> cases you can have a hidden bug that your tests are not seeing right away.\n>>>\n>>> Another advantage is that in this way you can made more\n>>> cases fallthrough in the same one even if they are not one over each other\n>>>\n>>> switch (enum) {\n>>> case .One:\n>>> // do something\n>>> reswitch .Two\n>>> case .OneAndAHalf\n>>> // so something that you don’t want to do for .One\n>>> reswitch .Two\n>>> case .Two:\n>>> // do something else that you may want to do for .One and .Two\n>>> default:\n>>> // and so one\n>>> }\n>>>\n>>> I must say that this is a side effect that can be used to messed up the\n>>> code flow in a way that is not intended, but is a new behaviour that gives\n>>> more power to the switch statement.\n>>>\n>>> The reswitch keyword in addition is not a mere fallthrough on the new\n>>> case without doing the optional checking attached to it, but is intended to\n>>> be a new call and all the check are executed.\n>>>\n>>> switch (enum) {\n>>> case .One:\n>>> // do something\n>>> x = 0;\n>>> reswitch .Two\n>>> case .OneAndAHalf\n>>> // so something that you don’t want to do for .One\n>>> reswitch .Two\n>>> case .Two where x > 0:\n>>> // do something else that you may want to do for .One and .Two\n>>> element = array[x]\n>>> default:\n>>> // and so one\n>>> }\n>>> (I’m going by memory and by writing this snippets in the mail app\n>>> directly, so the code must be incorrect in the syntax and for this I’m\n>>> sorry).\n>>>\n>>> In this case if enum is .One the only case that is executed is case .One\n>>> and the code doesn’t fallthrough in the .Two case because we are made the\n>>> where invalid by changing the x to a value less than 1.\n>>>\n>>> Now I don’t remember who was the first one who mede this proposal, and I\n>>> don’t know if he is working on a first draft to lay down the things better,\n>>> but for me this can be a nice improvement and a neat break with the\n>>> C-switch behaviour that Swift has trying to change from the very first beta\n>>> disallowing the implicit fallthrough.\n>>>\n>>> I can be completely wrong but I see the `fallthrough`keyword as a\n>>> “temporary” implementation for ease the transition from Obj-C to Swift and\n>>> is time to improve it and made the switch statement even more powerful.\n>>>\n>>> - Jacopo\n>>> Sent from my iPad\n>>>\n>>> On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution <\n>>> swift-evolution at swift.org> wrote:\n>>>\n>>> tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us\n>>> anything; and has at least minimal utility, as I try to demonstrate.\n>>>\n>>> Apologies for jumping into this thread at an awkward point, but I’ve\n>>> only just now subscribed to this list.\n>>>\n>>> I think the fallthrough keyword is useful in certain circumstances. I’ve\n>>> also yet to see an example of where it creates a negative impact, either in\n>>> code, optimization, or what have you. Other than “It’s like something in C,\n>>> and C is old and busted” I’m unsure of the rationale for removing it. (Feel\n>>> free to point me in the right direction.)\n>>>\n>>> Consider the Planet enum from the documentation. One of the simplest way\n>>> to define the number of a planet (i.e. its 1-based index in the ordering of\n>>> planets wrt. distance from the sun) is using a switch and fall-through:\n>>>\n>>> https://gist.github.com/cbarrett/23b24a9fe76efdf006df\n>>>\n>>> This technique is very extensible — for instance imagine computing the\n>>> force induced by the gravity of the other planets on a particular planet.\n>>> All that would need to change is the case statements.\n>>>\n>>> Yes, you could write this by putting the planets into a list and mapping\n>>> or folding (or looping) over that, but unless the compiler can “unroll”\n>>> that construct, you’re paying for an allocation simply bc of your choice of\n>>> control flow. But in fact, you could imagine generalizing this construct\n>>> into the implementation of fold for the Planet type — low-overhead folds\n>>> for monomorphic types seems like a pretty compelling an natural use case\n>>> for fallthrough to me.\n>>>\n>>> Thanks,\n>>> -Colin\n>>>\n>>> On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution <\n>>> swift-evolution at swift.org> wrote:\n>>>\n>>> +1 for this idea, but I will prefer the reswitch keyword instead of\n>>> overloading continue with a new syntax.\n>>>\n>>> If this proposal is accepted, it must be coupled with a compiler check\n>>> that the reswitch statements don't introduce an infinite \"switch\" loop.\n>>>\n>>> Sent from my iPad\n>>>\n>>> On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution <\n>>> swift-evolution at swift.org> wrote:\n>>>\n>>> Very much thinking out loud and not really the implications, I wonder if\n>>> we might just use \"continue\" instead of \"reswitch\".\n>>>\n>>> I very much like specifying what case to fall through into, no matter\n>>> how we spell it.\n>>>\n>>> - Steve\n>>>\n>>> On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution <\n>>> swift-evolution at swift.org> wrote:\n>>>\n>>> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution <\n>>> swift-evolution at swift.org> wrote:\n>>>\n>>> On Dec 4, 2015, at 11:37 PM, John Calsbeek <\n>>> john.calsbeek+lists at gmail.com> wrote:\n>>> `fallthrough` is conceptually similar to `goto` in that both allow\n>>> natural expression of concepts that exist at the instruction level but are\n>>> otherwise difficult to express with nested control structures.\n>>> `fallthrough` is perhaps slightly less objectionable because control flow\n>>> remains local, but it has a similar role.\n>>>\n>>> It is not particularly natural to write `switch` statements with\n>>> `fallthrough` in the reverse order that can be seen in Duff’s Device and\n>>> similar constructs (case 7 falls through to 6 which falls through to 5,\n>>> etc.). It’s just because you know for certain that all the code in case 6\n>>> would be duplicated in case 7, so 7 can transfer into 6 without a jump\n>>> instruction. Communicating that to the compiler without `fallthrough`\n>>> requires deeply nested `if`s.\n>>>\n>>>\n>>> Right.  One idea that I’ve always had for “fallthrough” is that we might\n>>> parameterize it in the future; parameterized it would mean “repeat the\n>>> switch with this new value”, so that unparameterized fallthrough would mean\n>>> “repeat the switch with a notional value that ends up in the next case”.\n>>> There’s a very common pattern in switches of deferring to another case that\n>>> I’ve always found very awkward to write in C, and while sometimes there’s\n>>> no choice but to extract a helper function, there’s a\n>>> still-fairly-structural code pattern here that I think we can sensibly\n>>> support.\n>>>\n>>> On the other hand, there’s an argument that this is an inappropriate\n>>> extension for “fallthrough” specifically, which is one reason we’ve never\n>>> pursued it.\n>>>\n>>>\n>>> Oh, I see that Joe already brought this up, spelled “reswitch”.\n>>>\n>>> John.\n>>>\n>>>\n>>> John.\n>>>\n>>>\n>>> One defense comes to mind: there is talk of Swift aiming at systems\n>>> programming. Is writing a threaded interpreter loop within the potential\n>>> scope of Swift? That’s a use case that could make use of both `fallthrough`\n>>> and `goto` (computed goto, really).\n>>>\n>>> switch op {\n>>> case LOAD_INDIRECT:\n>>>    in0 = memory[in1]\n>>>    fallthrough\n>>> case LOAD:\n>>>    out0 = memory[in0]\n>>> //...\n>>> }\n>>>\n>>> I am personally interested in the prospect of a language that can scale\n>>> up to high-level concepts and down to “portable assembler,” but I don’t\n>>> know if that is the right direction for Swift’s evolution.\n>>>\n>>> Cheers,\n>>> John\n>>>\n>>> On Dec 4, 2015, at 2:42 PM, John McCall < rjmccall at apple.com> wrote:\n>>>\n>>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard < kevin at sb.org> wrote:\n>>> It's not actually Duff's Device. Duff's Device relies on the fact that C\n>>> switch statements don't actually introduce a new scope, and so it overlaps\n>>> a switch with a do-while loop. This lets it only test the number of bytes\n>>> once, to jump into the middle of the loop, and then it switches over to a\n>>> while loop that decrements a counter every 8 instructions. Basically, it's\n>>> a trick for manual loop unrolling that deals with non-multiple-of-8 counts\n>>> efficiently.\n>>>\n>>>\n>>> To be pedantic, C switch statements do introduce a new scope.  What\n>>> Duff’s Device exploits is that switch is allowed to jump into (almost)\n>>> arbitrary scopes, and cases can appear anywhere recursively inside a\n>>> switch.\n>>>\n>>> But your point that Swift’s switch requires cases to be at the top level\n>>> within a switch and thus prevents the use of Duff’s Device is 100% correct.\n>>>\n>>> John.\n>>>\n>>>\n>>> Steve's code is also an example of manual loop unrolling that deals with\n>>> non-multiple-of-8 counts, but it has calculate the number of bytes on every\n>>> iteration instead of once. It's a good example of one of the uses of\n>>> `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's\n>>> Device in Swift.\n>>>\n>>> -Kevin Ballard\n>>>\n>>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:\n>>>\n>>> Streza’s source code is an example of Duff’s Device, which is a big\n>>> place where switch fallthrough is arguably the cleanest way to do things\n>>> and the reason why I’d personally prefer to keep it as part of the\n>>> language.\n>>>\n>>>\n>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun < erica at ericasadun.com> wrote:\n>>>\n>>> Oh let it die, let it die. Any time I use fallthrough I find myself\n>>> re-factoring to stop using it.\n>>>\n>>> *True fact*: On all of   gist.github.com, there are only 22 gist\n>>> results for \"fallthrough language:swift\".\n>>> Half of those are people just testing out the feature. Most of the\n>>> remaining ones are just complex cases:\n>>> *case .Enum1, .Enum2:*\n>>> expressed as\n>>> *case .Enum1: fallthrough*\n>>> *case .Enum2:*\n>>>\n>>> And then there's streza:\n>>> https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea    I'm pretty\n>>> sure that ponies were harmed in the production of whatever that last bit\n>>> is.\n>>>\n>>>\n>>>\n>>>\n>>>\n>>> On Dec 4, 2015, at 3:05 PM,   jalkut at red-sweater.com  wrote:\n>>>\n>>> In the spirit of some other proposals that remove C or C++ style\n>>> artifacts, what do folks think about the possibility of removing the\n>>> \"fallthrough\" keyword from the language?\n>>>\n>>> My understanding is this keyword is only used for the archaic seeming\n>>> purpose of perpetuating C-style fallthrough from one switch statement to\n>>> the subsequent one. The documentation hedges the use of this keyword in\n>>> forbidding terms that make it clear its use is not encouraged. The presence\n>>> of the keyword, while an improvement over C’s implicit fallthrough, is a\n>>> mark of inelegance on an otherwise well-designed, opinionated\n>>> implementation of swtich statements.\n>>>\n>>> The ugliness of fallthrough’s C-style behavior even demands a caveat in\n>>> the documentation:\n>>>\n>>> \"The fallthrough keyword does not check the case conditions for the\n>>> switch case that it causes execution to fall into. The fallthrough keyword\n>>> simply causes code execution to move directly to the statements inside the\n>>> next case (or default case) block, as in C’s standard switch statement\n>>> behavior.\"\n>>>\n>>> To my mind, the caveat explains just what is wrong with fallthrough,\n>>> both in C or Swift: coded that is clearly labeled with deliberate\n>>> conditions can nonetheless be reached.\n>>>\n>>> I quipped about this on Twitter, and the most common pushback I got\n>>> seemed to be from people who either did not know about Swift’s support for\n>>> comma-separated case statements, or harbored an aesthetic preference for\n>>> clustering such cases together with fallthrough statements.\n>>>\n>>> In my opinion, unless somebody can think of a strong defense for\n>>> supporting intentional fallthrough in Swift, removing the keyword would be\n>>> a move in the direction of minimizing the language’s complexity while also\n>>> discouraging poor coding style in switch statements.\n>>>\n>>> Thoughts?\n>>>\n>>> Daniel\n>>>\n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>\n>>>\n>>>\n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>\n>>>\n>>>\n>>> *_______________________________________________*\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>\n>>>\n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>\n>>>\n>>>  _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>\n>>>\n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>\n>>>\n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>\n>>>\n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>\n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>\n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>\n>>>\n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>\n>>>\n>>>\n>>> Untracked with Trackbuster <https://trackbuster.com/?sig>\n>>>\n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>>\n>>>\n>>\n>\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000684.html" , "inReplyTo" : "EF9FEF97-C7B8-4D54-B406-2B62FDD15B59@springsandstruts.com" , "date" : { "$date" : 1449439950000} , "subject" : "[swift-evolution] Proposal: Remove the \"fallthrough\" keyword" , "references" : [ "3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com" , "AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com" , "8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com" , "1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com" , "02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com" , "E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com" , "444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com" , "EF1675F6-7918-4262-B535-696104BFC405@apple.com" , "CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com" , "D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org" , "071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com" , "CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org" , "6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com" , "6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org" , "CAKCGC8DbhMOX6bHtzXQcAhjHQSw1wSSoX-TBUtew0arWA=4pSw@mail.gmail.com" , "CAKCGC8DHCxwtiU82CjxChc6PaiB495WOCJBP0iq04uw7iWcQmA@mail.gmail.com" , "ECE284CE-EDE3-4071-ABB6-821820F1FC44@jacopo.giola.org" , "EF9FEF97-C7B8-4D54-B406-2B62FDD15B59@springsandstruts.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/B6DDD94B-0755-4D40-94F0-D2469A644818@portableinnovations.de"}} , "_id" : "B6DDD94B-0755-4D40-94F0-D2469A644818@portableinnovations.de" , "from" : "thorsten at portableinnovations.de (thorsten at portableinnovations.de)" , "mailingList" : "swift-evolution" , "content" : "Absolutely. Just the same rule: parts that were statements must be expressions. The else clause becomes mandatory.\n\n-Thorsten \n\n> Am 06.12.2015 um 22:52 schrieb Alex Lew <alexl.mail+swift at gmail.com>:\n> \n> I agree that it's simplest to just reuse switch keyword, and keep braces. +1.  \n> \n> Would you allow the same thing with if?\n> \n> let thisColor = if condition { .Red } else { .Blue }\n> \n>> On Sun, Dec 6, 2015 at 4:44 PM, Rudolf Adamkovic <salutis at me.com> wrote:\n>> > On 06 Dec 2015, at 22:35, thorsten--- via swift-evolution <swift-evolution at swift.org> wrote:\n>> \n>> >\n>> > I would prefer the expression to match the statement. The only difference would be that all parts that were statements now have to be expressions.\n>> \n>> +1\n>> \n>> >\n>> > Therefore the switch-expression should simply look like follows:\n>> >\n>> > let thisColor = switch thatColor {\n>> >         case .Red: .Green // must be an expression\n>> >         default: .Yellow      // must be an expression\n>> >     }\n>> >\n>> > No returns needed in the case clauses.\n>> \n>> This actually looks great. One simple rule and zero new keywords.\n>> \n>> Readable and simple to learn.\n>> \n>> Fantastic!\n>> \n>> > Formatting this as a one-liner would just require adding semicolons (though I wouldn't recommend this).\n>> >\n>> > -Thorsten\n>> > _______________________________________________\n>> > swift-evolution mailing list\n>> > swift-evolution at swift.org\n>> > https://lists.swift.org/mailman/listinfo/swift-evolution\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000685.html" , "inReplyTo" : "CAKCGC8BmmCk55=6UC_qk_C+ZNq2JfGpOPO5cJ=SK2784kmvbGg@mail.gmail.com" , "date" : { "$date" : 1449439963000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com" , "CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com" , "C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com" , "18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com" , "2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io" , "BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com" , "CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com" , "CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com" , "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com" , "BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com" , "909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net" , "0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com" , "49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net" , "CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com" , "49EEA2E6-55F2-49DE-A59F-A13017626370@web.de" , "CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com" , "4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com" , "11462DA4-ACDD-4C" , "F3-BD57-47886B655970@anandabits.com" , "CAKCGC8AVDe6W9X=XvFEnbkae8xom2Us8xczKFShqKu2+kPnRJA@mail.gmail.com" , "07270E34-E284-4FF0-B2EA-6DBB54FF78B5@portableinnovations.de" , "45B71AF5-DD4F-4E9C-A128-5B8041917564@me.com" , "CAKCGC8BmmCk55=6UC_qk_C+ZNq2JfGpOPO5cJ=SK2784kmvbGg@mail.gmail.com"] , "descendants" : [ "CAKCGC8AerqpPTrwdmPAvhmp-fLt-v=LXw4z0t+2o93g9GmAaxw@mail.gmail.com" , "2116BFD1-25BC-4B9F-A3A6-08758782BB88@anandabits.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAKCGC8AerqpPTrwdmPAvhmp-fLt-v=LXw4z0t+2o93g9GmAaxw@mail.gmail.com"}} , "_id" : "CAKCGC8AerqpPTrwdmPAvhmp-fLt-v=LXw4z0t+2o93g9GmAaxw@mail.gmail.com" , "from" : "alexl.mail+swift at gmail.com (Alex Lew)" , "mailingList" : "swift-evolution" , "content" : "👍\n\nOn Sun, Dec 6, 2015 at 5:12 PM, thorsten at portableinnovations.de <\nthorsten at portableinnovations.de> wrote:\n\n> Absolutely. Just the same rule: parts that were statements must be\n> expressions. The else clause becomes mandatory.\n>\n> -Thorsten\n>\n> Am 06.12.2015 um 22:52 schrieb Alex Lew <alexl.mail+swift at gmail.com>:\n>\n> I agree that it's simplest to just reuse switch keyword, and keep braces.\n> +1.\n>\n> Would you allow the same thing with if?\n>\n> let thisColor = if condition { .Red } else { .Blue }\n>\n> On Sun, Dec 6, 2015 at 4:44 PM, Rudolf Adamkovic <salutis at me.com> wrote:\n>\n>> > On 06 Dec 2015, at 22:35, thorsten--- via swift-evolution <\n>> swift-evolution at swift.org> wrote:\n>>\n>> >\n>> > I would prefer the expression to match the statement. The only\n>> difference would be that all parts that were statements now have to be\n>> expressions.\n>>\n>> +1\n>>\n>> >\n>> > Therefore the switch-expression should simply look like follows:\n>> >\n>> > let thisColor = switch thatColor {\n>> >         case .Red: .Green // must be an expression\n>> >         default: .Yellow      // must be an expression\n>> >     }\n>> >\n>> > No returns needed in the case clauses.\n>>\n>> This actually looks great. One simple rule and zero new keywords.\n>>\n>> Readable and simple to learn.\n>>\n>> Fantastic!\n>>\n>> > Formatting this as a one-liner would just require adding semicolons\n>> (though I wouldn't recommend this).\n>> >\n>> > -Thorsten\n>> > _______________________________________________\n>> > swift-evolution mailing list\n>> > swift-evolution at swift.org\n>> > https://lists.swift.org/mailman/listinfo/swift-evolution\n>>\n>\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000687.html" , "inReplyTo" : "B6DDD94B-0755-4D40-94F0-D2469A644818@portableinnovations.de" , "date" : { "$date" : 1449440094000} , "subject" : "[swift-evolution] ternary operator ?: suggestion" , "references" : [ "CAAcV4sanOLx+jEMtXB9KFamzh=9ia4isqGM773xn7hqykkKkwQ@mail.gmail.com" , "CADQN+5ZPCa21=Jr0j0DGUBkrafC_e=KvbWRsmym-fJneY=Z96w@mail.gmail.com" , "C020F910-3F9F-427C-B1AE-F7555551C613@fifthace.com" , "18D5E2C2-2C14-42E2-8527-881F4277B761@hartbit.com" , "2E53C041-6B49-4FDB-8A3D-7AB4320A1001@owensd.io" , "BCEE203F-BDDE-4E2D-9295-F80C79A06B9E@hartbit.com" , "CAAcV4sbMPzSJFd5_JbRNzrK=hWMHf3LBFU7bE-BxhKOANfhtMA@mail.gmail.com" , "CAAcV4sbCArGH1UGgiannOhpj0kd9YAjwTBTQvVa8N1FkYm=A3g@mail.gmail.com" , "40188000-3F42-4A8E-953A-70A76CE360DF@apple.com" , "BEB0D6AD-367F-4A28-A733-1D4C704CE1EE@hartbit.com" , "909A2B64-C5AB-4884-B739-B1B4A2C1017E@oleb.net" , "0149849C-8E26-4F00-9234-3A2A20A6A552@lickel.com" , "49E71D19-9ADC-45E8-9461-105DC7A67E4D@oleb.net" , "CAKCGC8DV3DY+4Pab6rZkAxQHSPeEfT5211sS28zC_BTDyvZ36w@mail.gmail.com" , "49EEA2E6-55F2-49DE-A59F-A13017626370@web.de" , "CAKCGC8Dfx9uONS=vg4Yig-TWo8eWCx2_xpn1fA=+3Zv7cMgw+g@mail.gmail.com" , "4C5EE03C-BAA8-4B8E-8B5A-BA37B71F943C@fifthace.com" , "11462DA4-ACDD-4CF3-BD57-47886B655970@anandabits.com" , "CAKCGC8AVDe6W9X=XvFEnbkae8xom2Us8xczKFShqKu2+kPnRJA@mail.gmail.com" , "07270E34-E284-4FF0-B2EA-6DBB54FF78B5@portableinnovations.de" , "45B71AF5-DD4F-4E9C-A128-5B8041917564@me.com" , "CAKCGC8BmmCk55=6UC_qk_C+ZNq2JfGpOPO5cJ=SK2784kmvbGg@mail.gmail.com" , "B6DDD94B-0755-4D40-94F0-D2469A644818@portableinnovations.de"] , "descendants" : [ "2116BFD1-25BC-4B9F-A3A6-08758782BB88@anandabits.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/8CE71278-5DEC-4C9A-BDFF-A03C47A2FCA6@anandabits.com"}} , "_id" : "8CE71278-5DEC-4C9A-BDFF-A03C47A2FCA6@anandabits.com" , "from" : "matthew at anandabits.com (Matthew Johnson)" , "mailingList" : "swift-evolution" , "content" : "I would be happy with any solution that provides failable conversion so I would support that as well.  \n\nAny chance we could see something like this in Swift 2.2 or Swift 3?  I was hoping the failable initializers might be low hanging fruit but it seems like the scoped feature would be more than that.\n\nSent from my iPad\n\n> On Dec 6, 2015, at 4:04 PM, Chris Lattner <clattner at apple.com> wrote:\n> \n> Could definitely be interesting.  I’d personally like to turn it into a scoped feature along the lines of this post though:\n> \n> https://lists.swift.org/pipermail/swift-evolution/2015-December/000292.html\n> \n> -Chris\n> \n>> On Dec 6, 2015, at 5:29 AM, Matthew Johnson <matthew at anandabits.com> wrote:\n>> \n>> Related to this, but maybe easier to do in the short term: what do you think of adding failable overloads to the numeric conversion initializers Chris?  \n>> \n>> They would throw or return nil if the runtime value could not be preserved rather than trap, truncate, etc.  Floating point types might allow a tolerance for small value changes due to precision, although I'm not sure if that would be good or not.   These initializers would be very useful when processing data from an external source such as JSON that has an expected type but cannot be trusted.\n>> \n>> \n>> \n>> Sent from my iPad\n>> \n>>>> On Dec 6, 2015, at 1:02 AM, Chris Lattner via swift-evolution <swift-evolution at swift.org> wrote:\n>>>> \n>>>> On Dec 5, 2015, at 4:27 AM, Jonathan Hull <jhull at gbis.com> wrote:\n>>>> I understand why you can’t auto-convert from a Double to a Float or Int32 to Int8.  It is good that we have to add the cast explicitly and think though the implications.\n>>>> \n>>>> …but I don’t think through the implications because we currently have a boy who cried wolf situation where we have to explicitly cast everything (even the safe stuff).\n>>>> \n>>>> \n>>>> I think all of the numeric types should be able to auto-convert if the conversion is safe (without loss of precision or overflow).\n>>>> \n>>>> For example:\n>>>> • If an Int is casting to a larger size (Int16 -> Int32)\n>>>> • Float -> Double\n>>>> • Float -> CGFloat\n>>>> • Int -> Float, Double, or CGFloat (but not the other way)\n>>>> \n>>>> I don’t see why these aren’t allowed. The forced casts make my code much less readable.  Are the casts above dangerous in a way I am not aware of?\n>>> \n>>> I agree that the current Swift numerics model is suboptimal, I personally would like to see small integers implicitly promote to large integers (when they are known lossless), have Float promote to Double, and have both Float and Double promote to CGFloat (yes, I know that the Double -> CGFloat promotion would be lossy on 32-bit apple platforms).  I personally don’t think that integer -> floating point promotions are a good idea even if value preserving, since their domains are so different.\n>>> \n>>> The problem with doing this today is that there are a lot of dependencies we need to get resolved first.\n>>> \n>>> 1. The type checker is really slow, partially because of too-many and too-crazy implicit conversions.  We also get very surprising behavior when they kick in. Specifically, IMO, we need to reevaluate the T! <-> T and T to T? conversions.  We have thoughts on this, but should be discussed in a separate thread if you’re interested.\n>>> \n>>> 2. These promotions should be expressible in the library, not hard coded into the compiler.  This means that we would need a language feature to (e.g.) be able to define subtype relationships between structs.  Such a feature would be generally useful and could allow us to push some of our existing compiler magic out to the stdlib.\n>>> \n>>> 3. We want the existing work to revise the numerics protocols to be better understood and hopefully implemented.\n>>> \n>>> There are also a ton of unrelated specific problems that should be addressed in various ways: e.g. macros like M_PI get imported as Double instead of a typeless literal, forcing tons of casts in code that wants to use it (e.g.) with Floats.  These issues are separable, and blocked on things like generic properties not being in place.\n>>> \n>>> It would be great for interested contributors to start pushing on any of the above issues to help unblock progress on improving the numerics model.\n>>> \n>>> -Chris\n>>> \n>>> _______________________________________________\n>>> swift-evolution mailing list\n>>> swift-evolution at swift.org\n>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000688.html" , "inReplyTo" : "84057F09-3421-49B9-94C0-5ECF2AFE2A9D@apple.com" , "date" : { "$date" : 1449441209000} , "subject" : "[swift-evolution] Proposal: Auto-convert for numbers when safe" , "references" : [ "7E236CA1-A390-4B64-950C-14987C1E1D87@gbis.com" , "B4EA93B4-3A45-4203-A79A-0E959B3CC634@apple.com" , "81BD0070-9DE9-49C5-9E0D-01EC1E496461@anandabits.com" , "84057F09-3421-49B9-94C0-5ECF2AFE2A9D@apple.com"] , "descendants" : [ "8BC56862-79DB-43B7-985C-0EF8E2C68142@apple.com" , "etPan.566539dc.4f3b19ea.10e90@Manav-Gabhawalas-MacBook-Pro.local"]} , { "_links" : { "self" : { "href" : "/charter/emails/439F0200-ECDD-46FD-A200-85533E4B2C65@apple.com"}} , "_id" : "439F0200-ECDD-46FD-A200-85533E4B2C65@apple.com" , "from" : "clattner at apple.com (Chris Lattner)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 4, 2015, at 7:20 AM, Amir Michail <a.michail at me.com> wrote:\n> \n> So for example the following (probable) bug would result in a compile error:\n> \n> let f = x < 5 // where x is optional and could be nil\n> \n> If that was really what was intended, you would need to write:\n> \n> let f = x? < 5\n\nI don’t think this approach can work.\n\nConsider the == operator for example: if optionals are are equatable then they will work with ==.  If they are not, they cannot be used as a dictionary key.  The former approach defeats your goals, the later approach defeats common problems from being solved.\n\n-Chris" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000689.html" , "inReplyTo" : "1FE8A847-AA48-43D9-895D-0124C265A634@me.com" , "date" : { "$date" : 1449441574000} , "subject" : "[swift-evolution] mandatory \"?\" suffix for identifiers associated with optional types" , "references" : [ "1FE8A847-AA48-43D9-895D-0124C265A634@me.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CA66BF95-1A27-4B02-AE21-840DDEC185C0@apple.com"}} , "_id" : "CA66BF95-1A27-4B02-AE21-840DDEC185C0@apple.com" , "from" : "clattner at apple.com (Chris Lattner)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 6, 2015, at 1:38 PM, Tyler Mandry via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> What isn't clear to me from Chris's or John's comments is why the `if let x? = foo` syntax was taken away. Was it for backward-compatibility? \n\nFWIW, that syntax hasn’t been taken away, it just means something different now.\n\n\tif let x = foo() {\n\ncaptures is privileged syntax for testing an optional and binding to the thing inside of it.  The patch I linked to moved away from this, but at great cost: it uglified lots of common code.  Swift privileges optional in a number of ways (e.g. it is the result of as?, try?, etc) and the standard library uses it pervasively as well.  Optimizing for that common case makes sense.\n\n-Chris" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000690.html" , "inReplyTo" : "CAA9p5uv=U-=kLi0PSn+9YSNvnfcn6oDEqOss1q1UjLn-sU9xUQ@mail.gmail.com" , "date" : { "$date" : 1449441757000} , "subject" : "[swift-evolution] Proposal: Optional Binding Shorthand Syntax" , "references" : [ "CAA9p5uv=U-=kLi0PSn+9YSNvnfcn6oDEqOss1q1UjLn-sU9xUQ@mail.gmail.com"] , "descendants" : [ "CAA9p5uvdrk_QnRtpm6gu1hKUMZaXsbV-VXY5xpUYSc4XMuxbsQ@mail.gmail.com" , "226B86CA-EFD5-4503-B1C1-2E242E64D107@apple.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/44256317-DBE6-428B-9E38-7410464FE58A@apple.com"}} , "_id" : "44256317-DBE6-428B-9E38-7410464FE58A@apple.com" , "from" : "clattner at apple.com (Chris Lattner)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 6, 2015, at 1:26 PM, Amir Michail via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> It’s very irritating trying to initialize a list of lists with static data and unpredictably encountering expression too complex errors.\n> \n> One could then try to incrementally initialize such a list of lists with append for each row say.\n> \n> Such initialization with simple 2d static data should never result in an expression too complex error.\n\n\"Too complex” errors are not an evolution issue, they are an implementation issue.  Please feel free to submit PR’s to help improve the implementation!\n\n-Chris" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000691.html" , "inReplyTo" : "2F2A126F-228D-479F-99A1-C40B472BBD44@me.com" , "date" : { "$date" : 1449442036000} , "subject" : "[swift-evolution] Should be able to initialize list of lists with 2d static data without unexpected errors." , "references" : [ "2F2A126F-228D-479F-99A1-C40B472BBD44@me.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAA9p5uvdrk_QnRtpm6gu1hKUMZaXsbV-VXY5xpUYSc4XMuxbsQ@mail.gmail.com"}} , "_id" : "CAA9p5uvdrk_QnRtpm6gu1hKUMZaXsbV-VXY5xpUYSc4XMuxbsQ@mail.gmail.com" , "from" : "tmandry at gmail.com (Tyler Mandry)" , "mailingList" : "swift-evolution" , "content" : "True, I meant why was the `?` taken out of the syntax. I suppose it can\nfeel redundant to have `if x? = try? foo()` or similar, in the cases you\nmentioned. That said, in the common case of unwrapping a variable of\noptional type (`let foo: Int?`) which is not written with a `?`, it can add\nextra clarity.\n\nOn Sun, Dec 6, 2015 at 4:42 PM, Chris Lattner <clattner at apple.com> wrote:\n\n>\n> > On Dec 6, 2015, at 1:38 PM, Tyler Mandry via swift-evolution <\n> swift-evolution at swift.org> wrote:\n> >\n> > What isn't clear to me from Chris's or John's comments is why the `if\n> let x? = foo` syntax was taken away. Was it for backward-compatibility?\n>\n> FWIW, that syntax hasn’t been taken away, it just means something\n> different now.\n>\n>         if let x = foo() {\n>\n> captures is privileged syntax for testing an optional and binding to the\n> thing inside of it.  The patch I linked to moved away from this, but at\n> great cost: it uglified lots of common code.  Swift privileges optional in\n> a number of ways (e.g. it is the result of as?, try?, etc) and the standard\n> library uses it pervasively as well.  Optimizing for that common case makes\n> sense.\n>\n> -Chris\n>\n>\n>\n\n\n-- \nTyler Mandry" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000692.html" , "inReplyTo" : "CA66BF95-1A27-4B02-AE21-840DDEC185C0@apple.com" , "date" : { "$date" : 1449442090000} , "subject" : "[swift-evolution] Proposal: Optional Binding Shorthand Syntax" , "references" : [ "CAA9p5uv=U-=kLi0PSn+9YSNvnfcn6oDEqOss1q1UjLn-sU9xUQ@mail.gmail.com" , "CA66BF95-1A27-4B02-AE21-840DDEC185C0@apple.com"] , "descendants" : [ "226B86CA-EFD5-4503-B1C1-2E242E64D107@apple.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/1449442122.2380087.459714713.0AC4A201@webmail.messagingengine.com"}} , "_id" : "1449442122.2380087.459714713.0AC4A201@webmail.messagingengine.com" , "from" : "kevin at sb.org (Kevin Ballard)" , "mailingList" : "swift-evolution" , "content" : "reswitch looks really confusing. Certainly significantly more confusing\nthan fallthrough.\n\nI notice that all the examples here are using relatively trivial cases,\nlike `case .LOAD`. Sure it doesn't look confusing there. But it will \nget confusing with complicated cases:\n\nswitch value {\ncase .Foo(bar, .Baz(.Qux(quux), .Corge), .Grault(.Garply)):\n    // do some stuff\n    reswitch(.Foo(bar, .Baz(.Qux(quux), .Corge), .Grault(.Waldo)))\ncase .Foo(bar, .Baz(.Qux(quux), .Corge), .Grault(.Waldo)):\n    // do some more stuff\n    // ...\n}\n\nIt also fails to account for those cases where you explicitly cannot\nre-evaluate against the start of the case list because that won't match\nthe right case. Trivial example:\n\nswitch value {\ncase .Foo(let s) where seen[s] == nil:\n    seen[s] = true\n    fallthrough\ncase .Foo:\n    // ...\n}\n\nThere's no way to use reswitch here to bypass that first case (any value\nyou might come up with may still pass that where clause and execute the\nfirst case).\n\n-Kevin Ballard\n\nOn Sun, Dec 6, 2015, at 02:09 PM, Jacopo Andrea Giola via\nswift-evolution wrote:\n> \n> > On 06 Dec 2015, at 22:23, Colin Barrett <colin at springsandstruts.com> wrote:\n> > \n> >> \n> >> On Dec 6, 2015, at 4:14 PM, Jacopo Andrea Giola <swift-evolution at jacopo.giola.org> wrote:\n> >> \n> >> Yes, I’m aware that at this time the reswitch can be abused and maybe can be better refined to disallow such cases.\n> > \n> > I’m curious, how do you propose to do this?\n> \n> I really don’t know right now, I hope we can find a way.\n> \n> > \n> >> Checking the case statement is not a problem by itself, but can be a problem if is coupled with a where clause that is not true when you fallthrought.\n> > \n> > In your document you give the example:\n> > \n> >> case .Three where x > 0:\n> > \n> > Now I may be wrong but I feel as though most of the uses of where clauses are also ones that reference variables bound in a `case let`. For instance:\n> > \n> >> case .Four(x) where x > 0:\n> > \n> > In that case, fallthrough would required to evaluating the case part anyway, as per my postulated rules below.\n> \n> Yes, maybe my example is not the most correct one, I’ve tried to come up\n> with something obvious and easy to read/write, but the problem will\n> remain for falltrhought as for the Swift iBook:\n> \n> NOTE\n> The fallthrough keyword does not check the case conditions for the switch\n> case that it causes execution to fall into. The fallthrough keyword\n> simply causes code execution to move directly to the statements inside\n> the next case (or default case) block, as in C’s standard switch\n> statement behaviour.\n> \n> For me this behaviour is not something that marry together with the where\n> clause that we can add to the switch's cases.\n> \n> > \n> > In any case, I appreciate you taking the time to discuss your proposal, even if I didn’t end up convinced. Thanks.\n> > \n> > -Colin\n> \n> Well technically I wasn’t the original proposal, I’ve only appreciate the\n> direction it took and now I’m here to try to spark more discussion to see\n> if is a valid direction and if we can improve it :)\n> \n> > \n> >> I’ve written a really bad draft here https://gist.github.com/JGiola/f735212789bf2f697847\n> >> If anyone wants to jump in and elaborate further is welcome. I will try to stay on par with this thread but I’m really bad at writing so every help is welcome.\n> >> \n> >> And if I remember correctly Daniel Jakult was the first one to made this proposal so if he wants to take on and then made the official proposal has every right to do so and I will be very glad if my gist can be a first reference :)\n> >> \n> >> - Jacopo\n> >> \n> >>> On 06 Dec 2015, at 21:52, Colin Barrett <colin at springsandstruts.com> wrote:\n> >>> \n> >>> Apologies, Jacopo, for missing the updated proposal, and thank you for your patience in summarizing it again.\n> >>> \n> >>> I’ve only glanced through it but my concern here is that it introduces a whole class of new and creative “foot-guns\" :) In particular, it allows this construction to loop arbitrarily and creatively, particularly in the case of associated values.\n> >>> \n> >>> I’m not sure why not checking the case statement is considered a problem for the fallthrough keyword. Assuming it’s impossible to fallthrough to a case that introduces binders (what would they be bound to?), and that this is statically checked (both of which seem reasonable assumptions to me, although if I’m wrong feel free to correct me), isn’t it the entire point of the fallthrough keyword that it skips checking the case statement? I can understand how that might be somewhat confusing (and perhaps it should be documented less prominently) but I’m not sure how it’s a *problem*, exactly...\n> >>> \n> >>> I think I’m still on the side of keeping fallthrough. What’s the downside of doing nothing? For instance in the case of ++ and -- those features complicate the design of a numerics library.\n> >>> \n> >>> Thanks,\n> >>> -Colin\n> >>> \n> >>>> On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola <swift-evolution at jacopo.giola.org> wrote:\n> >>>> \n> >>>> Hi Colin,\n> >>>> \n> >>>> the initial proposal was indeed to remove entirely the `fallthrough` keyword but many people expressed your similar concern and from that point the discussion was steered through an \"enhancement\" and better refinement of the keyword.\n> >>>> \n> >>>> The new idea is to substitute the old keyword with \"reswitch\" passing the desired new value on which the switch is applied.\n> >>>> So something like this:\n> >>>> \n> >>>> switch (enum) {\n> >>>> \tcase .One:\n> >>>> \t\t// do something\n> >>>> \t\treswitch .Two\n> >>>> \tcase .Two:\n> >>>> \t\t// do something else\n> >>>> \tdefault:\n> >>>> \t\t// and so one\n> >>>> }\n> >>>> \n> >>>> This new behaviour, IMO, is better suited for Swift because is more declarative of the developer intent and doesn't carry over unintentional misbehaviour.\n> >>>> Is more declarative because you are forced to state in which case you want to go, and even if the order of the switch’ cases will change in the future, you don't fall in the wrong case by mistake.\n> >>>> \n> >>>> switch (enum) {\n> >>>> \tcase .One:\n> >>>> \t\t// do something\n> >>>> \t\treswitch .Two\n> >>>> \tcase .OneAndAHalf\n> >>>> \t\t// maybe this change is not made by you but by a messed up merge\n> >>>> \tcase .Two:\n> >>>> \t\t// do something else\n> >>>> \tdefault:\n> >>>> \t\t// and so one\n> >>>> }\n> >>>> \n> >>>> In this case if you are using the fallthrough keyboard your code is now broken by accident, and depending on what are you trying to do inside the cases you can have a hidden bug that your tests are not seeing right away. \n> >>>> \n> >>>> Another advantage is that in this way you can made more cases fallthrough in the same one even if they are not one over each other\n> >>>> \n> >>>> switch (enum) {\n> >>>> \tcase .One:\n> >>>> \t\t// do something\n> >>>> \t\treswitch .Two\n> >>>> \tcase .OneAndAHalf\n> >>>> \t\t// so something that you don’t want to do for .One\n> >>>> \t\treswitch .Two\n> >>>> \tcase .Two:\n> >>>> \t\t// do something else that you may want to do for .One and .Two\n> >>>> \tdefault:\n> >>>> \t\t// and so one\n> >>>> }\n> >>>> \n> >>>> I must say that this is a side effect that can be used to messed up the code flow in a way that is not intended, but is a new behaviour that gives more power to the switch statement.\n> >>>> \n> >>>> The reswitch keyword in addition is not a mere fallthrough on the new case without doing the optional checking attached to it, but is intended to be a new call and all the check are executed.\n> >>>> \n> >>>> switch (enum) {\n> >>>> \tcase .One:\n> >>>> \t\t// do something\n> >>>> \t\tx = 0;\n> >>>> \t\treswitch .Two\n> >>>> \tcase .OneAndAHalf\n> >>>> \t\t// so something that you don’t want to do for .One\n> >>>> \t\treswitch .Two\n> >>>> \tcase .Two where x > 0:\n> >>>> \t\t// do something else that you may want to do for .One and .Two\n> >>>> \t\telement = array[x]\n> >>>> \tdefault:\n> >>>> \t\t// and so one\n> >>>> }\n> >>>> (I’m going by memory and by writing this snippets in the mail app directly, so the code must be incorrect in the syntax and for this I’m sorry).\n> >>>> \n> >>>> In this case if enum is .One the only case that is executed is case .One and the code doesn’t fallthrough in the .Two case because we are made the where invalid by changing the x to a value less than 1.\n> >>>> \n> >>>> Now I don’t remember who was the first one who mede this proposal, and I don’t know if he is working on a first draft to lay down the things better, but for me this can be a nice improvement and a neat break with the C-switch behaviour that Swift has trying to change from the very first beta disallowing the implicit fallthrough.\n> >>>> \n> >>>> I can be completely wrong but I see the `fallthrough`keyword as a “temporary” implementation for ease the transition from Obj-C to Swift and is time to improve it and made the switch statement even more powerful.\n> >>>> \n> >>>> - Jacopo\n> >>>> Sent from my iPad\n> >>>> \n> >>>> On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution <swift-evolution at swift.org> wrote:\n> >>>> \n> >>>>> tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.\n> >>>>> \n> >>>>> Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.\n> >>>>> \n> >>>>> I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)\n> >>>>> \n> >>>>> Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:\n> >>>>> \n> >>>>> https://gist.github.com/cbarrett/23b24a9fe76efdf006df\n> >>>>> \n> >>>>> This technique is very extensible — for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.\n> >>>>> \n> >>>>> Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type — low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.\n> >>>>> \n> >>>>> Thanks,\n> >>>>> -Colin\n> >>>>> \n> >>>>>> On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution <swift-evolution at swift.org> wrote:\n> >>>>>> \n> >>>>>> +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.\n> >>>>>> \n> >>>>>> If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don't introduce an infinite \"switch\" loop.\n> >>>>>> \n> >>>>>> Sent from my iPad\n> >>>>>> \n> >>>>>> On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution <swift-evolution at swift.org> wrote:\n> >>>>>> \n> >>>>>>> Very much thinking out loud and not really the implications, I wonder if we might just use \"continue\" instead of \"reswitch\".\n> >>>>>>> \n> >>>>>>> I very much like specifying what case to fall through into, no matter how we spell it.\n> >>>>>>> \n> >>>>>>> - Steve\n> >>>>>>> \n> >>>>>>> On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution <swift-evolution at swift.org> wrote:\n> >>>>>>> \n> >>>>>>>>> On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution <swift-evolution at swift.org> wrote:\n> >>>>>>>>>> On Dec 4, 2015, at 11:37 PM, John Calsbeek <john.calsbeek+lists at gmail.com> wrote:\n> >>>>>>>>>> `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.\n> >>>>>>>>>> \n> >>>>>>>>>> It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.\n> >>>>>>>>> \n> >>>>>>>>> Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.\n> >>>>>>>>> \n> >>>>>>>>> On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.\n> >>>>>>>> \n> >>>>>>>> Oh, I see that Joe already brought this up, spelled “reswitch”.\n> >>>>>>>> \n> >>>>>>>> John.\n> >>>>>>>> \n> >>>>>>>>> \n> >>>>>>>>> John.\n> >>>>>>>>> \n> >>>>>>>>>> \n> >>>>>>>>>> One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).\n> >>>>>>>>>> \n> >>>>>>>>>> switch op {\n> >>>>>>>>>> case LOAD_INDIRECT:\n> >>>>>>>>>>   in0 = memory[in1]\n> >>>>>>>>>>   fallthrough\n> >>>>>>>>>> case LOAD:\n> >>>>>>>>>>   out0 = memory[in0]\n> >>>>>>>>>> //...\n> >>>>>>>>>> }\n> >>>>>>>>>> \n> >>>>>>>>>> I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.\n> >>>>>>>>>> \n> >>>>>>>>>> Cheers,\n> >>>>>>>>>> John\n> >>>>>>>>>> \n> >>>>>>>>>>> On Dec 4, 2015, at 2:42 PM, John McCall <rjmccall at apple.com> wrote:\n> >>>>>>>>>>> \n> >>>>>>>>>>>> On Dec 4, 2015, at 2:33 PM, Kevin Ballard <kevin at sb.org> wrote:\n> >>>>>>>>>>>> It's not actually Duff's Device. Duff's Device relies on the fact that C switch statements don't actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it's a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.\n> >>>>>>>>>>> \n> >>>>>>>>>>> To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.\n> >>>>>>>>>>> \n> >>>>>>>>>>> But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.\n> >>>>>>>>>>> \n> >>>>>>>>>>> John.\n> >>>>>>>>>>> \n> >>>>>>>>>>>> \n> >>>>>>>>>>>> Steve's code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It's a good example of one of the uses of `fallthrough`, it's just not Duff's Device. It's impossible to use Duff's Device in Swift.\n> >>>>>>>>>>>> \n> >>>>>>>>>>>> -Kevin Ballard\n> >>>>>>>>>>>> \n> >>>>>>>>>>>> On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:\n> >>>>>>>>>>>>> Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.\n> >>>>>>>>>>>>> \n> >>>>>>>>>>>>>> On Dec 4, 2015, at 2:12 PM, Erica Sadun <erica at ericasadun.com> wrote:\n> >>>>>>>>>>>>>> \n> >>>>>>>>>>>>>> Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it. \n> >>>>>>>>>>>>>> \n> >>>>>>>>>>>>>> True fact: On all of gist.github.com, there are only 22 gist results for \"fallthrough language:swift\".\n> >>>>>>>>>>>>>> Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:\n> >>>>>>>>>>>>>> case .Enum1, .Enum2:\n> >>>>>>>>>>>>>> expressed as \n> >>>>>>>>>>>>>> case .Enum1: fallthrough\n> >>>>>>>>>>>>>> case .Enum2:\n> >>>>>>>>>>>>>> \n> >>>>>>>>>>>>>> And then there's streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea   I'm pretty sure that ponies were harmed in the production of whatever that last bit is.\n> >>>>>>>>>>>>>> \n> >>>>>>>>>>>>>> \n> >>>>>>>>>>>>>> \n> >>>>>>>>>>>>>> \n> >>>>>>>>>>>>>>> On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com wrote:\n> >>>>>>>>>>>>>>> \n> >>>>>>>>>>>>>>> In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the \"fallthrough\" keyword from the language?\n> >>>>>>>>>>>>>>> \n> >>>>>>>>>>>>>>> My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.\n> >>>>>>>>>>>>>>> \n> >>>>>>>>>>>>>>> The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:\n> >>>>>>>>>>>>>>> \n> >>>>>>>>>>>>>>> \"The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.\"\n> >>>>>>>>>>>>>>> \n> >>>>>>>>>>>>>>> To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.\n> >>>>>>>>>>>>>>> \n> >>>>>>>>>>>>>>> I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.\n> >>>>>>>>>>>>>>> \n> >>>>>>>>>>>>>>> In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.\n> >>>>>>>>>>>>>>> \n> >>>>>>>>>>>>>>> Thoughts?\n> >>>>>>>>>>>>>>> \n> >>>>>>>>>>>>>>> Daniel\n> >>>>>>>>>>>>>>> \n> >>>>>>>>>>>>>>> _______________________________________________\n> >>>>>>>>>>>>>>> swift-evolution mailing list\n> >>>>>>>>>>>>>>> swift-evolution at swift.org\n> >>>>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> >>>>>>>>>>>>>> \n> >>>>>>>>>>>>>> \n> >>>>>>>>>>>>>> _______________________________________________\n> >>>>>>>>>>>>>> swift-evolution mailing list\n> >>>>>>>>>>>>>> swift-evolution at swift.org\n> >>>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> >>>>>>>>>>>>> \n> >>>>>>>>>>>>> \n> >>>>>>>>>>>>> _______________________________________________\n> >>>>>>>>>>>>> swift-evolution mailing list\n> >>>>>>>>>>>>> swift-evolution at swift.org\n> >>>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> >>>>>>>>>>>> \n> >>>>>>>>>>>> \n> >>>>>>>>>>>> _______________________________________________\n> >>>>>>>>>>>> swift-evolution mailing list\n> >>>>>>>>>>>> swift-evolution at swift.org\n> >>>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> >>>>>>>>>>> \n> >>>>>>>>>>> _______________________________________________\n> >>>>>>>>>>> swift-evolution mailing list\n> >>>>>>>>>>> swift-evolution at swift.org\n> >>>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> >>>>>>>>>> \n> >>>>>>>>>> \n> >>>>>>>>>> _______________________________________________\n> >>>>>>>>>> swift-evolution mailing list\n> >>>>>>>>>> swift-evolution at swift.org\n> >>>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> >>>>>>>>> \n> >>>>>>>>> \n> >>>>>>>>> _______________________________________________\n> >>>>>>>>> swift-evolution mailing list\n> >>>>>>>>> swift-evolution at swift.org\n> >>>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> >>>>>>>> \n> >>>>>>>> \n> >>>>>>>> _______________________________________________\n> >>>>>>>> swift-evolution mailing list\n> >>>>>>>> swift-evolution at swift.org\n> >>>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> >>>>>>> \n> >>>>>>> _______________________________________________\n> >>>>>>> swift-evolution mailing list\n> >>>>>>> swift-evolution at swift.org\n> >>>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> >>>>>> \n> >>>>>> _______________________________________________\n> >>>>>> swift-evolution mailing list\n> >>>>>> swift-evolution at swift.org\n> >>>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> >>>>> \n> >>>>> \n> >>>>> _______________________________________________\n> >>>>> swift-evolution mailing list\n> >>>>> swift-evolution at swift.org\n> >>>>> https://lists.swift.org/mailman/listinfo/swift-evolution\n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000693.html" , "inReplyTo" : "D7B06EA6-A46C-4920-9E09-CB99B96242AA@jacopo.giola.org" , "date" : { "$date" : 1449442122000} , "subject" : "[swift-evolution] Proposal: Remove the \"fallthrough\" keyword" , "references" : [ "3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com" , "AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com" , "8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com" , "1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com" , "02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com" , "E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com" , "444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com" , "EF1675F6-7918-4262-B535-696104BFC405@apple.com" , "CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com" , "D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org" , "071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com" , "CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org" , "6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com" , "6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org" , "A56C416E-E246-44FC-A681-3DD66171DF30@springsandstruts.com" , "D7B06EA6-A46C-4920-9E09-CB99B96242AA@jacopo.giola.org"] , "descendants" : [ "CEA837D7-E2B1-48DC-A53B-D216F96DD8DF@apple.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/226B86CA-EFD5-4503-B1C1-2E242E64D107@apple.com"}} , "_id" : "226B86CA-EFD5-4503-B1C1-2E242E64D107@apple.com" , "from" : "clattner at apple.com (Chris Lattner)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 6, 2015, at 2:48 PM, Tyler Mandry <tmandry at gmail.com> wrote:\n> \n> True, I meant why was the `?` taken out of the syntax\n\nSwift 2 does support ? patterns.\n\n-Chris" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000694.html" , "inReplyTo" : "CAA9p5uvdrk_QnRtpm6gu1hKUMZaXsbV-VXY5xpUYSc4XMuxbsQ@mail.gmail.com" , "date" : { "$date" : 1449442287000} , "subject" : "[swift-evolution] Proposal: Optional Binding Shorthand Syntax" , "references" : [ "CAA9p5uv=U-=kLi0PSn+9YSNvnfcn6oDEqOss1q1UjLn-sU9xUQ@mail.gmail.com" , "CA66BF95-1A27-4B02-AE21-840DDEC185C0@apple.com" , "CAA9p5uvdrk_QnRtpm6gu1hKUMZaXsbV-VXY5xpUYSc4XMuxbsQ@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAPrQK3BEaJh55t9xsntD9FSbSZ4k3H2CcRE9jkM_c6ua-b4S=w@mail.gmail.com"}} , "_id" : "CAPrQK3BEaJh55t9xsntD9FSbSZ4k3H2CcRE9jkM_c6ua-b4S=w@mail.gmail.com" , "from" : "nickmshelley at gmail.com (Nick Shelley)" , "mailingList" : "swift-evolution" , "content" : "I like that self is only required in closures because it serves as a good\nreminder that there are memory and safety implications with using self in a\nclosure, such as creating retain cycles or having the closure run after\nself has been deallocated.\n\nI can't seem to find an official Apple Swift style guide, but github's (\nhttps://github.com/github/swift-style-guide) suggests only using self in\nclosures with the rationale: \"This makes the capturing semantics of self\nstand out more in closures, and avoids verbosity elsewhere.\"\n\nOn Sat, Dec 5, 2015 at 3:16 AM, Yichen Cao <ycao at me.com> wrote:\n\n> Teaching wise, its much less confusing for self to be required so students\n> don't mix up instance properties and local vars. Especially when self is\n> required in closures, it confuses students. If self is mandatory for all\n> instance properties, it would be so much clearer and much easier to read.\n>\n> Yichen\n>\n> On Dec 5, 2015, at 18:11, swift-evolution-request at swift.org wrote:\n>\n> Re: Proposal: Re-instate mandatory self for accessing\n>      instance properties and functions (David Hart)\n>\n>\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000695.html" , "inReplyTo" : "32D55766-386B-4584-8563-54AB8C1EDBFB@me.com" , "date" : { "$date" : 1449442514000} , "subject" : "[swift-evolution] Proposal: Re-instate mandatory self for accessing instance properties and functions (David Hart)" , "references" : [ "mailman.379.1449310286.15739.swift-evolution@swift.org" , "32D55766-386B-4584-8563-54AB8C1EDBFB@me.com"] , "descendants" : [ "DE739335-2DEA-4AA2-A234-2491A12C00B2@hartbit.com" , "CAAcV4sbzcShO1JSmi=1X6VQ1a+kdj-zpVAOUe15OtLT7kM0dDg@mail.gmail.com" , "05322415-8F1B-4710-B495-52D5342137B6@me.com" , "CAPrQK3Ageu90ZbjazndsVsjgCFqU3BpKZpvwwPTJN+PtX3hLqA@mail.gmail.com" , "CAN9tzpAPQ9aPNskJGREK9GZJG-uV9ea9HrtcXrx825XR4J77aA@mail.gmail.com" , "E736B9BF-51EE-4E21-B97B-B9E3FBF2F7FF@apple.com" , "F2DAF202-6D66-414B-B750-DF7585E0A853@hartbit.com" , "B15A79AB-7129-4ECF-8AD2-85CBA9375BE0@gmail.com" , "1449624250.2451853.462081217.481224F1@webmail.messagingengine.com" , "4883E95F-AA25-4629-AF6D-B99AC236F87F@me.com" , "CALkjWZsjNtOdxqbK8cKo714daAx294tjnV9CVTG=nHLic8Y02w@mail.gmail.com" , "CAPrQK3AcnUxLSczR2YT_3rijNVBiLJfMFSiauwactbSTuFwrZQ@mail.gmail.com" , "430ACC5F-459F-48F7-91AA-DFE127BF8858@me.com" , "CAE+=ROUO5JoC+nbBD2pQ9CzS2Rc1tNj4a52D4rcQEydz02QQDw@mail.gmail.com" , "CALkjWZsb_6XFuYCiZhe3xxYb14VczeYNfaS5kW=Xx2w_rDQJ0g@mail.gmail.com" , "CALkjWZssdohRaAbmx8Etag80fhaNVOBkV70XQ8Tz0ch7VjzfDQ@mail.gmail.com" , "670EEDED-B19A-4450-AA30-D18FEE9099FE@pobox.com" , "CALkjWZs7csQtg1-4CKcUASC0YOymZ1-Ujb5JZ6JiR8igc=s1rw@mail.gmail.com" , "135FDC57-1CDC-4743-87CD-32ABFEF65F2C@pobox.com" , "F2BE0980-C733-4E6E-BA5F-2E58AA0C332D@apple.com" , "CAOKWLrE=EgpfKZU-PWcxNKNryf3ndM7A2MyLstcU+yVzcryLDw@mail.gmail.com" , "CALkjWZtroRX6ifRUM4Ljiwy+6u=uimr5H1xdrYvPCMjjQKUP-w@mail.gmail.com" , "1AE2E8D5-9C68-4B31-AEBC-85074655D508@mac.com" , "CAPrQK3D4ddpFpH22r-MvVtnmyru3qCvmOjgmrYY5+tF-3a9xOw@mail.gmail.com" , "63714B98-F7D6-4779-8309-D18D82994482@fifthace.com" , "CALkjWZv5x=NRO1nBZqM5AJ9_FuTa9Q=GqHJC93T+kh7jjLT0wQ@mail.gmail.com" , "82A5881E-25BA-4E20-A447-75CBB056AD20@googlemail.com" , "FAA03445-5880-409C-AC17-46EAAAFB4D13@gmail.com" , "612F239D-A8D6-45B6-8C2B-79EA3D71DF7A@googlemail.com" , "07ED0789-399F-4D75-8000-3FA6A6687684@yahoo.ca" , "2177D4A0-BFBE-480F-A76E-B06DD949444C@mac.com" , "9FAD0E6B-0DAC-427F-86C2-BA58D184899F@gmx.de" , "09C66A58-1F80-40B1-BDE7-DE40EE6D815B@googlemail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/04492F1A-DC29-41D3-B9CD-44E87AA44E49@apple.com"}} , "_id" : "04492F1A-DC29-41D3-B9CD-44E87AA44E49@apple.com" , "from" : "clattner at apple.com (Chris Lattner)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 6, 2015, at 12:17 PM, Per Melin <p at greendale.se> wrote:\n> \n> On Sat, Dec 5, 2015 at 7:15 PM, Chris Lattner <clattner at apple.com <mailto:clattner at apple.com>> wrote:\n> Further, it is important to consider whether the code written using this will actually be *better* than the code written with these things as statements.  For example, the “switch” blocks tend to be very large, and turning them into expressions encourages additional indentation.\n> \n> If you give functions implicit return at the same time – as in Haskell, Erlang, Scala, Rust, Ruby, Lisp/Scheme/Clojure, etc –  there would be no need for additional indentation half of the time.\n\nThis isn’t something that I’m personally interested in.  I think that it is *feature* of swift that statements an declarations start with keywords.  This greatly simplifies the grammar in various ways, and allows declmodifiers to be introduced without taking keywords space.  \n\nFor example, relevant to this proposal, if/when we support “tail return foo()\" for example, you don’t want to take “tail” as a keyword to make “tail foo()” work.\n\n> Not even Slava Pestov would factor Swift that aggressively.\n\nUnderestimating Slava is not a good idea! :-)\n\n-Chris" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000696.html" , "inReplyTo" : "CADS5KKXGd3L=b+mTPwn=L9CeyVDMorYVQgJoBPxFgngozcWwmQ@mail.gmail.com" , "date" : { "$date" : 1449442569000} , "subject" : "[swift-evolution] Control Flow Expressions" , "references" : [ "DE55FD91-8C65-4BE0-9D74-30F7E42C7FFD@gmail.com" , "7EDDCB03-B726-4557-91C4-3E7A724FAD94@apple.com" , "CADS5KKXGd3L=b+mTPwn=L9CeyVDMorYVQgJoBPxFgngozcWwmQ@mail.gmail.com"] , "descendants" : [ "B3409EB3-139D-4E3E-A038-8FAF66900BF9@mac.com" , "CAAcV4sYgcx0zs664Q3Ab8qvxmTmzvoYOYA-Ya7U4YNM9YPHEsg@mail.gmail.com" , "CAAcV4saMd7NArJb_pGDNSBw8bjgrKt=LQ943C0P_5AZoWk_Bgw@mail.gmail.com" , "FE43B84C-3DE6-4D96-A1C3-9A566934C9D3@gmail.com" , "0F76202A-15E5-4F3A-AEE1-35F254569186@gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/A4969909-2AD7-41AD-A0E3-07590FBA33D4@apple.com"}} , "_id" : "A4969909-2AD7-41AD-A0E3-07590FBA33D4@apple.com" , "from" : "clattner at apple.com (Chris Lattner)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 6, 2015, at 1:21 AM, Roy Fu via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> Hi all,\n> \n> Similar to the syntax ‘do try catch throw’ and ’throws’ for error handling, I propose another syntax for handling CPS functions or async call backs:\n\nWe are all very interested in doing things along these lines, but need to keep Swift 3 relatively focused to achieve our goals.  Please bring this idea back up as work on Swift 3 is winding down, for consideration in Swift 4.\n\n-Chris\n\n> \n> func someFutureWrappedFunc(input: Int) future-> String{\n>     doSomeStaffInBackground{ (result:String) in\n>         fulfil result\n>     }\n> }\n> \n> do{\n>     let resultX = perform someFutureWrappedFunc(param)\n>     let resultY = perform anotherFutureWrappedFunc(resultX)\n>     let final   = resultX + resultY + perform justAnotherFutureWrappedFunc(resultX)\n>     self.someLabel.text = final\n> } timeout let context {\n>     //maybe some additional information\n> }\n> \n> the reason for this proposal is for the importance of async models in modern application  architectures, and avoid such pyramids:\n> \n> doSomeStaffInBackground { (resultX) -> Void in\n>     \n>     doSomeOtherStaff { (resultY) -> Void in\n>         \n>         if resultY.someCondition(resultX) {\n>             \n>             evenMakesItMadness(resultY) { (final) -> Void in\n>                 \n>                 //finally\n>             }\n>         }\n>     }\n> }\n> \n> \n> \n> \n> For more context comparing this async syntax to the ‘do try catch’:\n> \n> do try catch:\n> enum Result<T> {\n>     case Success(T)\n>     case Failure(ErrorType)\n> }\n> \n> func flatMap<T,U> (result:Result<T>, f:T->Result<U>) -> Result<U>{\n>     switch result{\n>     case .Success(let v): return f(v)\n>     case .Failure(let e): return .Failure(e)\n>     }\n> }\n> \n> func wrap1<T,U>(f:T throws-> U) -> T->Result<U> {\n>     return {\n>         do{\n>             return try .Success(f($0))\n>         }catch let e{\n>             return .Failure(e)\n>         }\n>     }\n> }\n> \n> func wrap2<T,U>(f:T -> Result<U>) -> T throws-> U{\n>     return{\n>         switch f($0){\n>         case .Success(let v): return v\n>         case .Failure(let e): throw e\n>         }\n>     }\n> }\n> \n> async:\n> \n> func flatMap<T,U> (async: (T -> Void) -> Void, f:T -> (U->Void) -> Void) -> (U -> Void) -> Void {\n>     return{ cont in\n>         async{ f($0)(cont) }\n>     }\n> }\n> \n> func wrap1<T,U>(f:T future-> U) -> T->(U->Void)->Void {\n>     return {input in\n>         {cont in\n>             do{\n>                 cont(perform f(input))\n>             }catch _{\n> \n>             }\n>         }\n>     }\n> }\n> \n> func wrap2<T,U>(f:T -> (U->Void)->Void) -> T future-> U{\n>     return{\n>         f(input)({\n>             fulfil $0\n>         })\n>     }\n> }\n> \n> \n> \n> \n> \n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000697.html" , "inReplyTo" : "78552B11-3A65-4239-8B33-990E34FEA48A@gmail.com" , "date" : { "$date" : 1449442772000} , "subject" : "[swift-evolution] Proposal: Syntax sugar for cps or async functions similar to the \"do try catch\" for error handling." , "references" : [ "78552B11-3A65-4239-8B33-990E34FEA48A@gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CADcs6kNHbRbLb6O9Gnn=iJRAQpf6TFv4zAJnXzHM9eSSh+kk_A@mail.gmail.com"}} , "_id" : "CADcs6kNHbRbLb6O9Gnn=iJRAQpf6TFv4zAJnXzHM9eSSh+kk_A@mail.gmail.com" , "from" : "jtbandes at gmail.com (Jacob Bandes-Storch)" , "mailingList" : "swift-evolution" , "content" : "zip2 (aka \"zip\") is present in Swift. zip3 is often useful, but not\nbuilt-in.\n\nIt can be achieved by using multiple copies of zip2:\n\n  for (one, (two, three)) in zip(list1, zip(list2, list3)) ...\n\nIt seems like either of these could make sense:\n\n- Put some reasonable number of implementations, like zip2...zip10, in the\nstandard library, using gyb.\n\n- Have the compiler generate them on the fly as requested by the user.\n\nOr, some alternate approaches:\n\n- Don't do this right now, but count it as motivation for a macro system.\n\n- Consider making Swift's pattern-matching system extensible, which might\nallow custom array-based patterns, like \"for [one, two, three] in\nzip(list1, list2, list3)\".  (I've been thinking of writing a proposal for\nthis anyway.)\n\n\nDoes anyone else care about zip3-and-higher? How do these options sound?\n\nJacob Bandes-Storch" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000699.html" , "date" : { "$date" : 1449442878000} , "subject" : "[swift-evolution] [Discussion] [Pitch] zip3, zip4, ..." , "references" : [ ""] , "inReplyTo" :  null  , "descendants" : [ "1723E3BA-76C7-4039-9B74-9A6CBA7E69E5@ericasadun.com" , "CA+Y5xYd2__HYbg2jkrumggHhnZRKX9fSUTGy0m6DS3en5ZnQGg@mail.gmail.com" , "03768AFB-648B-471B-9CC9-4CEEA5730BA0@ericasadun.com" , "52258245-20CC-4C12-864C-31A8EA887E5E@gmail.com" , "CA+Y5xYcNfXfs1=xJUuuFZJ-1RjiM9qhp6vYGCJEPwZjdkNUaow@mail.gmail.com" , "D61FCBEA-C671-447A-925C-054150AC7010@gmail.com" , "5111D805-5219-42C8-AF4B-18AA304C4773@anandabits.com" , "BLU436-SMTP1520EC88CEE6FB74292EFA8AA090@phx.gbl"]} , { "_links" : { "self" : { "href" : "/charter/emails/6F2EF9CF-2E73-4470-9AA7-93DFE00FEA6D@apple.com"}} , "_id" : "6F2EF9CF-2E73-4470-9AA7-93DFE00FEA6D@apple.com" , "from" : "clattner at apple.com (Chris Lattner)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 6, 2015, at 7:41 AM, Matthew Johnson <matthew at anandabits.com> wrote:\n> \n> Thanks for chiming in on this thread.  I definitely understand the desire to wait on features like this until post-Swfit 3 and possibly post-hygienic macros as well.\n> \n> I would add to your list of memberwise initializer deficiencies the fact that it is “all or nothing”.  I’m wondering what you think of generalizing our “utterance” of the memberwise initializer in a way that allows the flexibility for the initializer itself to handle initialization of some of the members while allowing the compiler to generate the implementation for other members.  I described one idea for doing this in a post last night where I described an @initializable member attribute.  I’m not tied to that specific solution, but I do think it is highly desirable to have complier-generated memberwise initialization that is more flexible than an “all or nothing” solution.  What are your thoughts?\n\nThat would be great of course, but it depends on the details.  We’d need someone to make a specific proposal to hash out whether and how it can work.\n\n-Chris" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000698.html" , "inReplyTo" : "475AB355-591C-42D9-A43B-1ED8D02BA1C3@anandabits.com" , "date" : { "$date" : 1449442916000} , "subject" : "[swift-evolution] Proposal: helpers for initializing properties of same name as parameters" , "references" : [ "CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com" , "4F8C6141-CEFA-43DA-8FD9-5C787789ED68@architechies.com" , "819785E7-2803-4A65-882F-DB1A9EC0483B@apple.com" , "475AB355-591C-42D9-A43B-1ED8D02BA1C3@anandabits.com"] , "descendants" : [ "CA+ddMk2uvrEwLZf4fcsYxDbFnagOcywttsdC7HRB9jkeVdZ=zA@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/271820A9-BB4A-44F7-B227-E105D15B2327@apple.com"}} , "_id" : "271820A9-BB4A-44F7-B227-E105D15B2327@apple.com" , "from" : "clattner at apple.com (Chris Lattner)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 6, 2015, at 6:40 AM, Daniel Steinberg via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> I love that the team has released API Design Guidelines and find them very helpful. One piece of advice, however, seems to be at odds with current Standard Library practice.\n> \n> Currently the methods sort() and sortInPlace() are the non-mutating and mutating versions of sorting a collection. Similarly, there are pairs of methods in Set named union() and unionInPlace(), intersect() and intersectInPlace() and so on.\n\nHi Daniel,\n\nThis is a known issue, and it is because we want to keep Swift 2.2 reasonable source compatible with Swift 2.  The changes to the standard library will land after Swift 2.2 branches for its release in the spring.  \n\nIf you’re interested in more details on this effort, check out this blog post:\nhttps://swift.org/blog/swift-3-api-design/ <https://swift.org/blog/swift-3-api-design/>\n\nIt includes a link to the diff-in-progress for the standard library.\n\n-Chris" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000700.html" , "inReplyTo" : "2BD23417-1AD2-4F2C-BC8D-BA60B4C059E1@dimsumthinking.com" , "date" : { "$date" : 1449443012000} , "subject" : "[swift-evolution] Proposal: Update the API Design Guidelines to reflect current Standard Library method naming conventions" , "references" : [ "2BD23417-1AD2-4F2C-BC8D-BA60B4C059E1@dimsumthinking.com"] , "descendants" : [ "CA+Y5xYefFnpgb_5ruKkaDQHLxrrRj=Jit3PErq7uVbXZ1QV6Ow@mail.gmail.com" , "B9EC68C8-F4F2-4929-A76D-2F30ABF39F62@dimsumthinking.com" , "7C2CA2AE-E4BE-45BF-AD09-617F38B6736D@dimsumthinking.com" , "29F7EE3C-7967-4651-9C38-6D071AE543B0@apple.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/D9340CB2-A696-478A-BAE7-F93ED39CB2DC@red-sweater.com"}} , "_id" : "D9340CB2-A696-478A-BAE7-F93ED39CB2DC@red-sweater.com" , "from" : "jalkut at red-sweater.com (jalkut at red-sweater.com)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 6, 2015, at 4:14 PM, Jacopo Andrea Giola via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> And if I remember correctly Daniel Jakult was the first one to made this proposal so if he wants to take on and then made the official proposal has every right to do so and I will be very glad if my gist can be a first reference :)\n> \n\nHi Jacopo - I have been interested to read the counter-arguments to my proposal to remove the keyword.\n\nI’m also glad it helped to spark a proposal to try to refine the behavior with some kind of \"reswitch\" mechanism, but I don’t have any passion for pushing that particular proposal along.\n\nMy motivation in proposing to remove the fallthrough keyword was that it makes sense to be judicious about language features and keywords especially while the language is young. The feature still seems questionable to me, but if the prevailing opinion is that \"fallthrough\" or a similar case-jumping mechanism is worth keeping, then I respect that and will not be pushing my original proposal any further.\n\nDaniel" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000701.html" , "inReplyTo" : "6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org" , "date" : { "$date" : 1449443163000} , "subject" : "[swift-evolution] (5.391):Re: Proposal: Remove the \"fallthrough\" keyword" , "references" : [ "3558D166-0A3C-4FE0-A055-BB6E669C4D28@red-sweater.com" , "AED69BC8-8520-49CB-9205-756DB9A5137C@ericasadun.com" , "8BE216C4-8F94-4754-A48D-6A900F9C2891@omnigroup.com" , "1449268427.2866331.458460281.302CEF27@webmail.messagingengine.com" , "02F3F4E8-EBF0-46C1-A3CC-162156AB5855@apple.com" , "E7CC1457-1E95-4B61-9C80-FF02E36D9366@gmail.com" , "444ABEA5-1A26-4EB7-88CE-BFD4B22A6590@apple.com" , "EF1675F6-7918-4262-B535-696104BFC405@apple.com" , "CA6BFF82-A212-41B6-8104-A0527E84D31C@apple.com" , "D6A94BD6-5211-4110-96C0-74068003EA50@jacopo.giola.org" , "071C537E-380E-43B5-8959-54587123CCA9@springsandstruts.com" , "CEA1D04A-CBFC-4AA8-98D3-4EE3BC1660B0@jacopo.giola.org" , "6C37A6BF-D261-401A-9E48-3D14429EE05D@springsandstruts.com" , "6E2D0A5F-303A-4806-A49B-F51E4D78F58C@jacopo.giola.org"]} , { "_links" : { "self" : { "href" : "/charter/emails/7C63AD72-C9A4-4794-9F1F-7D978357F5C5@apple.com"}} , "_id" : "7C63AD72-C9A4-4794-9F1F-7D978357F5C5@apple.com" , "from" : "clattner at apple.com (Chris Lattner)" , "mailingList" : "swift-evolution" , "content" : "On Dec 6, 2015, at 6:22 AM, David Zarzycki <zarzycki at icloud.com> wrote:\n>> That is definitely an interesting idea.  In practice, we won’t be able to remove ++/— from the compiler until the ~Spring 2017 release, since Swift 3 will want to parse the old code and reject it with a fixit hint. \n>> \n>>> Doing so would define away a type checking ambiguity where “let f = T -> T = someOperatorIdentifier” is ambiguous when both prefix and postfix operators exist.\n>> \n>> Besides the general simplification potential for the language, is this a theoretical concern or an actual one?  You can currently do something like “let f = T->T = {$0^}” or “{^$0}” to disambiguate the prefix/postfix forms.\n> \n> It is just simplification that opens the door to further simplicity and self-consistency within the language. In addition to not needing the above workaround, one could remove the fixity keywords/attributes altogether, because they’d be inferable from context.\n> \n> If one wants to go deep down the rabbit hole, one could let developers avoid nested parenthesis and the “spiral call syntax problem” by allowing the language to use the same unary operator in either prefix or postfix positions. For example, instead of “(^(-(~x).a).b).c”, one could write “x~.a-.b^.c” to accomplish the same goal.\n\nOk, we can consider this when work on the Spring 2017 release is active.\n\n-Chris" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000702.html" , "inReplyTo" : "7BDB9D9E-C327-4904-AC6F-D430D98A9EAC@icloud.com" , "date" : { "$date" : 1449443169000} , "subject" : "[swift-evolution] Feedback for SE-0004: Remove the ++ and -- operators" , "references" : [ "A7E9633F-7227-47A7-BE95-68F839D76549@icloud.com" , "F9C56B7C-34E8-40A8-B232-1FA9CC0C1FB6@apple.com" , "7BDB9D9E-C327-4904-AC6F-D430D98A9EAC@icloud.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CA+Y5xYefFnpgb_5ruKkaDQHLxrrRj=Jit3PErq7uVbXZ1QV6Ow@mail.gmail.com"}} , "_id" : "CA+Y5xYefFnpgb_5ruKkaDQHLxrrRj=Jit3PErq7uVbXZ1QV6Ow@mail.gmail.com" , "from" : "gribozavr at gmail.com (Dmitri Gribenko)" , "mailingList" : "swift-evolution" , "content" : "On Sun, Dec 6, 2015 at 3:03 PM, Chris Lattner via swift-evolution <\nswift-evolution at swift.org> wrote:\n\n>\n> On Dec 6, 2015, at 6:40 AM, Daniel Steinberg via swift-evolution <\n> swift-evolution at swift.org> wrote:\n>\n> I love that the team has released API Design Guidelines and find them very\n> helpful. One piece of advice, however, seems to be at odds with current\n> Standard Library practice.\n>\n> Currently the methods sort() and sortInPlace() are the non-mutating and\n> mutating versions of sorting a collection. Similarly, there are pairs of\n> methods in Set named union() and unionInPlace(), intersect() and\n> intersectInPlace() and so on.\n>\n>\n> Hi Daniel,\n>\n> This is a known issue, and it is because we want to keep Swift 2.2\n> reasonable source compatible with Swift 2.  The changes to the standard\n> library will land after Swift 2.2 branches for its release in the spring.\n>\n> If you’re interested in more details on this effort, check out this blog\n> post:\n> https://swift.org/blog/swift-3-api-design/\n>\n> It includes a link to the diff-in-progress for the standard library.\n>\n\nHi Chris,\n\nI think Daniel is not highlighting the inconsistency, but saying that he\nlikes ~InPlace better:\n\nOn Dec 6, 2015, at 6:40 AM, Daniel Steinberg via swift-evolution <\nswift-evolution at swift.org> wrote:\n> Previously the sort methods were named sort() and sorted(). I never could\nremember which is which.\n\nDmitri\n\n\n-- \nmain(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if\n(j){printf(\"%d\\n\",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000703.html" , "inReplyTo" : "271820A9-BB4A-44F7-B227-E105D15B2327@apple.com" , "date" : { "$date" : 1449443439000} , "subject" : "[swift-evolution] Proposal: Update the API Design Guidelines to reflect current Standard Library method naming conventions" , "references" : [ "2BD23417-1AD2-4F2C-BC8D-BA60B4C059E1@dimsumthinking.com" , "271820A9-BB4A-44F7-B227-E105D15B2327@apple.com"] , "descendants" : [ "7C2CA2AE-E4BE-45BF-AD09-617F38B6736D@dimsumthinking.com" , "29F7EE3C-7967-4651-9C38-6D071AE543B0@apple.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/289929F8-E37F-40CA-9C1F-E71537027F5F@architechies.com"}} , "_id" : "289929F8-E37F-40CA-9C1F-E71537027F5F@architechies.com" , "from" : "brent at architechies.com (Brent Royal-Gordon)" , "mailingList" : "swift-evolution" , "content" : "> I think that the C-style for loop should be removed from Swift.\n\nThe silence you’re hearing on this proposal is because we just had a thread about this a couple days ago. :^) Take a look at the archives--most people seem to agree that the for loop ought to go. They’ve even started changing standard library for loops to for-in.\n\n-- \nBrent Royal-Gordon\nArchitechies" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000704.html" , "inReplyTo" : "9896FC65-F28A-4BF4-AA7A-95C18904C56B@yahoo.com" , "date" : { "$date" : 1449444144000} , "subject" : "[swift-evolution] C-style For Loops" , "references" : [ "9896FC65-F28A-4BF4-AA7A-95C18904C56B@yahoo.com"] , "descendants" : [ "CA+Y5xYdpHCoCSwGi8MB3cWLd79XHNGo8BB2G=LJaPSPVtsq8Qg@mail.gmail.com" , "8E65F943-2F5B-4D60-B294-E66A418B2C17@gmail.com" , "7CBA0795-377E-4B17-ACEC-5714B273E18C@alkaline-solutions.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CA+Y5xYdpHCoCSwGi8MB3cWLd79XHNGo8BB2G=LJaPSPVtsq8Qg@mail.gmail.com"}} , "_id" : "CA+Y5xYdpHCoCSwGi8MB3cWLd79XHNGo8BB2G=LJaPSPVtsq8Qg@mail.gmail.com" , "from" : "gribozavr at gmail.com (Dmitri Gribenko)" , "mailingList" : "swift-evolution" , "content" : "On Sun, Dec 6, 2015 at 3:22 PM, Brent Royal-Gordon via swift-evolution\n<swift-evolution at swift.org> wrote:\n>They’ve even started changing standard library for loops to for-in.\n\nThe patch that was submitted changes the obvious cases.  It would be\ngood to see a patch that converts all instances, including the \"hard\"\nones.\n\nDmitri\n\n-- \nmain(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if\n(j){printf(\"%d\\n\",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000705.html" , "inReplyTo" : "289929F8-E37F-40CA-9C1F-E71537027F5F@architechies.com" , "date" : { "$date" : 1449444241000} , "subject" : "[swift-evolution] C-style For Loops" , "references" : [ "9896FC65-F28A-4BF4-AA7A-95C18904C56B@yahoo.com" , "289929F8-E37F-40CA-9C1F-E71537027F5F@architechies.com"] , "descendants" : [ "8E65F943-2F5B-4D60-B294-E66A418B2C17@gmail.com" , "7CBA0795-377E-4B17-ACEC-5714B273E18C@alkaline-solutions.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/B9EC68C8-F4F2-4929-A76D-2F30ABF39F62@dimsumthinking.com"}} , "_id" : "B9EC68C8-F4F2-4929-A76D-2F30ABF39F62@dimsumthinking.com" , "from" : "daniel at dimsumthinking.com (Daniel Steinberg)" , "mailingList" : "swift-evolution" , "content" : "Thank you\n> On Dec 6, 2015, at 6:03 PM, Chris Lattner <clattner at apple.com> wrote:\n> \n> \n>> On Dec 6, 2015, at 6:40 AM, Daniel Steinberg via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>> \n>> I love that the team has released API Design Guidelines and find them very helpful. One piece of advice, however, seems to be at odds with current Standard Library practice.\n>> \n>> Currently the methods sort() and sortInPlace() are the non-mutating and mutating versions of sorting a collection. Similarly, there are pairs of methods in Set named union() and unionInPlace(), intersect() and intersectInPlace() and so on.\n> \n> Hi Daniel,\n> \n> This is a known issue, and it is because we want to keep Swift 2.2 reasonable source compatible with Swift 2.  The changes to the standard library will land after Swift 2.2 branches for its release in the spring.  \n> \n> If you’re interested in more details on this effort, check out this blog post:\n> https://swift.org/blog/swift-3-api-design/ <https://swift.org/blog/swift-3-api-design/>\n> \n> It includes a link to the diff-in-progress for the standard library.\n> \n> -Chris\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000706.html" , "inReplyTo" : "271820A9-BB4A-44F7-B227-E105D15B2327@apple.com" , "date" : { "$date" : 1449444818000} , "subject" : "[swift-evolution] Proposal: Update the API Design Guidelines to reflect current Standard Library method naming conventions" , "references" : [ "2BD23417-1AD2-4F2C-BC8D-BA60B4C059E1@dimsumthinking.com" , "271820A9-BB4A-44F7-B227-E105D15B2327@apple.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/1723E3BA-76C7-4039-9B74-9A6CBA7E69E5@ericasadun.com"}} , "_id" : "1723E3BA-76C7-4039-9B74-9A6CBA7E69E5@ericasadun.com" , "from" : "erica at ericasadun.com (Erica Sadun)" , "mailingList" : "swift-evolution" , "content" : "It's pretty easy to build your own Zips. Not sure the language really needs this. For example, I recently built a zip that produces (T?, T?) which fills one of the two with nil until both lists are consumed:\n\nfunc longZip<S0: SequenceType, S1: SequenceType>(seq0: S0, _ seq1: S1) ->\n    AnyGenerator<(S0.Generator.Element?, S1.Generator.Element?)> {\n        var generators = (seq0.generate(), seq1.generate())\n        return anyGenerator {\n            let items = (generators.0.next(), generators.1.next())\n            if case (.None, .None) = items {return nil}\n            return items\n        }\n}\n\nI'm rather fond of this variant although I don't know if it's generally useful enough to be worth even considering for the language\n\n-- E\n\n\n> On Dec 6, 2015, at 4:01 PM, Jacob Bandes-Storch via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> zip2 (aka \"zip\") is present in Swift. zip3 is often useful, but not built-in.\n> \n> It can be achieved by using multiple copies of zip2:\n> \n>   for (one, (two, three)) in zip(list1, zip(list2, list3)) ...\n> \n> It seems like either of these could make sense:\n> \n> - Put some reasonable number of implementations, like zip2...zip10, in the standard library, using gyb.\n> \n> - Have the compiler generate them on the fly as requested by the user.\n> \n> Or, some alternate approaches:\n> \n> - Don't do this right now, but count it as motivation for a macro system.\n> \n> - Consider making Swift's pattern-matching system extensible, which might allow custom array-based patterns, like \"for [one, two, three] in zip(list1, list2, list3)\".  (I've been thinking of writing a proposal for this anyway.)\n> \n> \n> Does anyone else care about zip3-and-higher? How do these options sound?\n> \n> Jacob Bandes-Storch\n>  _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000707.html" , "inReplyTo" : "CADcs6kNHbRbLb6O9Gnn=iJRAQpf6TFv4zAJnXzHM9eSSh+kk_A@mail.gmail.com" , "date" : { "$date" : 1449444855000} , "subject" : "[swift-evolution] zip3, zip4, ..." , "references" : [ "CADcs6kNHbRbLb6O9Gnn=iJRAQpf6TFv4zAJnXzHM9eSSh+kk_A@mail.gmail.com"] , "descendants" : [ "CA+Y5xYd2__HYbg2jkrumggHhnZRKX9fSUTGy0m6DS3en5ZnQGg@mail.gmail.com" , "03768AFB-648B-471B-9CC9-4CEEA5730BA0@ericasadun.com" , "52258245-20CC-4C12-864C-31A8EA887E5E@gmail.com" , "CA+Y5xYcNfXfs1=xJUuuFZJ-1RjiM9qhp6vYGCJEPwZjdkNUaow@mail.gmail.com" , "D61FCBEA-C671-447A-925C-054150AC7010@gmail.com" , "5111D805-5219-42C8-AF4B-18AA304C4773@anandabits.com" , "BLU436-SMTP1520EC88CEE6FB74292EFA8AA090@phx.gbl"]} , { "_links" : { "self" : { "href" : "/charter/emails/7C2CA2AE-E4BE-45BF-AD09-617F38B6736D@dimsumthinking.com"}} , "_id" : "7C2CA2AE-E4BE-45BF-AD09-617F38B6736D@dimsumthinking.com" , "from" : "daniel at dimsumthinking.com (Daniel Steinberg)" , "mailingList" : "swift-evolution" , "content" : "Yes\n> On Dec 6, 2015, at 6:10 PM, Dmitri Gribenko <gribozavr at gmail.com> wrote:\n> \n> On Sun, Dec 6, 2015 at 3:03 PM, Chris Lattner via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n> \n>> On Dec 6, 2015, at 6:40 AM, Daniel Steinberg via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n>> \n>> I love that the team has released API Design Guidelines and find them very helpful. One piece of advice, however, seems to be at odds with current Standard Library practice.\n>> \n>> Currently the methods sort() and sortInPlace() are the non-mutating and mutating versions of sorting a collection. Similarly, there are pairs of methods in Set named union() and unionInPlace(), intersect() and intersectInPlace() and so on.\n> \n> Hi Daniel,\n> \n> This is a known issue, and it is because we want to keep Swift 2.2 reasonable source compatible with Swift 2.  The changes to the standard library will land after Swift 2.2 branches for its release in the spring.  \n> \n> If you’re interested in more details on this effort, check out this blog post:\n> https://swift.org/blog/swift-3-api-design/ <https://swift.org/blog/swift-3-api-design/>\n> \n> It includes a link to the diff-in-progress for the standard library.\n> \n> Hi Chris,\n> \n> I think Daniel is not highlighting the inconsistency, but saying that he likes ~InPlace better:\n> \n> On Dec 6, 2015, at 6:40 AM, Daniel Steinberg via swift-evolution <swift-evolution at swift.org <mailto:swift-evolution at swift.org>> wrote:\n> > Previously the sort methods were named sort() and sorted(). I never could remember which is which.\n> \n> Dmitri\n> \n> \n> -- \n> main(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if\n> (j){printf(\"%d\\n\",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com <mailto:gribozavr at gmail.com>>*/" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000708.html" , "inReplyTo" : "CA+Y5xYefFnpgb_5ruKkaDQHLxrrRj=Jit3PErq7uVbXZ1QV6Ow@mail.gmail.com" , "date" : { "$date" : 1449444870000} , "subject" : "[swift-evolution] Proposal: Update the API Design Guidelines to reflect current Standard Library method naming conventions" , "references" : [ "2BD23417-1AD2-4F2C-BC8D-BA60B4C059E1@dimsumthinking.com" , "271820A9-BB4A-44F7-B227-E105D15B2327@apple.com" , "CA+Y5xYefFnpgb_5ruKkaDQHLxrrRj=Jit3PErq7uVbXZ1QV6Ow@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CA+ddMk2uvrEwLZf4fcsYxDbFnagOcywttsdC7HRB9jkeVdZ=zA@mail.gmail.com"}} , "_id" : "CA+ddMk2uvrEwLZf4fcsYxDbFnagOcywttsdC7HRB9jkeVdZ=zA@mail.gmail.com" , "from" : "me at tal.by (Tal Atlas)" , "mailingList" : "swift-evolution" , "content" : "I greatly appreciate the feedback from those working directly with the\nlanguage. Having read though the other proposals I would like to return to\nmy original proposal, as it seems to have the greatest flexibility and\nsimplicity from an api perspective. The most frequent pain point with\ncurrent initializers are structs with more than a few private stored\nproperties, the amount of boilerplate is rather annoying. The other benefit\nis it gives the writer direct control over what the external api for the\ngiven object is for each specific initializer. I”m not married to the\n`init(self.var: Type)` syntax, but would be sad if any solution didn’t stem\nfrom a similar sort of idea.\n\nOn Sun, Dec 6, 2015 at 6:02 PM Chris Lattner via swift-evolution <\nswift-evolution at swift.org> wrote:\n\n>\n> > On Dec 6, 2015, at 7:41 AM, Matthew Johnson <matthew at anandabits.com>\n> wrote:\n> >\n> > Thanks for chiming in on this thread.  I definitely understand the\n> desire to wait on features like this until post-Swfit 3 and possibly\n> post-hygienic macros as well.\n> >\n> > I would add to your list of memberwise initializer deficiencies the fact\n> that it is “all or nothing”.  I’m wondering what you think of generalizing\n> our “utterance” of the memberwise initializer in a way that allows the\n> flexibility for the initializer itself to handle initialization of some of\n> the members while allowing the compiler to generate the implementation for\n> other members.  I described one idea for doing this in a post last night\n> where I described an @initializable member attribute.  I’m not tied to that\n> specific solution, but I do think it is highly desirable to have\n> complier-generated memberwise initialization that is more flexible than an\n> “all or nothing” solution.  What are your thoughts?\n>\n> That would be great of course, but it depends on the details.  We’d need\n> someone to make a specific proposal to hash out whether and how it can work.\n>\n> -Chris\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000709.html" , "inReplyTo" : "6F2EF9CF-2E73-4470-9AA7-93DFE00FEA6D@apple.com" , "date" : { "$date" : 1449444990000} , "subject" : "[swift-evolution] Proposal: helpers for initializing properties of same name as parameters" , "references" : [ "CA+ddMk3Wp_JOdoFwwhaJ7xMVL1RCPtrvYaK2JmsH-ttMWSwRAg@mail.gmail.com" , "4F8C6141-CEFA-43DA-8FD9-5C787789ED68@architechies.com" , "819785E7-2803-4A65-882F-DB1A9EC0483B@apple.com" , "475AB355-591C-42D9-A43B-1ED8D02BA1C3@anandabits.com" , "6F2EF9CF-2E73-4470-9AA7-93DFE00FEA6D@apple.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CA+Y5xYd2__HYbg2jkrumggHhnZRKX9fSUTGy0m6DS3en5ZnQGg@mail.gmail.com"}} , "_id" : "CA+Y5xYd2__HYbg2jkrumggHhnZRKX9fSUTGy0m6DS3en5ZnQGg@mail.gmail.com" , "from" : "gribozavr at gmail.com (Dmitri Gribenko)" , "mailingList" : "swift-evolution" , "content" : "On Sun, Dec 6, 2015 at 3:34 PM, Erica Sadun via swift-evolution <\nswift-evolution at swift.org> wrote:\n\n> It's pretty easy to build your own Zips. Not sure the language really\n> needs this. For example, I recently built a zip that produces (T?, T?)\n> which fills one of the two with nil until both lists are consumed:\n>\n> func longZip<S0: SequenceType, S1: SequenceType>(seq0: S0, _ seq1: S1) ->\n>     AnyGenerator<(S0.Generator.Element?, S1.Generator.Element?)> {\n>\n\n\nJust wanted to point out that AnyGenerator has an inherent cost from the\ntype erasure.  The implementation in the standard library uses generics and\nis fully optimizable.\n\nDmitri\n\n-- \nmain(i,j){for(i=2;;i++){for(j=2;j<i;j++){if(!(i%j)){j=0;break;}}if\n(j){printf(\"%d\\n\",i);}}} /*Dmitri Gribenko <gribozavr at gmail.com>*/" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000710.html" , "inReplyTo" : "1723E3BA-76C7-4039-9B74-9A6CBA7E69E5@ericasadun.com" , "date" : { "$date" : 1449445023000} , "subject" : "[swift-evolution] zip3, zip4, ..." , "references" : [ "CADcs6kNHbRbLb6O9Gnn=iJRAQpf6TFv4zAJnXzHM9eSSh+kk_A@mail.gmail.com" , "1723E3BA-76C7-4039-9B74-9A6CBA7E69E5@ericasadun.com"] , "descendants" : [ "03768AFB-648B-471B-9CC9-4CEEA5730BA0@ericasadun.com" , "52258245-20CC-4C12-864C-31A8EA887E5E@gmail.com" , "CA+Y5xYcNfXfs1=xJUuuFZJ-1RjiM9qhp6vYGCJEPwZjdkNUaow@mail.gmail.com" , "D61FCBEA-C671-447A-925C-054150AC7010@gmail.com" , "5111D805-5219-42C8-AF4B-18AA304C4773@anandabits.com" , "BLU436-SMTP1520EC88CEE6FB74292EFA8AA090@phx.gbl"]},{ "_links" : { "self" : { "href" : "/charter/emails/CAKCGC8AjTGQRer0paqVGnbt4qR3M=T_95hTw44CF6QXQmzV1oQ@mail.gmail.com"}} , "_id" : "CAKCGC8AjTGQRer0paqVGnbt4qR3M=T_95hTw44CF6QXQmzV1oQ@mail.gmail.com" , "from" : "alexl.mail+swift at gmail.com (Alex Lew)" , "mailingList" : "swift-evolution" , "content" : "let a: Int? = 3\nif case let b? = a {\n    print(b)\n}\n\nworks for me in Swift 2.2. Have they announced that they're taking this\naway?\n\n\nOn Sun, Dec 6, 2015 at 4:38 PM, Tyler Mandry via swift-evolution <\nswift-evolution at swift.org> wrote:\n\n> What isn't clear to me from Chris's or John's comments is why the `if let\n> x? = foo` syntax was taken away. Was it for backward-compatibility? To me,\n> this syntax does have special syntactic support, and also seems to make it\n> clearer what's going on. It's also analogous to Swift's type inference for\n> generic <T?> types, for example:\n>\n>    func doSomething<T? where T: Equatable>(x: T?) -> T { ... }\n>\n> Note the T? in brackets. If I pass an Int? to doSomething, the type is\n> \"unwrapped\" and T becomes Int. It seems like `if let x? = foo` would follow\n> the same pattern.\n>\n> Was the syntax taken away for reasons unlikely to change, or is it up for\n> discussion? :)\n>\n> --\n> Tyler Mandry\n>\n>\n> _______________________________________________\n> swift-evolution mailing list\n> swift-evolution at swift.org\n> https://lists.swift.org/mailman/listinfo/swift-evolution\n>\n>" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000667.html" , "inReplyTo" : "CAA9p5uv=U-=kLi0PSn+9YSNvnfcn6oDEqOss1q1UjLn-sU9xUQ@mail.gmail.com" , "date" : { "$date" : 1449438193000} , "subject" : "[swift-evolution] Proposal: Optional Binding Shorthand Syntax" , "references" : [ "CAA9p5uv=U-=kLi0PSn+9YSNvnfcn6oDEqOss1q1UjLn-sU9xUQ@mail.gmail.com"] , "descendants" : [ "CAA9p5uv3WeXTKsuAg=H4h=sd0C23WTOwhuLLe=PkwEGM4Hvwxg@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAA9p5uvdrk_QnRtpm6gu1hKUMZaXsbV-VXY5xpUYSc4XMuxbsQ@mail.gmail.com"}} , "_id" : "CAA9p5uvdrk_QnRtpm6gu1hKUMZaXsbV-VXY5xpUYSc4XMuxbsQ@mail.gmail.com" , "from" : "tmandry at gmail.com (Tyler Mandry)" , "mailingList" : "swift-evolution" , "content" : "True, I meant why was the `?` taken out of the syntax. I suppose it can\nfeel redundant to have `if x? = try? foo()` or similar, in the cases you\nmentioned. That said, in the common case of unwrapping a variable of\noptional type (`let foo: Int?`) which is not written with a `?`, it can add\nextra clarity.\n\nOn Sun, Dec 6, 2015 at 4:42 PM, Chris Lattner <clattner at apple.com> wrote:\n\n>\n> > On Dec 6, 2015, at 1:38 PM, Tyler Mandry via swift-evolution <\n> swift-evolution at swift.org> wrote:\n> >\n> > What isn't clear to me from Chris's or John's comments is why the `if\n> let x? = foo` syntax was taken away. Was it for backward-compatibility?\n>\n> FWIW, that syntax hasn’t been taken away, it just means something\n> different now.\n>\n>         if let x = foo() {\n>\n> captures is privileged syntax for testing an optional and binding to the\n> thing inside of it.  The patch I linked to moved away from this, but at\n> great cost: it uglified lots of common code.  Swift privileges optional in\n> a number of ways (e.g. it is the result of as?, try?, etc) and the standard\n> library uses it pervasively as well.  Optimizing for that common case makes\n> sense.\n>\n> -Chris\n>\n>\n>\n\n\n-- \nTyler Mandry" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000692.html" , "inReplyTo" : "CA66BF95-1A27-4B02-AE21-840DDEC185C0@apple.com" , "date" : { "$date" : 1449442090000} , "subject" : "[swift-evolution] Proposal: Optional Binding Shorthand Syntax" , "references" : [ "CAA9p5uv=U-=kLi0PSn+9YSNvnfcn6oDEqOss1q1UjLn-sU9xUQ@mail.gmail.com" , "CA66BF95-1A27-4B02-AE21-840DDEC185C0@apple.com"] , "descendants" : [ "226B86CA-EFD5-4503-B1C1-2E242E64D107@apple.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CAA9p5uv3WeXTKsuAg=H4h=sd0C23WTOwhuLLe=PkwEGM4Hvwxg@mail.gmail.com"}} , "_id" : "CAA9p5uv3WeXTKsuAg=H4h=sd0C23WTOwhuLLe=PkwEGM4Hvwxg@mail.gmail.com" , "from" : "tmandry at gmail.com (Tyler Mandry)" , "mailingList" : "swift-evolution" , "content" : "Ah no, it's just that they at one time had support for taking away `case`\nand doing `if let b? = a`. See the commit notes that Chris linked to here:\nhttps://github.com/apple/swift/commit/20f8f09ea8de5eb1c0cb559e59c8a8e8a0e115a9#diff-4513b692cdd5476630ebb66b73d5bf4b\n.\n\nI guess the current `if let b = a` syntax is what John was referring to as\nspecial syntactic support, but I still don't see why the `?` was taken out\nof the syntax.\n\nOn Sun, Dec 6, 2015 at 3:43 PM, Alex Lew <alexl.mail+swift at gmail.com> wrote:\n\n> let a: Int? = 3\n> if case let b? = a {\n>     print(b)\n> }\n>\n> works for me in Swift 2.2. Have they announced that they're taking this\n> away?\n>\n>\n> On Sun, Dec 6, 2015 at 4:38 PM, Tyler Mandry via swift-evolution <\n> swift-evolution at swift.org> wrote:\n>\n>> What isn't clear to me from Chris's or John's comments is why the `if let\n>> x? = foo` syntax was taken away. Was it for backward-compatibility? To me,\n>> this syntax does have special syntactic support, and also seems to make it\n>> clearer what's going on. It's also analogous to Swift's type inference for\n>> generic <T?> types, for example:\n>>\n>>    func doSomething<T? where T: Equatable>(x: T?) -> T { ... }\n>>\n>> Note the T? in brackets. If I pass an Int? to doSomething, the type is\n>> \"unwrapped\" and T becomes Int. It seems like `if let x? = foo` would follow\n>> the same pattern.\n>>\n>> Was the syntax taken away for reasons unlikely to change, or is it up for\n>> discussion? :)\n>>\n>> --\n>> Tyler Mandry\n>>\n>>\n>> _______________________________________________\n>> swift-evolution mailing list\n>> swift-evolution at swift.org\n>> https://lists.swift.org/mailman/listinfo/swift-evolution\n>>\n>>\n>\n\n\n-- \nTyler Mandry" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000670.html" , "inReplyTo" : "CAKCGC8AjTGQRer0paqVGnbt4qR3M=T_95hTw44CF6QXQmzV1oQ@mail.gmail.com" , "date" : { "$date" : 1449438418000} , "subject" : "[swift-evolution] Proposal: Optional Binding Shorthand Syntax" , "references" : [ "CAA9p5uv=U-=kLi0PSn+9YSNvnfcn6oDEqOss1q1UjLn-sU9xUQ@mail.gmail.com" , "CAKCGC8AjTGQRer0paqVGnbt4qR3M=T_95hTw44CF6QXQmzV1oQ@mail.gmail.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/CA66BF95-1A27-4B02-AE21-840DDEC185C0@apple.com"}} , "_id" : "CA66BF95-1A27-4B02-AE21-840DDEC185C0@apple.com" , "from" : "clattner at apple.com (Chris Lattner)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 6, 2015, at 1:38 PM, Tyler Mandry via swift-evolution <swift-evolution at swift.org> wrote:\n> \n> What isn't clear to me from Chris's or John's comments is why the `if let x? = foo` syntax was taken away. Was it for backward-compatibility? \n\nFWIW, that syntax hasn’t been taken away, it just means something different now.\n\n\tif let x = foo() {\n\ncaptures is privileged syntax for testing an optional and binding to the thing inside of it.  The patch I linked to moved away from this, but at great cost: it uglified lots of common code.  Swift privileges optional in a number of ways (e.g. it is the result of as?, try?, etc) and the standard library uses it pervasively as well.  Optimizing for that common case makes sense.\n\n-Chris" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000690.html" , "inReplyTo" : "CAA9p5uv=U-=kLi0PSn+9YSNvnfcn6oDEqOss1q1UjLn-sU9xUQ@mail.gmail.com" , "date" : { "$date" : 1449441757000} , "subject" : "[swift-evolution] Proposal: Optional Binding Shorthand Syntax" , "references" : [ "CAA9p5uv=U-=kLi0PSn+9YSNvnfcn6oDEqOss1q1UjLn-sU9xUQ@mail.gmail.com"] , "descendants" : [ "CAA9p5uvdrk_QnRtpm6gu1hKUMZaXsbV-VXY5xpUYSc4XMuxbsQ@mail.gmail.com" , "226B86CA-EFD5-4503-B1C1-2E242E64D107@apple.com"]} , { "_links" : { "self" : { "href" : "/charter/emails/226B86CA-EFD5-4503-B1C1-2E242E64D107@apple.com"}} , "_id" : "226B86CA-EFD5-4503-B1C1-2E242E64D107@apple.com" , "from" : "clattner at apple.com (Chris Lattner)" , "mailingList" : "swift-evolution" , "content" : "> On Dec 6, 2015, at 2:48 PM, Tyler Mandry <tmandry at gmail.com> wrote:\n> \n> True, I meant why was the `?` taken out of the syntax\n\nSwift 2 does support ? patterns.\n\n-Chris" , "archiveURL" : "https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000694.html" , "inReplyTo" : "CAA9p5uvdrk_QnRtpm6gu1hKUMZaXsbV-VXY5xpUYSc4XMuxbsQ@mail.gmail.com" , "date" : { "$date" : 1449442287000} , "subject" : "[swift-evolution] Proposal: Optional Binding Shorthand Syntax" , "references" : [ "CAA9p5uv=U-=kLi0PSn+9YSNvnfcn6oDEqOss1q1UjLn-sU9xUQ@mail.gmail.com" , "CA66BF95-1A27-4B02-AE21-840DDEC185C0@apple.com" , "CAA9p5uvdrk_QnRtpm6gu1hKUMZaXsbV-VXY5xpUYSc4XMuxbsQ@mail.gmail.com"]}]}}