
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">upshift/actions/actions.go (0.0%)</option>
				
				<option value="file1">upshift/actions/android.go (0.0%)</option>
				
				<option value="file2">upshift/actions/cocoapods.go (40.0%)</option>
				
				<option value="file3">upshift/actions/fastlane.go (0.0%)</option>
				
				<option value="file4">upshift/actions/gems.go (25.6%)</option>
				
				<option value="file5">upshift/actions/gradle.go (0.0%)</option>
				
				<option value="file6">upshift/actions/ios.go (0.0%)</option>
				
				<option value="file7">upshift/actions/pod.go (84.6%)</option>
				
				<option value="file8">upshift/actions/setup.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package actions

import (
        "fmt"
        "upshift/utils"
)

// GradleWrapper : Action to install the gradle wrapper
func GradleWrapper() int <span class="cov0" title="0">{
        var gradle Gradle

        // Check if gradle exists
        err := gradle.Version()
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError(err.Error())
                return 1
        }</span>

        // Add the wrapper
        <span class="cov0" title="0">status, err := gradle.AddWrapper()
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError(err.Error())
        }</span>
        <span class="cov0" title="0">return status</span>
}

// PodInstall : Install pods for this project, if the project uses it
func PodInstall() int <span class="cov0" title="0">{
        var pod Pod

        // Check if this project uses cocoapods
        if pod.AreUsed() == false </span><span class="cov0" title="0">{
                fmt.Println("It looks like this project doesn't use pods")
                return 0
        }</span>

        // Install pod
        <span class="cov0" title="0">status, err := pod.Install()
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError("Could not install pods\n" + err.Error())
                return status
        }</span>

        <span class="cov0" title="0">fmt.Println("We were able to successfully setup cocoapods, moving on")
        return 0</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package actions

import (
        // "errors"
        "fmt"
        "path/filepath"
        "strings"
        "upshift/basher"
        c "upshift/colours"
        "upshift/command"
        "upshift/config"
        "upshift/utils"
)

func init() <span class="cov8" title="1">{

}</span>

// UpgradeAndroid : Upgrade the android sdk
func UpgradeAndroid() int <span class="cov0" title="0">{
        var b basher.Basher
        logPath, _ := filepath.Abs(".upshift/logs/android-sdk-upgrade.log")
        _, err := b.Run("AndroidUpgradeSDK", []string{logPath})
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError("We could not start upgrading android.\n" + err.Error())
                return 1
        }</span>

        <span class="cov0" title="0">return 0</span>
}

// SetupAndroid : Install the android sdk
func SetupAndroid() int <span class="cov0" title="0">{
        var b basher.Basher
        logPath, _ := filepath.Abs(".upshift/logs/android-sdk-upgrade.log")
        _, err := b.Run("AndroidInstallSDK", []string{logPath})
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError("We could not start upgrading android.\n" + err.Error())
                return 1
        }</span>

        <span class="cov0" title="0">return 0</span>
}

// AndroidBuild : Build the android project
func AndroidBuild() int <span class="cov0" title="0">{

        var b basher.Basher
        conf := config.Get()
        cleanOnStart := conf.Settings.CleanBeforeBuild

        if cleanOnStart == true </span><span class="cov0" title="0">{
                // Clean the project first, we might not ALWAYS want to do this
                fmt.Println("Let's clean the project before starting")
                // #TODO : Replace with Gradle.Clean
                logPath, _ := filepath.Abs(".upshift/logs/android-clean.log")
                _, err := b.Run("AndroidClean", []string{logPath})
                if err != nil </span><span class="cov0" title="0">{
                        utils.LogError("We could not clean your project. It's really dirty\n" + err.Error())
                        return 1
                }</span>
                // #END
        }

        <span class="cov0" title="0">launchEmulator()

        // Check if there are any connected devices
        if len(devicesConnected()) &gt; 0 </span><span class="cov0" title="0">{
                // Delete older builds if they are installed
                fmt.Println("Removing older builds from connected devices")
                // #TODO : Change to Gradle.Uninstall
                logPath, _ := filepath.Abs(".upshift/logs/android-uninstall.log")
                _, err := b.Run("AndroidUninstall", []string{logPath})
                if err != nil </span><span class="cov0" title="0">{
                        utils.LogError("We could not uninstall the older binaries.\n" + err.Error())
                        // Don't return on this, we don't even know why this fails, maybe because a device isn't connected
                }</span>
                // #END
        }

        // #TODO : Replace with Gradle.Lint
        <span class="cov0" title="0">fmt.Println("Before we build, we need to lint")
        utils.LogMessage("$ ./gradlew lint")
        logPath, _ := filepath.Abs(".upshift/logs/android-lint.log")
        _, err := b.Run("AndroidLint", []string{logPath})
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError("We could not start lintin your project.\n" + err.Error())
                return 1
        }</span>

        <span class="cov0" title="0">tailData, err := utils.FileTail(logPath, 500)
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError("It seems we couldn't read the output. Here's what happened\n" + err.Error())
                return 1
        }</span>

        <span class="cov0" title="0">if strings.Contains(tailData, "BUILD SUCCESSFUL") == false </span><span class="cov0" title="0">{
                utils.LogError("Something went wrong while linting, you need to look at this.")
                return 1
        }</span>
        // #END

        // #TODO : Replace with Gradle.Assemble
        <span class="cov0" title="0">fmt.Println("Okay, so lets build Debug and install it on a emulator")
        utils.LogMessage("$ ./gradlew assemble --stacktrace")
        logPath, _ = filepath.Abs(".upshift/logs/android-assemble.log")
        _, err = b.Run("AndroidAssemble", []string{logPath})
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError("We could not start building your project.\n" + err.Error())
                return 1
        }</span>

        <span class="cov0" title="0">tailData, err = utils.FileTail(logPath, 500)
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError("It seems we couldn't read the output. Here's what happened\n" + err.Error())
                return 1
        }</span>

        <span class="cov0" title="0">if strings.Contains(tailData, "BUILD SUCCESSFUL") == false </span><span class="cov0" title="0">{
                utils.LogError("Something went wrong while building, you need to look at this.")
                return 1
        }</span>
        // #END

        <span class="cov0" title="0">return 0</span>
}

func launchEmulator() bool <span class="cov0" title="0">{

        var b basher.Basher

        // 1. Check if any devices are connected, if yes, use one of those
        // 2. If nothing so far, see if any avds are listed and start the first one
        // 3. If still nothing, create an avd and launch it
        // - N E V E R - G I V E - U P - (Alright, gave up, not creating avds, too much pain)

        // avdToStart := ""
        // avdToStart = "Nexus_5_API_22"

        devices := devicesConnected()
        if len(devices) &gt; 0 </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">avds := avdsAvailable()
        if len(avds) == 0 </span><span class="cov0" title="0">{
                // No AVDs found, create one
                // to view a list of available avds you can create, run 'android list targets'
                // we prefer to use the latest one possible, and we only feed in the required fields
                // look for ones with ABIs
                // android create avd --target android-23 --name "Google Inc.:Google APIs:22" -b "google_apis/x86_64"
                return false
        }</span>

        <span class="cov0" title="0">fmt.Println("Time to load up the emulator " + c.Blue + avds[0] + c.Default)
        logPath, _ := filepath.Abs(".upshift/logs/android-emulator.log")
        _, err := b.Run("AndroidLaunchEmulator", []string{avds[0], logPath})
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError("We could not start loading up the emulator.\n" + err.Error())
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

func avdsAvailable() []string <span class="cov0" title="0">{
        out, err := command.Run([]string{"emulator", "-list-avds"}, "")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("We couldn't start finding devices\n" + err.Error())
                return []string{}
        }</span>

        <span class="cov0" title="0">avds := utils.CreateList(out, []string{})
        return avds</span>
}

func devicesConnected() []string <span class="cov0" title="0">{
        out, err := command.Run([]string{"adb", "devices"}, "")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("We couldn't start finding devices\n" + err.Error())
                return []string{}
        }</span>

        <span class="cov0" title="0">devices := utils.CreateList(out, []string{"List of devices attached", "daemon not running. starting it now on port", "daemon started successfully", "offline"})

        return devices</span>
}

//     printf "\n\n${greenColour}Super${noColour}! The build was fine.\n"
//     # Check if package is empty
//     if [ "${package}" != "" ];then
//       if [ "${mainActivity}" != "" ]; then
//         printf "Starting activity ${blueColour}${mainActivity}${noColour} in package ${blueColour}${package}${noColour}\n"

//         # Start the activity and package
//         adb shell am start -n ${package}/${package}.${mainActivity}

//         # Tell the user everything is nice and easy
//         printf "\nAlright, the build was ${greenColour}successful${noColour} 🍺\n\n"
//       else
//         # The mainActivity is empty it seems
//         printf "Alright, the build was ${greenColour}successful${noColour}, but there was no ${blueColour}mainActivity${noColour} defined, so couldn't start it automatically 🍺\n\n"
//       fi
//     else
//       # The package is empty it seems
//       printf "Alright, the build was ${greenColour}successful${noColour}, but there was no ${blueColour}package${noColour} defined, so couldn't start it automatically 🍺\n\n"
//     fi
//   fi
// }
</pre>
		
		<pre class="file" id="file2" style="display: none">package actions

import "errors"

// Cocoapods : Construct to handle all things related to fastlane
type Cocoapods struct{}

// Install : Install cocoapods on the machine
func (c *Cocoapods) Install() error <span class="cov8" title="1">{
        var g Gems
        err := g.Install("cocoapods", "pod")
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("Could not install cocoapods\n" + err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Uninstall : Uninstall cocoapods on the machine
func (c *Cocoapods) Uninstall() error <span class="cov0" title="0">{
        var g Gems
        err := g.Uninstall("cocoapods", "pod")
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("Could not uninstall cocoapods\n" + err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package actions

import "errors"

// Fastlane : Construct to handle all things related to fastlane
type Fastlane struct{}

// Install : Install fastlane on the machine
func (f *Fastlane) Install() error <span class="cov0" title="0">{
        var g Gems
        err := g.InstallSimple("fastlane")
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("Could not install fastlane\n" + err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Uninstall : Uninstall fastlane on the machine
func (f *Fastlane) Uninstall() error <span class="cov0" title="0">{
        var g Gems
        err := g.UninstallSimple("fastlane")
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("Could not uninstall fastlane\n" + err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package actions

import (
        "errors"
        "fmt"
        "strconv"
        "strings"
        "upshift/basher"
        "upshift/command"
        "upshift/config"
)

// Gems structure to install, upgrade, uninstall gems
type Gems struct{}

// InstallSimple a gem with gem name only
func (g *Gems) InstallSimple(gem string) error <span class="cov0" title="0">{
        return g.Install(gem, "")
}</span>

// Install a gem with gem name and scriptName
func (g *Gems) Install(gem string, scriptName string) error <span class="cov8" title="1">{
        // Get the global config
        conf := config.Get()

        // If scriptName is empty, use the gem name
        if scriptName == "" </span><span class="cov0" title="0">{
                scriptName = gem
        }</span>

        // Check if gem is installed
        <span class="cov8" title="1">installed, _ := g.version(scriptName)
        if installed == true </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Okay, so the gem was not installed, big deal
        // Let's install the effing thing
        <span class="cov0" title="0">var b basher.Basher
        RootPassword, err := conf.GetRootPassword()
        if conf.IsCI() == true &amp;&amp; err != nil </span><span class="cov0" title="0">{
                return errors.New("Unable to find the RootPassword\n" + err.Error())
        }</span>

        <span class="cov0" title="0">status, err := b.Run("SetupGem", []string{gem, strconv.FormatBool(conf.IsCI()), RootPassword})
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("Could not install " + gem + " [Error Code &lt;" + strconv.Itoa(status) + "&gt;]\n" + err.Error())
        }</span>

        // Verify if gem was installed
        <span class="cov0" title="0">installed, _ = g.version(scriptName)
        if installed == true </span><span class="cov0" title="0">{
                // It was successfull installed
                return nil
        }</span>
        <span class="cov0" title="0">return errors.New("The script ran but the gem " + gem + " was not installed on the machine")</span>
}

// UninstallSimple a gem with gem name only
func (g *Gems) UninstallSimple(gem string) error <span class="cov0" title="0">{
        return g.Uninstall(gem, "")
}</span>

// Uninstall : remove a gem from the system
func (g *Gems) Uninstall(gem string, scriptName string) error <span class="cov0" title="0">{
        // If scriptName is not set, use the gem name
        if scriptName == "" </span><span class="cov0" title="0">{
                scriptName = gem
        }</span>

        // Check if the gem is installed
        <span class="cov0" title="0">installed, _ := g.version(scriptName)
        if installed == false </span><span class="cov0" title="0">{
                // If it is not installed then return
                return nil
        }</span>

        // Get the global config
        <span class="cov0" title="0">conf := config.Get()

        // So we know that it is installed, go ahead and uninstall it
        // Let's uninstall the effing thing
        var b basher.Basher
        RootPassword, err := conf.GetRootPassword()
        if conf.IsCI() == true &amp;&amp; err != nil </span><span class="cov0" title="0">{
                return errors.New("Unable to find the RootPassword\n" + err.Error())
        }</span>

        <span class="cov0" title="0">status, err := b.Run("UninstallGem", []string{gem, strconv.FormatBool(conf.IsCI()), RootPassword})
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("Could not uninstall " + gem + " [Error Code &lt;" + strconv.Itoa(status) + "&gt;]\n" + err.Error())
        }</span>

        // Verify if gem was uninstalled
        <span class="cov0" title="0">installed, _ = g.version(scriptName)
        if installed == false </span><span class="cov0" title="0">{
                // It was successfull uninstalled
                return nil
        }</span>
        <span class="cov0" title="0">return errors.New("The script ran but the gem " + gem + " was not installed on the machine")</span>
}

func (g *Gems) version(gem string) (bool, string) <span class="cov8" title="1">{
        // Check which version of the gem was installed
        ver, err := command.Run([]string{gem, "--version"}, "")
        if err == nil </span><span class="cov8" title="1">{
                // This means that the gem is installed
                // Get rid of the name and get the version number
                ver = strings.Replace(ver, gem, "", 1)
                // Next trim what's left
                ver = strings.TrimSpace(ver)
                fmt.Println(gem + " v" + ver + " is installed on your machine")
                return true, ver
        }</span>

        // Not installed
        <span class="cov0" title="0">return false, ""</span>
}

// #TODO : Find out how do we know that an update is available and update it
// When an upgrade is available, they say
// CocoaPods 1.0.1 is available.
// To update use: `sudo gem install cocoapods`
// Until we reach version 1.0 the features of CocoaPods can and will change.
// We strongly recommend that you use the latest version at all times.
// if strings.Contains(tailData, "sudo gem install cocoapods") == true {
// This means that an update is available, run cocoapods update
//        status := SetupPods(true)
// if status &gt; 0 {
// return errors.New("We couldn't update to the new version of cocoapods")
// }
// fmt.Println("Updated cocoapods to the latest version")
// }
</pre>
		
		<pre class="file" id="file5" style="display: none">package actions

import (
        "errors"
        "strings"
        "upshift/basher"
        "upshift/command"
        "upshift/utils"
)

// Gradle : Keep track of everything related to gradle in upshift
type Gradle struct {
        version          string
        wrapperInstalled bool
        basher           basher.Basher
}

// Version : Find the version number of gradle installed
func (g *Gradle) Version() error <span class="cov0" title="0">{
        // Run gradle -v to figure out if it is install
        utils.LogMessage("$ gradle -v")
        out, err := command.Run([]string{"gradle", "-v"}, "")
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("Gradle is not installed, you can download it from http://gradle.com.")
        }</span>

        <span class="cov0" title="0">list := utils.CreateList(out, []string{"Build time", "Build number:", "Revision:", "Groovy:", "Ant:", "JVM:", "OS:", "--------------"})
        g.version = strings.TrimSpace(strings.Replace(strings.Join(list[:], ""), "Gradle", "", 1))
        return nil</span>
}

// AddWrapper : Check and confirm if gradlew exists in the project
func (g *Gradle) AddWrapper() (int, error) <span class="cov0" title="0">{
        // Check if gradle is installed
        if g.version == "" </span><span class="cov0" title="0">{
                g.wrapperInstalled = false
                return 1, errors.New("Gradle version not known. Please check version first")
        }</span>

        // Check if gradlew file exists
        <span class="cov0" title="0">if utils.FileExists("./gradlew") == true </span><span class="cov0" title="0">{
                g.wrapperInstalled = true
                return 0, nil
        }</span>

        // So, gradle is installed, just need to install wrapper [SetupGradleW]
        // I won't touch anything to do with gradle and pipes with a ten foot pole, so this goes to basher
        <span class="cov0" title="0">utils.LogMessage("$ gradle wrapper")
        status, err := g.basher.Run("GradleWrapper", []string{})
        if err != nil </span><span class="cov0" title="0">{
                g.wrapperInstalled = false
                return status, errors.New("We couldn't initialise gradle wrapper\n" + err.Error())
        }</span>

        <span class="cov0" title="0">g.wrapperInstalled = true
        return status, nil</span>
}

// Task : Execute a gradle task
func (g *Gradle) Task(task string, params []string, logPath string, success string) (int, error) <span class="cov0" title="0">{
        // Check if task exists
        if task == "" </span><span class="cov0" title="0">{
                return 1, errors.New("Gradle needs a task to run")
        }</span>

        // Check if gradle is installed
        <span class="cov0" title="0">if g.version == "" </span><span class="cov0" title="0">{
                return 1, errors.New("Gradle version not known. Please check version first")
        }</span>

        // Check if gradlew file exists
        <span class="cov0" title="0">if utils.FileExists("./gradlew") == false </span><span class="cov0" title="0">{
                return 1, errors.New("Gradle wrapper is not installed")
        }</span>

        <span class="cov0" title="0">utils.LogMessage("$ ./gradlew " + task + " " + strings.Join(params[:], " "))
        status, err := g.basher.RunAndTail("GradlewTask", []string{task, logPath}, logPath, []string{success}, []string{})
        return status, err</span>
}

// Clean : Execute gradle clean on the Android project
func (g *Gradle) Clean(logPath string) (int, error) <span class="cov0" title="0">{
        return g.Task("clean", []string{}, logPath, "BUILD SUCCESSFUL")
}</span>

// Lint : Execute gradle lint on the Android project
func (g *Gradle) Lint(logPath string) (int, error) <span class="cov0" title="0">{
        return g.Task("lint", []string{}, logPath, "BUILD SUCCESSFUL")
}</span>

// Uninstall : Remove installed versions of the app from connected devices
func (g *Gradle) Uninstall(logPath string) (int, error) <span class="cov0" title="0">{
        return g.Task("uninstallAll", []string{}, logPath, "BUILD SUCCESSFUL")
}</span>

// InstallDebug : Install the debug app on to connected devices
func (g *Gradle) InstallDebug(logPath string) (int, error) <span class="cov0" title="0">{
        return g.Task("installDebug", []string{"--stacktrace"}, logPath, "BUILD SUCCESSFUL")
}</span>

// Assemble : Build an android project
func (g *Gradle) Assemble(logPath string) (int, error) <span class="cov0" title="0">{
        return g.Task("assemble", []string{"--stacktrace"}, logPath, "BUILD SUCCESSFUL")
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package actions

import (
        "errors"
        "fmt"
        "io/ioutil"
        "path/filepath"
        "regexp"
        "strings"
        "upshift/basher"
        c "upshift/colours"
        "upshift/command"
        "upshift/config"
        "upshift/utils"
)

var projectSettings map[string]string

// IosUploadBuild : Upload an build to itunesconnect
func IosUploadBuild() int <span class="cov0" title="0">{
        err := uploadBuildToItunes()
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError(err.Error())
                return 1
        }</span>

        <span class="cov0" title="0">return 0</span>
}

// IosCreateApp : Create an app on itunesconnect
func IosCreateApp() int <span class="cov0" title="0">{
        err := createAppOniTunes()
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError(err.Error())
                return 1
        }</span>

        <span class="cov0" title="0">return 0</span>
}

// IosExportIPA : Export an IPA
func IosExportIPA() int <span class="cov0" title="0">{
        // Try the build now
        projectName := projectSettings["PROJECT_NAME"]

        err := exportIPAForIOS(projectName)
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError(err.Error())
                return 1
        }</span>

        <span class="cov0" title="0">return 0</span>
}

// IosArchive : Archive an iOS project
func IosArchive() int <span class="cov0" title="0">{
        projectType := projectSettings["UP_PROJECT_TYPE"]
        projectName := projectSettings["PROJECT_NAME"]
        projectExtension := projectSettings["UP_PROJECT_EXTENSION"]
        projectPath := projectName + projectExtension
        projectScheme := projectSettings["UP_PROJECT_SCHEME"]

        err := archiveForIOS(projectType, projectPath, projectScheme, projectName)
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError(err.Error())
                return 1
        }</span>

        <span class="cov0" title="0">return 0</span>
}

// IosCertificates : Install certificates for iOS
func IosCertificates() int <span class="cov0" title="0">{
        err := installCertificates()
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError(err.Error())
                return 1
        }</span>

        <span class="cov0" title="0">return 0</span>
}

// IosProvisioning : Install the provisioning profiles for a project
func IosProvisioning() int <span class="cov0" title="0">{
        err := addProvisioningProfiles()
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError(err.Error())
                return 1
        }</span>

        <span class="cov0" title="0">return 0</span>
}

// IosDeploySimulator : Deploy an app to the simulator
func IosDeploySimulator() int <span class="cov0" title="0">{
        projectName := projectSettings["PROJECT_NAME"]
        projectBundleIdentifier := projectSettings["PRODUCT_BUNDLE_IDENTIFIER"]

        err := deployToSimulator(projectName, projectBundleIdentifier)
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError(err.Error())
                return 1
        }</span>

        <span class="cov0" title="0">return 0</span>
}

// IosTest : Execute tests written for the iOS project
func IosTest() int <span class="cov0" title="0">{

        projectType := projectSettings["UP_PROJECT_TYPE"]
        projectName := projectSettings["PROJECT_NAME"]
        projectExtension := projectSettings["UP_PROJECT_EXTENSION"]
        projectPath := projectName + projectExtension
        projectScheme := projectSettings["UP_PROJECT_SCHEME"]
        projectDevice := projectSettings["UP_SIMULATOR_IPHONE"]

        err := testForIOS(projectType, projectPath, projectScheme, projectDevice)
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError(err.Error())
                return 1
        }</span>

        <span class="cov0" title="0">return 0</span>
}

// IosBuild : Build an iOS project
func IosBuild() int <span class="cov0" title="0">{

        // Try the build now
        projectType := projectSettings["UP_PROJECT_TYPE"]
        projectName := projectSettings["PROJECT_NAME"]
        projectExtension := projectSettings["UP_PROJECT_EXTENSION"]
        projectPath := projectName + projectExtension
        projectScheme := projectSettings["UP_PROJECT_SCHEME"]
        projectDevice := projectSettings["UP_SIMULATOR_IPHONE"]

        err := compileForIOS(projectType, projectPath, projectScheme, projectDevice)
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError(err.Error())
                return 1
        }</span>

        <span class="cov0" title="0">return 0</span>
}

// IosPrepare : Prepare upshift to execute ios builds, we do this so that we don't have to call xcodebuild again and again
func IosPrepare() int <span class="cov0" title="0">{
        fmt.Println("We will now try and load your xcode settings")
        err := xcodeBuildSettings() // Gets PROJECT_NAME, FULL_PRODUCT_NAME, PRODUCT_BUNDLE_IDENTIFIER amongst others in projectSettings
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError("We could not read your xcode settings, it this an iOS repo?\n" + err.Error())
                return 1
        }</span>

        <span class="cov0" title="0">getProjectPath()             // Gets UP_PROJECT_EXTENSION, UP_PROJECT_TYPE in projectSettings
        findXcodeAndOSForSimulator() // Gets UP_XCODE_VERSION, UP_SIMULATOR_IPHONE, UP_SIMULATOR_IPHONEOS in projectSettings

        // Create the device name for testing
        deviceForSimulator := projectSettings["UP_SIMULATOR_IPHONE"] + " (" + projectSettings["UP_SIMULATOR_IPHONEOS"] + ")"

        // Check if this device is available on this machine
        fmt.Println("Checking if this machine can run the simulator for " + deviceForSimulator)
        if findIfDeviceIsAvailable(deviceForSimulator) == true </span><span class="cov0" title="0">{
                // If simulator is running, don't do anything, if not start it
                if isSimulatorRunning() == true </span><span class="cov0" title="0">{
                        fmt.Println("Oh, it seems your simulator is already running, we can't figure out which version it is though")
                }</span><span class="cov0" title="0"> else {
                        fmt.Println("It sure is available, lets start up the simulator")
                        startSimulator(deviceForSimulator)
                        fmt.Println("You should see a simulator loading in the background")
                }</span>
        }<span class="cov0" title="0"> else {
                // Device not found, can't start the simulator
                return 1
        }</span>

        // Either simulator should be running by now or should have been started

        // Find available schemes
        <span class="cov0" title="0">err = findAvailableSchemes()
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError(err.Error())
                return 1
        }</span>

        // Increment the build number
        <span class="cov0" title="0">err = incrementBuildNumber()
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError(err.Error())
                return 1
        }</span>

        <span class="cov0" title="0">return 0</span>
}

func incrementBuildNumber() error <span class="cov0" title="0">{
        var b basher.Basher
        projectName := projectSettings["PROJECT_NAME"]
        _, err := b.Run("IOSIncrementBuildNumber", []string{projectName})
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("We couldn't incremenet the build number")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func deployToSimulator(projectName string, projectBundleIdentifier string) error <span class="cov0" title="0">{
        builtFile := ""
        debugFile, _ := filepath.Abs(".upshift/build/Build/Products/Debug-iphonesimulator/" + projectName + ".app")
        releaseFile, _ := filepath.Abs(".upshift/build/Build/Products/Release-iphonesimulator/" + projectName + ".app")
        fileExits := utils.FileExists(debugFile)
        if fileExits == false </span><span class="cov0" title="0">{
                fileExits = utils.FileExists(releaseFile)
                if fileExits == false </span><span class="cov0" title="0">{
                        return errors.New("It seems you haven't build for the simulator yet. Please try " + c.Red + "upshift ios build" + c.Default + " first")
                }</span>
                // we found the release file
                <span class="cov0" title="0">builtFile = releaseFile</span>
        }<span class="cov0" title="0"> else {
                // we found the debug file
                builtFile = debugFile
        }</span>

        // If file exists, push it to the simulator
        <span class="cov0" title="0">fmt.Println("Installing the app in the simulator")
        _, err := command.Run([]string{"xcrun", "simctl", "install", "booted", builtFile}, "")
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("We could not deploy the app to the simulator\n" + err.Error())
        }</span>

        // Start the app
        <span class="cov0" title="0">fmt.Println("Starting the app in the simulator")
        _, err = command.Run([]string{"xcrun", "simctl", "launch", "booted", projectBundleIdentifier}, "")
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("We could not deploy the app to the simulator\n" + err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// xcrun simctl launch booted "${productBundleIdentifier}"

// SetupExportPlist : Create an export.plist to archive the project
func SetupExportPlist() int <span class="cov0" title="0">{
        configExits := utils.FileExists(".private/export.plist")
        if configExits == true </span><span class="cov0" title="0">{
                fmt.Println("It looks like .private/export.plist is already here, skipping this step")
                return 1
        }</span>
        // export.Plist does not exist
        // Create a new export.plist in this directory in .private

        <span class="cov0" title="0">sampleExportPlist := `&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
        &lt;key&gt;method&lt;/key&gt;
        &lt;string&gt;ad-hoc&lt;/string&gt;
        &lt;key&gt;uploadSymbols&lt;/key&gt;
        &lt;true/&gt;
        &lt;key&gt;uploadBitcode&lt;/key&gt;
        &lt;true/&gt;
&lt;/dict&gt;
&lt;/plist&gt;"`

        exportPlistBytes := []byte(sampleExportPlist)

        err := ioutil.WriteFile(".private/export.plist", exportPlistBytes, 0644)
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError("We could not write the .private/export.plist file\n" + err.Error())
                return 1
        }</span>

        <span class="cov0" title="0">fmt.Println("We just added a sample file to .private/export.plist!")
        return 0</span>

}

// SetupProfiles : Setup provisioning profiles
// This will probably be run once in a while
func SetupProfiles() int <span class="cov0" title="0">{

        var b basher.Basher
        developerAccounts, err := getDeveloperAccounts()
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError(err.Error())
                return 1
        }</span>

        <span class="cov0" title="0">for _, email := range developerAccounts </span><span class="cov0" title="0">{
                email = strings.TrimSpace(email)

                if email != "" </span><span class="cov0" title="0">{
                        fmt.Println("Trying to repair your provisioning profiles and installing new and fixed ones for " + email)
                        _, err := b.Run("FetchAndRepairProvisioningProfiles", []string{email})
                        if err != nil </span><span class="cov0" title="0">{
                                utils.LogError("We couldn't fix and install your provisioning profiles")
                                return 1
                        }</span>
                }
        }
        <span class="cov0" title="0">return 0</span>
}

func getDeveloperAccounts() ([]string, error) <span class="cov0" title="0">{

        var developerAccounts []string

        conf := config.Get()

        if conf.Settings.IOSDeveloperAccount == "" </span><span class="cov0" title="0">{
                return developerAccounts, errors.New("You should define the emails of the developer account in the global config")
        }</span>

        <span class="cov0" title="0">developerAccounts = strings.SplitN(conf.Settings.IOSDeveloperAccount, ",", -1)
        return developerAccounts, nil</span>
}

func installCertificates() error <span class="cov0" title="0">{
        var b basher.Basher
        utils.LogMessage("Checking for apple.cer, distribution.p12 and distribution.cer in .private")

        basePath, _ := filepath.Abs(".private")

        // First check if the certificates are added to .private folder
        appleCer, _ := filepath.Abs(".private/apple.cer")
        distributionCer, _ := filepath.Abs(".private/distribution.cer")
        distributionP12, _ := filepath.Abs(".private/distribution.p12")

        // If they exist, install them
        appleCerExists := utils.FileExists(appleCer)
        distributionCerExists := utils.FileExists(distributionCer)
        distributionP12Exists := utils.FileExists(distributionP12)

        if !(appleCerExists &amp;&amp; distributionCerExists &amp;&amp; distributionP12Exists) </span><span class="cov0" title="0">{
                // If they don't exist, check global config to see if they have them
                conf := config.Get()
                globalBasePath := conf.Settings.IOSCertificatePath

                if globalBasePath == "" </span><span class="cov0" title="0">{
                        return errors.New("The certificates don't exist in both .private and global conf")
                }</span>

                <span class="cov0" title="0">basePath = globalBasePath

                appleCer, _ = filepath.Abs(globalBasePath + "/apple.cer")
                distributionCer, _ = filepath.Abs(globalBasePath + "/distribution.cer")
                distributionP12, _ = filepath.Abs(globalBasePath + "/distribution.p12")

                // If they exist, install them
                appleCerExists = utils.FileExists(appleCer)
                distributionCerExists = utils.FileExists(distributionCer)
                distributionP12Exists = utils.FileExists(distributionP12)

                if !(appleCerExists &amp;&amp; distributionCerExists &amp;&amp; distributionP12Exists) </span><span class="cov0" title="0">{
                        return errors.New("All the certificates don't exist in both .private and global conf")
                }</span>
                // If they don't, crash and burn
        }

        <span class="cov0" title="0">b.Run("InstallCertificates", []string{basePath})
        // #TODO Ignore the error here. Even if it says that certificates are already installed, it gets treated like an error
        // if err != nil {
        //         return errors.New("The certicates could not be installed!")
        // }

        fmt.Println("The certificates were successfully installed")
        return nil</span>
}

func uploadBuildToItunes() error <span class="cov0" title="0">{
        var b basher.Basher
        utils.LogMessage("Upload the IPA on iTunesConnect")

        // Get the username which will need to login
        // Highest priority to local config
        conf := config.Get()
        developerAccount := conf.Settings.IOSDeveloperAccount

        if developerAccount == "" </span><span class="cov0" title="0">{
                // Second priority to machine config
                developerAccounts, err := getDeveloperAccounts()
                if err != nil </span><span class="cov0" title="0">{
                        return errors.New(err.Error())
                }</span>

                // If there is only one in machine config, then we can use it, if there are more you need to add it to local config
                <span class="cov0" title="0">if len(developerAccounts) &gt; 1 </span><span class="cov0" title="0">{
                        return errors.New("There are too many developer accounts in the machine config, we either need one in machine config or one in local config")
                }</span>

                <span class="cov0" title="0">if len(developerAccounts) == 1 </span><span class="cov0" title="0">{
                        developerAccount = developerAccounts[0]
                }</span>
        }

        <span class="cov0" title="0">projectScheme := projectSettings["UP_PROJECT_SCHEME"]
        projectName := projectSettings["PROJECT_NAME"]

        // Add SwitSources if required - AddSwiftSources
        status, err := b.Run("AddSwiftSources", []string{projectName, projectScheme})
        fmt.Println("status", status)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("err", err.Error())
                return errors.New("We could not add SwiftSources to the IPA")
        }</span>

        <span class="cov0" title="0">_, err = b.Run("UploadIPAoniTunes", []string{developerAccount, ".upshift/" + projectScheme + ".ipa"})
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("We could not upload the IPA on iTunes")
        }</span>

        <span class="cov0" title="0">fmt.Println("We have successfully uploaded this IPA on iTunes, it's all yours now")
        return nil</span>
}

func createAppOniTunes() error <span class="cov0" title="0">{
        var b basher.Basher
        utils.LogMessage("Create an app on iTunesConnect if it doesn't exist")

        // Get the username which will need to login
        // Highest priority to local config
        conf := config.Get()
        developerAccount := conf.Settings.IOSDeveloperAccount

        if developerAccount == "" </span><span class="cov0" title="0">{
                // Second priority to machine config
                developerAccounts, err := getDeveloperAccounts()
                if err != nil </span><span class="cov0" title="0">{
                        return errors.New(err.Error())
                }</span>

                // If there is only one in machine config, then we can use it, if there are more you need to add it to local config
                <span class="cov0" title="0">if len(developerAccounts) &gt; 1 </span><span class="cov0" title="0">{
                        return errors.New("There are too many developer accounts in the machine config, we either need one in machine config or one in local config")
                }</span>

                <span class="cov0" title="0">if len(developerAccounts) == 1 </span><span class="cov0" title="0">{
                        developerAccount = developerAccounts[0]
                }</span>
        }

        // Get the bundle identifier for this project
        <span class="cov0" title="0">projectBundleIdentifier := projectSettings["PRODUCT_BUNDLE_IDENTIFIER"]

        // Get the name of the project
        // And add your shit to it
        projectName := projectSettings["PROJECT_NAME"] + " Beta by Upshift"

        _, err := b.Run("CreateAppOnItunes", []string{developerAccount, projectBundleIdentifier, projectName})
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("We could not create the app on iTunes\n" + err.Error())
        }</span>

        <span class="cov0" title="0">fmt.Println("We have successfully added this app on iTunes, woohoo")
        return nil</span>
}

func addProvisioningProfiles() error <span class="cov0" title="0">{
        var b basher.Basher
        utils.LogMessage("We will now try to find the provisioning profile")

        // Get the username which will need to login
        // Highest priority to local config
        conf := config.Get()
        developerAccount := conf.Settings.IOSDeveloperAccount

        if developerAccount == "" </span><span class="cov0" title="0">{
                // Second priority to machine config
                developerAccounts, err := getDeveloperAccounts()
                if err != nil </span><span class="cov0" title="0">{
                        return errors.New(err.Error())
                }</span>

                // If there is only one in machine config, then we can use it, if there are more you need to add it to local config
                <span class="cov0" title="0">if len(developerAccounts) &gt; 1 </span><span class="cov0" title="0">{
                        return errors.New("There are too many developer accounts in the machine config, we either need one in machine config or one in local config")
                }</span>

                <span class="cov0" title="0">if len(developerAccounts) == 1 </span><span class="cov0" title="0">{
                        developerAccount = developerAccounts[0]
                }</span>
        }

        // Get the bundle identifier for this project
        <span class="cov0" title="0">projectBundleIdentifier := projectSettings["PRODUCT_BUNDLE_IDENTIFIER"]

        _, err := b.Run("FindProvisioningProfile", []string{developerAccount, projectBundleIdentifier})
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("We could not find your provisioning profile")
        }</span>

        <span class="cov0" title="0">fmt.Println("We have successfully added your profiles to this machine, woohoo")
        return nil</span>
}

func exportIPAForIOS(projectName string) error <span class="cov0" title="0">{
        var b basher.Basher
        // Check if .private/export.plist exists, we can't do shit without it
        exportPlistPath, _ := filepath.Abs(".private/export.plist")
        exportPlistExists := utils.FileExists(exportPlistPath)

        if exportPlistExists == false </span><span class="cov0" title="0">{
                // If export.plist doesn't exist, create it
                status := SetupExportPlist()
                if status != 0 </span><span class="cov0" title="0">{
                        return errors.New("We could not add an export.plist to your .private folder")
                }</span>
        }

        // Fire the export IPA bash script
        <span class="cov0" title="0">utils.LogMessage("$ xcodebuild -exportArchive -exportOptionsPlist .private/export.plist -archivePath .upshift/" + projectName + ".xcarchive -exportPath .upshift")
        logPath, _ := filepath.Abs(".upshift/logs/xcode-export.log")
        _, err := b.Run("ExportIOS", []string{projectName, logPath})
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("We could not export IPA\n" + err.Error())
        }</span>

        // Read the last 500 bytes from the whole message, we just want to see what happened at the end
        <span class="cov0" title="0">tailData, err := utils.FileTail(logPath, 500)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("It seems we couldn't read the output. Here's what happened\n" + err.Error())
        }</span>

        <span class="cov0" title="0">if strings.Contains(tailData, "EXPORT SUCCEEDED") == false </span><span class="cov0" title="0">{
                return errors.New("Something went wrong while exporting the IPA, you need to look at this.")
        }</span>

        <span class="cov0" title="0">fmt.Println("We were able to export an IPA successfully, awesome")
        return nil</span>
}

func archiveForIOS(projectType string, projectPath string, scheme string, projectName string) error <span class="cov0" title="0">{
        var b basher.Basher
        utils.LogMessage("$ xcodebuild -" + projectType + " " + projectPath + " -scheme " + scheme + " -derivedDataPath .upshift/build -archivePath .upshift/" + projectName + ".xcarchive archive")
        logPath, _ := filepath.Abs(".upshift/logs/xcode-archive.log")
        _, err := b.Run("ArchiveIOS", []string{projectType, projectPath, scheme, projectName, logPath})
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("We could not archive for iOS\n" + err.Error())
        }</span>

        // Read the last 500 bytes from the whole message, we just want to what happened at the end
        <span class="cov0" title="0">tailData, err := utils.FileTail(logPath, 500)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("It seems we couldn't read the output. Here's what happened\n" + err.Error())
        }</span>

        <span class="cov0" title="0">if strings.Contains(tailData, "ARCHIVE SUCCEEDED") == false </span><span class="cov0" title="0">{
                return errors.New("Something went wrong with the archive, you need to look at this.")
        }</span>

        <span class="cov0" title="0">fmt.Println("We were able to archive successfully, awesome")
        return nil</span>
}

func testForIOS(projectType string, projectPath string, scheme string, device string) error <span class="cov0" title="0">{
        var b basher.Basher
        utils.LogMessage("$ xctool -" + projectType + " " + projectPath + " -scheme " + scheme + " -sdk iphonesimulator -destination \"platform=iphonesimulator,name=" + device + "\" test")
        logPath, _ := filepath.Abs(".upshift/logs/xcode-test.log")
        _, err := b.Run("TestIOS", []string{projectType, projectPath, scheme, device, logPath})
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("We could not run tests for iOS\n" + err.Error())
        }</span>

        // Read the last 500 bytes from the whole message, we just want to what happened at the end
        <span class="cov0" title="0">tailData, err := utils.FileTail(logPath, 500)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("It seems we couldn't read the output. Here's what happened\n" + err.Error())
        }</span>

        <span class="cov0" title="0">if strings.Contains(tailData, "BUILD SUCCEEDED") == false </span><span class="cov0" title="0">{
                return errors.New("Something went wrong with the build, you need to look at this.")
        }</span>

        <span class="cov0" title="0">fmt.Println("We were able to run all tests successfully, awesome")
        return nil</span>
}

func compileForIOS(projectType string, projectPath string, scheme string, device string) error <span class="cov0" title="0">{
        var b basher.Basher
        utils.LogMessage("$ xcodebuild -" + projectType + " " + projectPath + " -scheme " + scheme + " -sdk iphonesimulator -destination \"platform=iphonesimulator,name=" + device + "\" -derivedDataPath .upshift/build")
        logPath, _ := filepath.Abs(".upshift/logs/xcode-build.log")
        _, err := b.Run("CompileIOS", []string{projectType, projectPath, scheme, device, logPath})
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("We could not compile for iOS\n" + err.Error())
        }</span>

        // Read the last 500 bytes from the whole message, we just want to what happened at the end
        <span class="cov0" title="0">tailData, err := utils.FileTail(logPath, 500)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("It seems we couldn't read the output. Here's what happened\n" + err.Error())
        }</span>

        <span class="cov0" title="0">if strings.Contains(tailData, "BUILD SUCCEEDED") == false </span><span class="cov0" title="0">{
                return errors.New("Something went wrong with the build, you need to look at this.")
        }</span>

        <span class="cov0" title="0">fmt.Println("We were able to build successfully, awesome")
        return nil</span>
}

func findAvailableSchemes() error <span class="cov0" title="0">{
        // 1. If scheme defined in config exists, use that
        // 2. If there is no scheme in config, but there is only one scheme, use that
        // 3. If there is no scheme in config and multiple in xcode, show an error

        // If a scheme is available in config, get that
        conf := config.Get()
        confScheme := conf.Settings.IOSScheme

        // Get the list of schemes from xcode
        listDump, err := command.Run([]string{"xcodebuild", "-list"}, "")
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("We could not get a list from xcode\n" + err.Error())
        }</span>

        <span class="cov0" title="0">listRows := strings.Split(listDump, "\n")
        schemeRows := []string{}
        readingSchemesFlag := false
        for _, row := range listRows </span><span class="cov0" title="0">{
                // If we have already found "    Schemes:", lets add non null values
                if readingSchemesFlag == true </span><span class="cov0" title="0">{
                        // Remove extra spaces
                        row = strings.TrimSpace(row)
                        if row != "" </span><span class="cov0" title="0">{
                                // Add if non-null
                                schemeRows = append(schemeRows, row)
                                // Since we are looping, check if the scheme available from conf is available in the sytem
                                // if it is, just return and say it is
                                if row == confScheme </span><span class="cov0" title="0">{
                                        projectSettings["UP_PROJECT_SCHEME"] = row
                                        return nil
                                }</span>
                        }
                }
                // After you see the row which says "    Schemes:", start adding items to list of schemes available
                <span class="cov0" title="0">if strings.Contains(row, "Schemes:") </span><span class="cov0" title="0">{
                        readingSchemesFlag = true
                }</span>
        }

        // Throw an error if there are no schemes available
        <span class="cov0" title="0">if len(schemeRows) == 0 </span><span class="cov0" title="0">{
                return errors.New("You have no " + c.Red + "schemes" + c.Default + " defined in your project. I'm going home.")
        }</span>

        // Condition 1 : has already been checked, check the error condition
        <span class="cov0" title="0">if confScheme != "" </span><span class="cov0" title="0">{
                return errors.New("Your config says we should use " + c.Red + confScheme + c.Default + " to build the project. But that scheme is missing!")
        }</span>

        // Condition 2 : Checking
        <span class="cov0" title="0">if len(schemeRows) == 1 </span><span class="cov0" title="0">{
                // There is only one scheme, you can set this in projectSettings
                fmt.Println("It seems you didn't define a scheme, but Xcode told us about " + c.Blue + schemeRows[0] + c.Default + " so we are using that")
                projectSettings["UP_PROJECT_SCHEME"] = schemeRows[0]
                return nil
        }</span>

        // Condition 3 : Just throw an error
        <span class="cov0" title="0">return errors.New("You have multiple schemes in your project, hence we can't pick one automatically. Please choose one in your config")</span>
}

func startSimulator(device string) <span class="cov0" title="0">{
        // basher returns an error if status &gt; 0 or if there is an error
        // Whenever we start the simulator, for some reason, the exit code is always 255, though there is no error
        // Hence skipping the error check here
        var b basher.Basher
        b.Run("StartSimulator", []string{device})
}</span>

func findIfDeviceIsAvailable(device string) bool <span class="cov0" title="0">{
        instrumentsDump, err := command.Run([]string{"instruments", "-s", "devices"}, "")
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">instrumentRows := strings.Split(instrumentsDump, "\n")
        uuidRegexp, _ := regexp.Compile("\\[(.*?)\\]")
        var instruments []string

        for _, instrument := range instrumentRows </span><span class="cov0" title="0">{
                uuid := uuidRegexp.FindString(instrument)

                isSimulator := strings.Contains(instrument, "(Simulator)")
                instrument = strings.Replace(instrument, "(Simulator)", "", 1)

                simulatorString := "DEVICE   "
                if isSimulator == true </span><span class="cov0" title="0">{
                        simulatorString = "SIMULATOR"
                }</span>

                <span class="cov0" title="0">if uuid != "" </span><span class="cov0" title="0">{
                        instrument = strings.TrimSpace(strings.Replace(instrument, uuid, "", 1))
                        instruments = append(instruments, c.Gray+simulatorString+c.Default+" "+c.Bold+c.Green+instrument+c.Default+" "+uuid)
                }</span>

                <span class="cov0" title="0">if instrument == device </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">utils.LogError("Your device " + c.Red + device + c.Default + " was not found\nThe following devices are available")
        for _, item := range instruments </span><span class="cov0" title="0">{
                fmt.Println(item)
        }</span>
        <span class="cov0" title="0">return false</span>
}

// Start the simulator
func findXcodeAndOSForSimulator() <span class="cov0" title="0">{
        conf := config.Get()
        var iPhoneOS string

        // Find the correct simulator
        // From here - https://en.wikipedia.org/wiki/Xcode - Xcode 7.0 - 7.x (since Swift 2.0 support)

        os93 := "9.3"
        os92 := "9.2"
        os91 := "9.1"
        os90 := "9.0"

        switch conf.Settings.IOSXcodeVersion </span>{
        <span class="cov0" title="0">case "7.3.1":
                iPhoneOS = os93</span>
        <span class="cov0" title="0">case "7.3":
                iPhoneOS = os93</span>
        <span class="cov0" title="0">case "7.2.1":
                iPhoneOS = os92</span>
        <span class="cov0" title="0">case "7.2":
                iPhoneOS = os92</span>
        <span class="cov0" title="0">case "7.1.1":
                iPhoneOS = os91</span>
        <span class="cov0" title="0">case "7.1":
                iPhoneOS = os91</span>
        <span class="cov0" title="0">case "7.0.1":
                iPhoneOS = os90</span>
        <span class="cov0" title="0">case "7.0":
                iPhoneOS = os90</span>
        <span class="cov0" title="0">default:
                iPhoneOS = os93</span>
        }

        <span class="cov0" title="0">projectSettings["UP_XCODE_VERSION"] = conf.Settings.IOSXcodeVersion
        projectSettings["UP_SIMULATOR_IPHONE"] = conf.Settings.IOSTestDevice
        projectSettings["UP_SIMULATOR_IPHONEOS"] = iPhoneOS

        // This is sort of the wrong place, but we want scheme for later too
        projectSettings["UP_PROJECT_SCHEME"] = conf.Settings.IOSScheme</span>
}

// Is Simulator running
func isSimulatorRunning() bool <span class="cov0" title="0">{
        _, err := command.Run([]string{"pgrep", "-f", "Simulator.app"}, "")
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// Get Project Path
func getProjectPath() <span class="cov0" title="0">{
        conf := config.Get()

        useWorkspace := conf.Settings.IOSUseWorkspace
        podFileFullPath, _ := filepath.Abs("Podfile")
        podfileExists := utils.FileExists(podFileFullPath)

        if useWorkspace || podfileExists </span><span class="cov0" title="0">{
                projectSettings["UP_PROJECT_TYPE"] = "workspace"
                projectSettings["UP_PROJECT_EXTENSION"] = ".xcworkspace"
        }</span><span class="cov0" title="0"> else {
                projectSettings["UP_PROJECT_TYPE"] = "project"
                projectSettings["UP_PROJECT_EXTENSION"] = ".xcodeproj"
        }</span>
}

// Read values from xcodebuild settings
func xcodeBuildSettings() error <span class="cov0" title="0">{
        projectSettings = make(map[string]string)
        version, err := command.Run([]string{"xcodebuild", "-showBuildSettings"}, "")
        if err != nil </span><span class="cov0" title="0">{
                return errors.New(("We were unable to read xcodebuild settings\n" + err.Error()))
        }</span>

        <span class="cov0" title="0">settingsRows := strings.Split(version, "\n")
        for _, row := range settingsRows </span><span class="cov0" title="0">{
                settingsKeys := strings.Split(row, "=")
                if len(settingsKeys) == 2 </span><span class="cov0" title="0">{
                        key := strings.TrimSpace(settingsKeys[0])
                        value := strings.TrimSpace(settingsKeys[1])
                        projectSettings[key] = value
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// SetupXcode : Choose the correct version of Xcode for the project
// It is usually defined in config.toml
func SetupXcode() int <span class="cov0" title="0">{
        version, err := command.Run([]string{"xcodebuild", "-version"}, "")
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError("We were unable to get the Xcode version " + err.Error())
                return 1
        }</span>

        <span class="cov0" title="0">var currentXcodeVersion string
        versionRows := strings.Split(version, "\n")
        for _, row := range versionRows </span><span class="cov0" title="0">{
                if strings.Contains(row, "Xcode") == true </span><span class="cov0" title="0">{
                        currentXcodeVersion = strings.TrimSpace(strings.Trim(row, "Xcode"))
                }</span>
        }

        <span class="cov0" title="0">fmt.Println("We are currently using Xcode-" + currentXcodeVersion)

        conf := config.Get()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("We were unable to load the config file\n", err.Error())

                fmt.Println("You are currently on Xcode-" + currentXcodeVersion + " and the latest Xcode version is " + conf.Settings.IOSXcodeVersion + ". For now, we will continue using the version that you have right now")
                return 0
        }</span>

        <span class="cov0" title="0">requiredXcodeVersion := conf.Settings.IOSXcodeVersion

        if requiredXcodeVersion == currentXcodeVersion </span><span class="cov0" title="0">{
                fmt.Println("You are on the correct version of Xcode")
                return 0
        }</span>

        <span class="cov0" title="0">fmt.Println("Alright, so we will try and switch the Xcode version now to " + requiredXcodeVersion)

        if utils.FileExists("/Applications/Xcode-"+requiredXcodeVersion+".app/") == false </span><span class="cov0" title="0">{
                fmt.Println("It seems you don't have /Applications/Xcode-" + requiredXcodeVersion + ".app/\nWe expect XCode versions to be placed like this\n/Applications/Xcode-7.2.app\n/Applications/Xcode-7.3.app")
                return 1
        }</span>

        <span class="cov0" title="0">var RootPassword string
        if conf.IsCI() == true </span><span class="cov0" title="0">{
                // We are on CI, we need to enter password programatically
                RootPassword, err = conf.GetRootPassword()
                if err != nil </span><span class="cov0" title="0">{
                        utils.LogError(err.Error())
                        return 1
                }</span>
        }

        <span class="cov0" title="0">out, err := command.Run([]string{"sudo", "-S", "xcode-select", "-switch", "/Applications/Xcode-" + requiredXcodeVersion + ".app/"}, RootPassword+"\n")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("We couldn't switch Xcodes, you're going to be stuck with this one")
                return 1
        }</span>
        <span class="cov0" title="0">fmt.Println(out)
        fmt.Println("We are now on the " + c.Underline + "Xcode-" + requiredXcodeVersion + c.Default)

        return 0</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package actions

import (
        "upshift/basher"
        "upshift/utils"
)

// Pod : Handle everything related to install pods
type Pod struct{}

// IsInstalled : Check if cocoapods is installed
func (p *Pod) IsInstalled() bool <span class="cov8" title="1">{
        var c Cocoapods
        err := c.Install()
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError("Could not install underlying cocoapods\n" + err.Error())
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

// AreUsed : Check if this project uses pods
func (p *Pod) AreUsed() bool <span class="cov8" title="1">{
        return utils.FileExists("Podfile")
}</span>

// Install : Install pods which are being used in the system
func (p *Pod) Install() (int, error) <span class="cov8" title="1">{
        var b basher.Basher
        utils.LogMessage("$ pod install")
        return b.RunAndTail("PodInstall", []string{".upshift/logs/pod-install.log"}, ".upshift/logs/pod-install.log", []string{}, []string{})
}</span>

// RepoUpdate : Update the pod repo, not sure who will call it
func (p *Pod) RepoUpdate() (int, error) <span class="cov8" title="1">{
        var b basher.Basher
        utils.LogMessage("$ pod repo update --verbose")
        return b.RunAndTail("PodRepoUpdate", []string{".upshift/logs/pod-repo-update.log"}, ".upshift/logs/pod-repo-update.log", []string{}, []string{"error"})
}</span>

// #TODO : Find out how do we know that an update is available and update it
// When an upgrade is available, they say
// CocoaPods 1.0.1 is available.
// To update use: `sudo gem install cocoapods`
// Until we reach version 1.0 the features of CocoaPods can and will change.
// We strongly recommend that you use the latest version at all times.
// if strings.Contains(tailData, "sudo gem install cocoapods") == true {
// This means that an update is available, run cocoapods update
//        status := SetupPods(true)
// if status &gt; 0 {
// return errors.New("We couldn't update to the new version of cocoapods")
// }
// fmt.Println("Updated cocoapods to the latest version")
// }
</pre>
		
		<pre class="file" id="file8" style="display: none">package actions

import (
        "fmt"
        "io/ioutil"
        "net/http"
        "path/filepath"
        "strings"
        "upshift/basher"
        c "upshift/colours"
        "upshift/command"
        "upshift/config"
        "upshift/utils"
)

// ShowVersion : shows the version of upshift on the command line
func ShowVersion() int <span class="cov0" title="0">{
        conf := config.Get()
        fmt.Println(conf.Settings.AppVersion)
        return 0
}</span>

// GitSubmodules : Initialize submodules in a project
func GitSubmodules() int <span class="cov0" title="0">{
        submodulePath, _ := filepath.Abs(".gitmodules")
        submodulesExist := utils.FileExists(submodulePath)

        if submodulesExist == false </span><span class="cov0" title="0">{
                fmt.Println("It looks like this project doesn't use submodules")
                return 0
        }</span>

        // So git submodules exist
        <span class="cov0" title="0">fmt.Println("It looks like this project uses git submodules, let me try and set them up")

        utils.LogMessage("$ git submodule init")
        initLogFileFullPath, _ := filepath.Abs(".upshift/logs/git-submodule-init.log")
        var b basher.Basher
        status, err := b.Run("GitSubmoduleInit", []string{initLogFileFullPath})
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError("We couldn't initialise submodules\n" + err.Error())
                return status
        }</span>

        <span class="cov0" title="0">utils.LogMessage("$ git submodule update")
        updateLogFileFullPath, _ := filepath.Abs(".upshift/logs/git-submodule-update.log")
        status, err = b.Run("GitSubmoduleUpdate", []string{updateLogFileFullPath})
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError("We couldn't update submodules\n" + err.Error())
                return status
        }</span>

        // Read the last 500 bytes from the whole message, we just want to what happened at the end
        <span class="cov0" title="0">tailData, err := utils.FileTail(updateLogFileFullPath, 500)
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError("It seems we couldn't read the output. Here's what happened\n" + err.Error())
                return status
        }</span>

        <span class="cov0" title="0">if strings.Contains(tailData, "fatal:") == true || strings.Contains(tailData, "error:") == true </span><span class="cov0" title="0">{
                utils.LogError("Something went wrong with submodule update, you need to look at this.")
                return 1
        }</span>

        <span class="cov0" title="0">fmt.Println("We were able to successfully setup submodules, moving on")
        return 0</span>
}

// GitPull : Do a git pull on the project based on the defined remote and the branch the user is currently on
func GitPull() int <span class="cov0" title="0">{
        conf := config.Get()

        // If you are running on a CI, we don't need to worry about this, just skip and take up the next thing
        if conf.IsCI() == true </span><span class="cov0" title="0">{
                fmt.Println("It seems you're running this on a CI, so we are going to skip the git pull, it's the CI's job to give me the latest code")
                return 0
        }</span>

        // Find out which repo and branch are they on
        <span class="cov0" title="0">out, err := command.Run([]string{"git", "status"}, "")
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError("Either this is not a git repository, or you don't even have git installed.")
                return 1
        }</span>

        // Read the first row of git sttus which says 'on branch xyz'
        <span class="cov0" title="0">gitStatusOutputRows := strings.Split(out, "\n")
        var firstRow string
        if len(gitStatusOutputRows) &gt; 0 </span><span class="cov0" title="0">{
                firstRow = gitStatusOutputRows[0]
        }</span><span class="cov0" title="0"> else {
                utils.LogError("You are probably not in a git repository. Quit messing around.")
                return 1
        }</span>

        // Alright find the correct branch and show it to the user
        <span class="cov0" title="0">currentBranch := strings.TrimSpace(strings.Replace(firstRow, "On branch ", "", 1))
        fmt.Println("We suspect that you are on branch " + c.Blue + currentBranch + c.Default)

        // Check if the user has one or more remotes
        // If they have one, just use it
        // If they have more
        //                 Show them the remotes, and ask them to specify it in config.toml

        // Find out which repo and branch are they on
        out, err = command.Run([]string{"git", "remote"}, "")
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError("Either this is not a git repository, or you don't even have git installed.")
                return 1
        }</span>

        <span class="cov0" title="0">var currentRemote string
        gitRemoteOutputRows := strings.Split(strings.TrimSpace(out), "\n")
        switch len(gitRemoteOutputRows) </span>{
        <span class="cov0" title="0">case 0:
                utils.LogError("Um, you have no remotes, I really don't know what to do. I'm going to kill myself")
                return 1</span>
        <span class="cov0" title="0">case 1:
                currentRemote = strings.TrimSpace(gitRemoteOutputRows[0])
                fmt.Println("And we suspect that you are using the " + c.Blue + currentRemote + c.Default + " remote")</span>
        <span class="cov0" title="0">default:
                // This means that the user has multiple remotes, read the config to see if they have mentioned a remote there
                conf := config.Get()

                if conf.Settings.Remote != "" </span><span class="cov0" title="0">{
                        // Alright, so they have defined a remote, let's check if it exits in our list of remotes
                        for _, row := range gitRemoteOutputRows </span><span class="cov0" title="0">{
                                if strings.TrimSpace(conf.Settings.Remote) == strings.TrimSpace(row) </span><span class="cov0" title="0">{
                                        currentRemote = row
                                }</span>
                        }

                        // Didn't find their remote in git remotes, tell them so
                        <span class="cov0" title="0">if currentRemote == "" </span><span class="cov0" title="0">{
                                utils.LogError("Here's a strange problem. Your config says you want to use\nthe " + conf.Settings.Remote + " remote, but sadly we " + c.Underline + "couldn't find that remote" + c.Default + " for\nthis repo. All we found was " + strings.Join(gitRemoteOutputRows, ", "))
                                return 1
                        }</span>
                        <span class="cov0" title="0">fmt.Println("And your config tells me you want to read from the remote " + c.Blue + currentRemote + c.Default)</span>
                }<span class="cov0" title="0"> else {
                        // They haven't defined a remote in config, screw them
                        utils.LogError("You have more than one remote. In your config.toml you need to specify which remote to pull from\nThe following remotes are avilable " + strings.TrimSpace(out))
                        return 1
                }</span>
        }

        <span class="cov0" title="0">utils.LogMessage("$ git pull " + currentRemote + " " + currentBranch)
        // Now we have both, a remote and a branch, let's pull
        logFileFullPath, _ := filepath.Abs(".upshift/logs/git-pull.log")
        var b basher.Basher
        status, err := b.Run("GitPull", []string{currentRemote, currentBranch, logFileFullPath})
        // status, err := basher.Run("RunSingleCommand", []string{"$(git pull " + currentRemote + " " + currentBranch + " 2&gt;&amp;1 | tee \"" + logFileFullPath + "\")"})
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError("We couldn't pull the branch " + currentBranch + " from the remote " + currentRemote + " - \n" + err.Error())
                return status
        }</span>

        // Read the last 500 bytes from the whole message, we just want to what happened at the end
        <span class="cov0" title="0">tailData, err := utils.FileTail(logFileFullPath, 500)
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError("It seems we couldn't read the output. Here's what happened\n" + err.Error())
                return status
        }</span>

        <span class="cov0" title="0">if strings.Contains(tailData, "fatal:") == true || strings.Contains(tailData, "error:") == true </span><span class="cov0" title="0">{
                utils.LogError("Something went wrong with the pull, you need to look at this.")
                return 1
        }</span>

        <span class="cov0" title="0">fmt.Println("We were able to pull the latest code, awesome")
        return 0</span>
}

// ShowHelp : Show help, so that the user knows what to do
func ShowHelp() int <span class="cov0" title="0">{
        fmt.Println("\nUPSHIFT(1)               Upshift Commands Manual               UPSHIFT(1)")
        fmt.Println(c.Bold + "\nNAME" + c.Default)
        fmt.Println("\tupshift -- the creative mobile app builder")
        fmt.Println(c.Bold + "\nSYNOPSIS" + c.Default)
        fmt.Println("\tupshift " + c.Underline + "job" + c.Default + " " + c.Underline + "action" + c.Default)
        fmt.Println(c.Bold + "\nDESCRIPTION" + c.Default)
        fmt.Println("\tThis tool helps you run, build, test and deploy your iOS and Android\n\tapps while you dream about the next big thing")

        fmt.Println(c.Bold + "\nOPTIONS (job queues)" + c.Default)
        fmt.Println("\tIt is still not as awesome as we want it to be. But here are the things\n\tthat you can currently do")
        fmt.Println("\tupshift ios build\n\t\tto build your iOS project")
        fmt.Println("\tupshift ios run\n\t\tto run your iOS project in a simulator")
        fmt.Println("\tupshift ios deploy\n\t\tto create an .ipa and deploy it on TestFlight")
        fmt.Println("\tupshift android build\n\t\tto build your Android project")
        fmt.Println("\tupshift android run\n\t\tto run your Android project in a simulator")
        fmt.Println("\tupshift android deploy\n\t\tto create an .apk and upload it to Fabric")
        fmt.Println("\tupshift setup clone\n\t\tto clone a repo defined in config.toml")
        fmt.Println("\tupshift setup config\n\t\tto setup an empty config.toml in your current folder")
        fmt.Println("\tupshift setup export.plist\n\t\tto setup a sample .private/export.plist in your project")
        fmt.Println("\tupshift install\n\t\tto install this binary for the first time")
        fmt.Println("\tupshift -v\n\t\tto view the version number")

        fmt.Println(c.Bold + "\nOPTIONS (specific actions)" + c.Default)
        fmt.Println("\tWe combine actions like these to create the jobs above, you should ideally\n\tbe running jobs not actions")
        fmt.Println("\tupshift action setupSsh -- to setup your ssh keys")
        fmt.Println("\tupshift action setupScript -- to setup this very script")
        fmt.Println("\tupshift action setupGradleW -- to setup gradle on your machine")
        fmt.Println("\tupshift action setupPods -- to setup cocoapods on your machine")
        fmt.Println("\tupshift action setupXcode -- to choose the correct xcode version for the project")
        fmt.Println("\tupshift action setupXcpretty -- to setup xcpretty for build output which doesn't suck")
        fmt.Println("\tupshift action upgradeScript -- to upgrade this script")

        fmt.Println("\tupshift action gitPull -- to pull from code from a repo")
        // fmt.Println("\tupshift action gitClone -- to clone a repo")
        fmt.Println("\tupshift action gitSubmodules -- to setup git modules in the project")

        fmt.Println("\tupshift action iosSimulator -- to start the iOS simulator")
        fmt.Println("\tupshift action iosBuild -- to build an iOS app")
        fmt.Println("\tupshift action iosRun -- to run an iOS app in the simulator")
        fmt.Println("\tupshift action iosDeploy -- to archive and deploy an iOS app")

        fmt.Println("\tupshift action androidEmulator -- to start the android emulator")
        fmt.Println("\tupshift action androidBuild -- to build an android project")
        fmt.Println("\tupshift action androidRun -- to run an android project")
        fmt.Println("\tupshift action androidDeploy -- to deploy an android project")

        fmt.Println(c.Bold + "\nCOMPATIBILITY" + c.Default)
        fmt.Println("\tWe've only tested this on Mac OSX, Linux and Docker. If you're on\n\twindows, you should switch operating systems because nobody can help\n\tyou there.")
        fmt.Println("\nLeftshift Technologies           Made with ❤️  in India                " + c.Underline + "https://leftshift.io\n" + c.Default)

        return 0
}</span>

// SetupXctool : Install xctool via brew
func SetupXctool() int <span class="cov0" title="0">{
        return SetupBrew("xctool")
}</span>

// SetupBrew : Common function to setup tools via brew
func SetupBrew(tool string) int <span class="cov0" title="0">{
        // Check which version of the brew was installed
        version, err := command.Run([]string{tool, "--version"}, "")
        if err == nil </span><span class="cov0" title="0">{
                // Remove the name of the tool if it is part of the version string
                version = strings.Replace(version, tool, "", 1)
                // Now trim whatever is left
                version = strings.TrimSpace(version)
                fmt.Println(tool + " is pretty much setup on this system. You are on version " + version)
                return 0
        }</span>

        // Check if the command was not found
        <span class="cov0" title="0">var errorString string
        if err != nil </span><span class="cov0" title="0">{
                errorString = err.Error()
        }</span>

        <span class="cov0" title="0">if strings.Contains(errorString, "executable file not found") == true </span><span class="cov0" title="0">{
                // Alright, so the tool was not found, go ahead and install it
                fmt.Println("Latest " + tool + " was not found, installing it")

                // Brew cowardly refuses to use sudo, hell yeah
                var b basher.Basher
                var status int
                status, err = b.Run("SetupBrewTool", []string{tool})
                if err != nil </span><span class="cov0" title="0">{
                        utils.LogError("We couldn't install " + tool + "\n" + err.Error())
                        return status
                }</span>

                <span class="cov0" title="0">fmt.Println(tool + " has been setup on your machine. Have fun.")
                return 0</span>
        }

        <span class="cov0" title="0">fmt.Println("There was a problem installing " + tool + "\n" + err.Error())
        return 1</span>
}

// SetupXcpretty : If Xcpretty is not setup, we go ahead and do it
// It formats the output from xcode so that you can make sense of what is going wrong
func SetupXcpretty() int <span class="cov0" title="0">{
        // return SetupGem("xcpretty", "xcpretty", false)
        return 0
}</span>

// UpgradeScript : Call this function to download the latest version of the binary
// And update the user to the latest version.
// It does nothing if the user is on the latest version
func UpgradeScript() int <span class="cov0" title="0">{
        conf := config.Get()

        resp, err := http.Get("https://raw.githubusercontent.com/leftshifters/upshift/master/release")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("We couldn't connect to the internet :(", err.Error())
                return 1
        }</span>

        <span class="cov0" title="0">defer resp.Body.Close()
        body, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("We were unable to figure out what is the latest version on the server, next time maybe", err.Error())
                return 1
        }</span>

        <span class="cov0" title="0">latestVersion := string(body)
        latestVersion = strings.TrimSpace(latestVersion)

        if latestVersion == conf.Settings.AppVersion </span><span class="cov0" title="0">{
                fmt.Println("Your powers (and version) are already at the top. You're running v", conf.Settings.AppVersion)
                return 0
        }</span>

        <span class="cov0" title="0">fmt.Println("Get ready to feel the power at your fingertips")

        var b basher.Basher
        status, err := b.Run("UpgradeScript", []string{})
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError("Your fingertips will suck for some more time, we couldn't upgrade you because of this - \n" + err.Error())
                return status
        }</span>

        <span class="cov0" title="0">fmt.Println("You are now awesome. The new version of awesomeness is v", conf.Settings.AppVersion)
        return 0</span>
}

// SetupConfig : When a new project doesn't have config, they call this one to create one for them
func SetupConfig() int <span class="cov0" title="0">{

        configExits := utils.FileExists("./config.toml")
        if configExits == true </span><span class="cov0" title="0">{
                fmt.Println("It looks like a config.toml is already here, skipping this step")
                return 1
        }</span>
        // Config does not exist
        // Create a new config.toml in this directory

        <span class="cov0" title="0">sampleToml := `[Application]
Debug = false

[Runner]
RootPassword = "testPassword"

[Build]
GitRepoURL = "testRepo"
GitRepoRemote = "origin"
CleanBeforeBuild = false
UninstallOlderBuilds = false

[IOS]
ProjectName = "testProject"
UseWorkspace = false
Scheme = "testScheme"
TestDevice = "iPhone 6"
Xcode = "7.3.1"
DeveloperAccount = ""

[Android]
PackageName = "testPackage"
MainActivityName = "testActivity"`

        tomlBytes := []byte(sampleToml)

        err := ioutil.WriteFile("./config.toml", tomlBytes, 0644)
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError("We could not write the config file, the OS told us this &lt;" + err.Error() + "&gt;")
                return 1
        }</span>

        <span class="cov0" title="0">fmt.Println("We just added a config.toml to this folder!")
        return 0</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
