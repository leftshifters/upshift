
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/leftshifters/upshift/actions/actions.go (44.4%)</option>
				
				<option value="file1">github.com/leftshifters/upshift/actions/android.go (100.0%)</option>
				
				<option value="file2">github.com/leftshifters/upshift/actions/androidemulator.go (35.6%)</option>
				
				<option value="file3">github.com/leftshifters/upshift/actions/brew.go (87.5%)</option>
				
				<option value="file4">github.com/leftshifters/upshift/actions/cocoapods.go (90.0%)</option>
				
				<option value="file5">github.com/leftshifters/upshift/actions/fastlane.go (80.0%)</option>
				
				<option value="file6">github.com/leftshifters/upshift/actions/gems.go (67.4%)</option>
				
				<option value="file7">github.com/leftshifters/upshift/actions/git.go (74.1%)</option>
				
				<option value="file8">github.com/leftshifters/upshift/actions/gradle.go (67.4%)</option>
				
				<option value="file9">github.com/leftshifters/upshift/actions/iossimulator.go (33.3%)</option>
				
				<option value="file10">github.com/leftshifters/upshift/actions/pilot.go (77.8%)</option>
				
				<option value="file11">github.com/leftshifters/upshift/actions/pod.go (92.3%)</option>
				
				<option value="file12">github.com/leftshifters/upshift/actions/produce.go (87.5%)</option>
				
				<option value="file13">github.com/leftshifters/upshift/actions/sigh.go (85.7%)</option>
				
				<option value="file14">github.com/leftshifters/upshift/actions/upshift.go (93.8%)</option>
				
				<option value="file15">github.com/leftshifters/upshift/actions/xcodebuild.go (30.3%)</option>
				
				<option value="file16">github.com/leftshifters/upshift/actions/xcpretty.go (80.0%)</option>
				
				<option value="file17">github.com/leftshifters/upshift/actions/xctool.go (52.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package actions

import (
        "fmt"

        "github.com/leftshifters/upshift/config"
        "github.com/leftshifters/upshift/utils"
)

// GradleWrapper : Action to install the gradle wrapper
func GradleWrapper() int <span class="cov8" title="1">{
        var gradle Gradle

        // Check if gradle exists
        err := gradle.Version()
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError(err.Error())
                return 1
        }</span>

        // Add the wrapper
        <span class="cov8" title="1">status, err := gradle.AddWrapper()
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError(err.Error())
        }</span>
        <span class="cov8" title="1">return status</span>
}

// PodInstall : Install pods for this project, if the project uses it
func PodInstall() int <span class="cov8" title="1">{
        var pod Pod

        // Check if this project uses cocoapods
        if pod.AreUsed() == false </span><span class="cov0" title="0">{
                fmt.Println("It looks like this project doesn't use pods")
                return 0
        }</span>

        // Install pod
        <span class="cov8" title="1">status, err := pod.Install()
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError("Could not install pods\n" + err.Error())
                return status
        }</span>

        <span class="cov8" title="1">fmt.Println("We were able to successfully setup cocoapods, moving on")
        return 0</span>
}

// AndroidBuild : Build an android project
func AndroidBuild() int <span class="cov8" title="1">{
        var gradle Gradle
        var emulator AndroidEmulator
        conf := config.Get()

        // Clean builds if required
        if conf.Settings.CleanBeforeBuild </span><span class="cov8" title="1">{
                // Clean the build
                _, err := gradle.Clean(".upshift/logs/android-clean.log")
                if err != nil </span><span class="cov8" title="1">{
                        utils.LogError("We could not clean your project. It's really dirty\n" + err.Error())
                        return 1
                }</span>
        }

        // Launch a device or emulator
        <span class="cov0" title="0">err := emulator.Launch()
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError(err.Error())
                return 1
        }</span>

        // Uninstall apps if required
        <span class="cov0" title="0">if conf.Settings.UninstallOlderBuilds </span><span class="cov0" title="0">{
                _, err = gradle.Uninstall(".upshift/logs/android-unintall.log")
                if err != nil </span><span class="cov0" title="0">{
                        utils.LogError(err.Error())
                        return 1
                }</span>
        }

        // Run Lint
        <span class="cov0" title="0">_, err = gradle.Lint(".upshift/logs/android-lint.log")
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError(err.Error())
                return 1
        }</span>

        // Gradle Assemble
        <span class="cov0" title="0">_, err = gradle.Assemble(".upshift/logs/android-assemble.log")
        if err != nil </span><span class="cov0" title="0">{
                utils.LogError(err.Error())
                return 1
        }</span>

        <span class="cov0" title="0">return 0</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package actions

// Android : Construct for all activities related to the android binary
type Android struct {
}

// UpgradeAndroid : Upgrade the android sdk
func (a *Android) UpgradeAndroid(logPath string) error <span class="cov8" title="1">{
        // var b basher.Basher
        // _, err := b.Run("AndroidUpgradeSDK", []string{logPath})
        // if err != nil {
        //         return err
        // }
        return nil
}</span>

// SetupAndroid : Install the android sdk
func (a *Android) SetupAndroid(logPath string) error <span class="cov8" title="1">{
        // var b basher.Basher
        // _, err := b.Run("AndroidInstallSDK", []string{logPath})
        // if err != nil {
        //         return err
        // }
        return nil
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package actions

import (
        "errors"
        "fmt"
        "os"
        "path/filepath"

        "github.com/leftshifters/upshift/basher"
        "github.com/leftshifters/upshift/command"
        "github.com/leftshifters/upshift/utils"
)

// AndroidEmulator : Construct to handle all things related to the emulator
type AndroidEmulator struct{}

// Launch : launch the available emulator
func (a *AndroidEmulator) Launch() error <span class="cov8" title="1">{

        // 1. Check if any devices are connected, if yes, use one of those
        devices, err := a.ConnectedDevices()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // If a device is available, we can do everything there
        <span class="cov8" title="1">if len(devices) &gt; 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // 2. If nothing so far, see if any avds are listed and start the first one
        <span class="cov0" title="0">avds, err := a.AVDsAvailable()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(avds) == 0 </span><span class="cov0" title="0">{
                // 3. If still nothing, create an avd and launch it
                err = a.CreateAVD()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">var b basher.Basher
        _, err = b.Run("AndroidLaunchEmulator", []string{avds[0], ".upshift/logs/android-emulator.log"})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// AVDsAvailable : find which AVDs are available
func (a *AndroidEmulator) AVDsAvailable() ([]string, error) <span class="cov8" title="1">{
        out, err := command.Run([]string{"emulator", "-list-avds"}, "")
        if err != nil </span><span class="cov8" title="1">{
                return []string{}, err
        }</span>

        <span class="cov0" title="0">avds := utils.CreateList(out, []string{})
        return avds, nil</span>
}

// ConnectedDevices : find which devices are connected
func (a *AndroidEmulator) ConnectedDevices() ([]string, error) <span class="cov8" title="1">{
        out, err := command.Run([]string{"adb", "devices"}, "")
        if err != nil </span><span class="cov0" title="0">{
                return []string{}, err
        }</span>

        <span class="cov8" title="1">devices := utils.CreateList(out, []string{"List of devices attached", "daemon not running. starting it now on port", "daemon started successfully", "offline"})
        return devices, nil</span>
}

// LaunchApp : start the app in the emulator
func (a *AndroidEmulator) LaunchApp(packageName string, activityName string) error <span class="cov8" title="1">{
        if packageName == "" </span><span class="cov0" title="0">{
                return errors.New("We need the package name to launch the app")
        }</span>

        <span class="cov8" title="1">if activityName == "" </span><span class="cov0" title="0">{
                return errors.New("We need the main activity name to launch the app")
        }</span>

        <span class="cov8" title="1">out, err := command.Run([]string{"adb", "shell", "am", "start", "-n", packageName + "/" + packageName + "." + activityName}, "")
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov0" title="0">fmt.Println(out)

        return nil</span>
}

// CreateAVD : Create an AVD
func (a *AndroidEmulator) CreateAVD() error <span class="cov8" title="1">{
        // to view a list of available avds you can create, run 'android list targets'
        // look for ones with ABIs
        // android create avd --name "Android_22_AVD" --target android-22

        // check if the ABI is available
        if utils.FileExists(filepath.Join(os.Getenv("ANDROID_HOME"), "system-images", "android-23", "google_apis", "x86", "system.img")) == false </span><span class="cov8" title="1">{
                var b basher.Basher
                status, _ := b.Run("AndroidInstallABI", []string{})
                if status &gt; 0 </span><span class="cov8" title="1">{
                        return errors.New("We could not install the ABI")
                }</span>
        }

        <span class="cov0" title="0">var b basher.Basher
        _, err := b.Run("AndroidCreateAVD", []string{"Android23", "android-23", "google_apis/x86_64", "Nexus 6"})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteAVD : delete an AVD
func (a *AndroidEmulator) DeleteAVD(avd string) error <span class="cov0" title="0">{
        // Check if AVD is available
        avds, err := a.AVDsAvailable()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var found bool
        for _, item := range avds </span><span class="cov0" title="0">{
                if avd == item </span><span class="cov0" title="0">{
                        found = true
                }</span>
        }

        <span class="cov0" title="0">if found == false </span><span class="cov0" title="0">{
                return errors.New("This avd does not exist")
        }</span>

        <span class="cov0" title="0">_, err = command.Run([]string{"android", "delete", "avd", "-n", avd}, "")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package actions

import (
        "github.com/leftshifters/upshift/basher"
        "github.com/leftshifters/upshift/command"
)

// Brew : Construct to take care of all brew tasks
type Brew struct {
}

// Install a cask using brew
func (b *Brew) Install(cask string) (int, error) <span class="cov8" title="1">{
        if b.isInstalled(cask) == true </span><span class="cov8" title="1">{
                return 0, nil
        }</span>

        <span class="cov8" title="1">var basher basher.Basher
        return basher.Run("BrewInstall", []string{cask})</span>
}

// Upgrade a cask using brew
func (b *Brew) Upgrade(cask string) (int, error) <span class="cov8" title="1">{
        if b.isInstalled(cask) == false </span><span class="cov8" title="1">{
                return b.Install(cask)
        }</span>

        <span class="cov0" title="0">var basher basher.Basher
        return basher.Run("BrewUpgrade", []string{cask})</span>
}

// Uninstall a cask using brew
func (b *Brew) Uninstall(cask string) (int, error) <span class="cov8" title="1">{
        if b.isInstalled(cask) == false </span><span class="cov8" title="1">{
                return 0, nil
        }</span>

        <span class="cov8" title="1">var basher basher.Basher
        return basher.Run("BrewUninstall", []string{cask})</span>
}

func (b *Brew) isInstalled(cask string) bool <span class="cov8" title="1">{
        // Check if the cask is installed
        _, err := command.Run([]string{cask, "--version"}, "")
        if err == nil </span><span class="cov8" title="1">{
                // Remove the name of the tool if it is part of the version string
                // version = strings.Replace(version, cask, "", 1)
                // Now trim whatever is left
                // version = strings.TrimSpace(version)
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package actions

import "errors"

// Cocoapods : Construct to handle all things related to fastlane
type Cocoapods struct{}

// Install : Install cocoapods on the machine
func (c *Cocoapods) Install() error <span class="cov8" title="1">{
        var g Gems
        err := g.Install("cocoapods", "pod")
        if err != nil </span><span class="cov8" title="1">{
                return errors.New("Could not install cocoapods\n" + err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Uninstall : Uninstall cocoapods on the machine
func (c *Cocoapods) Uninstall() error <span class="cov8" title="1">{
        var g Gems
        err := g.Uninstall("cocoapods", "pod")
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("Could not uninstall cocoapods\n" + err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package actions

import "errors"

// Fastlane : Construct to handle all things related to fastlane
type Fastlane struct{}

// Install : Install fastlane on the machine
func (f *Fastlane) Install() error <span class="cov8" title="1">{
        var g Gems
        err := g.InstallSimple("fastlane")
        if err != nil </span><span class="cov8" title="1">{
                return errors.New("Could not install fastlane\n" + err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Uninstall : Uninstall fastlane on the machine
func (f *Fastlane) Uninstall() error <span class="cov8" title="1">{
        var g Gems
        err := g.UninstallSimple("fastlane")
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("Could not uninstall fastlane\n" + err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package actions

import (
        "errors"
        "fmt"
        "strconv"
        "strings"

        "github.com/leftshifters/upshift/basher"
        "github.com/leftshifters/upshift/command"
        "github.com/leftshifters/upshift/config"
)

// Gems structure to install, upgrade, uninstall gems
type Gems struct{}

// InstallSimple a gem with gem name only
func (g *Gems) InstallSimple(gem string) error <span class="cov8" title="1">{
        return g.Install(gem, "")
}</span>

// Install a gem with gem name and scriptName
func (g *Gems) Install(gem string, scriptName string) error <span class="cov8" title="1">{
        // Get the global config
        conf := config.Get()

        // If scriptName is empty, use the gem name
        if scriptName == "" </span><span class="cov8" title="1">{
                scriptName = gem
        }</span>

        // Check if gem is installed
        <span class="cov8" title="1">installed, _ := g.version(scriptName)
        if installed == true </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Okay, so the gem was not installed, big deal
        // Let's install the effing thing
        <span class="cov8" title="1">var b basher.Basher
        RootPassword, err := conf.GetRootPassword()
        if conf.IsCI() == true &amp;&amp; err != nil </span><span class="cov8" title="1">{
                return errors.New("Unable to find the RootPassword\n" + err.Error())
        }</span>

        <span class="cov8" title="1">status, err := b.Run("SetupGem", []string{gem, strconv.FormatBool(conf.IsCI()), RootPassword})
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("Could not install " + gem + " [Error Code &lt;" + strconv.Itoa(status) + "&gt;]\n" + err.Error())
        }</span>

        // Verify if gem was installed
        <span class="cov8" title="1">installed, _ = g.version(scriptName)
        if installed == true </span><span class="cov8" title="1">{
                // It was successfull installed
                return nil
        }</span>
        <span class="cov8" title="1">return errors.New("The script ran but the gem " + gem + " was not installed on the machine")</span>
}

// UninstallSimple a gem with gem name only
func (g *Gems) UninstallSimple(gem string) error <span class="cov8" title="1">{
        return g.Uninstall(gem, "")
}</span>

// Uninstall : remove a gem from the system
func (g *Gems) Uninstall(gem string, scriptName string) error <span class="cov8" title="1">{
        // If scriptName is not set, use the gem name
        if scriptName == "" </span><span class="cov8" title="1">{
                scriptName = gem
        }</span>

        // Check if the gem is installed
        <span class="cov8" title="1">installed, _ := g.version(scriptName)
        if installed == false </span><span class="cov8" title="1">{
                // If it is not installed then return
                return nil
        }</span>

        // Get the global config
        <span class="cov0" title="0">conf := config.Get()

        // So we know that it is installed, go ahead and uninstall it
        // Let's uninstall the effing thing
        var b basher.Basher
        RootPassword, err := conf.GetRootPassword()
        if conf.IsCI() == true &amp;&amp; err != nil </span><span class="cov0" title="0">{
                return errors.New("Unable to find the RootPassword\n" + err.Error())
        }</span>

        <span class="cov0" title="0">status, err := b.Run("UninstallGem", []string{gem, strconv.FormatBool(conf.IsCI()), RootPassword})
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("Could not uninstall " + gem + " [Error Code &lt;" + strconv.Itoa(status) + "&gt;]\n" + err.Error())
        }</span>

        // Verify if gem was uninstalled
        <span class="cov0" title="0">installed, _ = g.version(scriptName)
        if installed == false </span><span class="cov0" title="0">{
                // It was successfull uninstalled
                return nil
        }</span>
        <span class="cov0" title="0">return errors.New("The script ran but the gem " + gem + " was not installed on the machine")</span>
}

func (g *Gems) version(gem string) (bool, string) <span class="cov8" title="1">{
        // Check which version of the gem was installed
        ver, err := command.Run([]string{gem, "--version"}, "")
        if err == nil </span><span class="cov8" title="1">{
                // This means that the gem is installed
                // Get rid of the name and get the version number
                ver = strings.Replace(ver, gem, "", 1)
                // Next trim what's left
                ver = strings.TrimSpace(ver)
                fmt.Println(gem + " v" + ver + " is installed on your machine")
                return true, ver
        }</span>

        // Not installed
        <span class="cov8" title="1">return false, ""</span>
}

// #TODO : Find out how do we know that an update is available and update it
// When an upgrade is available, they say
// CocoaPods 1.0.1 is available.
// To update use: `sudo gem install cocoapods`
// Until we reach version 1.0 the features of CocoaPods can and will change.
// We strongly recommend that you use the latest version at all times.
// if strings.Contains(tailData, "sudo gem install cocoapods") == true {
// This means that an update is available, run cocoapods update
//        status := SetupPods(true)
// if status &gt; 0 {
// return errors.New("We couldn't update to the new version of cocoapods")
// }
// fmt.Println("Updated cocoapods to the latest version")
// }
</pre>
		
		<pre class="file" id="file7" style="display: none">package actions

import (
        "errors"
        "strings"

        "github.com/leftshifters/upshift/basher"
        "github.com/leftshifters/upshift/command"
        "github.com/leftshifters/upshift/config"
        "github.com/leftshifters/upshift/utils"
)

// Git : Strucut to handle everything related to git
type Git struct {
}

// AreSubmodulesUsed : Find out if the system uses git submodules
func (g *Git) AreSubmodulesUsed() bool <span class="cov8" title="1">{
        return utils.FileExists(".gitmodules")
}</span>

// SubmoduleInit : Initialize submodules
func (g *Git) SubmoduleInit() (int, error) <span class="cov8" title="1">{
        var b basher.Basher
        utils.LogMessage("$ git submodule init")
        return b.RunAndTail("GitSubmoduleInit", []string{".upshift/logs/git-submodule-init.log"}, ".upshift/logs/git-submodule-init.log", []string{}, []string{"error"})
}</span>

// SubmoduleUpdate : Update submodules
func (g *Git) SubmoduleUpdate() (int, error) <span class="cov8" title="1">{
        var b basher.Basher
        utils.LogMessage("$ git submodule update")
        return b.RunAndTail("GitSubmoduleUpdate", []string{".upshift/logs/git-submodule-update.log"}, ".upshift/logs/git-submodule-update.log", []string{}, []string{"error:", "fatal:"})
}</span>

// IsRepo : Find out if you are in a git repo, if yes, throw the output of git status
func (g *Git) IsRepo() bool <span class="cov8" title="1">{
        _, err := command.Run([]string{"git", "status"}, "")
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

// Branch : find the branch that you are on in the git repo
func (g *Git) Branch() (string, error) <span class="cov8" title="1">{
        // Run git status
        out, err := command.Run([]string{"git", "status"}, "")
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        // Read the first row of git status which says 'on branch xyz'
        <span class="cov8" title="1">gitStatusOutputRows := strings.Split(out, "\n")
        var firstRow string
        if len(gitStatusOutputRows) &gt; 0 </span><span class="cov8" title="1">{
                firstRow = gitStatusOutputRows[0]
        }</span><span class="cov0" title="0"> else {
                return "", errors.New("You are probably not in a git repository. Quit messing around.")
        }</span>

        // Alright find the correct branch and show it to the user
        <span class="cov8" title="1">currentBranch := strings.TrimSpace(strings.Replace(firstRow, "On branch ", "", 1))
        return currentBranch, nil</span>
}

// Remote : find the remote they are working with
func (g *Git) Remote() (string, error) <span class="cov8" title="1">{
        // Check how many remotes does the user have
        out, err := command.Run([]string{"git", "remote"}, "")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">var currentRemote string
        gitRemoteOutputRows := strings.Split(strings.TrimSpace(out), "\n")
        switch len(gitRemoteOutputRows) </span>{

        <span class="cov0" title="0">case 0:
                return "", errors.New("You have no remotes!")</span>

        <span class="cov8" title="1">case 1:
                // If there's only one remote, use it
                currentRemote = strings.TrimSpace(gitRemoteOutputRows[0])
                return currentRemote, nil</span>

        <span class="cov8" title="1">default:
                // This means that the user has multiple remotes, read the config to see if they have mentioned a remote there
                conf := config.Get()

                if conf.Settings.Remote == "" </span><span class="cov8" title="1">{
                        // They didn't define a remote, throw a tantrum
                        return "", errors.New("You have multiple repos in this project. To use one, please add Remote=remoteName to your config.toml. Here are the ones that we see " + strings.TrimSpace(out))
                }</span>

                // Alright, so they have defined a remote, let's check if it exits in our list of remotes
                <span class="cov0" title="0">for _, row := range gitRemoteOutputRows </span><span class="cov0" title="0">{
                        if strings.TrimSpace(conf.Settings.Remote) == strings.TrimSpace(row) </span><span class="cov0" title="0">{
                                currentRemote = row
                        }</span>
                }

                // Didn't find their remote in git remotes, tell them so
                <span class="cov0" title="0">if currentRemote == "" </span><span class="cov0" title="0">{
                        return "", errors.New("We can't find " + conf.Settings.Remote + " in this project")
                }</span>

                <span class="cov0" title="0">return currentRemote, nil</span>
        }
}

// Pull : pull a git repo
func (g *Git) Pull(remote string, branch string) (int, error) <span class="cov8" title="1">{
        if remote == "" </span><span class="cov0" title="0">{
                return 1, errors.New("Please select a remote that you want to pull from")
        }</span>

        <span class="cov8" title="1">if branch == "" </span><span class="cov8" title="1">{
                return 1, errors.New("Please select a branch that you want to pull from")
        }</span>

        <span class="cov0" title="0">var b basher.Basher
        utils.LogMessage("$ git pull " + remote + " " + branch)
        return b.RunAndTail("GitPull", []string{remote, branch, ".upshift/logs/git-pull.log"}, ".upshift/logs/git-pull.log", []string{}, []string{"fatal:", "error:"})</span>
}

// AddRemote : add a new remote
func (g *Git) AddRemote(remote string, url string) error <span class="cov8" title="1">{
        if g.IsRepo() == false </span><span class="cov0" title="0">{
                return errors.New("This is not a git repo")
        }</span>

        <span class="cov8" title="1">_, err := command.Run([]string{"git", "remote", "add", remote, url}, "")
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// RemoveRemote : remove a remote
func (g *Git) RemoveRemote(remote string) error <span class="cov8" title="1">{
        if g.IsRepo() == false </span><span class="cov0" title="0">{
                return errors.New("This is not a git repo")
        }</span>

        <span class="cov8" title="1">_, err := command.Run([]string{"git", "remote", "rm", remote}, "")
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package actions

import (
        "errors"
        "strings"

        "github.com/leftshifters/upshift/basher"
        "github.com/leftshifters/upshift/command"
        "github.com/leftshifters/upshift/utils"
)

// Gradle : Keep track of everything related to gradle in upshift
type Gradle struct {
        version          string
        wrapperInstalled bool
        basher           basher.Basher
}

// Install : install gradle on a machine
func (g *Gradle) Install() error <span class="cov8" title="1">{
        var b basher.Basher
        _, err := b.Run("GradleInstall", []string{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Version : Find the version number of gradle installed
func (g *Gradle) Version() error <span class="cov8" title="1">{
        // Run gradle -v to figure out if it is install
        utils.LogMessage("$ gradle -v")
        out, err := command.Run([]string{"gradle", "-v"}, "")
        if err != nil </span><span class="cov8" title="1">{
                err = g.Install()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">list := utils.CreateList(out, []string{"Build time", "Build number:", "Revision:", "Groovy:", "Ant:", "JVM:", "OS:", "--------------"})
        g.version = strings.TrimSpace(strings.Replace(strings.Join(list[:], ""), "Gradle", "", 1))
        return nil</span>
}

// AddWrapper : Check and confirm if gradlew exists in the project
func (g *Gradle) AddWrapper() (int, error) <span class="cov8" title="1">{
        // Check if gradle is installed
        if g.version == "" </span><span class="cov8" title="1">{
                err := g.Version()
                if err != nil </span><span class="cov0" title="0">{
                        return 1, err
                }</span>
        }

        // Check if gradlew file exists
        <span class="cov8" title="1">if utils.FileExists("./gradlew") == true </span><span class="cov8" title="1">{
                g.wrapperInstalled = true
                return 0, nil
        }</span>

        // So, gradle is installed, just need to install wrapper [SetupGradleW]
        // I won't touch anything to do with gradle and pipes with a ten foot pole, so this goes to basher
        <span class="cov0" title="0">utils.LogMessage("$ gradle wrapper")
        status, err := g.basher.Run("GradleWrapper", []string{})
        if err != nil </span><span class="cov0" title="0">{
                g.wrapperInstalled = false
                return status, errors.New("We couldn't initialise gradle wrapper\n" + err.Error())
        }</span>

        <span class="cov0" title="0">g.wrapperInstalled = true
        return status, nil</span>
}

// Task : Execute a gradle task
func (g *Gradle) Task(task string, params []string, logPath string, success string) (int, error) <span class="cov8" title="1">{
        // Check if task exists
        if task == "" </span><span class="cov0" title="0">{
                return 1, errors.New("Gradle needs a task to run")
        }</span>

        // Check if gradle is installed
        <span class="cov8" title="1">if g.version == "" </span><span class="cov8" title="1">{
                err := g.Version()
                if err != nil </span><span class="cov0" title="0">{
                        return 1, err
                }</span>
        }

        // Check if gradlew file exists
        <span class="cov8" title="1">if utils.FileExists("./gradlew") == false </span><span class="cov0" title="0">{
                status, err := g.AddWrapper()
                if err != nil </span><span class="cov0" title="0">{
                        return status, err
                }</span>
        }

        <span class="cov8" title="1">utils.LogMessage("$ ./gradlew " + task + " " + strings.Join(params[:], " "))
        status, err := g.basher.RunAndTail("GradlewTask", []string{task, logPath}, logPath, []string{success}, []string{})
        return status, err</span>
}

// Clean : Execute gradle clean on the Android project
func (g *Gradle) Clean(logPath string) (int, error) <span class="cov8" title="1">{
        return g.Task("clean", []string{}, logPath, "BUILD SUCCESSFUL")
}</span>

// Lint : Execute gradle lint on the Android project
func (g *Gradle) Lint(logPath string) (int, error) <span class="cov8" title="1">{
        return g.Task("lint", []string{}, logPath, "BUILD SUCCESSFUL")
}</span>

// Uninstall : Remove installed versions of the app from connected devices
func (g *Gradle) Uninstall(logPath string) (int, error) <span class="cov8" title="1">{
        return g.Task("uninstallAll", []string{}, logPath, "BUILD SUCCESSFUL")
}</span>

// InstallDebug : Install the debug app on to connected devices
func (g *Gradle) InstallDebug(logPath string) (int, error) <span class="cov8" title="1">{
        return g.Task("installDebug", []string{"--stacktrace"}, logPath, "BUILD SUCCESSFUL")
}</span>

// Assemble : Build an android project
func (g *Gradle) Assemble(logPath string) (int, error) <span class="cov8" title="1">{
        return g.Task("assemble", []string{"--stacktrace"}, logPath, "BUILD SUCCESSFUL")
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package actions

import (
        "fmt"
        "regexp"
        "strings"

        "github.com/leftshifters/upshift/basher"
        "github.com/leftshifters/upshift/colours"
        "github.com/leftshifters/upshift/command"
        "github.com/leftshifters/upshift/utils"
)

// IOSSimulator : Construct to handle everything on the ios simulator
type IOSSimulator struct {
}

// IsSimulatorRunning : find out if the simulator is running
func (i *IOSSimulator) IsSimulatorRunning() bool <span class="cov8" title="1">{
        _, err := command.Run([]string{"pgrep", "-f", "Simulator.app"}, "")
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

// StartSimulator : start up the iOS simulator
func (i *IOSSimulator) StartSimulator(device string) <span class="cov8" title="1">{
        // If simulator is already running, just ignore
        if i.IsSimulatorRunning() </span><span class="cov8" title="1">{
                return
        }</span>

        // basher returns an error if status &gt; 0 or if there is an error
        // Whenever we start the simulator, for some reason, the exit code is always 255, though there is no error
        // Hence skipping the error check here
        <span class="cov0" title="0">var b basher.Basher
        b.Run("StartSimulator", []string{device})</span>
}

// StopSimulator : stop the simulator
func (i *IOSSimulator) StopSimulator() <span class="cov8" title="1">{
        // If simulator is not running, just go back
        if i.IsSimulatorRunning() == false </span><span class="cov0" title="0">{
                return
        }</span>

        // #TODO : If simulator is running, kill it
        <span class="cov8" title="1">fmt.Println("We don't know how to kill the simular yet")</span>
}

// FindDevice : find if the suggested device is available on this machine
func (i *IOSSimulator) FindDevice(device string) bool <span class="cov8" title="1">{
        instrumentsDump, err := command.Run([]string{"instruments", "-s", "devices"}, "")
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov0" title="0">instrumentRows := strings.Split(instrumentsDump, "\n")
        uuidRegexp, _ := regexp.Compile("\\[(.*?)\\]")
        var instruments []string

        for _, instrument := range instrumentRows </span><span class="cov0" title="0">{
                uuid := uuidRegexp.FindString(instrument)

                isSimulator := strings.Contains(instrument, "(Simulator)")
                instrument = strings.Replace(instrument, "(Simulator)", "", 1)

                simulatorString := "DEVICE   "
                if isSimulator == true </span><span class="cov0" title="0">{
                        simulatorString = "SIMULATOR"
                }</span>

                <span class="cov0" title="0">if uuid != "" </span><span class="cov0" title="0">{
                        instrument = strings.TrimSpace(strings.Replace(instrument, uuid, "", 1))
                        instruments = append(instruments, colours.Gray+simulatorString+colours.Default+" "+colours.Bold+colours.Green+instrument+colours.Default+" "+uuid)
                }</span>

                <span class="cov0" title="0">if instrument == device </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        // If device is not available, show all devices that are available
        <span class="cov0" title="0">utils.LogError("Your device " + colours.Red + device + colours.Default + " was not found\nThe following devices are available")
        for _, item := range instruments </span><span class="cov0" title="0">{
                fmt.Println(item)
        }</span>
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package actions

import (
        "errors"
        "fmt"

        "github.com/leftshifters/upshift/basher"
)

// Pilot : Handle everything related to pilot
type Pilot struct{}

// UploadToITunes : upload the binary to itunes
func (p *Pilot) UploadToITunes(developerAccount string, scheme string, name string) error <span class="cov8" title="1">{
        var b basher.Basher

        // Add SwitSources if required - AddSwiftSources
        _, err := b.Run("AddSwiftSources", []string{name, scheme})
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("We could not add SwiftSources to the IPA\n" + err.Error())
        }</span>

        <span class="cov8" title="1">_, err = b.Run("UploadIPAoniTunes", []string{developerAccount, ".upshift/" + scheme + ".ipa"})
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("We could not upload the IPA on iTunes\n" + err.Error())
        }</span>

        <span class="cov8" title="1">fmt.Println("We have successfully uploaded this IPA on iTunes, it's all yours now")
        return nil</span>

}
</pre>
		
		<pre class="file" id="file11" style="display: none">package actions

import (
        "github.com/leftshifters/upshift/basher"
        "github.com/leftshifters/upshift/utils"
)

// Pod : Handle everything related to install pods
type Pod struct{}

// IsInstalled : Check if cocoapods is installed
func (p *Pod) IsInstalled() bool <span class="cov8" title="1">{
        var c Cocoapods
        err := c.Install()
        if err != nil </span><span class="cov8" title="1">{
                utils.LogError("Could not install underlying cocoapods\n" + err.Error())
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// AreUsed : Check if this project uses pods
func (p *Pod) AreUsed() bool <span class="cov8" title="1">{
        return utils.FileExists("Podfile")
}</span>

// Install : Install pods which are being used in the system
func (p *Pod) Install() (int, error) <span class="cov8" title="1">{
        var b basher.Basher
        utils.LogMessage("$ pod install")
        return b.RunAndTail("PodInstall", []string{".upshift/logs/pod-install.log"}, ".upshift/logs/pod-install.log", []string{}, []string{})
}</span>

// RepoUpdate : Update the pod repo, not sure who will call it
func (p *Pod) RepoUpdate() (int, error) <span class="cov8" title="1">{
        var b basher.Basher
        utils.LogMessage("$ pod repo update --verbose")
        return b.RunAndTail("PodRepoUpdate", []string{".upshift/logs/pod-repo-update.log"}, ".upshift/logs/pod-repo-update.log", []string{}, []string{"error"})
}</span>

// #TODO : Find out how do we know that an update is available and update it
// When an upgrade is available, they say
// CocoaPods 1.0.1 is available.
// To update use: `sudo gem install cocoapods`
// Until we reach version 1.0 the features of CocoaPods can and will change.
// We strongly recommend that you use the latest version at all times.
// if strings.Contains(tailData, "sudo gem install cocoapods") == true {
// This means that an update is available, run cocoapods update
//        status := SetupPods(true)
// if status &gt; 0 {
// return errors.New("We couldn't update to the new version of cocoapods")
// }
// fmt.Println("Updated cocoapods to the latest version")
// }
</pre>
		
		<pre class="file" id="file12" style="display: none">package actions

import (
        "errors"
        "fmt"

        "github.com/leftshifters/upshift/basher"
        "github.com/leftshifters/upshift/utils"
)

// Produce : Construct to handle all things related to produce
type Produce struct {
}

// CreateAppOnITunes : create an app on iTunes if it does not exist
func (p *Produce) CreateAppOnITunes(developerAccount string, bundleIdentifier string, name string) error <span class="cov8" title="1">{
        var b basher.Basher
        utils.LogMessage("Create an app on iTunesConnect if it doesn't exist")

        name = name + " Beta by Upshift"
        _, err := b.Run("CreateAppOnItunes", []string{developerAccount, bundleIdentifier, name})
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("We could not create the app on iTunes\n" + err.Error())
        }</span>

        <span class="cov8" title="1">fmt.Println("We have successfully added this app on iTunes, woohoo")
        return nil</span>

}
</pre>
		
		<pre class="file" id="file13" style="display: none">package actions

import (
        "errors"
        "fmt"

        "github.com/leftshifters/upshift/basher"
        "github.com/leftshifters/upshift/utils"
)

// Sigh : Handle everything related to sigh
type Sigh struct{}

// FindProvisioning : find and install a provisioning profile
func (s *Sigh) FindProvisioning(developerAccount string, bundleIdentifier string) error <span class="cov8" title="1">{
        var b basher.Basher
        utils.LogMessage("We will now try to find the provisioning profile")

        _, err := b.Run("FindProvisioningProfile", []string{developerAccount, bundleIdentifier})
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("We could not find your provisioning profile")
        }</span>

        <span class="cov8" title="1">fmt.Println("We have successfully added your profiles to this machine, woohoo")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package actions

import (
        "fmt"
        "io/ioutil"
        "net/http"
        "strings"

        "github.com/leftshifters/upshift/basher"
        "github.com/leftshifters/upshift/colours"
        "github.com/leftshifters/upshift/config"
)

// Upshift : Construct to handle all upshift related things
type Upshift struct {
}

// Upgrade : upgrade the upshift binary to the latest one
func (u *Upshift) Upgrade(beta string) error <span class="cov8" title="1">{
        conf := config.Get()

        // Get Latest version
        version, err := u.LatestVersion()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if version == conf.Settings.AppVersion </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">var b basher.Basher
        _, err = b.Run("UpgradeScript", []string{beta})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">fmt.Println("The new version of awesomeness is v", version)
        return nil</span>
}

// LatestVersion : get the latest version of upshift from the server
func (u *Upshift) LatestVersion() (string, error) <span class="cov8" title="1">{
        versionURL := "https://raw.githubusercontent.com/leftshifters/upshift/master/release"

        // Get the latest version from the server
        resp, err := http.Get(versionURL)
        defer resp.Body.Close()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Read the response received
        <span class="cov8" title="1">body, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Trim and send the version back
        <span class="cov8" title="1">return strings.TrimSpace(string(body)), nil</span>
}

// ShowVersion : shows the version of upshift on the command line
func (u *Upshift) ShowVersion() <span class="cov8" title="1">{
        conf := config.Get()
        fmt.Println(conf.Settings.AppVersion)
}</span>

// ShowHelp : Show help, so that the user knows what to do
func (u *Upshift) ShowHelp() <span class="cov8" title="1">{
        fmt.Println("\nUPSHIFT(1)               Upshift Commands Manual               UPSHIFT(1)")
        fmt.Println(colours.Bold + "\nNAME" + colours.Default)
        fmt.Println("\tupshift -- the creative mobile app builder")
        fmt.Println(colours.Bold + "\nSYNOPSIS" + colours.Default)
        fmt.Println("\tupshift " + colours.Underline + "job" + colours.Default + " " + colours.Underline + "action" + colours.Default)
        fmt.Println(colours.Bold + "\nDESCRIPTION" + colours.Default)
        fmt.Println("\tThis tool helps you run, build, test and deploy your iOS and Android\n\tapps while you dream about the next big thing")

        fmt.Println(colours.Bold + "\nOPTIONS (job queues)" + colours.Default)
        fmt.Println("\tIt is still not as awesome as we want it to be. But here are the things\n\tthat you can currently do")
        fmt.Println("\tupshift ios build\n\t\tto build your iOS project")
        fmt.Println("\tupshift ios run\n\t\tto run your iOS project in a simulator")
        fmt.Println("\tupshift ios deploy\n\t\tto create an .ipa and deploy it on TestFlight")
        fmt.Println("\tupshift android build\n\t\tto build your Android project")
        fmt.Println("\tupshift android run\n\t\tto run your Android project in a simulator")
        fmt.Println("\tupshift android deploy\n\t\tto create an .apk and upload it to Fabric")
        fmt.Println("\tupshift setup clone\n\t\tto clone a repo defined in config.toml")
        fmt.Println("\tupshift setup config\n\t\tto setup an empty config.toml in your current folder")
        fmt.Println("\tupshift setup export.plist\n\t\tto setup a sample .private/export.plist in your project")
        fmt.Println("\tupshift install\n\t\tto install this binary for the first time")
        fmt.Println("\tupshift -v\n\t\tto view the version number")

        fmt.Println(colours.Bold + "\nOPTIONS (specific actions)" + colours.Default)
        fmt.Println("\tWe combine actions like these to create the jobs above, you should ideally\n\tbe running jobs not actions")
        fmt.Println("\tupshift action setupSsh -- to setup your ssh keys")
        fmt.Println("\tupshift action setupScript -- to setup this very script")
        fmt.Println("\tupshift action setupGradleW -- to setup gradle on your machine")
        fmt.Println("\tupshift action setupPods -- to setup cocoapods on your machine")
        fmt.Println("\tupshift action setupXcode -- to choose the correct xcode version for the project")
        fmt.Println("\tupshift action setupXcpretty -- to setup xcpretty for build output which doesn't suck")
        fmt.Println("\tupshift action upgradeScript -- to upgrade this script")

        fmt.Println("\tupshift action gitPull -- to pull from code from a repo")
        // fmt.Println("\tupshift action gitClone -- to clone a repo")
        fmt.Println("\tupshift action gitSubmodules -- to setup git modules in the project")

        fmt.Println("\tupshift action iosSimulator -- to start the iOS simulator")
        fmt.Println("\tupshift action iosBuild -- to build an iOS app")
        fmt.Println("\tupshift action iosRun -- to run an iOS app in the simulator")
        fmt.Println("\tupshift action iosDeploy -- to archive and deploy an iOS app")

        fmt.Println("\tupshift action androidEmulator -- to start the android emulator")
        fmt.Println("\tupshift action androidBuild -- to build an android project")
        fmt.Println("\tupshift action androidRun -- to run an android project")
        fmt.Println("\tupshift action androidDeploy -- to deploy an android project")

        fmt.Println(colours.Bold + "\nCOMPATIBILITY" + colours.Default)
        fmt.Println("\tWe've only tested this on Mac OSX, Linux and Docker. If you're on\n\twindows, you should switch operating systems because nobody can help\n\tyou there.")
        fmt.Println("\nLeftshift Technologies           Made with   in India                " + colours.Underline + "https://leftshift.io\n" + colours.Default)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package actions

import (
        "errors"
        "fmt"
        "io/ioutil"
        "os"
        "path/filepath"
        "strings"

        "github.com/leftshifters/upshift/basher"
        "github.com/leftshifters/upshift/colours"
        "github.com/leftshifters/upshift/command"
        "github.com/leftshifters/upshift/config"
        "github.com/leftshifters/upshift/utils"
)

// Xcodebuild : construct to handle all xcode functions
type Xcodebuild struct {
        Name             string
        BundleIdentifier string
        Type             string
        Extension        string
        XcodeVersion     string
        iPhoneOS         string
        TestDevice       string
        Scheme           string
        DeviceName       string
        Path             string
        UseWorkspace     bool
        UsePods          bool
}

// LoadSettings : load settings from xcodebuild
func (x *Xcodebuild) LoadSettings() error <span class="cov8" title="1">{
        settings, err := command.Run([]string{"xcodebuild", "-showBuildSettings"}, "")
        if err != nil </span><span class="cov8" title="1">{
                return errors.New("We are unable to read settings for this iOS Project\n" + err.Error())
        }</span>

        // Load settings from xcodebuild -showBuildSettings
        <span class="cov0" title="0">settingsRows := strings.Split(settings, "\n")
        for _, row := range settingsRows </span><span class="cov0" title="0">{
                settingsKeys := strings.Split(row, "=")
                if len(settingsKeys) == 2 </span><span class="cov0" title="0">{
                        key := strings.TrimSpace(settingsKeys[0])
                        value := strings.TrimSpace(settingsKeys[1])
                        // fmt.Println("key", key, "value", value)

                        switch key </span>{
                        <span class="cov0" title="0">case "PROJECT_NAME":
                                x.Name = value</span>
                        <span class="cov0" title="0">case "PRODUCT_BUNDLE_IDENTIFIER":
                                x.BundleIdentifier = value</span>
                        <span class="cov0" title="0">default:</span>
                        }
                }
        }

        // Load config
        <span class="cov0" title="0">var pod Pod
        conf := config.Get()

        x.UseWorkspace = conf.Settings.IOSUseWorkspace
        x.UsePods = pod.AreUsed()

        x.Type = "project"
        x.Extension = ".xcodeproj"
        if x.UseWorkspace || x.UsePods </span><span class="cov0" title="0">{
                x.Type = "workspace"
                x.Extension = ".xcworkspace"
        }</span>
        <span class="cov0" title="0">x.Path = x.Name + x.Extension

        // Find the correct simulator
        // From here - https://en.wikipedia.org/wiki/Xcode - Xcode 7.0 - 7.x (since Swift 2.0 support)
        x.XcodeVersion = conf.Settings.IOSXcodeVersion
        x.TestDevice = conf.Settings.IOSTestDevice
        x.Scheme = conf.Settings.IOSScheme

        os93 := "9.3"
        os92 := "9.2"
        os91 := "9.1"
        os90 := "9.0"

        switch conf.Settings.IOSXcodeVersion </span>{
        <span class="cov0" title="0">case "7.3.1":
                x.iPhoneOS = os93</span>
        <span class="cov0" title="0">case "7.3":
                x.iPhoneOS = os93</span>
        <span class="cov0" title="0">case "7.2.1":
                x.iPhoneOS = os92</span>
        <span class="cov0" title="0">case "7.2":
                x.iPhoneOS = os92</span>
        <span class="cov0" title="0">case "7.1.1":
                x.iPhoneOS = os91</span>
        <span class="cov0" title="0">case "7.1":
                x.iPhoneOS = os91</span>
        <span class="cov0" title="0">case "7.0.1":
                x.iPhoneOS = os90</span>
        <span class="cov0" title="0">case "7.0":
                x.iPhoneOS = os90</span>
        <span class="cov0" title="0">default:
                x.iPhoneOS = os93</span>
        }

        <span class="cov0" title="0">x.DeviceName = x.TestDevice + " (" + x.iPhoneOS + ")"
        fmt.Println(x)

        return nil</span>
}

// FindSchemes : find a scheme which we can use
func (x *Xcodebuild) FindSchemes() error <span class="cov8" title="1">{
        conf := config.Get()

        // Get the list of schemes from xcode
        listDump, err := command.Run([]string{"xcodebuild", "-list"}, "")
        if err != nil </span><span class="cov8" title="1">{
                return errors.New("We could not get a list from xcode\n" + err.Error())
        }</span>

        <span class="cov0" title="0">listRows := strings.Split(listDump, "\n")
        schemeRows := []string{}
        readingSchemesFlag := false
        for _, row := range listRows </span><span class="cov0" title="0">{
                // If we have already found "    Schemes:", lets add non null values
                if readingSchemesFlag == true </span><span class="cov0" title="0">{
                        // Remove extra spaces
                        row = strings.TrimSpace(row)
                        if row != "" </span><span class="cov0" title="0">{
                                // Add if non-null
                                schemeRows = append(schemeRows, row)
                                // Since we are looping, check if the scheme available from conf is available in the sytem
                                // if it is, just return and say it is
                                if row == conf.Settings.IOSScheme </span><span class="cov0" title="0">{
                                        x.Scheme = row
                                        return nil
                                }</span>
                        }
                }
                // After you see the row which says "    Schemes:", start adding items to list of schemes available
                <span class="cov0" title="0">if strings.Contains(row, "Schemes:") </span><span class="cov0" title="0">{
                        readingSchemesFlag = true
                }</span>
        }

        // Throw an error if there are no schemes available
        <span class="cov0" title="0">if len(schemeRows) == 0 </span><span class="cov0" title="0">{
                return errors.New("You have no " + colours.Red + "schemes" + colours.Default + " defined in your project. You need to share them.")
        }</span>

        // 1. If scheme defined in config exists, use that
        // 2. If there is no scheme in config, but there is only one scheme, use that
        // 3. If there is no scheme in config and multiple in xcode, show an error

        // Condition 1 : has already been checked, check the error condition
        // If we didn't find a matching scheme, but your config has marked one, it means we didn't find it
        <span class="cov0" title="0">if conf.Settings.IOSScheme != "" &amp;&amp; x.Scheme == "" </span><span class="cov0" title="0">{
                return errors.New("Your config says we should use " + colours.Red + conf.Settings.IOSScheme + colours.Default + " to build the project. But that scheme is missing!")
        }</span>

        // Condition 2 : Checking
        <span class="cov0" title="0">if len(schemeRows) == 1 </span><span class="cov0" title="0">{
                // There is only one scheme, you can set this in projectSettings
                fmt.Println("It seems you didn't define a scheme in your config, but Xcode told us about " + colours.Blue + schemeRows[0] + colours.Default + " so we are using that")
                x.Scheme = schemeRows[0]
                return nil
        }</span>

        // Condition 3 : Just throw an error
        <span class="cov0" title="0">return errors.New("You have multiple schemes in your project, hence we can't pick one automatically. Please choose one in your config")</span>
}

// Build : compile an iOS project
func (x *Xcodebuild) Build() error <span class="cov8" title="1">{
        if x.TestDevice == "" || x.Scheme == "" || x.Type == "" || x.Path == "" </span><span class="cov8" title="1">{
                return errors.New("We need the TestDevice, Scheme, Type, Path to proceed")
        }</span>

        <span class="cov0" title="0">utils.LogMessage("$ xcodebuild -" + x.Type + " " + x.Path + " -scheme " + x.Scheme + " -sdk iphonesimulator -destination \"platform=iphonesimulator,name=" + x.TestDevice + "\" -derivedDataPath .upshift/build")

        var b basher.Basher
        _, err := b.RunAndTail("IOSBuild", []string{x.Type, x.Path, x.Scheme, x.TestDevice, ".upshift/logs/xcode-build.log"}, ".upshift/logs/xcode-build.log", []string{"BUILD SUCCEEDED"}, []string{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Archive : archive a project
func (x *Xcodebuild) Archive() error <span class="cov8" title="1">{
        if x.Name == "" || x.Scheme == "" || x.Type == "" || x.Path == "" </span><span class="cov8" title="1">{
                return errors.New("We need the Name, Scheme, Type, Path to proceed")
        }</span>

        <span class="cov0" title="0">utils.LogMessage("$ xcodebuild -" + x.Type + " " + x.Path + " -scheme " + x.Scheme + " -derivedDataPath .upshift/build -archivePath .upshift/" + x.Name + ".xcarchive archive")

        var b basher.Basher
        _, err := b.RunAndTail("IOSArchive", []string{x.Type, x.Path, x.Scheme, x.Name, ".upshift/logs/xcode-archive.log"}, ".upshift/logs/xcode-archive.log", []string{"ARCHIVE SUCCEEDED"}, []string{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ExportIPA : export an IPA
func (x *Xcodebuild) ExportIPA() error <span class="cov8" title="1">{
        if x.Name == "" </span><span class="cov8" title="1">{
                return errors.New("We need a project name to proceed")
        }</span>

        <span class="cov0" title="0">utils.LogMessage("$ xcodebuild -exportArchive -exportOptionsPlist .private/export.plist -archivePath .upshift/" + x.Name + ".xcarchive -exportPath .upshift")

        var b basher.Basher
        _, err := b.RunAndTail("IOSExport", []string{x.Name, ".upshift/logs/xcode-export.log"}, ".upshift/logs/xcode-export.log", []string{"EXPORT SUCCEEDED"}, []string{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// SetupExportPlist : create an export.plist file if it doesn't exist
func (x *Xcodebuild) SetupExportPlist() error <span class="cov8" title="1">{
        // Check if the export.plist exists
        if utils.FileExists(".private/export.plist") </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">sampleExportPlist := `&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
        &lt;key&gt;method&lt;/key&gt;
        &lt;string&gt;ad-hoc&lt;/string&gt;
        &lt;key&gt;uploadSymbols&lt;/key&gt;
        &lt;true/&gt;
        &lt;key&gt;uploadBitcode&lt;/key&gt;
        &lt;true/&gt;
&lt;/dict&gt;
&lt;/plist&gt;"`

        exportPlistBytes := []byte(sampleExportPlist)

        err := ioutil.WriteFile(".private/export.plist", exportPlistBytes, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("We could not write the .private/export.plist file\n" + err.Error())
        }</span>

        <span class="cov0" title="0">fmt.Println("We just added a sample file to .private/export.plist!")
        return nil</span>
}

// IncrementBuildNumber : increment the build number.
func (x *Xcodebuild) IncrementBuildNumber() error <span class="cov8" title="1">{
        if x.Name == "" </span><span class="cov8" title="1">{
                return errors.New("Please find the project name first")
        }</span>

        <span class="cov0" title="0">var b basher.Basher
        _, err := b.Run("IOSIncrementBuildNumber", []string{x.Name})
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("We couldn't incremenet the build number")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// SwitchXcode : change the xcode version
func (x *Xcodebuild) SwitchXcode() error <span class="cov8" title="1">{
        currentVersion, err := x.Version()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if currentVersion == x.XcodeVersion </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if utils.FileExists("/Applications/Xcode-"+x.XcodeVersion+".app/") == false </span><span class="cov0" title="0">{
                return errors.New("It seems you don't have /Applications/Xcode-" + x.XcodeVersion + ".app/\nWe expect XCode versions to be placed like this\n/Applications/Xcode-7.2.app\n/Applications/Xcode-7.3.app")
        }</span>

        <span class="cov8" title="1">conf := config.Get()
        RootPassword, err := conf.GetRootPassword()
        if conf.IsCI() == true &amp;&amp; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">inputVia := "-S"
        if conf.IsCI() == false &amp;&amp; RootPassword == "" </span><span class="cov8" title="1">{
                inputVia = "-k"
        }</span>

        <span class="cov8" title="1">out, err := command.Run([]string{"sudo", inputVia, "xcode-select", "--switch", "/Applications/Xcode-" + x.XcodeVersion + ".app/"}, RootPassword+"\n")
        if err != nil </span><span class="cov8" title="1">{
                return errors.New("We couldn't switch Xcodes, you're going to be stuck with this one")
        }</span>
        <span class="cov0" title="0">fmt.Println(out)
        fmt.Println("We are now on the " + colours.Underline + "Xcode-" + x.XcodeVersion + colours.Default)
        return nil</span>
}

// Version : current xcodebuild version
func (x *Xcodebuild) Version() (string, error) <span class="cov8" title="1">{
        versionData, err := command.Run([]string{"xcodebuild", "-version"}, "")
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.New("We were unable to get the Xcode version\n" + err.Error())
        }</span>

        <span class="cov8" title="1">var currentXcodeVersion string
        versionRows := strings.Split(versionData, "\n")
        for _, row := range versionRows </span><span class="cov8" title="1">{
                if strings.Contains(row, "Xcode") == true </span><span class="cov8" title="1">{
                        currentXcodeVersion = strings.TrimSpace(strings.Trim(row, "Xcode"))
                }</span>
        }

        <span class="cov8" title="1">return currentXcodeVersion, nil</span>
}

// Run : run a build in the simulator
func (x *Xcodebuild) Run() error <span class="cov8" title="1">{
        if x.BundleIdentifier == "" </span><span class="cov8" title="1">{
                return errors.New("We need the bundle identifier to proceed")
        }</span>

        <span class="cov0" title="0">var build string
        debug := ".upshift/build/Build/Products/Debug-iphonesimulator/" + x.Name + ".app"
        release := ".upshift/build/Build/Products/Release-iphonesimulator/" + x.Name + ".app"

        if utils.FileExists(debug) </span><span class="cov0" title="0">{
                build, _ = filepath.Abs(debug)
        }</span><span class="cov0" title="0"> else if utils.FileExists(release) </span><span class="cov0" title="0">{
                build, _ = filepath.Abs(release)
        }</span><span class="cov0" title="0"> else {
                return errors.New("You have not build for the simulator yet")
        }</span>

        // If file exists, push it to the simulator
        <span class="cov0" title="0">fmt.Println("Installing the app in the simulator")
        _, err := command.Run([]string{"xcrun", "simctl", "install", "booted", build}, "")
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("We could not deploy the app to the simulator\n" + err.Error())
        }</span>

        // Start the app
        <span class="cov0" title="0">fmt.Println("Starting the app in the simulator")
        _, err = command.Run([]string{"xcrun", "simctl", "launch", "booted", x.BundleIdentifier}, "")
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("We could not deploy the app to the simulator\n" + err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// InstallCertificates : Find where are the certificates and install them
func (x *Xcodebuild) InstallCertificates() error <span class="cov8" title="1">{
        utils.LogMessage("Checking for apple.cer, distribution.p12 and distribution.cer in .private")

        var appleCert, distributionCert, distributionP12Cert string

        if utils.FileExists(".private/apple.cer") &amp;&amp; utils.FileExists(".private/distribution.cer") &amp;&amp; utils.FileExists(".private/distribution.p12") </span><span class="cov0" title="0">{
                // Install certs from .private
                appleCert, _ = filepath.Abs(".private/apple.cer")
                distributionCert, _ = filepath.Abs(".private/distribution.cer")
                distributionP12Cert, _ = filepath.Abs(".private/distribution.p12")
        }</span><span class="cov8" title="1"> else {
                // Since they don't exist in .private, look in machine config
                conf := config.Get()
                base := conf.Settings.IOSCertificatePath

                if base == "" </span><span class="cov0" title="0">{
                        return errors.New("The certificates don't exist in both .private and global conf")
                }</span>

                <span class="cov8" title="1">if utils.FileExists(base+"/apple.cer") &amp;&amp; utils.FileExists(base+"/distribution.cer") &amp;&amp; utils.FileExists(base+"/distribution.p12") </span><span class="cov8" title="1">{
                        appleCert, _ = filepath.Abs(base + "/apple.cer")
                        distributionCert, _ = filepath.Abs(base + "/distribution.cer")
                        distributionP12Cert, _ = filepath.Abs(base + "/distribution.p12")
                }</span>
        }

        <span class="cov8" title="1">if appleCert == "" </span><span class="cov0" title="0">{
                return errors.New("All the certificates don't exist in both .private and global conf")
        }</span>

        <span class="cov8" title="1">outApple, err := command.Run([]string{"security", "import", appleCert, "-k", os.Getenv("HOME") + "/Library/Keychains/login.keychain", "-T", "/usr/bin/codesign", "-T", "/usr/bin/security"}, "")
        fmt.Println(outApple)
        if err != nil &amp;&amp; strings.Contains(outApple, "already exists in the keychain") == false </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov0" title="0">outCert, err := command.Run([]string{"security", "import", distributionCert, "-k", os.Getenv("HOME") + "/Library/Keychains/login.keychain", "-T", "/usr/bin/codesign", "-T", "/usr/bin/security"}, "")
        fmt.Println(outCert)
        if err != nil &amp;&amp; strings.Contains(outCert, "already exists in the keychain") == false </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">outP12, err := command.Run([]string{"security", "import", distributionP12Cert, "-k", os.Getenv("HOME") + "/Library/Keychains/login.keychain", "-T", "/usr/bin/codesign", "-T", "/usr/bin/security", "-P", ""}, "")
        fmt.Println(outP12)
        if err != nil &amp;&amp; strings.Contains(outP12, "already exists in the keychain") == false </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package actions

import "errors"

// Xcpretty : Construct to handle all things related to xcpretty
type Xcpretty struct{}

// Install : Install xcpretty on the machine
func (x *Xcpretty) Install() error <span class="cov8" title="1">{
        var g Gems
        err := g.InstallSimple("xcpretty")
        if err != nil </span><span class="cov8" title="1">{
                return errors.New("Could not install xcpretty\n" + err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Uninstall : Uninstall xcpretty on the machine
func (x *Xcpretty) Uninstall() error <span class="cov8" title="1">{
        var g Gems
        err := g.UninstallSimple("xcpretty")
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("Could not uninstall xcpretty\n" + err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package actions

import (
        "errors"

        "github.com/leftshifters/upshift/basher"
        "github.com/leftshifters/upshift/utils"
)

// Xctool : Construct to handle all things related to xctool
type Xctool struct{}

// Install : Install Xctool on the machine
func (x *Xctool) Install() error <span class="cov8" title="1">{
        var b Brew
        _, err := b.Install("xctool")
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("Could not install xctool\n" + err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Upgrade : Upgrade Xctool on the machine
func (x *Xctool) Upgrade() error <span class="cov8" title="1">{
        var b Brew
        _, err := b.Upgrade("xctool")
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("Could not upgrade xctool\n" + err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Uninstall : Uninstall xctool on the machine
func (x *Xctool) Uninstall() error <span class="cov8" title="1">{
        var b Brew
        _, err := b.Uninstall("xctool")
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("Could not uninstall xctool\n" + err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Test : run tests for an iOS project
func (x *Xctool) Test(projecttype string, path string, scheme string, device string) error <span class="cov0" title="0">{
        if projecttype == "" || path == "" || scheme == "" || device == "" </span><span class="cov0" title="0">{
                return errors.New("We need the Type, Path, Scheme and Device to proceed")
        }</span>

        <span class="cov0" title="0">utils.LogMessage("$ xctool -" + projecttype + " " + path + " -scheme " + scheme + " -sdk iphonesimulator -destination \"platform=iphonesimulator,name=" + device + "\" test")

        var b basher.Basher
        _, err := b.RunAndTail("IOSTest", []string{projecttype, path, scheme, device, ".upshift/logs/xcode-test.log"}, ".upshift/logs/xcode-test.log", []string{"BUILD SUCCEEDED"}, []string{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
